{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, n-1, 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            for i in range(top+1, bottom+1):\n                res.append(matrix[i][right])\n            if left < right and top < bottom:\n                for i in range(right-1, left, -1):\n                    res.append(matrix[bottom][i])\n                for i in range(bottom, top, -1):\n                    res.append(matrix[i][left])\n            left, right, top, bottom = left+1, right-1, top+1, bottom-1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        i, j = 0, 0\n        while i < m and j < n:\n            for k in range(j, n):\n                res.append(matrix[i][k])\n            i += 1\n            for k in range(i, m):\n                res.append(matrix[k][n-1])\n            n -= 1\n            if i < m:\n                for k in range(n-1, j-1, -1):\n                    res.append(matrix[m-1][k])\n                m -= 1\n            if j < n:\n                for k in range(m-1, i-1, -1):\n                    res.append(matrix[k][j])\n                j += 1\n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = []\n        \n        left = 0\n        right = n - 1\n        top = 0\n        bottom = m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = []\n        \n        left = 0\n        right = n - 1\n        top = 0\n        bottom = m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        i, j = 0, 0\n        while i < m and j < n:\n            for k in range(j, n):\n                res.append(matrix[i][k])\n            i += 1\n            for k in range(i, m):\n                res.append(matrix[k][n-1])\n            n -= 1\n            if i < m:\n                for k in range(n-1, j-1, -1):\n                    res.append(matrix[m-1][k])\n                m -= 1\n            if j < n:\n                for k in range(m-1, i-1, -1):\n                    res.append(matrix[k][j])\n                j += 1\n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        \n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        \n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        n = len(s)\n        m = len(t)\n        \n        dp = [[0] * (m+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        return dp[n][m]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        \n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        \n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        \n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and 0 as 1\n        # 2. mark the index of the number as negative\n        # 3. find the first positive number\n        # 4. return the index + 1\n        \n        # 1. mark all negative numbers and 0 as 1\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = 1\n        \n        # 2. mark the index of the number as negative\n        for i in range(len(nums)):\n            if abs(nums[i]) <= len(nums):\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\n        \n        # 3. find the first positive number\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. return the index + 1\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and 0 as 1\n        # 2. mark the index of the number as negative\n        # 3. find the first positive number\n        # 4. return the index + 1\n        \n        # 1. mark all negative numbers and 0 as 1\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = 1\n        \n        # 2. mark the index of the number as negative\n        for i in range(len(nums)):\n            if abs(nums[i]) <= len(nums):\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\n        \n        # 3. find the first positive number\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. return the index + 1\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and 0 as 1\n        # 2. mark the number at index i-1 as negative if it is positive\n        # 3. return the first index which is positive\n        \n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = 1\n        \n        for i in range(n):\n            val = abs(nums[i])\n            if val <= n:\n                nums[val-1] = -abs(nums[val-1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i+1\n        \n        return n+1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and 0 as 1\n        # 2. mark the number at index i-1 as negative if it is positive\n        # 3. return the first index which is positive\n        \n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = 1\n        \n        for i in range(n):\n            val = abs(nums[i])\n            if val <= n:\n                nums[val-1] = -abs(nums[val-1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i+1\n        \n        return n+1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and 0 as 1\n        # 2. mark the index of the number as negative\n        # 3. find the first positive number\n        # 4. return the index + 1\n        \n        # 1. mark all negative numbers and 0 as 1\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = 1\n        \n        # 2. mark the index of the number as negative\n        for i in range(len(nums)):\n            if abs(nums[i]) <= len(nums):\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\n        \n        # 3. find the first positive number\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. return the index + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461258\n        # 23. 23rd permutation is 123461285\n        # 24. 24th permutation is 123461528\n        # 25. 25th permutation is 123461582\n        # 26. 26th permutation is 123461825\n        # 27. 27th permutation is 123461852\n        # 28. 28th permutation is 123462158\n        # 29. 29th permutation is 123462185\n        # 30. 30th permutation is 123462518\n        # 31. 31st permutation is 123462581\n        # 32. 32nd permutation is 123462815\n        # 33. 33rd permutation is 123462851\n        # 34. 34th permutation is 123465128\n        # 35. 35th permutation is 123465182\n        # 36. 36th permutation is 123465218\n        # 37. 37th permutation is 123465281\n        # 38. 38th permutation is 123465812\n        # 39. 39th permutation is 123465818\n        # 40. 40th permutation is 123465821\n        # 41. 41st permutation is 123468125\n        # 42. 42nd permutation is 123468152\n        # 43. 43rd permutation is 123468215\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461258\n        # 23. 23rd permutation is 123461285\n        # 24. 24th permutation is 123461528\n        # 25. 25th permutation is 123461582\n        # 26. 26th permutation is 123461825\n        # 27. 27th permutation is 123461852\n        # 28. 28th permutation is 123462158\n        # 29. 29th permutation is 123462185\n        # 30. 30th permutation is 123462518\n        # 31. 31st permutation is 123462581\n        # 32. 32nd permutation is 123462815\n        # 33. 33rd permutation is 123462851\n        # 34. 34th permutation is 123465128\n        # 35. 35th permutation is 123465182\n        # 36. 36th permutation is 123465218\n        # 37. 37th permutation is 123465281\n        # 38. 38th permutation is 123465812\n        # 39. 39th permutation is 123465818\n        # 40. 40th permutation is 123465821\n        # 41. 41st permutation is 123468125\n        # 42. 42nd permutation is 123468152\n        # 43. 43rd permutation is 123468215\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461258\n        # 23. 23rd permutation is 123461285\n        # 24. 24th permutation is 123461528\n        # 25. 25th permutation is 123461582\n        # 26. 26th permutation is 123461825\n        # 27. 27th permutation is 123461852\n        # 28. 28th permutation is 123462158\n        # 29. 29th permutation is 123462185\n        # 30. 30th permutation is 123462518\n        # 31. 31st permutation is 123462581\n        # 32. 32nd permutation is 123462815\n        # 33. 33rd permutation is 123462851\n        # 34. 34th permutation is 123465128\n        # 35. 35th permutation is 123465182\n        # 36. 36th permutation is 123465218\n        # 37. 37th permutation is 123465281\n        # 38. 38th permutation is 123465812\n        # 39. 39th permutation is 123465818\n        # 40. 40th permutation is 123465821\n        # 41. 41st permutation is 123468125\n        # 42. 42nd permutation is 123468152\n        # 43. 43rd permutation is 123468215\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461258\n        # 23. 23rd permutation is 123461285\n        # 24. 24th permutation is 123461528\n        # 25. 25th permutation is 123461582\n        # 26. 26th permutation is 123461825\n        # 27. 27th permutation is 123461852\n        # 28. 28th permutation is 123462158\n        # 29. 29th permutation is 123462185\n        # 30. 30th permutation is 123462518\n        # 31. 31st permutation is 123462581\n        # 32. 32nd permutation is 123462815\n        # 33. 33rd permutation is 123462851\n        # 34. 34th permutation is 123465128\n        # 35. 35th permutation is 123465182\n        # 36. 36th permutation is 123465218\n        # 37. 37th permutation is 123465281\n        # 38. 38th permutation is 123465812\n        # 39. 39th permutation is 123465818\n        # 40. 40th permutation is 123465821\n        # 41. 41st permutation is 123468125\n        # 42. 42nd permutation is 123468152\n        # 43. 43rd permutation is 123468215\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461258\n        # 23. 23rd permutation is 123461285\n        # 24. 24th permutation is 123461528\n        # 25. 25th permutation is 123461582\n        # 26. 26th permutation is 123461825\n        # 27. 27th permutation is 123461852\n        # 28. 28th permutation is 123462158\n        # 29. 29th permutation is 123462185\n        # 30. 30th permutation is 123462518\n        # 31. 31st permutation is 123462581\n        # 32. 32nd permutation is 123462815\n        # 33. 33rd permutation is 123462851\n        # 34. 34th permutation is 123465128\n        # 35. 35th permutation is 123465182\n        # 36. 36th permutation is 123465218\n        # 37. 37th permutation is 123465281\n        # 38. 38th permutation is 123465812\n        # 39. 39th permutation is 123465818\n        # 40. 40th permutation is 123465821\n        # 41. 41st permutation is 123468125\n        # 42. 42nd permutation is 123468152\n        # 43. 43rd permutation is 123468215\n        # 44. 44th"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # two pointers\n        # O(n) time, O(1) space\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n        return []"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # two pointers\n        # O(n) time, O(1) space\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n        return []"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # Time: O(n)\n        # Space: O(1)\n        \n        left, right = 0, len(numbers) - 1\n        \n        while left < right:\n            curr_sum = numbers[left] + numbers[right]\n            \n            if curr_sum == target:\n                return [left + 1, right + 1]\n            elif currum < target:\n                left += 1\n            else:\n                right -= 1"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        \n        left, right = 0, len(numbers) - 1\n        \n        while left < right:\n            curr_sum = numbers[left] + numbers[right]\n            if curr_sum == target:\n                return [left + 1, right + 1]\n            elif curr"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # two pointers\n        # O(n) time, O(1) space\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n        return []"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num:\n                if currVal == target:\n                    res.append(path)\n                return\n            \n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                curr = int(num[:i])\n                if not path:\n                    dfs(num[i:], target, num[:i], res, curr, curr)\n                else:\n                    dfs(num[i:], target, path + '+' + num[:i], res, currVal + curr, curr)\n                    dfs(num[i:], target, path + '-' + num[:i], res, currVal - curr, -curr)\n                    dfs(num[i:], target, path + '*' + num[:i], res, currVal - curr + curr * currNum, curr * currNum)\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num:\n                if currVal == target:\n                    res.append(path)\n                return\n            \n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                curr = int(num[:i])\n                if not path:\n                    dfs(num[i:], target, num[:i], res, curr, curr)\n                else:\n                    dfs(num[i:], target, path + '+' + num[:i], res, currVal + curr, curr)\n                    dfs(num[i:], target, path + '-' + num[:i], res, currVal - curr, -curr)\n                    dfs(num[i:], target, path + '*' + num[:i], res, currVal - curr + curr * currNum, curr * currNum)\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num:\n                if currVal == target:\n                    res.append(path)\n                return\n            \n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                curr = int(num[:i])\n                if not path:\n                    dfs(num[i:], target, num[:i], res, curr, curr)\n                else:\n                    dfs(num[i:], target, path + '+' + num[:i], res, currVal + curr, curr)\n                    dfs(num[i:], target, path + '-' + num[:i], res, currVal - curr, -curr)\n                    dfs(num[i:], target, path + '*' + num[:i], res, currVal - curr + curr * currNum, curr * currNum)\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num:\n                if currVal == target:\n                    res.append(path)\n                return\n            \n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                \n                currStr = num[:i]\n                currVal = currVal + int(currStr)\n                if path:\n                    dfs(num[i:], target, path + '+' + currStr, res, currVal, int(currStr))\n                    dfs(num[i:], target, path + '-' + currStr, res, currVal, -int(currStr))\n                    dfs(num[i:], target, path + '*' + currStr, res, currVal - currNum + currNum * int(currStr), currNum * int(currStr))\n                else:\n                    dfs(num[i:], target, currStr, res, currVal, int(currStr))\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num:\n                if currVal == target:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                curr = int(num[:i])\n                if not path:\n                    dfs(num[i:], target, num[:i], res, curr, curr)\n                else:\n                    dfs(num[i:], target, path + '+' + num[:i], res, currVal + curr, curr)\n                    dfs(num[i:], target, path + '-' + num[:i], res, currVal - curr, -curr)\n                    dfs(num[i:], target, path + '*' + num[:i], res, currVal - curr + curr * currNum, curr * currNum)\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            curr = curr * 10 + root.val\n            if not root.left and not root.right:\n                return curr\n            return dfs(root.left, curr) + dfs(root.right, curr)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            curr = curr * 10 + root.val\n            if not root.left and not root.right:\n                return curr\n            return dfs(root.left, curr) + dfs(root.right, curr)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            curr = curr * 10 + root.val\n            if not root.left and not root.right:\n                return curr\n            return dfs(root.left, curr) + dfs(root.right, curr)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            curr = curr * 10 + root.val\n            if not root.left and not root.right:\n                return curr\n            return dfs(root.left, curr) + dfs(root.right, curr)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            curr = curr * 10 + root.val\n            if not root.left and not root.right:\n                return curr\n            return dfs(root.left, curr) + dfs(root.right, curr)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\").upper()\n        n = len(s)\n        if n <= k:\n            return s\n        res = s[n-k:]\n        for i in range(n-k-1, -1, -k):\n            res = s[i:i+k] + \"-\" + res\n        return res"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\").upper()\n        n = len(s)\n        if n <= k:\n            return s\n        else:\n            return s[:n-n%k][::-1] + \"-\" + s[n-n%k:][::-1].replace(\"-\", \"\", n%k-1)"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        res = s[n-k:]\n        for i in range(n-k-1, -1, -k):\n            res = s[i:i+k] + '-' + res\n        return res"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        res = s[n-k:]\n        for i in range(n-k-1, -1, -k):\n            res = s[i:i+k] + '-' + res\n        return res"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        res = s[n-k:]\n        i = n - k - 1\n        while i >= 0:\n            res = s[i:i+k] + '-' + res\n            i -= k\n        return res"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a number\n        num = int(''.join(map(str, digits)))\n        \n        # add 1 to the number\n        num += 1\n        \n        # convert the number back to a list of digits\n        return [int(x) for x in str(num)]"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits = ''.join(str(x) for x in digits)\n        \n        # convert the string to an integer\n        digits = int(digits)\n        \n        # add 1 to the integer\n        digits += 1\n        \n        # convert the integer back to a string\n        digits = str(digits)\n        \n        # convert the string back to a list of digits\n        digits = [int(x) for x in digits]\n        \n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits = ''.join(map(str, digits))\n        \n        # convert the string to an integer\n        digits = int(digits)\n        \n        # add 1 to the integer\n        digits += 1\n        \n        # convert the integer back to a string\n        digits = str(digits)\n        \n        # convert the string back to a list of digits\n        digits = list(map(int, digits))\n        \n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits = ''.join(str(x) for x in digits)\n        \n        # convert the string to an integer\n        digits = int(digits)\n        \n        # add 1 to the integer\n        digits += 1\n        \n        # convert the integer back to a string\n        digits = str(digits)\n        \n        # convert the string back to a list of digits\n        digits = [int(x) for x in digits]\n        \n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits = ''.join(str(x) for x in digits)\n        \n        # convert the string to an integer\n        digits = int(digits)\n        \n        # add 1 to the integer\n        digits += 1\n        \n        # convert the integer back to a string\n        digits = str(digits)\n        \n        # convert the string back to a list of digits\n        digits = [int(x) for x in digits]\n        \n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        \n        # m = len(s)\n        # n = len(p)\n        \n        # dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        # dp[0][0] = True\n        \n        # for j in range(1, n+1):\n        #     if p[j-1] == '*':\n        #         dp[0][j] = dp[0][j-2]\n        \n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if p[j-1] == '.' or p[j-1] == s[i-1]:\n        #             dp[i][j] = dp[i-1][j-1]\n        #         elif p[j-1] == '*':\n        #             dp[i][j] = dp[i][j-2]\n        #             if p[j-2] == '.' or p[j-2] == s[i-1]:\n        #                 dp[i][j] = dp[i][j] or dp[i-1][j]\n        #         else:\n        #             dp[i][j] = False\n        \n        # return dp[m][n]\n        \n        # Recursive Solution\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in {s[0], '.'}\n        \n        if len(p) >= 2 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or first_match and self.isMatch(s[1:], p)\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # m = len(s)\n        # n = len(p)\n        \n        # dp = [[False] * (n+1) for _ in range(m+1)]\n        \n        # dp[0][0] = True\n        \n        # for j in range(1, n+1):\n        #     if p[j-1] == '*':\n        #         dp[0][j] = dp[0][j-2]\n        \n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if p[j-1] == '.' or p[j-1] == s[i-1]:\n        #             dp[i][j] = dp[i-1][j-1]\n        #         elif p[j-1] == '*':\n        #             dp[i][j] = dp[i][j-2]\n        #             if p[j-2] == '.' or p[j-2] == s[i-1]:\n        #                 dp[i][j] = dp[i][j] or dp[i-1][j]\n        #         else:\n        #             dp[i][j] = False\n        \n        # return dp[m][n]\n        \n        # Recursive solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in {s[0], '.'}\n        \n        if len(p) >= 2 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or first_match and self.isMatch(s[1:], p)\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for i in range(1, n+1):\n            if p[i-1] == '*':\n                dp[0][i] = dp[0][i-2]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '.' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    if p[j-2] == '.' or p[j-2] == s[i-1]:\n                        dp[i][j] = dp[i][j-2] or dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i][j-2]\n        \n        return dp[m][n]"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        \n        m, n = len(s), len(p)\n        \n        # dp[i][j] represents if s[:i] matches p[:j]\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        \n        # empty pattern matches empty string\n        dp[0][0] = True\n        \n        # empty pattern can match empty string\n        # if previous pattern is '*'\n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '.' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # Dynamic Programming\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        \n        m, n = len(s), len(p)\n        \n        # dp[i][j] = True if s[0:i] matches p[0:j]\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        \n        # empty pattern matches empty string\n        dp[0][0] = True\n        \n        # empty pattern can match empty string\n        # if previous pattern is '*'\n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '.' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def prep(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            return [max(a, b).pop(0) for _ in a+b]\n        \n        return max(merge(prep(nums1, i), prep(nums2, k-i))\n                   for i in range(k+1)\n                   if i <= len(nums1) and k-i <= len(nums2))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def prep(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            return [max(a, b).pop(0) for _ in a+b]\n        \n        return max(merge(prep(nums1, i), prep(nums2, k-i))\n                   for i in range(k+1)\n                   if i <= len(nums1) and k-i <= len(nums2))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def prep(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            return [max(a, b).pop(0) for _ in a+b]\n        \n        return max(merge(prep(nums1, i), prep(nums2, k-i))\n                   for i in range(k+1)\n                   if i <= len(nums1) and k-i <= len(nums2))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def prep(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            return [max(a, b).pop(0) for _ in a+b]\n        \n        return max(merge(prep(nums1, i), prep(nums2, k-i))\n                   for i in range(k+1)\n                   if i <= len(nums1) and k-i <= len(nums2))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def prep(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            return [max(a, b).pop(0) for _ in a+b]\n        \n        return max(merge(prep(nums1, i), prep(nums2, k-i))\n                   for i in range(k+1)\n                   if i <= len(nums1) and k-i <= len(nums2))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num // i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num // i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        \n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        \n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        \n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Split the string by space\n        # 2. Count the number of segments\n        # 3. Return the number of segments\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Split the string by space\n        # 2. Count the number of segments\n        # 3. Return the number of segments\n        \n        # 1. Split the string by space\n        segments = s.split()\n        \n        # 2. Count the number of segments\n        return len(segments)"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        s = list(s)\n        l, r = 0, len(s)-1\n        while l < r:\n            if s[l] in vowels and s[r] in vowels:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n            elif s[l] in vowels:\n                r -= 1\n            elif s[r] in vowels:\n                l += 1\n            else:\n                l += 1\n                r -= 1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        s = list(s)\n        i,j = 0,len(s)-1\n        while i<j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i],s[j] = s[j],s[i]\n                i+=1\n                j-=1\n            elif s[i] in vowels:\n                j-=1\n            elif s[j] in vowels:\n                i+=1\n            else:\n                i+=1\n                j-=1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        s = list(s)\n        l, r = 0, len(s)-1\n        while l < r:\n            if s[l] in vowels and s[r] in vowels:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n            elif s[l] in vowels:\n                r -= 1\n            elif s[r] in vowels:\n                l += 1\n            else:\n                l += 1\n                r -= 1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        s = list(s)\n        i,j = 0,len(s)-1\n        while i<j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i],s[j] = s[j],s[i]\n                i+=1\n                j-=1\n            elif s[i] in vowels:\n                j-=1\n            elif s[j] in vowels:\n                i+=1\n            else:\n                i+=1\n                j-=1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        s = list(s)\n        i,j = 0,len(s)-1\n        while i<j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i],s[j] = s[j],s[i]\n                i+=1\n                j-=1\n            elif s[i] in vowels:\n                j-=1\n            elif s[j] in vowels:\n                i+=1\n            else:\n                i+=1\n                j-=1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the array is complete, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the array is complete, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the array is complete, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the array is complete, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the array is complete, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left >= 0 and nums[left] == target:\n            left -= 1\n        while right < len(nums) and nums[right] == target:\n            right += 1\n        return [left + 1, right - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left - 1 >= 0 and nums[left - 1] == target:\n            left -= 1\n        while right + 1 < len(nums) and nums[right + 1] == target:\n            right += 1\n        return [left, right]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left - 1 >= 0 and nums[left - 1] == target:\n            left -= 1\n        while right + 1 < len(nums) and nums[right + 1] == target:\n            right += 1\n        return [left, right]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left >= 0 and nums[left] == target:\n            left -= 1\n        while right < len(nums) and nums[right] == target:\n            right += 1\n        return [left + 1, right - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left >= 0 and nums[left] == target:\n            left -= 1\n        while right < len(nums) and nums[right] == target:\n            right += 1\n        return [left + 1, right - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # 1st pointer is the slow pointer\n        # 2nd pointer is the fast pointer\n        # if nums[slow] != nums[fast]\n        # then we know that nums[slow] is unique\n        # so we can increment slow and set nums[slow] = nums[fast]\n        # else we just increment fast\n        \n        slow = 0\n        fast = 1\n        \n        while fast < len(nums):\n            if nums[slow] != nums[fast]:\n                slow += 1\n                nums[slow] = nums[fast]\n            fast += 1\n            \n        return slow + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(nums)\n        q = deque([0])\n        steps = 0\n        while q:\n            for _ in range(len(q)):\n                i = q.popleft()\n                if i == n - 1:\n                    return steps\n                for j in range(i + 1, min(i + nums[i] + 1, n)):\n                    q.append(j)\n            steps += 1\n        return -1"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(nums)\n        # queue = deque([(0, 0)])\n        # visited = set([0])\n        # while queue:\n        #     i, step = queue.popleft()\n        #     if i == n - 1:\n        #         return step\n        #     for j in range(i + 1, min(i + nums[i] + 1, n)):\n        #         if j not in visited:\n        #             queue.append((j, step + 1))\n        #             visited.add(j)\n        \n        # 2. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        n = len(nums)\n        if n == 1:\n            return 0\n        max_reach = nums[0]\n        step = 1\n        next_reach = nums[0]\n        for i in range(1, n):\n            if i > max_reach:\n                return -1\n            if i == n - 1:\n                return step\n            next_reach = max(next_reach, i + nums[i])\n            if i == max_reach:\n                step += 1\n                max_reach = next_reach\n        return -1"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0] = 0\n        # dp[i] = min(dp[i], dp[j] + 1) for j in range(i)\n        # dp[0"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = min(dp[i], dp[j] + 1) for all j < i and nums[j] >= i - j\n        # dp[0] = 0\n        # dp[n-1] = min(dp[n-1], dp[j] + 1) for all j < n-1 and nums[j] >= n-1 - j\n        # return dp[n-1]\n        \n        # 2. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # max_reach = max(max_reach, i + nums[i])\n        # if i == curr_reach\n        #   curr_reach = max_reach\n        #   steps += 1\n        # return steps\n        \n        # 3. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = [0]\n        # steps = 0\n        # while queue:\n        #   next_queue = []\n        #   for i in queue:\n        #       for j in range(i+1, min(i+nums[i]+1, len(nums))):\n        #           if j == len(nums) - 1:\n        #               return steps + 1\n        #           next_queue.append(j)\n        #   queue = next_queue\n        #   steps += 1\n        # return steps\n        \n        # 4. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # max_reach = nums[0]\n        # steps = 0\n        # curr_reach = 0\n        # for i in range(len(nums)):\n        #   if i > curr_reach:\n        #       curr_reach = max_reach\n        #       steps += 1\n        #   max_reach = max(max_reach, i + nums[i])\n        # return steps\n        \n        # 5. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # max_reach = nums[0]\n        # steps = 0\n        # curr_reach = 0\n        # for i in range(len(nums)):\n        #   if i > curr_reach:\n        #       curr_reach = max_reach\n        #       steps += 1\n        #   max_reach = max(max_reach, i + nums[i])\n        #   if max_reach >= len(nums) - 1:\n        #       return steps + 1\n        # return steps\n        \n        # 6. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # max_reach = nums[0]\n        # steps = 0\n        # curr_reach = 0\n        # for i in range(len(nums)):\n        #   if i > curr_reach:\n        #       curr_reach = max_reach\n        #       steps += 1\n        #   max_reach = max(max_reach, i + nums[i])\n        #   if max_reach >= len(nums) - 1:\n        #       return steps + 1\n        # return steps\n        \n        # 7. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # max_reach = nums[0]\n        # steps = 0\n        # curr_reach = 0\n        # for i in range(len(nums)):\n        #   if i > curr_reach:\n        #       curr_reach = max_reach\n        #       steps += 1\n        #   max_reach = max(max_reach, i + nums[i])\n        #   if max_reach >= len(nums) - 1:\n        #       return steps + 1\n        # return steps\n        \n        # 8. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # max_reach = nums[0]\n        # steps = 0\n        # curr_reach = 0\n        # for i in range(len(nums)):\n        #   if"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. Initialize the queue with the first index and the number of jumps\n        queue = deque([(0, 0)])\n        \n        # 2. While the queue is not empty\n        while queue:\n            # 3. Pop the first element from the queue\n            i, jumps = queue.popleft()\n            \n            # 4. If the index is the last index, return the number of jumps\n            if i == len(nums) - 1:\n                return jumps\n            \n            # 5. Add the next indices to the queue\n            for j in range(1, nums[i] + 1):\n                queue.append((i + j, jumps + 1))\n        \n        # 6. If the queue is empty, return -1\n        return -1"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[j][i] = max(dp[j - 1][i], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[j][i - 1] - prices[j])\n        \n        return dp[-1][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[j][i] = max(dp[j - 1][i], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[j][i - 1] - prices[j])\n        \n        return dp[-1][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[j][i] = max(dp[j - 1][i], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[j][i - 1] - prices[j])\n        \n        return dp[-1][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(prices[i] - prices[i-1] for i in range(1, len(prices)) if prices[i] > prices[i-1])\n        \n        dp = [[0] * len(prices) for _ in range(k+1)]\n        \n        for i in range(1, k+1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i-1][j-1] - prices[j])\n                \n        return dp[k][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[j][i] = max(dp[j - 1][i], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[j - 1][i - 1] - prices[j])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num:\n            res = hex(num & 0xf)[2:] + res\n            num >>= 4\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num:\n            res = hex(num & 0xf)[2:] + res\n            num >>= 4\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num:\n            res = hex(num & 0xf)[2:] + res\n            num >>= 4\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num:\n            res = hex(num & 0xf)[2:] + res\n            num >>= 4\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num:\n            res = hex(num & 0xf)[2:] + res\n            num >>= 4\n        \n        return res"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(indexDiff)\n        \n        # bucket sort\n        # time: O(n)\n        # space: O(indexDiff)\n        \n        # bucket sort\n        # time: O(n)\n        # space: O(1)\n        \n        buckets = {}\n        for i, num in enumerate(nums):\n            bucket = num // (valueDiff + 1)\n            if bucket in buckets:\n                return True\n            if bucket - 1 in buckets and abs(num - buckets[bucket - 1]) <= valueDiff:\n                return True\n            if bucket + 1 in buckets and abs(num - buckets[bucket + 1]) <= valueDiff:\n                return True\n            buckets[bucket] = num\n            if i >= indexDiff:\n                del buckets[nums[i - indexDiff] // (valueDiff + 1)]\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(indexDiff)\n        \n        if indexDiff == 0:\n            return False\n        \n        window = {}\n        \n        for i, num in enumerate(nums):\n            key = num // (valueDiff + 1)\n            if key in window or key - 1 in window and num - window[key - 1] <= valueDiff or key + 1 in window and window[key + 1] - num <= valueDiff:\n                return True\n            window[key] = num\n            if i >= indexDiff:\n                del window[nums[i - indexDiff] // (valueDiff + 1)]\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # bucket sort\n        # bucket size = valueDiff + 1\n        # bucket id = nums[i] / (valueDiff + 1)\n        # bucket id can be negative\n        # bucket id can be positive\n        # bucket id can be 0\n        \n        buckets = {}\n        \n        for i in range(len(nums)):\n            bucket_id = nums[i] // (valueDiff + 1)\n            if bucket_id in buckets:\n                return True\n            if bucket_id - 1 in buckets and abs(nums[i] - buckets[bucket_id - 1]) <= valueDiff:\n                return True\n            if bucket_id + 1 in buckets and abs(nums[i] - buckets[bucketbucket_id + 1]) <= valueDiff:\n                return True\n            buckets[bucket_id] = nums[i]\n            if i >= indexDiff:\n                del buckets[nums[i - indexDiff] // (valueDiff + 1)]\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if indexDiff < 1 or valueDiff < 0:\n            return False\n        \n        buckets = {}\n        for i, num in enumerate(nums):\n            bucket = num // (valueDiff + 1)\n            if bucket in buckets:\n                return True\n            if bucket - 1 in buckets and abs(num - buckets[bucket - 1]) <= valueDiff:\n                return True\n            if bucket + 1 in buckets and abs(num - buckets[bucket + 1]) <= valueDiff:\n                return True\n            buckets[bucket] = num\n            if i >= indexDiff:\n                del buckets[nums[i - indexDiff] // (valueDiff + 1)]\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if indexDiff == 0 or valueDiff == 0:\n            return len(set(nums)) < len(nums)\n        \n        buckets = {}\n        for i, num in enumerate(nums):\n            bucket = num // (valueDiff + 1)\n            if bucket in buckets:\n                return True\n            if bucket - 1 in buckets and abs(num - buckets[bucket - 1]) <= valueDiff:\n                return True\n            if bucket + 1 in buckets and abs(num - buckets[bucket + 1]) <= valueDiff:\n                return True\n            buckets[bucket] = num\n            if i >= indexDiff:\n                del buckets[nums[i - indexDiff] // (valueDiff + 1)]\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 2-pass solution\n        # count = collections.Counter(nums)\n        # nums[:count[0]] = [0] * count[0]\n        # nums[count[0]:count[0]+count[1]] = [1] * count[1]\n        # nums[count[0]+count[1]:] = [2] * count[2]\n        \n        # 2. 1-pass solution\n        # p0 = cur = 0\n        # p2 = len(nums) - 1\n        \n        # while cur <= p2:\n        #     if nums[cur] == 0:\n        #         nums[p0], nums[cur] = nums[cur], nums[p0]\n        #         p0 += 1\n        #         cur += 1\n        #     elif nums[cur] == 2:\n        #         nums[cur], nums[p2] = nums[p2], nums[cur]\n        #         p2 -= 1\n        #     else:\n        #         cur += 1\n        \n        # 3. 1-pass solution\n        p0 = cur = 0\n        p2 = len(nums) - 1\n        \n        while cur <= p2:\n            if nums[cur] == 0:\n                nums[p0], nums[cur] = nums"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 3-way partitioning\n        # Dutch National Flag problem solution\n        # https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n        \n        # for all idx < i : nums[idx < i] = 0\n        # for all idx > k : nums[idx > k] = 2\n        # for all idx from i to k: unclassified\n        \n        # initialize\n        i = 0\n        j = 0\n        k = len(nums) - 1\n        \n        while j <= k:\n            if nums[j] == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j += 1\n            elif nums[j] == 1:\n                j += 1\n            else:\n                nums[j], nums[k] = nums[k], nums[j]\n                k -= 1"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 3-way partitioning\n        # Dutch National Flag problem solution\n        \n        # for all idx < low : nums[idx < low] = 0\n        # for all idx > high : nums[idx > high] = 2\n        # for all idx in [low, high] : nums[idx] = 1\n        \n        low, high = 0, len(nums) - 1\n        i = 0\n        \n        while i <= high:\n            if nums[i] == 0:\n                nums[i], nums[low] = nums[low], nums[i]\n                i += 1\n                low += 1\n            elif nums[i] == 2:\n                nums[i], nums[high] = nums[high], nums[i]\n                high -= 1\n            else:\n                i += 1"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 0, 1, 2\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 1, 1, 2, 2, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 2-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1, 2, 2, 2\n        \n        # 1-pass\n        # 0, 1, 2, 0, 2, 1, 1, 2, 0\n        # 0, 0, 0, 1, 1, 2, 2, 2, 0\n        # 0, 0, 0, 0, 1, 1"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 3-way partitioning\n        # Dutch National Flag problem solution\n        \n        # for all idx < low : nums[idx < low] = 0\n        # for all idx > high : nums[idx > high] = 2\n        # for all idx in [low, high] : nums[idx] = 1\n        \n        low = mid = 0\n        high = len(nums) - 1\n        \n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 168 ms, faster than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## Memory Usage: 13.7 MB, less than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## 1. Initialize a variable to store the maximum number of consecutive 1s\n        ## 2. Initialize a variable to store the current number of consecutive 1s\n        ## 3. Iterate through the array\n        ## 4. If the current element is 1, increment the current number of consecutive 1s\n        ## 5. If the current element is 0, update the maximum number of consecutive 1s if the current number of consecutive 1s is greater than the maximum number of consecutive 1s\n        ## 6. Reset the current number of consecutive 1s to 0\n        ## 7. Return the maximum number of consecutive 1s\n        \n        ## 2. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## Memory Usage: 13.7 MB, less than 99 of Python online submissions for Max Consecutive Ones.\n        ## 1. Initialize a variable to store the maximum number of consecutive 1s\n        ## 2. Initialize a variable to store the current number of consecutive 1s\n        ## 3. Iterate through the array\n        ## 4. If the current element is 1, increment the current number of consecutive 1s\n        ## 5. If the current element is 0, update the maximum number of consecutive 1s if the current number of consecutive 1s is greater than the maximum number of consecutive 1s\n        ## 6. Reset the current number of consecutive 1s to 0\n        ## 7. Return the maximum number of consecutive 1s\n        \n        ## 3. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## Memory Usage: 13.7 MB, less than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## 1. Initialize a variable to store the maximum number of consecutive 1s\n        ## 2. Initialize a variable to store the current number of consecutive 1s\n        ## 3. Iterate through the array\n        ## 4. If the current element is 1, increment the current number of consecutive 1s\n        ## 5. If the current element is 0, update the maximum number of consecutive 1s if the current number of consecutive 1s is greater than the maximum number of consecutive 1s\n        ## 6. Reset the current number of consecutive 1s to 0\n        ## 7. Return the maximum number of consecutive 1s\n        \n        ## 4. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## Memory Usage: 13.7 MB, less than 99.97% of Python online submissions for Max Consecutive Ones.\n        ## 1. Initialize a variable to store the maximum number of consecutive 1s\n        ## 2. Initialize a variable to store the current number of consecutive 1s\n        ## 3. Iterate through the array\n        ## 4. If the current element is 1, increment the current number of consecutive 1s\n        ## 5. If the current element is 0, update the maximum number of consecutive 1s if the current number of consecutive 1s is greater than the maximum number of consecutive 1s"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if not root:\n            return 0\n        \n        # get the height of the left and right subtree\n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        # if the height of the left subtree is equal to the height of the right subtree,\n        # then the left subtree is a full binary tree, and we can count the nodes in the left subtree\n        # and add 1 for the root node\n        if left_height == right_height:\n            return (1 << left_height) + self.countNodes(root.right)\n        # otherwise, the right subtree is a full binary tree, and we can count the nodes in the right subtree\n        # and add 1 for the root node\n        else:\n            return (1 << right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # base case\n        if not root:\n            return 0\n        # recursively get the height of the left and right subtree\n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = 0\n        left_node = root\n        while left_node:\n            left_height += 1\n            left_node = left_node.left\n        \n        right_height = 0\n        right_node = root\n        while right_node:\n            right_height += 1\n            right_node = right_node.right\n        \n        if left_height == right_height:\n            return 2 ** left_height - 1\n        \n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = 0\n        left_node = root\n        while left_node:\n            left_height += 1\n            left_node = left_node.left\n        \n        right_height = 0\n        right_node = root\n        while right_node:\n            right_height += 1\n            right_node = right_node.right\n        \n        if left_height == right_height:\n            return 2 ** left_height - 1\n        \n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        def get_depth(node):\n            if not node:\n                return 0\n            return 1 + get_depth(node.left)\n        \n        left_depth = get_depth(root.left)\n        right_depth = get_depth(root.right)\n        \n        if left_depth == right_depth:\n            return 2**left_depth + self.countNodes(root.right)\n        else:\n            return 2**right_depth + self.countNodes(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = 0\n        left_node = root\n        while left_node:\n            left_height += 1\n            left_node = left_node.left\n        \n        right_height = 0\n        right_node = root\n        while right_node:\n            right_height += 1\n            right_node = right_node.right\n        \n        if left_height == right_height:\n            return 2**left_height - 1\n        \n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        return str(num1 + num2)"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        num3 = num1 + num2\n        \n        # convert to string\n        num3 = str(num3)\n        \n        return num3"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        i = 0\n        res = \"\"\n        \n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        return str(num1 + num2)"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        return str(num1 + num2)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif c == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        \n        return res + sign * num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u7a7a\u683c\n        s = s.replace(\" \", \"\")\n        \n        # 2. \u53bb\u9664\u62ec\u53f7\n        while '(' in s:\n            s = self.remove(s)\n        \n        # 3. \u8ba1\u7b97\n        return self.helper(s)\n    \n    def remove(self, s):\n        stack = []\n        i, n = 0, len(s)\n        while i < n and s[i] != ')':\n            if s[i] != '(':\n                stack.append(s[i])\n            i += 1\n        return ''.join(stack) + s[i + 1:]\n    \n    def helper(self, s):\n        stack = []\n        pre_op = '+'\n        num = 0\n        n = len(s)\n        for i, ch in enumerate(s):\n            if ch.isdigit():\n                num = 10 * num + int(ch)\n            if i == n - 1 or not ch.isdigit():\n                if pre_op == '+':\n                    stack.append(num)\n                elif pre_op == '-':\n                    stack.append(-num)\n                elif pre_op == '*':\n                    stack[-1] *= num\n                else:\n                    if stack[-1] >= 0:\n                        stack[-1] //= num\n                    else:\n                        stack[-1] = -(-stack[-1] // num)\n                pre_op = ch\n                num = 0\n        return sum(stack)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif c == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        \n        return res + sign * num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif c == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        \n        return res + sign * num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif c == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        \n        return res + sign * num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # greedy\n        # time: O(nlogn)\n        # space: O(n)\n        \n        # sort by capital\n        # use a max heap to store profits\n        # pop the max profit from the heap and add to capital\n        # repeat until k projects are done\n        \n        # sort by capital\n        projects = sorted(zip(profits, capital))\n        \n        # max heap\n        heap = []\n        \n        # index of current project\n        i = 0\n        \n        # while there are projects left and we have not done k projects\n        while i < len(projects) and k > 0:\n            # if the current project can be done\n            if projects[i][1] <= w:\n                # add the profit to the heap\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            else:\n                # if the current project cannot be done\n                # if the heap is empty\n                if not heap:\n                    # return the current capital\n                    return w\n                # pop the max profit from the heap\n                w -= heapq.heappop(heap)\n                k -= 1\n        \n        # if there are no more projects left\n        # return the current capital\n        return w + sum(heap)"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Greedy\n        # Time: O(nlogn)\n        # Space: O(n)\n        \n        # 1. Sort the projects by capital\n        # 2. Use a max heap to store the profits\n        # 3. Pop the max profit from the heap and add it to the total capital\n        # 4. Repeat 2 and 3 until k projects are done or no more projects can be done\n        \n        # Sort the projects by capital\n        projects = sorted(zip(profits, capital))\n        \n        # Initialize the heap\n        heap = []\n        \n        # Initialize the index\n        i = 0\n        \n        # Loop until k projects are done or no more projects can be done\n        while k > 0:\n            # Add all projects that can be done\n            while i < len(projects) and projects[i][1] <= w:\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            # If no more projects can be done, break\n            if not heap:\n                break\n            # Pop the max profit from the heap and add it to the total capital\n            w -= heapq.heappop(heap)\n            k -= 1\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # greedy\n        # time: O(nlogn)\n        # space: O(n)\n        \n        # 1. sort by capital\n        # 2. use a max heap to store profits\n        # 3. pop k times\n        \n        projects = sorted(zip(profits, capital))\n        heap = []\n        i = 0\n        for _ in range(k):\n            while i < len(projects) and projects[i][1] <= w:\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            if heap:\n                w -= heapq.heappop(heap)\n            else:\n                break\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # greedy\n        # time: O(nlogn)\n        # space: O(n)\n        \n        # sort by capital\n        # use a max heap to store profits\n        # pop the max profit from the heap and add to capital\n        # repeat until k projects are done\n        \n        # sort by capital\n        projects = sorted(zip(profits, capital))\n        \n        # max heap\n        heap = []\n        \n        # index of the current project\n        i = 0\n        \n        # while there are projects left and we have not finished k projects\n        while i < len(projects) and k > 0:\n            # if the current project can be done\n            if projects[i][1] <= w:\n                # add the profit to the heap\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            else:\n                # if the current project cannot be done\n                # check if there are any projects left\n                if not heap:\n                    break\n                # pop the max profit from the heap\n                w -= heapq.heappop(heap)\n                k -= 1\n        \n        # add the remaining profits to the capital\n        w -= sum(heap)\n        \n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Greedy\n        # Time: O(nlogn)\n        # Space: O(n)\n        \n        # 1. Sort by capital\n        # 2. Use a max heap to store profits\n        # 3. Pop k times from the heap\n        \n        projects = sorted(zip(profits, capital))\n        heap = []\n        i = 0\n        \n        for _ in range(k):\n            while i < len(projects) and projects[i][1] <= w:\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            if heap:\n                w -= heapq.heappop(heap)\n            else:\n                break\n        \n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        \n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the first decreasing element from the end\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # 2. If found, swap it with the next greater element to its right\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # 3. Reverse the subarray to the right of the found element\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the first decreasing element from the end\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # 2. If found, swap it with the next greater element to its right\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # 3. Reverse the suffix to the right of the found element\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the first decreasing element from the end\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # 2. If found, swap it with the next greater element to its right\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # 3. Reverse the subarray to the right of the found element\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the first decreasing element from the end\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # 2. If found, swap it with the next greater element to its right\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # 3. Reverse the suffix to the right of the found element\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the first decreasing element from the end\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # 2. If found, swap it with the next greater element to its right\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # 3. Reverse the subarray to the right of the found element\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary to the current index\n        # if the number is not in the dictionary, add it to the dictionary\n        # return False\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the index of each number\n        d = {}\n        \n        # iterate through the array\n        for i in range(len(nums)):\n            # if the number is already in the dictionary\n            if nums[i] in d:\n                # if the difference between the current index and the index in the dictionary is less than or equal to k\n                if i - d[nums[i]] <= k:\n                    # return True\n                    return True\n            # update the index in the dictionary to the current index\n            d[nums[i]] = i\n        # return False\n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary to the current index\n        # if the number is not in the dictionary, add it to the dictionary\n        # return False\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the index of each number\n        d = {}\n        \n        # iterate through the array\n        for i in range(len(nums)):\n            # if the number is already in the dictionary\n            if nums[i] in d:\n                # if the difference between the current index and the index in the dictionary is less than or equal to k\n                if i - d[nums[i]] <= k:\n                    # return True\n                    return True\n            # update the index in the dictionary to the current index\n            d[nums[i]] = i\n        # return False\n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        d = {}\n        \n        # iterate through the array\n        for i in range(len(nums)):\n            # if the number is in the dictionary\n            if nums[i] in d:\n                # if the difference between the current index and the index of the number is less than or equal to k\n                if i - d[nums[i]] <= k:\n                    # return True\n                    return True\n            # add the number to the dictionary with its index\n            d[nums[i]] = i\n        # return False\n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in the dictionary, add it to the dictionary with the current index\n        # if the number is not in"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary to the current index\n        # if the number is not in the dictionary, add it to the dictionary\n        # return False\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the index of each number\n        d = {}\n        \n        # iterate through the array\n        for i in range(len(nums)):\n            # if the number is already in the dictionary\n            if nums[i] in d:\n                # if the difference between the current index and the index in the dictionary is less than or equal to k\n                if i - d[nums[i]] <= k:\n                    # return True\n                    return True\n            # update the index in the dictionary to the current index\n            d[nums[i]] = i\n        # return False\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num = min(nums)\n        max_num = max(nums)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))\n        bucket_num = (max_num - min_num) // bucket_size + 1\n        \n        buckets = [[] for _ in range(bucket_num)]\n        \n        for num in nums:\n            bucket_idx = (num - min_num) // bucket_size\n            buckets[bucket_idx].append(num)\n        \n        max_gap = 0\n        prev_max = min_num\n        \n        for bucket in buckets:\n            if not bucket:\n                continue\n            \n            curr_min = min(bucket)\n            curr_max = max(bucket)\n            \n            max_gap = max(max_gap, curr_min - prev_max)\n            prev_max = curr"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num = min(nums)\n        max_num = max(nums)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))\n        bucket_num = (max_num - min_num) // bucket_size + 1\n        \n        buckets = [None] * bucket_num\n        \n        for num in nums:\n            bucket_idx = (num - min_num) // bucket_size\n            if buckets[bucket_idx] is None:\n                buckets[bucket_idx] = [num, num]\n            else:\n                buckets[bucket_idx][0] = min(buckets[bucket_idx][0], num)\n                buckets[bucket_idx][1] = max(buckets[bucket_idx][1], num)\n        \n        max_gap = 0\n        prev_max = min_num\n        \n        for bucket in buckets:\n            if bucket is not None:\n                max_gap = max(max_gap, bucket[0] - prev_max)\n                prev_max = bucket[1]\n        \n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num = min(nums)\n        max_num = max(nums)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))\n        bucket_num = (max_num - min_num) // bucket_size + 1\n        \n        buckets = [[] for _ in range(bucket_num)]\n        \n        for num in nums:\n            bucket_idx = (num - min_num) // bucket_size\n            buckets[bucket_idx].append(num)\n        \n        max_gap = 0\n        prev_max = min_num\n        \n        for bucket in buckets:\n            if not bucket:\n                continue\n            \n            curr_min = min(bucket)\n            curr_max = max(bucket)\n            \n            max_gap = max(max_gap, curr_min - prev_max)\n            prev_max = curr"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num = min(nums)\n        max_num = max(nums)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))\n        bucket_num = (max_num - min_num) // bucket_size + 1\n        \n        buckets = [None] * bucket_num\n        \n        for num in nums:\n            bucket_idx = (num - min_num) // bucket_size\n            if buckets[bucket_idx] is None:\n                buckets[bucket_idx] = [num, num]\n            else:\n                buckets[bucket_idx][0] = min(buckets[bucket_idx][0], num)\n                buckets[bucket_idx][1] = max(buckets[bucket_idx][1], num)\n        \n        max_gap = 0\n        prev_max = min_num\n        \n        for bucket in buckets:\n            if bucket is not None:\n                max_gap = max(max_gap, bucket[0] - prev_max)\n                prev_max = bucket[1]\n        \n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num = min(nums)\n        max_num = max(nums)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))\n        bucket_num = (max_num - min_num) // bucket_size + 1\n        \n        buckets = [None] * bucket_num\n        \n        for num in nums:\n            bucket_idx = (num - min_num) // bucket_size\n            if buckets[bucket_idx] is None:\n                buckets[bucket_idx] = [num, num]\n            else:\n                buckets[bucket_idx][0] = min(buckets[bucket_idx][0], num)\n                buckets[bucket_idx][1] = max(buckets[bucket_idx][1], num)\n        \n        max_gap = 0\n        prev_max = min_num\n        \n        for bucket in buckets:\n            if bucket is not None:\n                max_gap = max(max_gap, bucket[0] - prev_max)\n                prev_max = bucket[1]\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the partner of each person\n        # 2. iterate through the row, if the person is not in the dictionary, add it to the dictionary\n        # 3. if the person is in the dictionary, check if the partner is in the dictionary\n        # 4. if the partner is in the dictionary, swap the person with the partner\n        # 5. if the partner is not in the dictionary, swap the person with the next person\n        # 6. increment the swap count\n        # 7. return the swap count\n        \n        # create a dictionary to store the partner of each person\n        partners = {}\n        for i in range(0, len(row), 2):\n            partners[row[i]] = row[i+1]\n            partners[row[i+1]] = row[i]\n        \n        # iterate through the row\n        swaps = 0\n        for i in range(0, len(row), 2):\n            # if the person is not in the dictionary, add it to the dictionary\n            if row[i] not in partners:\n                partners[row[i]] = row[i+1]\n                partners[row[i+1]] = row[i]\n            # if the person is in the dictionary, check if the partner is in the dictionary\n            elif partners[row[i]] in partners:\n                # if the partner is in the dictionary, swap the person with the partner\n                partner = partners[row[i]]\n                partners[row[i]] = row[i+1]\n                partners[row[i+1]] = row[i]\n                partners[partner] = partner\n                partners[row[i+1]] = partner\n            else:\n                # if the partner is not in the dictionary, swap the person with the next person\n                partners[row[i+1]] = row[i]\n                partners[row[i]] = row[i+1]\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the partner of each person\n        # 2. iterate through the row, if the current person's partner is not in the row, swap it with the person's partner\n        # 3. if the current person's partner is in the row, swap it with the next person\n        # 4. return the number of swaps\n        \n        # create a dictionary to store the partner of each person\n        partners = {}\n        for i in range(len(row)):\n            partners[row[i]] = row[i] % 2 == 0 and row[i] + 1 or row[i] - 1\n        \n        # iterate through the row\n        swaps = 0\n        for i in range(0, len(row), 2):\n            if row[i + 1] != partners[row[i]]:\n                swaps += 1\n                # swap the current person's partner with the next person\n                j = row.index(partners[row[i]])\n                row[i + 1], row[j] = row[j], row[i + 1]\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the partner of each person\n        # 2. iterate through the row, if the person is not in the dictionary, add it to the dictionary\n        # 3. if the person is in the dictionary, check if the partner is in the dictionary\n        # 4. if the partner is in the dictionary, check if the partner is the next person in the row\n        # 5. if the partner is not the next person in the row, swap the person with the partner\n        # 6. if the partner is the next person in the row, do nothing\n        # 7. if the person is not in the dictionary, add it to the dictionary\n        # 8. return the number of swaps\n        \n        # create a dictionary to store the partner of each person\n        partners = {}\n        # iterate through the row\n        for i in range(0, len(row), 2):\n            # if the person is not in the dictionary, add it to the dictionary\n            if row[i] not in partners:\n                partners[row[i]] = row[i+1]\n            # if the person is in the dictionary, check if the partner is in the dictionary\n            elif row[i] in partners:\n                # if the partner is in the dictionary, check if the partner is the next person in the row\n                if partners[row[i]] == row[i+1]:\n                    # if the partner is the next person in the row, do nothing\n                    continue\n                # if the partner is not the next person in the row, swap the person with the partner\n                else:\n                    # swap the person with the partner\n                    row[i+1], row[row.index(partners[row[i]])] = row[row.index(partners[row[i]])], row[i+1]\n                    # update the dictionary\n                    partners[row[i+1]] = row[i]\n        # return the number of swaps\n        return len(row) // 2 - len(partners)"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the partner of each person\n        # 2. create a set to store the people who are already seated\n        # 3. create a variable to store the number of swaps\n        # 4. iterate through the row\n        # 5. if the person is not in the set, add them to the set\n        # 6. if the person is in the set, remove them from the set\n        # 7. if the person is not in the set, find their partner\n        # 8. if the partner is not in the set, add them to the set and increment the number of swaps\n        # 9. if the partner is in the set, remove them from the set\n        # 10. return the number of swaps\n        \n        # create a dictionary to store the partner of each person\n        partners = {}\n        for i in range(len(row)):\n            partners[row[i]] = row[i] % 2 == 0 and row[i] + 1 or row[i] - 1\n        \n        # create a set to store the people who are already seated\n        seated = set()\n        \n        # create a variable to store the number of swaps\n        swaps = 0\n        \n        # iterate through the row\n        for person in row:\n            # if the person is not in the set, add them to the set\n            if person not in seated:\n                seated.add(person)\n            # if the person is in the set, remove them from the set\n            else:\n                seated.remove(person)\n                # if the person is not in the set, find their partner\n                if partners[person] not in seated:\n                    # if the partner is not in the set, add them to the set and increment the number of swaps\n                    seated.add(partners[person])\n                    swaps += 1\n                # if the partner is in the set, remove them from the set\n                else:\n                    seated.remove(partners[person])\n        \n        # return the number of swaps\n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i > 0:\n                    dp[i][j] = dp[i][j] or (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n                if j > 0:\n                    dp[i][j] = dp[i][j] or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i > 0:\n                    dp[i][j] = dp[i][j] or (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n                if j > 0:\n                    dp[i][j] = dp[i][j] or (dp[i][j - ] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i > 0:\n                    dp[i][j] = dp[i][j] or (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1])\n                if j > 0:\n                    dp[i][j] = dp[i][j] or (dp[i][j - ] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            w = set(word.lower())\n            if w.issubset(first) or w.issubset(second) or w.issubset(third):\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            w = set(word.lower())\n            if w.issubset(first) or w.issubset(second) or w.issubset(third):\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            w = set(word.lower())\n            if w.issubset(first) or w.issubset(second) or w.issubset(third):\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            w = set(word.lower())\n            if w.issubset(first) or w.issubset(second) or w.issubset(third):\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            w = set(word.lower())\n            if w.issubset(first) or w.issubset(second) or w.issubset(third):\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur, prev = head, None\n        while left > 1:\n            prev = cur\n            cur = cur.next\n            left, right = left - 1, right - 1\n            \n        tail, con = cur, prev\n        \n        while right:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            right -= 1\n            \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur, prev = head, None\n        while left > 1:\n            prev = cur\n            cur = cur.next\n            left, right = left - 1, right - 1\n        \n        tail, con = cur, prev\n        \n        while right:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            right -= 1\n        \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        cur, prev = head, None\n        while left > 1:\n            prev = cur\n            cur = cur.next\n            left, right = left - 1, right - 1\n            \n        tail, con = cur, prev\n        \n        while right:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            right -= 1\n            \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur, prev = head, None\n        while left > 1:\n            prev = cur\n            cur = cur.next\n            left, right = left - 1, right - 1\n        \n        tail, con = cur, prev\n        \n        while right:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            right -= 1\n        \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for i in range(left - 1):\n            prev = prev.next\n        \n        curr = prev.next\n        \n        for i in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # KMP\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        if n == 0:\n            return s\n        \n        # build the KMP table\n        table = [0] * n\n        i, j = 1, 0\n        while i < n:\n            if s[i] == s[j]:\n                table[i] = j + 1\n                i += 1\n                j += 1\n            elif j > 0:\n                j = table[j - 1]\n            else:\n                table[i] = 0\n                i += 1\n        \n        # find the longest palindrome prefix\n        i, j = n - 1, n - 1\n        while i >= 0 and s[i] == s[j]:\n            i -= 1\n            j -= 1\n        \n        # add the suffix of the original string to the front\n        return s[j + 1:][::-1] + s"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # KMP\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        if n <= 1:\n            return s\n        \n        # build the KMP table\n        # table[i] = the longest proper prefix of s[:i+1] which is also a suffix of s[:i+1]\n        table = [0] * n\n        i, j = 1, 0\n        while i < n:\n            if s[i] == s[j]:\n                table[i] = j + 1\n                i += 1\n                j += 1\n            elif j == 0:\n                table[i] = 0\n                i += 1\n            else:\n                j = table[j - 1]\n        \n        # find the longest palindrome prefix\n        i = n - 1\n        while i >= 0 and s[i] == s[table[i]]:\n            i -= 1\n        \n        # add the suffix of s[:i+1] to the front of s\n        return s[table[n - 1]:][::-1] + s"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # KMP\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        if n == 0:\n            return s\n        \n        # build the KMP table\n        # table[i] = the longest proper prefix of s[:i+1] which is also a suffix\n        table = [0] * n\n        for i in range(1, n):\n            j = table[i-1]\n            while j > 0 and s[i] != s[j]:\n                j = table[j-1]\n            if s[i] == s[j]:\n                j += 1\n            table[i] = j\n        \n        # find the longest palindrome prefix\n        i = n - 1\n        while i >= 0 and s[i] != s[table[i]]:\n            i = table[i] - 1\n        \n        # add the suffix of the palindrome prefix to the front\n        return s[table[n-1]:][::-1] + s"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # KMP\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        if n <= 1:\n            return s\n        \n        # build the KMP table\n        # table[i] = the longest proper prefix of s[:i+1] which is also a suffix\n        table = [0] * n\n        i, j = 1, 0\n        while i < n:\n            if s[i] == s[j]:\n                table[i] = j + 1\n                i += 1\n                j += 1\n            elif j == 0:\n                table[i] = 0\n                i += 1\n            else:\n                j = table[j - 1]\n        \n        # find the longest palindrome prefix\n        i = n - 1\n        while i >= 0 and s[i] == s[table[i]]:\n            i -= 1\n        \n        # add the suffix of s[i+1:] to the front\n        return s[table[n - 1]:][::-1] + s"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # KMP\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        if n <= 1:\n            return s\n        \n        # build the KMP table\n        # table[i] = the longest proper prefix of s[:i+1] which is also a suffix of s[:i+1]\n        table = [0] * n\n        i, j = 1, 0\n        while i < n:\n            if s[i] == s[j]:\n                table[i] = j + 1\n                i += 1\n                j += 1\n            elif j == 0:\n                table[i] = 0\n                i += 1\n            else:\n                j = table[j - 1]\n        \n        # find the longest palindrome prefix\n        i = n - 1\n        while i >= 0 and s[i] == s[table[i]]:\n            i -= 1\n        \n        # add the suffix of s[:i+1] to the front of s\n        return s[table[n - 1]:][::-1] + s"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if t == \"\": return \"\"\n        \n        countT, window = {}, {}\n        \n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n        \n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n            \n            if c in countT and window[c] == countT[c]:\n                have += 1\n            \n            while have == need:\n                # update our result\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                # pop from the left of our window\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l:r+1] if resLen != float(\"infinity\") else \"\""}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if t == \"\": return \"\"\n        \n        countT, window = {}, {}\n        \n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n        \n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n            \n            if c in countT and window[c] == countT[c]:\n                have += 1\n            \n            while have == need:\n                # update our result\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                # pop from the left of our window\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l:r+1] if resLen != float(\"infinity\") else \"\""}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if t == \"\": return \"\"\n        \n        countT, window = {}, {}\n        \n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n        \n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n            \n            if c in countT and window[c] == countT[c]:\n                have += 1\n            \n            while have == need:\n                # update our result\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                # pop from the left of our window\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l:r+1] if resLen != float(\"infinity\") else \"\""}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_count = {}\n        for c in t:\n            t_count[c] = t_count.get(c, 0) + 1\n        \n        s_count = {}\n        left = 0\n        min_len = float('inf')\n        min_left = 0\n        min_right = 0\n        \n        for right, c in enumerate(s):\n            s_count[c] = s_count.get(c, 0) + 1\n            \n            while all(s_count.get(c, 0) >= count for c, count in t_count.items()):\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    min_left = left\n                    min_right = right\n                \n                s_count[s[left]] -= 1\n                left += 1\n        \n        return s[min_left:min_right+1] if min_len != float('inf') else \"\""}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if t == \"\": return \"\"\n        \n        countT, window = {}, {}\n        \n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n        \n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n            \n            if c in countT and window[c] == countT[c]:\n                have += 1\n            \n            while have == need:\n                # update our result\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                # pop from the left of our window\n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l:r+1] if resLen != float(\"infinity\") else \"\""}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) < 4:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            \n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            \n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n        \n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4th line crosses 1st line and work backwards\n        # 2. 5th line crosses 1st line and work backwards\n        # 3. 6th line crosses 1st line and work backwards\n        \n        # 1. 4th line crosses 1st line and work backwards\n        if len(distance) >= 5 and distance[3] >= distance[1] and distance[4] >= distance[2]:\n            return True\n        \n        # 2. 5th line crosses 1st line and work backwards\n        if len(distance) >= 6 and distance[5] + distance[1] >= distance[3] and distance[4] + distance[0] >= distance[2] and distance[4] >= distance[2] and distance[5] >= distance[1]:\n            return True\n        \n        # 3. 6th line crosses 1st line and work backwards\n        if len(distance) >= 7 and distance[6] + distance[2] >= distance[4] and distance[5] + distance[1] >= distance[3] and distance[5] >= distance[1] and distance[6] >= distance[2]:\n            return True\n        \n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) < 4:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            \n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            \n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n        \n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) < 4:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            \n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                return True\n            \n            if i >= 5 and distance[i-2] >= distance[i-4] and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            \n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4th line crosses 1st line and point of intersection is (0,0)\n        # 2. 5th line crosses 1st line and point of intersection is (0,0)\n        # 3. 6th line crosses 1st line and point of intersection is (0,0)\n        # 4. 7th line crosses 1st line and point of intersection is (0,0)\n        # 5. 8th line crosses 1st line and point of intersection is (0,0)\n        # 6. 9th line crosses 1st line and point of intersection is (0,0)\n        # 7. 10th line crosses 1st line and point of intersection is (0,0)\n        # 8. 11th line crosses 1st line and point of intersection is (0,0)\n        # 9. 12th line crosses 1st line and point of intersection is (0,0)\n        # 10. 13th line crosses 1st line and point of intersection is (0,0)\n        # 11. 14th line crosses 1st line and point of intersection is (0,0)\n        # 12. 15th line crosses 1st line and point of intersection is (0,0)\n        # 13. 16th line crosses 1st line and point of intersection is (0,0)\n        # 14. 17th line crosses 1st line and point of intersection is (0,0)\n        # 15. 18th line crosses 1st line and point of intersection is (0,0)\n        # 16. 19th line crosses 1st line and point of intersection is (0,0)\n        # 17. 20th line crosses 1st line and point of intersection is (0,0)\n        # 18. 21st line crosses 1st line and point of intersection is (0,0)\n        # 19. 22nd line crosses 1st line and point of intersection is (0,0)\n        # 20. 23rd line crosses 1st line and point of intersection is (0,0)\n        # 21. 24th line crosses 1st line and point of intersection is (0,0)\n        # 22. 25th line crosses 1st line and point of intersection is (0,0)\n        # 23. 26th line crosses 1st line and point of intersection is (0,0)\n        # 24. 27th line crosses 1st line and point of intersection is (0,0)\n        # 25. 28th line crosses 1st line and point of intersection is (0,0)\n        # 26. 29th line crosses 1st line and point of intersection is (0,0)\n        # 27. 30th line crosses 1st line and point of intersection is (0,0)\n        # 28. 31st line crosses 1st line and point of intersection is (0,0)\n        # 29. 32nd line crosses 1st line and point of intersection is (0,0)\n        # 30. 33rd line crosses 1st line and point of intersection is (0,0)\n        # 31. 34th line crosses 1st line and point of intersection is (0,0)\n        # 32. 35th line crosses 1st line and point of intersection is (0,0)\n        # 33. 36th line crosses 1st line and point of intersection is (0,0)\n        # 34. 37th line crosses 1st line and point of intersection is (0,0)\n        # 35. 38th line crosses 1st line and point of intersection is (0,0)\n        # 36. 39th line crosses 1st line and point of intersection is (0,0)\n        # 37. 40th line crosses 1st line and point of intersection is (0,0)\n        #"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even values to the result\n        # 3. if there is a odd value, add it to the result\n        # 4. if there is a odd value, add it to the result\n        # 5. if there is a odd value, add it to the result\n        # 6. if there is a odd value, add it to the result\n        # 7. if there is a odd value, add it to the result\n        # 8. if there is a odd value, add it to the result\n        # 9. if there is a odd value, add it to the result\n        # 10. if there is a odd value, add it to the result\n        # 11. if there is a odd value, add it to the result\n        # 12. if there is a odd value, add it to the result\n        # 13. if there is a odd value, add it to the result\n        # 14. if there is a odd value, add it to the result\n        # 15. if there is a odd value, add it to the result\n        # 16. if there is a odd value, add it to the result\n        # 17. if there is a odd value, add it to the result\n        # 18. if there is a odd value, add it to the result\n        # 19. if there is a odd value, add it to the result\n        # 20. if there is a odd value, add it to the result\n        # 21. if there is a odd value, add it to the result\n        # 22. if there is a odd value, add it to the result\n        # 23. if there is a odd value, add it to the result\n        # 24. if there is a odd value, add it to the result\n        # 25. if there is a odd value, add it to the result\n        # 26. if there is a odd value, add it to the result\n        # 27. if there is a odd value, add it to the result\n        # 28. if there is a odd value, add it to the result\n        # 29. if there is a odd value, add it to the result\n        # 30. if there is a odd value, add it to the result\n        # 31. if there is a odd value, add it to the result\n        # 32. if there is a odd value, add it to the result\n        # 33. if there is a odd value, add it to the result\n        # 34. if there is a odd value, add it to the result\n        # 35. if there is a odd value, add it to the result\n        # 36. if there is a odd value, add it to the result\n        # 37. if there is a odd value, add it to the result\n        # 38. if there is a odd value, add it to the result\n        # 39. if there is a odd value, add it to the result\n        # 40. if there is a odd value, add it to the result\n        # 41. if there is a odd value, add it to the result\n        # 42. if there is a odd value, add it to the result\n        # 43. if there is a odd value, add it to the result\n        # 44. if there is a odd value, add it to the result\n        # 45. if there is a odd value, add it to the result\n        # 46. if there is a odd value, add it to the result\n        # 47. if there is a odd value, add it to the result\n        # 48. if there is a odd value, add it to the result\n        # 49. if there is a odd value, add it to the result\n        # 50. if there is a odd value, add it to the result\n        # 51. if there is a odd value, add it to the result\n        # 52. if there is a odd value, add it to the result\n        # 53. if there is a odd value, add it to the result\n        # 54. if there is a odd value, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the count of each character\n        # 2. iterate through the dictionary and add the even count to the result\n        # 3. if there is any odd count, add 1 to the result\n        # 4. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and add the count to the dictionary\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the dictionary and add the even count to the result\n        result = 0\n        for char in char_count:\n            result += char_count[char] // 2 * 2\n        \n        # if there is any odd count, add 1 to the result\n        if any(char_count[char] % 2 for char in char_count):\n            result += 1\n        \n        return result"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even values to the result\n        # 3. if there is an odd value, add it to the result\n        # 4. if there is an odd value, add it to the result\n        # 5. if there is an odd value, add it to the result\n        # 6. if there is an odd value, add it to the result\n        # 7. if there is an odd value, add it to the result\n        # 8. if there is an odd value, add it to the result\n        # 9. if there is an odd value, add it to the result\n        # 10. if there is an odd value, add it to the result\n        # 11. if there is an odd value, add it to the result\n        # 12. if there is an odd value, add it to the result\n        # 13. if there is an odd value, add it to the result\n        # 14. if there is an odd value, add it to the result\n        # 15. if there is an odd value, add it to the result\n        # 16. if there is an odd value, add it to the result\n        # 17. if there is an odd value, add it to the result\n        # 18. if there is an odd value, add it to the result\n        # 19. if there is an odd value, add it to the result\n        # 20. if there is an odd value, add it to the result\n        # 21. if there is an odd value, add it to the result\n        # 22. if there is an odd value, add it to the result\n        # 23. if there is an odd value, add it to the result\n        # 24. if there is an odd value, add it to the result\n        # 25. if there is an odd value, add it to the result\n        # 26. if there is an odd value, add it to the result\n        # 27. if there is an odd value, add it to the result\n        # 28. if there is an odd value, add it to the result\n        # 29. if there is an odd value, add it to the result\n        # 30. if there is an odd value, add it to the result\n        # 31. if there is an odd value, add it to the result\n        # 32. if there is an odd value, add it to the result\n        # 33. if there is an odd value, add it to the result\n        # 34. if there is an odd value, add it to the result\n        # 35. if there is an odd value, add it to the result\n        # 36. if there is an odd value, add it to the result\n        # 37. if there is an odd value, add it to the result\n        # 38. if there is an odd value, add it to the result\n        # 39. if there is an odd value, add it to the result\n        # 40. if there is an odd value, add it to the result\n        # 41. if there is an odd value, add it to the result\n        # 42. if there is an odd value, add it to the result\n        # 43. if there is an odd value, add it to the result\n        # 44. if there is an odd value, add it to the result\n        # 45. if there is an odd value, add it to the result\n        # 46. if there is an odd value, add it to the result\n        # 47. if there is an odd value, add it to the result\n        # 48. if there is an odd value, add it to the result\n        # 49. if there is an odd value, add it to the result\n        # 50. if there is an odd value, add it to the result\n        # 51. if there is an odd value, add it to the result\n        # 52. if there is an odd value, add it to the result\n        # 53. if there is an odd value, add it to the result\n        # 54. if there is an odd value, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even values to the result\n        # 3. if there is an odd value, add it to the result\n        # 4. if there is an odd value, add it to the result\n        # 5. if there is an odd value, add it to the result\n        # 6. if there is an odd value, add it to the result\n        # 7. if there is an odd value, add it to the result\n        # 8. if there is an odd value, add it to the result\n        # 9. if there is an odd value, add it to the result\n        # 10. if there is an odd value, add it to the result\n        # 11. if there is an odd value, add it to the result\n        # 12. if there is an odd value, add it to the result\n        # 13. if there is an odd value, add it to the result\n        # 14. if there is an odd value, add it to the result\n        # 15. if there is an odd value, add it to the result\n        # 16. if there is an odd value, add it to the result\n        # 17. if there is an odd value, add it to the result\n        # 18. if there is an odd value, add it to the result\n        # 19. if there is an odd value, add it to the result\n        # 20. if there is an odd value, add it to the result\n        # 21. if there is an odd value, add it to the result\n        # 22. if there is an odd value, add it to the result\n        # 23. if there is an odd value, add it to the result\n        # 24. if there is an odd value, add it to the result\n        # 25. if there is an odd value, add it to the result\n        # 26. if there is an odd value, add it to the result\n        # 27. if there is an odd value, add it to the result\n        # 28. if there is an odd value, add it to the result\n        # 29. if there is an odd value, add it to the result\n        # 30. if there is an odd value, add it to the result\n        # 31. if there is an odd value, add it to the result\n        # 32. if there is an odd value, add it to the result\n        # 33. if there is an odd value, add it to the result\n        # 34. if there is an odd value, add it to the result\n        # 35. if there is an odd value, add it to the result\n        # 36. if there is an odd value, add it to the result\n        # 37. if there is an odd value, add it to the result\n        # 38. if there is an odd value, add it to the result\n        # 39. if there is an odd value, add it to the result\n        # 40. if there is an odd value, add it to the result\n        # 41. if there is an odd value, add it to the result\n        # 42. if there is an odd value, add it to the result\n        # 43. if there is an odd value, add it to the result\n        # 44. if there is an odd value, add it to the result\n        # 45. if there is an odd value, add it to the result\n        # 46. if there is an odd value, add it to the result\n        # 47. if there is an odd value, add it to the result\n        # 48. if there is an odd value, add it to the result\n        # 49. if there is an odd value, add it to the result\n        # 50. if there is an odd value, add it to the result\n        # 51. if there is an odd value, add it to the result\n        # 52. if there is an odd value, add it to the result\n        # 53. if there is an odd value, add it to the result\n        # 54. if there is an odd value, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even values to the result\n        # 3. if there is a odd value, add it to the result\n        # 4. if there is a odd value, add it to the result\n        # 5. if there is a odd value, add it to the result\n        # 6. if there is a odd value, add it to the result\n        # 7. if there is a odd value, add it to the result\n        # 8. if there is a odd value, add it to the result\n        # 9. if there is a odd value, add it to the result\n        # 10. if there is a odd value, add it to the result\n        # 11. if there is a odd value, add it to the result\n        # 12. if there is a odd value, add it to the result\n        # 13. if there is a odd value, add it to the result\n        # 14. if there is a odd value, add it to the result\n        # 15. if there is a odd value, add it to the result\n        # 16. if there is a odd value, add it to the result\n        # 17. if there is a odd value, add it to the result\n        # 18. if there is a odd value, add it to the result\n        # 19. if there is a odd value, add it to the result\n        # 20. if there is a odd value, add it to the result\n        # 21. if there is a odd value, add it to the result\n        # 22. if there is a odd value, add it to the result\n        # 23. if there is a odd value, add it to the result\n        # 24. if there is a odd value, add it to the result\n        # 25. if there is a odd value, add it to the result\n        # 26. if there is a odd value, add it to the result\n        # 27. if there is a odd value, add it to the result\n        # 28. if there is a odd value, add it to the result\n        # 29. if there is a odd value, add it to the result\n        # 30. if there is a odd value, add it to the result\n        # 31. if there is a odd value, add it to the result\n        # 32. if there is a odd value, add it to the result\n        # 33. if there is a odd value, add it to the result\n        # 34. if there is a odd value, add it to the result\n        # 35. if there is a odd value, add it to the result\n        # 36. if there is a odd value, add it to the result\n        # 37. if there is a odd value, add it to the result\n        # 38. if there is a odd value, add it to the result\n        # 39. if there is a odd value, add it to the result\n        # 40. if there is a odd value, add it to the result\n        # 41. if there is a odd value, add it to the result\n        # 42. if there is a odd value, add it to the result\n        # 43. if there is a odd value, add it to the result\n        # 44. if there is a odd value, add it to the result\n        # 45. if there is a odd value, add it to the result\n        # 46. if there is a odd value, add it to the result\n        # 47. if there is a odd value, add it to the result\n        # 48. if there is a odd value, add it to the result\n        # 49. if there is a odd value, add it to the result\n        # 50. if there is a odd value, add it to the result\n        # 51. if there is a odd value, add it to the result\n        # 52. if there is a odd value, add it to the result\n        # 53. if there is a odd value, add it to the result\n        # 54. if there is a odd value, add it to the result\n        # 55"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. start from (0, 0) and move to each tree in order\n        #    and calculate the steps to reach each tree\n        #    if we cannot reach a tree, return -1\n        #    if we can reach a tree, move to the next tree\n        #    if we reach the last tree, return the steps\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        total_steps = 0\n        curr_i, curr_j = 0, 0\n        for tree in trees:\n            steps = self.bfs(forest, curr_i, curr_j, tree[1], tree[2])\n            if steps == -1:\n                return -1\n            total_steps += steps\n            curr_i, curr_j = tree[1], tree[2]\n        return total_steps\n    \n    def bfs(self, forest, curr_i, curr_j, target_i, target_j):\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        queue = [(curr_i, curr_j, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if i == target_i and j == target_j:\n                return steps\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < len(forest) and 0 <= new_j < len(forest[0]) and (new_i, new_j) not in visited and forest[new_i][new_j] > 0:\n                    visited.add((new_i, new_j))\n                    queue.append((new_i, new_j, steps + 1))\n        return -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. start from (0, 0) and move to each tree in order\n        #    and calculate the steps to reach each tree\n        #    if we cannot reach a tree, return -1\n        #    otherwise, add the steps to the total steps\n        total_steps = 0\n        curr_i, curr_j = 0, 0\n        for tree in trees:\n            steps = self.bfs(forest, curr_i, curr_j, tree[1], tree[2])\n            if steps == -1:\n                return -1\n            total_steps += steps\n            curr_i, curr_j = tree[1], tree[2]\n        \n        return total_steps\n    \n    def bfs(self, forest, start_i, start_j, target_i, target_j):\n        # BFS to find the shortest path from (start_i, start_j) to (target_i, target_j)\n        # return the number of steps if we can reach the target, or -1 if we cannot\n        m, n = len(forest), len(forest[0])\n        queue = [(start_i, start_j, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if (i, j) == (target_i, target_j):\n                return steps\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and forest[new_i][new_j] > 0:\n                    queue.append((new_i, new_j, steps + 1))\n        return -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total steps\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total steps\n        total_steps = 0\n        curr_i, curr_j = 0, 0\n        for tree in trees:\n            steps = self.bfs(forest, curr_i, curr_j, tree[1], tree[2])\n            if steps == -1:\n                return -1\n            total_steps += steps\n            curr_i, curr_j = tree[1], tree[2]\n        return total_steps\n    \n    def bfs(self, forest, curr_i, curr_j, target_i, target_j):\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total steps\n        queue = [(curr_i, curr_j, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if i == target_i and j == target_j:\n                return steps\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < len(forest) and 0 <= new_j < len(forest[0]) and (new_i, new_j) not in visited and forest[new_i][new_j] > 0:\n                    visited.add((new_i, new_j))\n                    queue.append((new_i, new_j, steps + 1))\n        return -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. start from (0, 0) and move to each tree in order\n        #    and calculate the steps to reach each tree\n        #    if we cannot reach a tree, return -1\n        #    if we can reach a tree, move to the next tree\n        #    if we reach the last tree, return the steps\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach the last tree, return -1\n        #    if we cannot reach"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            left = arr[start:mid+1]\n            right = arr[mid+1:end+1]\n            i = j = 0\n            count = 0\n            for k in range(start, end+1):\n                if j >= len(right) or (i < len(left) and left[i] <= right[j]):\n                    arr[k] = left[i]\n                    if left[i] >= lower and left[i] <= upper:\n                        count += 1\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    if right[j] >= lower and right[j] <= upper:\n                        count += mid - i + 1\n                    j += 1\n            return count\n        \n        def merge_sort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(arr, start, mid) + merge_sort(arr, mid+1, end)\n            return count + merge(arr, start, mid, end)\n        \n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return merge_sort(prefix_sum, 0, len(prefix_sum)-1)"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            count = 0\n            i = start\n            j = mid + 1\n            for k in range(start, mid + 1):\n                while i <= mid and arr[i] - arr[k] <= upper:\n                    i += 1\n                while j <= end and arr[j] - arr[k] < lower:\n                    j += 1\n                count += j - i\n            arr[start:end + 1] = sorted(arr[start:end + 1])\n            return count\n        \n        def merge_sort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(arr, start, mid) + merge_sort(arr, mid + 1, end)\n            return count + merge(arr, start, mid, end)\n        \n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return merge_sort(prefix_sum, 0, len(prefix"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            count = 0\n            i = start\n            j = mid + 1\n            for k in range(start, mid + 1):\n                while i <= mid and arr[i] - arr[k] <= upper:\n                    i += 1\n                while j <= end and arr[j] - arr[k] < lower:\n                    j += 1\n                count += j - i\n            arr[start:end+1] = sorted(arr[start:end+1])\n            return count\n        \n        def merge_sort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(arr, start, mid) + merge_sort(arr, mid + 1, end)\n            return count + merge(arr, start, mid, end)\n        \n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return merge_sort(prefix_sum, 0, len(prefix"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            count = 0\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and arr[i] > arr[j]:\n                    j += 1\n                count += j - (mid + 1)\n            arr[start:end + 1] = sorted(arr[start:end + 1])\n            return count\n        \n        def mergeSort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = mergeSort(arr, start, mid) + mergeSort(arr, mid + 1, end)\n            return count + merge(arr, start, mid, end)\n        \n        n = len(nums)\n        prefixSum = [0] * (n + 1)\n        for i in range(n):\n            prefixSum[i + 1] = prefixSum[i] + nums[i]\n        return mergeSort(prefixSum, 0, n)"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            count = 0\n            i = start\n            j = mid + 1\n            for k in range(start, mid + 1):\n                while i <= mid and arr[i] - arr[k] <= upper:\n                    i += 1\n                while j <= end and arr[j] - arr[k] < lower:\n                    j += 1\n                count += j - i\n            arr[start:end + 1] = sorted(arr[start:end + 1])\n            return count\n        \n        def merge_sort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(arr, start, mid) + merge_sort(arr, mid + 1, end)\n            return count + merge(arr, start, mid, end)\n        \n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return merge_sort(prefix_sum, 0, len(prefix"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = deque([root])\n        res = []\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x /= 10\n        \n        return x == reverse or x == reverse / 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x /= 10\n        \n        return x == reverse or x == reverse / 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x /= 10\n        \n        return x == reverse or x == reverse / 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x /= 10\n        \n        return x == reverse or x == reverse / 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x //= 10\n        \n        return x == reverse or x == reverse // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0 for i in range(len(s)+1)]\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s)+1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            \n            if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] < '7'):\n                dp[i] += dp[i-2]\n        \n        return dp[len(s)]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0 for i in range(len(s)+1)]\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s)+1):\n            if 0 < int(s[i-1:i]) <= 9:\n                dp[i] += dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n        \n        return dp[len(s)]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0 for i in range(len(s) + 1)]\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if 0 < int(s[i - 1:i]) <= 9:\n                dp[i] += dp[i - 1]\n            if 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0 for i in range(len(s) + 1)]\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if 0 < int(s[i - 1:i]):\n                dp[i] = dp[i - 1]\n            if 10 <= int(s[i - 2:i]):\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0 for i in range(len(s) + 1)]\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if 0 < int(s[i - 1:i]):\n                dp[i] = dp[i - 1]\n            if 10 <= int(s[i - 2:i]):\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s:\n            return True\n        \n        # if t is empty, return False\n        if not t:\n            return False\n        \n        # if s is longer than t, return False\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return True\n        if s == t:\n            return True\n        \n        # if s is not empty and t is not empty and s is not longer than t\n        # and s is not equal to t\n        # then we can use two pointers to solve this problem\n        # one pointer points to s and the other pointer points to t\n        # if the two pointers are equal, then we move the pointer of s to the next position\n        # if the two pointers are not equal, then we move the pointer of t to the next position\n        # if the pointer of s reaches the end of s, then we return True\n        # if the pointer of t reaches the end of t, then we return False\n        # if the pointer of s reaches the end of s and the pointer of t reaches the end of t, then we return True\n        # if the pointer of s reaches the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t reaches the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # 2 pointers\n        # O(n) time, O(1) space\n        i, j = 0, 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s:\n            return True\n        \n        # if t is empty, return False\n        if not t:\n            return False\n        \n        # if s is longer than t, return False\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return True\n        if s == t:\n            return True\n        \n        # if s is not empty and t is not empty and s is not longer than t\n        # and s is not equal to t\n        # then we need to check if s is a subsequence of t\n        # we can do this by iterating through t and checking if each character in s is in t\n        # if we find a character in s that is not in t, return False\n        # if we find all characters in s that are in t, return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is not in t, we can return False\n        # if we find all characters in s that are in t, we can return True\n        # if we find a character in s that is in t, we can skip all characters in t until we find the next character in s"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2 pointer approach\n        ## Time Complexity:"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s:\n            return True\n        \n        # if t is empty, return False\n        if not t:\n            return False\n        \n        # if s is longer than t, return False\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return True\n        if s == t:\n            return True\n        \n        # if s is not empty and t is not empty and s is not longer than t\n        # and s is not equal to t\n        # then we can use two pointers to solve this problem\n        # one pointer points to s and the other pointer points to t\n        # if the two pointers are equal, then we move the pointer of s to the next position\n        # if the two pointers are not equal, then we move the pointer of t to the next position\n        # if the pointer of s reaches the end of s, then we return True\n        # if the pointer of t reaches the end of t, then we return False\n        # if the pointer of s reaches the end of s and the pointer of t reaches the end of t, then we return True\n        # if the pointer of s reaches the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t reaches the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach the end of t, then we return False\n        # if the pointer of s does not reach the end of s and the pointer of t does not reach"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | (1 << i))\n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        \n        for i in range(1, n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | (1 << i))\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | 1 << i)\n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | (1 << i))\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        \n        for i in range(1, n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | 1 << i)\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a, b = 1, 2\n        for i in range(2, n):\n            a, b = b, a + b\n        return b"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n        \n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n        \n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i: i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n        \n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j in range(i)\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len(s)]\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[len(s)]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n        \n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, left, right):\n            if not root:\n                return True\n            if not (left < root.val < right):\n                return False\n            return helper(root.left, left, root.val) and helper(root.right, root.val, right)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, left, right):\n            if not root:\n                return True\n            if not (left < root.val < right):\n                return False\n            return helper(root.left, left, root.val) and helper(root.right, root.val, right)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, left, right):\n            if not root:\n                return True\n            if not (left < root.val < right):\n                return False\n            return helper(root.left, left, root.val) and helper(root.right, root.val, right)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort()\n        \n        # 2. \u518d\u5408\u5e76\n        res = []\n        for i in intervals:\n            if not res or res[-1][1] < i[0]:\n                res.append(i)\n            else:\n                res[-1][1] = max(res[-1][1], i[1])\n        return res"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort()\n        \n        # 2. \u518d\u5408\u5e76\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort()\n        \n        # 2. \u518d\u5408\u5e76\n        res = []\n        for i in intervals:\n            if not res or res[-1][1] < i[0]:\n                res.append(i)\n            else:\n                res[-1][1] = max(res[-1][1], i[1])\n        return res"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort()\n        \n        # 2. \u518d\u5408\u5e76\n        res = []\n        for i in intervals:\n            if not res or res[-1][1] < i[0]:\n                res.append(i)\n            else:\n                res[-1][1] = max(res[-1][1], i[1])\n        return res"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort()\n        \n        # 2. \u518d\u5408\u5e76\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u90fd\u653e\u5230\u4e00\u4e2a\u5927\u6839\u5806\u4e2d\n        # 2. \u4ece\u5806\u9876\u5143\u7d20\u4e2d\u627e\u5230\u6700\u5c0f\u7684\u5143\u7d20\u548c\u6700\u5927\u7684\u5143\u7d20\n        # 3. \u66f4\u65b0\u6700\u5c0f\u533a\u95f4\n        # 4. \u5c06\u6700\u5c0f\u7684\u5143\u7d20\u6240\u5728\u7684\u6570\u7ec4\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u653e\u5165\u5806\u4e2d\n        # 5. \u91cd\u590d2-4\u6b65\u9aa4\uff0c\u76f4\u5230\u67d0\u4e2a\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u5168\u90e8\u88ab\u904d\u5386\u5b8c\n        \n        import heapq\n        heap = []\n        cur_max = float('-inf')\n        for i, num in enumerate(nums):\n            heapq.heappush(heap, (num[0], i, 0))\n            cur_max = max(cur_max, num[0])\n        \n        res = [float('-inf'), float('inf')]\n        while len(heap) == len(nums):\n            cur_min, i, j = heapq.heappop(heap)\n            if cur_max - cur_min < res[1] - res[0]:\n                res = [cur_min, cur_max]\n            if j + 1 < len(nums[i]):\n                heapqheappush(heap, (nums[i][j + 1], i, j + 1))\n                cur_max = max(cur_max, nums[i][j + 1])\n        \n        return res"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        N = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        seen = {(0, 0)}\n        ans = 0\n        \n        while pq:\n            t, r, c = heapq.heappop(pq)\n            ans = max(ans, t)\n            if r == c == N-1: return ans\n            for cr, cc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if 0 <= cr < N and 0 <= cc < N and (cr, cc) not in seen:\n                    seen.add((cr, cc))\n                    heapq.heappush(pq, (grid[cr][cc], cr, cc))"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        seen = {(0, 0)}\n        res = 0\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\n                if 0 <= x < n and 0 <= y < n and (x, y) not in seen:\n                    seen.add((x, y))\n                    heapq.heappush(pq, (grid[x][y], x, y))\n        return res"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            if i == n - 1 and j == n - 1:\n                return t\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (max(t, grid[x][y]), x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            if i == n - 1 and j == n - 1:\n                return t\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (max(t, grid[x][y]), x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        N = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        seen = {(0, 0)}\n        ans = 0\n        \n        while pq:\n            t, r, c = heapq.heappop(pq)\n            ans = max(ans, t)\n            if r == c == N-1: return ans\n            for cr, cc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                if 0 <= cr < N and 0 <= cc < N and (cr, cc) not in seen:\n                    seen.add((cr, cc))\n                    heapq.heappush(pq, (grid[cr][cc], cr, cc))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(mn)\n        # Space: O(mn)\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n        return dp[m - 1][n - 1]\n        \n        # 2. Math\n        # Time: O(min(m, n))\n        # Space: O(1)\n        return math.comb(m + n - 2, n - 1)"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] += dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = 1\n        \n        for j in range(n):\n            dp[0][j] = 1\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = 1\n        \n        for j in range(n):\n            dp[0][j] = 1\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[0]*n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[-1][-1]\n        \n        # 2. DP\n        # Time: O(m*n)\n        # Space: O(n)\n        dp = [1]*n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j-1]\n        return dp[-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # multiply\n        product = num1 * num2\n        \n        # convert to string\n        product = str(product)\n        \n        return product"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert num1 and num2 to int\n        # 2. multiply them\n        # 3. convert the result to string\n        # 4. return the result\n        \n        num1 = int(num1)\n        num2 = int(num2)\n        result = num1 * num2\n        return str(result)"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # multiply\n        product = num1 * num2\n        \n        # convert to string\n        product = str(product)\n        \n        return product"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to int\n        # 2. multiply\n        # 3. convert back to string\n        \n        return str(int(num1) * int(num2))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to int\n        # 2. multiply\n        # 3. convert back to string\n        \n        return str(int(num1) * int(num2))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 2. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp + prices[j] - prices[s]) for s in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 3. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 4. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 5. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 6. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 7. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 8. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp["}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. 0 transaction\n        \n        # 1. 2 transactions"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        n = len(prices)\n        if n < 2:\n            return 0\n        \n        dp = [[0] * 5 for _ in range(n)]\n        dp[0][1] = -prices[0]\n        dp[0][3] = -prices[0]\n        \n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n        \n        return dp[n - 1][4]\n    \n        # 2. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        n = len(prices)\n        if n < 2:\n            return 0"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 2. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp + prices[j] - prices[s]) for s in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 3. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 4. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 5. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 6. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 7. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp[i][j] = max(dp[i][j-1], max(dp[i-1][k] + prices[j] - prices[k]) for k in range(j))\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # return dp[2][n-1]\n        \n        # 8. 1D DP\n        # Time: O(n)\n        # Space: O(1)\n        # dp[i][j] = max profit for up to i transactions, ending at day j\n        # dp["}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target < 0:\n            return \n        if target == 0:\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) == 1:\n            return True\n        \n        if word[0].isupper() and word[1].isupper():\n            for i in range(2, len(word)):\n                if word[i].islower():\n                    return False\n        else:\n            for i in range(1, len(word)):\n                if word[i].isupper():\n                    return False\n        \n        return True"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 1052 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.1 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     for j in range(i+1, n):\n        ##         profit = prices[j] - prices[i]\n        ##         if profit > max_profit:\n        ##             max_profit = profit\n        ## return max_profit\n        \n        ## 2. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.1 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 1600 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     for j in range(i+1, n):\n        ##         profit = prices[j] - prices[i]\n        ##         if profit > max_profit:\n        ##             max_profit = profit\n        ## return max_profit\n        \n        ## 2. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 160 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## min_price = float('inf')\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     if prices[i] < min_price:\n        ##         min_price = prices[i]\n        ##     elif prices[i] - min_price > max_profit:\n        ##         max_profit = prices[i] - min_price\n        ## return max_profit\n        \n        ## 3. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 160 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## min_price = float('inf')\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     min_price = min(min_price, prices[i])\n        ##     max_profit = max(max_profit, prices[i] - min_price)\n        ## return max_profit\n        \n        ## 4. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 160 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## min_price = float('inf')\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     min_price = min(min_price, prices[i])\n        ##     max_profit = max(max"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the variables\n        min_price = float('inf')\n        max_profit = 0\n        \n        # 2. Iterate through the prices\n        for price in prices:\n            # 3. Update the minimum price\n            min_price = min(min_price, price)\n            \n            # 4. Calculate the maximum profit\n            max_profit = max(max_profit, price - min_price)\n        \n        # 5. Return the maximum profit\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the variables\n        min_price = float('inf')\n        max_profit = 0\n        \n        # 2. Iterate through the prices\n        for price in prices:\n            # 3. Update the minimum price\n            min_price = min(min_price, price)\n            \n            # 4. Calculate the maximum profit\n            max_profit = max(max_profit, price - min_price)\n        \n        # 5. Return the maximum profit\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 1020 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.6 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     for j in range(i+1, n):\n        ##         profit = prices[j] - prices[i]\n        ##         if profit > max_profit:\n        ##             max_profit = profit\n        ## return max_profit\n        \n        ## 2. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.5 MB, less than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.merge(left, right)\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        else:\n            curr.next = l2\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        mid = len(lists) // 2\n        l = self.mergeKLists(lists[:mid])\n        r = self.mergeKLists(lists[mid:])\n        \n        return self.merge(l, r)\n    \n    def merge(self, l, r):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l and r:\n            if l.val < r.val:\n                curr.next = l\n                l = l.next\n            else:\n                curr.next = r\n                r = r.next\n            curr = curr.next\n        \n        curr.next = l or r\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        mid = len(lists) // 2\n        l = self.mergeKLists(lists[:mid])\n        r = self.mergeKLists(lists[mid:])\n        \n        return self.merge(l, r)\n    \n    def merge(self, l, r):\n        dummy = ListNode()\n        tail = dummy\n        \n        while l and r:\n            if l.val < r.val:\n                tail.next = l\n                l = l.next\n            else:\n                tail.next = r\n                r = r.next\n            tail = tail.next\n        \n        if l:\n            tail.next = l\n        if r:\n            tail.next = r\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.merge(left, right)\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        curr.next = l1 or l2\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.merge(left, right)\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        else:\n            curr.next = l2\n        \n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[0] = 0\n        # dp[len(s)] = min cuts to make s palindrome\n        \n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i-1-j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[i"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[len(s)] = min cuts to make s palindrome\n        \n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j <"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[0] = 0\n        # dp[len(s)] = min cuts to make s palindrome\n        \n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and s[j+1:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0) + 1\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i-1] and dp[j+1] == 0)"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[0] = 0\n        # dp[len(s)] = min cuts to make s palindrome\n        \n        # isPalindrome[i][j] = True if s[i:j+1] is palindrome\n        # isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i+1][j-1]\n        # isPalindrome[i][i] = True\n        # isPalindrome[i][i+1] = s[i] == s[i+1]\n        \n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        isPalindrome = [[False] * n for _ in range(n)]\n        \n        for i in range(n):\n            isPalindrome[i][i] = True\n            if i < n - 1 and s[i] == s[i + 1]:\n                isPalindrome[i][i + 1] = True\n        \n        for i in range(2, n):\n            for j in range(n - i):\n                isPalindrome[j][j + i] = s[j] == s[j + i] and isPalindrome[j + 1][j + i - 1]\n        \n        for i in range(1, n + 1):\n            if isPalindrome[0][i - 1]:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1] + 1\n                for j in range(1, i):\n                    if isPalindrome[j][i - 1]:\n                        dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[n]"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[0] = 0\n        # dp[len(s)] = -1\n        \n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and s[j+1:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -1)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == -"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        l, r = 0, 5 * (k + 1)\n        while l < r:\n            mid = (l + r) // 2\n            if trailingZeroes(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 5 if trailingZeroes(l) == k else 0"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        l, r = 0, 5 * (k + 1)\n        while l < r:\n            mid = (l + r) // 2\n            if trailingZeroes(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 5 if trailingZeroes(l) == k else 0"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        left, right = 0, 5 * (k + 1)\n        while left < right:\n            mid = left + (right - left) // 2\n            if trailingZeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return 0 if trailingZeroes(left) != k else right - left"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        l, r = 0, 5 * (k + 1)\n        while l < r:\n            mid = (l + r) // 2\n            if trailingZeroes(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 5 if trailingZeroes(l) == k else 0"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        l, r = 0, 5 * (k + 1)\n        while l < r:\n            mid = (l + r) // 2\n            if trailingZeroes(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 5 if trailingZeroes(l) == k else 0"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            if \"\" in word_dict and word != \"\" and isPalindrome(word):\n                res.append([i, word_dict[\"\"]])\n                \n            rword = word[::-1]\n            if rword in word_dict and word_dict[rword] != i:\n                res.append([i, word_dict[rword]])\n                \n            for j in range(1, len(word)):\n                left, right = word[:j], word[j:]\n                if isPalindrome(left):\n                    rright = right[::-1]\n                    if rright in word_dict:\n                        res.append([word_dict[rright], i])\n                if isPalindrome(right):\n                    rleft = left[::-1]\n                    if rleft in word_dict:\n                        res.append([i, word_dict[rleft]])\n                        \n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        wordDict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n+1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in wordDict:\n                        res.append([wordDict[back], i])\n                \n                if j != n and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in wordDict:\n                        res.append([i, wordDict[back]])\n        \n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        wordDict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n+1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in wordDict:\n                        res.append([wordDict[back], i])\n                \n                if j != n and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in wordDict:\n                        res.append([i, wordDict[back]])\n        \n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            if \"\" in word_dict and word != \"\" and isPalindrome(word):\n                res.append([i, word_dict[\"\"]])\n            if word[::-1] in word_dict and word_dict[word[::-1]] != i:\n                res.append([i, word_dict[word[::-1]]])\n            for j in range(1, len(word)):\n                if isPalindrome(word[:j]) and word[j:][::-1] in word_dict:\n                    res.append([i, word_dict[word[j:][::-1]]])\n                if isPalindrome(word[j:]) and word[:j][::-1] in word_dict:\n                    res.append([word_dict[word[:j][::-1]], i])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            if \"\" in word_dict and word != \"\" and isPalindrome(word):\n                res.append([i, word_dict[\"\"]])\n                \n            rword = word[::-1]\n            if rword in word_dict and word_dict[rword] != i:\n                res.append([i, word_dict[rword]])\n                \n            for j in range(1, len(word)):\n                left, right = word[:j], word[j:]\n                if isPalindrome(left):\n                    rright = right[::-1]\n                    if rright in word_dict:\n                        res.append([word_dict[rright], i])\n                if isPalindrome(right):\n                    rleft = left[::-1]\n                    if rleft in word_dict:\n                        res.append([i, word_dict[rleft]])\n                        \n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + sum(dfs(i + dx, j + dy, region) for dx, dy in dirs)\n        \n        def build(i, j, region):\n            for dx, dy in dirs:\n                x, y = i + dx, j + dy\n                if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 1:\n                    isInfected[x][y] = -region\n        \n        res = 0\n        while True:\n            walls = 0\n            regions = collections.defaultdict(int)\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        region = dfs(i, j, i * n + j + 2)\n                        if region:\n                            regions[i * n + j + 2] = region\n                            walls += region - 1\n            if not regions:\n                return res + walls\n            res += walls\n            region = max(regions, key=regions.get)\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == -region:\n                        build(i, j, region)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + dfs(i + 1, j, region) + dfs(i - 1, j, region) + dfs(i, j + 1, region) + dfs(i, j - 1, region)\n        \n        def bfs(i, j, region):\n            q = collections.deque([(i, j)])\n            while q:\n                i, j = q.popleft()\n                for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 1:\n                        isInfected[x][y] = -region\n                        q.append((x, y))\n        \n        res = 0\n        while True:\n            walls = 0\n            regions = collections.defaultdict(int)\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        region = dfs(i, j, i * n + j + 1)\n                        regions[i * n + j + 1] = region\n                        walls += region - 1\n            if not regions:\n                return res + walls\n            res += walls\n            region = max(regions, key = regions.get)\n            bfs(region / n - 1, region % n - 1, region)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + sum(dfs(i + dx, j + dy, region) for dx, dy in dirs)\n        \n        def spread(region):\n            walls = 0\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == region:\n                        for dx, dy in dirs:\n                            x, y = i + dx, j + dy\n                            if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 1:\n                                isInfected[x][y] = -region\n                                walls += 1\n            return walls\n        \n        regions = []\n        for i in range(m):\n            for j in range(n):\n                if isInfected[i][j] == 1:\n                    regions.append(dfs(i, j, len(regions) + 1))\n        \n        walls = 0\n        while len(regions) > 1:\n            walls += spread(len(regions))\n            regions.sort(reverse=True)\n            regions.pop()\n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + sum(dfs(i + dx, j + dy, region) for dx, dy in dirs)\n        \n        def spread(region):\n            walls = 0\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == region:\n                        for dx, dy in dirs:\n                            x, y = i + dx, j + dy\n                            if x < 0 or x >= m or y < 0 or y >= n or isInfected[x][y] == 0:\n                                walls += 1\n                            elif isInfected[x][y] == 1:\n                                isInfected[x][y] = -region\n            return walls\n        \n        regions = []\n        for i in range(m):\n            for j in range(n):\n                if isInfected[i][j] == 1:\n                    regions.append(dfs(i, j, len(regions) + 1))\n        \n        walls = 0\n        while len(regions) > 1:\n            walls += max(spread(region) for region in regions)\n            regions = [region for region in regions if region > 0]\n        \n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + dfs(i+1, j, region) + dfs(i-1, j, region) + dfs(i, j+1, region) + dfs(i, j-1, region)\n        \n        def bfs(i, j, region):\n            q = collections.deque([(i, j)])\n            while q:\n                i, j = q.popleft()\n                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                    if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 1:\n                        isInfected[x][y] = -region\n                        q.append((x, y))\n        \n        res = 0\n        while True:\n            walls = 0\n            regions = {}\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        region = dfs(i, j, i*n+j+2)\n                        regions[i*n+j+2] = region\n                        walls += region - 1\n            if not regions:\n                return res\n            res += walls\n            maxRegion = max(regions.values())\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == -maxRegion:\n                        bfs(i, j, maxRegion)\n                        break"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        ans = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            dp[i][j] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        ans = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            dp[i][j] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        ans = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            dp[i][j] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            dp[i][j] = 1\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        ans = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            dp[i][j] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10 + (n - 10)\n        \n        if n < 1000:\n            return 20 + (n - 100)\n        \n        if n < 10000:\n            return 30 + (n - 1000)\n        \n        if n < 100000:\n            return 40 + (n - 10000)\n        \n        if n < 1000000:\n            return 50 + (n - 100000)\n        \n        if n < 10000000:\n            return 60 + (n - 1000000)\n        \n        if n < 100000000:\n            return 70 + (n - 10000000)\n        \n        if n < 1000000000:\n            return 80 + (n - 100000000)\n        \n        return 90 + (n - 1000000000)"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10 + (n - 10)\n        \n        if n < 1000:\n            return 20 + (n - 100)\n        \n        if n < 10000:\n            return 30 + (n - 1000)\n        \n        if n < 100000:\n            return 40 + (n - 10000)\n        \n        if n < 1000000:\n            return 50 + (n - 100000)\n        \n        if n < 10000000:\n            return 60 + (n - 1000000)\n        \n        if n < 100000000:\n            return 70 + (n - 10000000)\n        \n        if n < 1000000000:\n            return 80 + (n - 100000000)\n        \n        return 90 + (n - 1000000000)"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10 + (n - 10)\n        \n        if n < 1000:\n            return 20 + (n - 100)\n        \n        if n < 10000:\n            return 30 + (n - 1000)\n        \n        if n < 100000:\n            return 40 + (n - 10000)\n        \n        if n < 1000000:\n            return 50 + (n - 100000)\n        \n        if n < 10000000:\n            return 60 + (n - 1000000)\n        \n        if n < 100000000:\n            return 70 + (n - 10000000)\n        \n        if n < 1000000000:\n            return 80 + (n - 100000000)\n        \n        return 90 + (n - 1000000000)"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10 + (n - 10)\n        \n        if n < 1000:\n            return 20 + (n - 100) * 2\n        \n        if n < 10000:\n            return 300 + (n - 1000) * 3\n        \n        if n < 100000:\n            return 4000 + (n - 10000) * 4\n        \n        if n < 1000000:\n            return 50000 + (n - 100000) * 5\n        \n        if n < 10000000:\n            return 600000 + (n - 1000000) * 6\n        \n        if n < 100000000:\n            return 7000000 + (n - 10000000) * 7\n        \n        if n < 1000000000:\n            return 80000000 + (n - 100000000) * 8\n        \n        return 900000000 + (n - 1000000000) * 9"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10 + (n - 10)\n        \n        if n < 1000:\n            return 20 + (n - 100)\n        \n        if n < 10000:\n            return 30 + (n - 1000)\n        \n        if n < 100000:\n            return 40 + (n - 10000)\n        \n        if n < 1000000:\n            return 50 + (n - 100000)\n        \n        if n < 10000000:\n            return 60 + (n - 1000000)\n        \n        if n < 100000000:\n            return 70 + (n - 10000000)\n        \n        if n < 1000000000:\n            return 80 + (n - 100000000)\n        \n        return 90 + (n - 1000000000)"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # dp[i] = True if s[:i] can be segmented into words in wordDict\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        \n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j <"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        wordSet = set(wordDict)\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [\"\"]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if s[j:i] in wordSet:\n                    for sub in dp[j]:\n                        dp[i].append(sub + \" \" + s[j:i] if sub else s[j:i])\n        \n        return dp[-1]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        wordSet = set(wordDict)\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [\"\"]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if s[j:i] in wordSet:\n                    for sub in dp[j]:\n                        dp[i].append(sub + \" \" + s[j:i] if sub else s[j:i])\n        \n        return dp[-1]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = list of strings that can be formed from s[:i]\n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [\"\"]\n        \n        for i in range(1, len(s) + 1):\n            for word in wordDict:\n                if word == s[i - len(word):i] and dp[i - len(word)]:\n                    dp[i] += [w + \" \" + word for w in dp[i - len(word)]]\n        \n        return [w.strip() for w in dp[-1]]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for word in wordDict:\n                if word == s[i - len(word):i] and dp[i - len(word)]:\n                    dp[i] = True\n        \n        if not dp[-1]:\n            return []\n        \n        res = []\n        self.dfs(s, wordDict, dp, 0, [], res)\n        return res\n    \n    def dfs(self, s, wordDict, dp, start, path, res):\n        if start == len(s):\n            res.append(' '.join(path))\n            return\n        \n        for i in range(start, len(s)):\n            if s[start:i + 1] in wordDict and dp[i + 1]:\n                path.append(s[start:i + 1])\n                self.dfs(s, wordDict, dp, i + 1, path, res)\n                path.pop()"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for _ in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for _ in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                count += 1\n                n &= n - 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                count += 1\n                n &= n - 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                count += 1\n                n &= n - 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n        \n        ans = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    ans.append(f'{h}:{m:02d}')\n        return ans"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        \n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(len(res[-1])-1):\n                temp.append(res[-1][j] + res[-1][j+1])\n            temp.append(1)\n            res.append(temp)\n            \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        \n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(len(res[-1])-1):\n                temp.append(res[-1][j] + res[-1][j+1])\n            temp.append(1)\n            res.append(temp)\n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1],[1,1]]\n        else:\n            res = [[1],[1,1]]\n            for i in range(2,numRows):\n                res.append([1])\n                for j in range(1,i):\n                    res[i].append(res[i-1][j-1] + res[i-1][j])\n                res[i].append(1)\n            return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        \n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(len(res[-1])-1):\n                temp.append(res[-1][j] + res[-1][j+1])\n            temp.append(1)\n            res.append(temp)\n            \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1],[1,1]]\n        else:\n            res = [[1],[1,1]]\n            for i in range(2,numRows):\n                res.append([1])\n                for j in range(1,i):\n                    res[i].append(res[i-1][j-1]+res[i-1][j])\n                res[i].append(1)\n            return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n /= 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            nonlocal max_sum\n            if not node:\n                return 0\n            \n            left_sum = max(dfs(node.left), 0)\n            right_sum = max(dfs(node.right), 0)\n            \n            max_sum = max(max_sum, left_sum + right_sum + node.val)\n            \n            return max(left_sum, right_sum) + node.val\n        \n        max_sum = float('-inf')\n        dfs(root)\n        return max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        if m <= 2 or n <= 2:\n            return 0\n        \n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        \n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] >= 0:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        \n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        if m <= 2 or n <= 2:\n            return 0\n        \n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        \n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] >= 0:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        \n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        if m <= 2 or n <= 2:\n            return 0\n        \n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        \n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] >= 0:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        \n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        if m <= 2 or n <= 2:\n            return 0\n        \n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        \n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] >= 0:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        \n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        \n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] != -1:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        \n        return res"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. convert to lowercase\n        # 2. remove non-alphanumeric characters\n        # 3. check if palindrome\n        \n        s = s.lower()\n        s = ''.join(c for c in s if c.isalnum())\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. convert to lowercase\n        # 2. remove non-alphanumeric characters\n        # 3. check if palindrome\n        \n        s = s.lower()\n        s = ''.join(c for c in s if c.isalnum())\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove non-alphanumeric characters\n        # 2. convert to lowercase\n        # 3. check if palindrome\n        \n        s = s.lower()\n        s = ''.join(c for c in s if c.isalnum())\n        \n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. convert to lowercase\n        # 2. remove non-alphanumeric characters\n        # 3. check if palindrome\n        \n        s = s.lower()\n        s = ''.join(c for c in s if c.isalnum())\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters into lowercase letters\n        # 3. check if the string is a palindrome\n        \n        # 1. remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # 2. convert all uppercase letters into lowercase letters\n        s = s.lower()\n        \n        # 3. check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window with the first k elements\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Calculate the median of the first window\n        if k % 2 == 0:\n            median = (window[k//2-1] + window[k//2]) / 2.0\n        else:\n            median = window[k//2]\n        \n        # 3. Add the median to the result list\n        result = [median]\n        \n        # 4. Slide the window to the right by one element at a time\n        for i in range(k, len(nums)):\n            # 4.1. Remove the leftmost element from the window\n            window.remove(nums[i-k])\n            \n            # 4.2. Add the new element to the window\n            bisect.insort(window, nums[i])\n            \n            # 4.3. Calculate the median of the new window\n            if k % 2 == 0:\n                median = (window[k//2-1] + window[k//2]) / 2.0\n            else:\n                median = window[k//2]\n            \n            # 4.4. Add the median to the result list\n            result.append(median)\n        \n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window with the first k elements\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Calculate the median of the first window\n        if k % 2 == 0:\n            median = (window[k//2-1] + window[k//2]) / 2.0\n        else:\n            median = window[k//2]\n        \n        # 3. Add the median to the result list\n        result = [median]\n        \n        # 4. Slide the window to the right by one element at a time\n        for i in range(k, len(nums)):\n            # 4.1. Remove the leftmost element from the window\n            window.remove(nums[i-k])\n            \n            # 4.2. Add the new element to the window\n            bisect.insort(window, nums[i])\n            \n            # 4.3. Calculate the median of the new window\n            if k % 2 == 0:\n                median = (window[k//2-1] + window[k//2]) / 2.0\n            else:\n                median = window[k//2]\n            \n            # 4.4. Add the median to the result list\n            result.append(median)\n        \n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window with the first k elements\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Calculate the median of the first window\n        if k % 2 == 0:\n            median = (window[k//2-1] + window[k//2]) / 2.0\n        else:\n            median = window[k//2]\n        \n        # 3. Add the median to the result list\n        result = [median]\n        \n        # 4. Slide the window to the right by one element at a time\n        for i in range(k, len(nums)):\n            # 4.1. Remove the leftmost element from the window\n            window.remove(nums[i-k])\n            \n            # 4.2. Add the new element to the window\n            bisect.insort(window, nums[i])\n            \n            # 4.3. Calculate the median of the new window\n            if k % 2 == 0:\n                median = (window[k//2-1] + window[k//2]) / 2.0\n            else:\n                median = window[k//2]\n            \n            # 4.4. Add the median to the result list\n            result.append(median)\n        \n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window with the first k elements\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Calculate the median of the first window\n        if k % 2 == 0:\n            median = (window[k//2-1] + window[k//2]) / 2.0\n        else:\n            median = window[k//2]\n        \n        # 3. Add the median to the result list\n        result = [median]\n        \n        # 4. Slide the window to the right by one element at a time\n        for i in range(k, len(nums)):\n            # 4.1. Remove the leftmost element from the window\n            window.remove(nums[i-k])\n            \n            # 4.2. Add the new element to the window\n            bisect.insort(window, nums[i])\n            \n            # 4.3. Calculate the median of the new window\n            if k % 2 == 0:\n                median = (window[k//2-1] + window[k//2]) / 2.0\n            else:\n                median = window[k//2]\n            \n            # 4.4. Add the median to the result list\n            result.append(median)\n        \n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window with the first k elements\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Calculate the median of the first window\n        if k % 2 == 0:\n            median = (window[k//2-1] + window[k//2]) / 2.0\n        else:\n            median = window[k//2]\n        \n        # 3. Initialize the result list with the median of the first window\n        result = [median]\n        \n        # 4. Slide the window to the right and update the median\n        for i in range(k, len(nums)):\n            # Remove the element that will be replaced\n            window.remove(nums[i-k])\n            \n            # Add the new element to the window\n            bisect.insort(window, nums[i])\n            \n            # Calculate the new median\n            if k % 2 == 0:\n                median = (window[k//2-1] + window[k//2]) / 2.0\n            else:\n                median = window[k//2]\n            \n            # Add the median to the result list\n            result.append(median)\n        \n        return result"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        new_head = tail.next\n        tail.next = None\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        for p in [2,3,5]:\n            while n % p == 0:\n                n /= p\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        for i in [2,3,5]:\n            while n % i == 0:\n                n /= i\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        for p in [2,3,5]:\n            while n % p == 0:\n                n /= p\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        for i in [2,3,5]:\n            while n % i == 0:\n                n /= i\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        for i in [2,3,5]:\n            while n % i == 0:\n                n /= i\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. use a list to store the height of each position\n        heights = [0] * len(positions)\n        \n        # 3. use a list to store the max height of each position\n        max_heights = [0] * len(positions)\n        \n        # 4. iterate through the positions\n        for i, (left, size) in enumerate(positions):\n            # 5. calculate the right of the current position\n            right = left + size\n            \n            # 6. calculate the height of the current position\n            height = size\n            \n            # 7. iterate through the previous positions\n            for j in range(i):\n                # 8. calculate the right of the previous position\n                prev_right = positions[j][0] + positions[j][1]\n                \n                # 9. if the current position is not overlapping with the previous position\n                if right <= positions[j][0] or left >= prev_right:\n                    continue\n                \n                # 10. update the height of the current position\n                height = max(height, heights[j] + size)\n            \n            # 11. update the height of the current position\n            heights[i] = height\n            \n            # 12. update the max height of the current position\n            max_heights[i] = max(max_heights[i - 1], height) if i > 0 else height\n        \n        # 13. return the max height of each position\n        return max_heights"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. use a list to store the height of each position\n        heights = [0] * len(positions)\n        \n        # 3. use a list to store the max height of each position\n        max_heights = [0] * len(positions)\n        \n        # 4. iterate through the positions\n        for i, (left, side) in enumerate(positions):\n            # 5. calculate the right of the current position\n            right = left + side\n            \n            # 6. calculate the height of the current position\n            height = side\n            \n            # 7. iterate through the previous positions\n            for j in range(i):\n                # 8. calculate the right of the previous position\n                prev_right = positions[j][0] + positions[j][1]\n                \n                # 9. if the current position is not overlapping with the previous position\n                if left >= prev_right:\n                    continue\n                \n                # 10. update the height of the current position\n                height = max(height, heights[j] + side)\n            \n            # 11. update the height of the current position\n            heights[i] = height\n            \n            # 12. update the max height of the current position\n            max_heights[i] = max(max_heights[i - 1], height) if i > 0 else height\n        \n        # 13. return the max height of each position\n        return max_heights"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. use a list to store the height of each position\n        heights = [0] * len(positions)\n        \n        # 3. use a list to store the max height of each position\n        max_heights = [0] * len(positions)\n        \n        # 4. iterate through the positions\n        for i, (left, size) in enumerate(positions):\n            # 5. calculate the right of the current position\n            right = left + size\n            \n            # 6. calculate the height of the current position\n            height = size\n            \n            # 7. iterate through the previous positions\n            for j in range(i):\n                # 8. calculate the right of the previous position\n                prev_right = positions[j][0] + positions[j][1]\n                \n                # 9. if the current position is not overlapping with the previous position\n                if left >= prev_right:\n                    continue\n                \n                # 10. update the height of the current position\n                height = max(height, heights[j] + size)\n            \n            # 11. update the height of the current position\n            heights[i] = height\n            \n            # 12. update the max height of the current position\n            max_heights[i] = max(max_heights[i - 1], height) if i > 0 else height\n        \n        # 13. return the max height of each position\n        return max_heights"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. use a list to store the height of the tallest stack of squares\n        heights = [0] * len(positions)\n        \n        # 3. use a list to store the max height of the tallest stack of squares\n        max_heights = [0] * len(positions)\n        \n        # 4. iterate through the positions\n        for i, (left, size) in enumerate(positions):\n            # 5. calculate the right\n            right = left + size\n            \n            # 6. calculate the height of the current square\n            height = size\n            \n            # 7. iterate through the previous squares\n            for j in range(i):\n                # 8. calculate the right of the previous square\n                prev_right = positions[j][0] + positions[j][1]\n                \n                # 9. if the current square is not overlapping with the previous square\n                if left >= prev_right:\n                    continue\n                \n                # 10. update the height of the current square\n                height = max(height, heights[j] + size)\n            \n            # 11. update the height of the current square\n            heights[i] = height\n            \n            # 12. update the max height of the tallest stack of squares\n            max_heights[i] = max(max_heights[i - 1], height) if i > 0 else height\n        \n        # 13. return the max height of the tallest stack of squares\n        return max_heights"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. create a list to store the max height of each position\n        max_height = [0] * len(positions)\n        \n        # 3. iterate through the positions\n        for i, (left, size) in enumerate(positions):\n            # 3.1. set the current height to the current max height\n            height = max_height[i] = max(max_height[i], size)\n            \n            # 3.2. iterate through the positions again\n            for j in range(i + 1, len(positions)):\n                # 3.2.1. if the current position is not overlapping with the previous position\n                if positions[j][0] >= left + size:\n                    break\n                # 3.2.2. update the max height\n                height = max(height, max_height[j] + size)\n            # 3.3. update the max height\n            max_height[i] = height\n        \n        # 4. return the max height\n        return max_height"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return node.val if is_left else 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return node.val if is_left else 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return node.val if is_left else 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return node.val if is_left else 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D prefix sum\n        # 2. 1D prefix sum\n        # 3. binary search\n        \n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    matrix[i][j] += matrix[i-1][j]\n                if j > 0:\n                    matrix[i][j] += matrix"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D prefix sum\n        # 2. binary search\n        # 3. 2D prefix sum\n        \n        m, n = len(matrix), len(matrix[0])\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n        \n        res = float('-inf')\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                for p in range(i, m + 1):\n                    for q in range(j, n + 1):\n                        curr = prefix[p][q] - prefix[i - 1][q] - prefix[p][j - 1] + prefix[i - 1][j - 1]\n                        if curr <= k:\n                            res = max(res, curr)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D prefix sum\n        # 2. binary search\n        # 3. 2D prefix sum\n        \n        m, n = len(matrix), len(matrix[0])\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n        \n        res = float('-inf')\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                for p in range(i, m + 1):\n                    for q in range(j, n + 1):\n                        curr = prefix[p][q] - prefix[p][j - 1] - prefix[i - 1][q] + prefix[i - 1][j - 1]\n                        if curr <= k:\n                            res = max(res, curr)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                res = max(res, self.maxSumSubarray(sums, k))\n                if res == k:\n                    return k\n        return res\n    \n    def maxSumSubarray(self, nums, k):\n        res = float('-inf')\n        curr = 0\n        prefix = [0]\n        for num in nums:\n            curr += num\n            idx = bisect.bisect_left(prefix, curr - k)\n            if idx < len(prefix):\n                res = max(res, curr - prefix[idx])\n            bisect.insort(prefix, curr)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        ans = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                ans = max(ans, self.maxSumSubarray(sums, k))\n                if ans == k:\n                    return k\n        return ans\n    \n    def maxSumSubarray(self, nums, k):\n        ans = float('-inf')\n        sums = [0]\n        prefix = 0\n        for num in nums:\n            prefix += num\n            idx = bisect.bisect_left(sums, prefix - k)\n            if idx < len(sums):\n                ans = max(ans, prefix - sums[idx])\n            bisect.insort(sums, prefix)\n        return ans"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        if dividend == 0:\n            return 0\n        \n        # 2. \n        if divisor == 1:\n            return dividend\n        \n        if divisor == -1:\n            if dividend == -2147483648:\n                return 2147483647\n            return -dividend\n        \n        # 3. \n        if dividend == divisor:\n            return 1\n        \n        if dividend == -divisor:\n            return -1\n        \n        # 4. \n        if divisor == -1:\n            return -dividend\n        \n        if dividend == -1:\n            return -divisor\n        \n        # 5. \n        if dividend == divisor:\n            return 1\n        \n        if dividend == -divisor:\n            return -1\n        \n        # 6. \n        if dividend == 0:\n            return 0\n        \n        # 7. \n        if divisor == 0:\n            return 0\n        \n        # 8. \n        if dividend == 0:\n            return 0\n        \n        # 9. \n        if divisor == 0:\n            return 0"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        if dividend == 0:\n            return 0\n        \n        # 2. \n        if divisor == 1:\n            return dividend\n        \n        if divisor == -1:\n            if dividend == -2147483648:\n                return 2147483647\n            else:\n                return -dividend\n        \n        # 3. \n        if dividend == divisor:\n            return 1\n        \n        if dividend == -divisor:\n            return -1\n        \n        # 4. \n        if divisor == -1:\n            return -dividend\n        \n        if dividend == -1:\n            return -divisor\n        \n        # 5. \n        if dividend == divisor:\n            return 1\n        \n        if dividend == -divisor:\n            return -1\n        \n        # 6. \n        if dividend == 0:\n            return 0\n        \n        # 7. \n        if divisor == 0:\n            return 0\n        \n        # 8. \n        if dividend == 0:\n            return 0\n        \n        # 9. \n        if divisor == 0:\n            return 0"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '.'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '.':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u628a\u8fb9\u754c\u7684O\u5168\u90e8\u53d8\u6210#\n        # 2. \u628a\u5269\u4e0b\u7684O\u5168\u90e8\u53d8\u6210X\n        # 3. \u628a#\u5168\u90e8\u53d8\u6210O\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '.'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '.':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u5c06\u8fb9\u754c\u7684O\u5168\u90e8\u53d8\u6210#\n        # 2. \u5c06\u5185\u90e8\u7684O\u5168\u90e8\u53d8\u6210X\n        # 3. \u5c06#\u5168\u90e8\u53d8\u6210O\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u5c06\u8fb9\u754c\u7684O\u5168\u90e8\u53d8\u6210#\n        # 2. \u5c06\u5269\u4e0b\u7684O\u5168\u90e8\u53d8\u6210X\n        # 3. \u5c06#\u5168\u90e8\u53d8\u6210O\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        d = {}\n        \n        # iterate through the nums list\n        for i, num in enumerate(nums):\n            # if the target minus the current number is in the dictionary, return the indices\n            if target - num in d:\n                return [d[target - num], i]\n            # otherwise, add the current number and its index to the dictionary\n            d[num] = i\n        \n        # if no solution is found, return an empty list\n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        d = {}\n        \n        # iterate through the nums list\n        for i, num in enumerate(nums):\n            # calculate the complement of the current number\n            complement = target - num\n            \n            # if the complement is in the dictionary, return the indices of the current number and the complement\n            if complement in d:\n                return [d[complement], i]\n            \n            # add the current number and its index to the dictionary\n            d[num] = i\n        \n        # if no solution is found, return an empty list\n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        d = {}\n        \n        # iterate through the nums list\n        for i, num in enumerate(nums):\n            # calculate the complement of the current number\n            complement = target - num\n            \n            # if the complement is in the dictionary, return the indices of the current number and the complement\n            if complement in d:\n                return [d[complement], i]\n            \n            # add the current number and its index to the dictionary\n            d[num] = i\n        \n        # if no solution is found, return an empty list\n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        d = {}\n        \n        # iterate through the nums list\n        for i, num in enumerate(nums):\n            # calculate the complement of the current number\n            complement = target - num\n            \n            # if the complement is in the dictionary, return the indices of the current number and the complement\n            if complement in d:\n                return [d[complement], i]\n            \n            # add the current number and its index to the dictionary\n            d[num] = i\n        \n        # if no solution is found, return an empty list\n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        d = {}\n        \n        # iterate through the nums list\n        for i, num in enumerate(nums):\n            # if the target minus the current number is in the dictionary, return the indices\n            if target - num in d:\n                return [d[target - num], i]\n            # otherwise, add the current number and its index to the dictionary\n            d[num] = i\n        \n        # if no solution is found, return an empty list\n        return []"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        stack = [\"JFK\"]\n        res = []\n        while stack:\n            while graph[stack[-1]]:\n                stack.append(graph[stack[-1]].pop())\n            res.append(stack.pop())\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build the graph\n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        \n        # 2. sort the graph\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        # 3. dfs\n        res = []\n        def dfs(src):\n            while graph[src]:\n                dfs(graph[src].pop())\n            res.append(src)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        \n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        stack = [\"JFK\"]\n        res = []\n        \n        while stack:\n            while graph[stack[-1]]:\n                stack.append(graph[stack[-1]].pop())\n            res.append(stack.pop())\n        \n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        \n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        stack = [\"JFK\"]\n        res = []\n        \n        while stack:\n            while graph[stack[-1]]:\n                stack.append(graph[stack[-1]].pop())\n            res.append(stack.pop())\n        \n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        stack = [\"JFK\"]\n        res = []\n        while stack:\n            while graph[stack[-1]]:\n                stack.append(graph[stack[-1]].pop())\n            res.append(stack.pop())\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 2. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 3. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 4. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 5. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 6. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 7. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 8. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 9. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 10. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 11. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 12. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 13. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 14. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 15. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 16. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 17. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 18. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 19. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 20. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 21. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 22. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 23. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 24. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 25. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 26. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 27. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 28. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 29. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 30. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 31. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 32. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 33. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 34. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 35. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 36. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 37. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 2. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 3. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 4. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 5. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 6. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 7. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 8. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 9. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 10. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 11. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 12. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 13. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 14. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 15. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 16. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 17. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 18. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 19. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 20. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 21. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 22. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 23. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 24. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 25. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 26. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 27. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 28. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 29. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 30. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 31. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 32. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 33. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 34. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 35. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 36. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 37. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 38. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 39."}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u7684\u9ad8\u5ea6\u4fe1\u606f\u5b58\u5165\u4e00\u4e2a\u5217\u8868\u4e2d\uff0c\u540c\u65f6\u8bb0\u5f55\u6bcf\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u8d77\u59cb\u4f4d\u7f6e\u548c\u7ec8\u6b62\u4f4d\u7f6e\n        # 2. \u5c06\u6240\u6709\u9ad8\u5ea6\u4fe1\u606f\u6309\u7167\u8d77\u59cb\u4f4d\u7f6e\u8fdb\u884c\u6392\u5e8f\n        # 3. \u904d\u5386\u9ad8\u5ea6\u4fe1\u606f\uff0c\u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u8d77\u59cb\u4f4d\u7f6e\u5728\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e4b\u524d\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 4. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u8d77\u59cb\u4f4d\u7f6e\u5728\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e4b\u540e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6ca1\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 5. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u5728\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e4b\u524d\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 6. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u5728\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e4b\u540e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6ca1\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 7. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 8. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 9. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 10. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 11. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 12. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 13. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 14. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 15. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u6709\u91cd\u53e0\uff0c\u5219\u5c06\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u4e0e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u8fdb\u884c\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u4f5c\u4e3a\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\n        # 16. \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e\u7b49\u4e8e\u4e0a\u4e00\u4e2a\u9ad8\u5ea6\u4fe1\u606f\u7684\u7ec8\u6b62\u4f4d\u7f6e"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u7aef\u70b9\u548c\u53f3\u7aef\u70b9\uff0c\u5e76\u6807\u8bb0\u4e3a\u6b63\u503c\u548c\u8d1f\u503c\n        # 2. \u5c06\u6240\u6709\u70b9\u8fdb\u884c\u6392\u5e8f\n        # 3. \u904d\u5386\u6240\u6709\u70b9\uff0c\u5bf9\u4e8e\u5de6\u7aef\u70b9\uff0c\u5c06\u9ad8\u5ea6\u52a0\u5165\u5806\u4e2d\uff0c\u5bf9\u4e8e\u53f3\u7aef\u70b9\uff0c\u5c06\u9ad8\u5ea6\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u9ad8\u5ea6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u7ed3\u679c\n        \n        # \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u7aef\u70b9\u548c\u53f3\u7aef\u70b9\uff0c\u5e76\u6807\u8bb0\u4e3a\u6b63\u503c\u548c\u8d1f\u503c\n        points = []\n        for l, r, h in buildings:\n            points.append((l, h))\n            points.append((r, -h))\n        \n        # \u5c06\u6240\u6709\u70b9\u8fdb\u884c\u6392\u5e8f\n        points.sort()\n        \n        # \u521d\u59cb\u5316\u5806\u548c\u7ed3\u679c\n        res = [[0, 0]]\n        heap = [0]\n        \n        # \u904d\u5386\u6240\u6709\u70b9\n        for x, h in points:\n            # \u5bf9\u4e8e\u5de6\u7aef\u70b9\uff0c\u5c06\u9ad8\u5ea6\u52a0\u5165\u5806\u4e2d\n            if h > 0:\n                heapq.heappush(heap, h)\n            # \u5bf9\u4e8e\u53f3\u7aef\u70b9\uff0c\u5c06\u9ad8\u5ea6\u4ece\u5806\u4e2d\u79fb\u9664\n            else:\n                heap.remove(-h)\n                heapq.heapify(heap)\n            \n            # \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u9ad8\u5ea6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u7ed3\u679c\n            if res[-1][1] != -heap[0]:\n                res.append([x, -heap[0]])\n        \n        return res[1:]"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 2. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 3. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 4. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 5. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 6. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 7. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 8. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 9. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 10. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 11. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 12. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 13. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 14. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 15. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 16. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 17. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 18. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 19. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 20. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 21. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 22. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 23. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 24. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 25. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 26. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 27. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 28. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 29. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 30. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 31. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 32. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 33. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 34. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 35. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 36. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 37. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 38. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u8d1f\uff0c\u53f3\u8fb9\u4e3a\u6b63\n        # 39."}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Pythonic way\n        # Time: O(n)\n        # Space: O(1)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n        \n        # 2. Pythonic way\n        # Time: O(n)\n        # Space: O(1)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n        \n        # 2. Pythonic way\n        # Time: O(n)\n        # Space: O(1)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Pythonic way\n        # Time: O(n)\n        # Space: O(1)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n        \n        # 2. Recursion\n        # Time: O(n)\n        # Space: O(n)\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n        \n        helper(0, len(s) - 1)"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(1)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n)\n        # Space: O(1)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n)\n        # Space: O(1)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n)\n        # Space: O(1)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)\n        \n        # DP\n        # Time: O(n)\n        # Space: O(n)"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # dp[i] = min(dp[i], dp[i-1] + triangle[i][j])\n        \n        # dp[0] = triangle[0][0]\n        # dp[1] = min(dp[0] + triangle[1][0], dp[0] + triangle[1][1])\n        # dp[2] = min(dp[1] + triangle[2][0], dp[1] + triangle[2][1], dp[1] + triangle[2][2])\n        # dp[3] = min(dp[2] + triangle[3][0], dp[2] + triangle[3][1], dp[2] + triangle[3][2], dp[2] + triangle[3][3])\n        \n        # return dp[-1]\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(1)\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        \n        # dp[0][0] = triangle[0][0]\n        # dp[1][0] = dp[0][0] + triangle[1][0]\n        # dp[1][1] = dp[0][0] + triangle[1][1]\n        # dp[2][0] = dp[1][0] + triangle[2][0]\n        # dp[2][1] = min(dp[1][0], dp[1][1]) + triangle[2][1]\n        # dp[2][2] = dp[1][1] + triangle[2][2]\n        # dp[3][0] = dp[2][0] + triangle[3][0]\n        # dp[3][1] = min(dp[2][0], dp[2][1]) + triangle[3][1]\n        # dp[3][2] = min(dp[2][1], dp[2][2]) + triangle[3][2]\n        # dp[3][3] = dp[2][2] + triangle[3][3]\n        \n        # return min(dp[-1])\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # dp[i] = min(dp[i], dp[i-1] + triangle[i][j])\n        \n        # dp[0] = triangle[0][0]\n        # dp[1] = min(dp[0] + triangle[1][0], dp[0] + triangle[1][1])\n        # dp[2] = min(dp[1] + triangle[2][0], dp[1] + triangle[2][1], dp[1] + triangle[2][2])\n        # dp[3] = min(dp[2] + triangle[3][0], dp[2] + triangle[3][1], dp[2] + triangle[3][2], dp[2] + triangle[3][3])\n        \n        # return dp[-1]\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(1)\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        \n        # dp[0][0] = triangle[0][0]\n        # dp[1][0] = dp[0][0] + triangle[1][0]\n        # dp[1][1] = dp[0][0] + triangle[1][1]\n        # dp[2][0] = dp[1][0] + triangle[2][0]\n        # dp[2][1] = min(dp[1][0], dp[1][1]) + triangle[2][1]\n        # dp[2][2] = dp[1][1] + triangle[2][2]\n        # dp[3][0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return one[num] + \" \"\n            elif num < 100:\n                return ten[num//10] + \" \" + helper(num%10)\n            else:\n                return one[num//100] + \" Hundred \" + helper(num%100)\n        \n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        ten = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousand = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        res = \"\"\n        i = 0\n        \n        while num > 0:\n            if num%1000 != 0:\n                res = helper(num%1000) + thousand[i] + \" \" + res\n            num //= 1000\n            i += 1\n        \n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return one[num] + \" \"\n            elif num < 100:\n                return ten[num//10] + \" \" + helper(num%10)\n            else:\n                return one[num//100] + \" Hundred \" + helper(num%100)\n        \n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        ten = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousand = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        res = \"\"\n        i = 0\n        \n        while num > 0:\n            if num%1000 != 0:\n                res = helper(num%1000) + thousand[i] + \" \" + res\n            num //= 1000\n            i += 1\n        \n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return one[num] + \" \"\n            elif num < 100:\n                return ten[num // 10] + \" \" + helper(num % 10)\n            else:\n                return one[num // 100] + \" Hundred \" + helper(num % 100)\n        \n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        ten = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousand = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        res = \"\"\n        i = 0\n        \n        while num > 0:\n            if num % 1000 != 0:\n                res = helper(num % 1000) + thousand[i] + \" \" + res\n            num //= 1000\n            i += 1\n        \n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return one[num] + \" \"\n            elif num < 100:\n                return ten[num//10] + \" \" + helper(num%10)\n            else:\n                return one[num//100] + \" Hundred \" + helper(num%100)\n        \n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        ten = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousand = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        res = \"\"\n        i = 0\n        while num > 0:\n            if num%1000 != 0:\n                res = helper(num%1000) + thousand[i] + \" \" + res\n            num //= 1000\n            i += 1\n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return below_20[num] + \" \"\n            elif num < 100:\n                return tens[num//10] + \" \" + helper(num%10)\n            else:\n                return helper(num//1000000000) + \"Billion \" + helper(num//1000000) + \"Million \" + helper(num//1000) + \"Thousand \" + helper(num%1000)\n        \n        below_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % (10 ** 9 + 7)\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i]) % (10 ** 9 + 7)\n        return dp[n][k]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr and curr.next:\n            # save pointers\n            first_node = curr\n            second_node = curr.next\n            \n            # perform swap\n            prev.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            # update pointers\n            prev = first_node\n            curr = first_node.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr and curr.next:\n            # save pointers\n            first_node = curr\n            second_node = curr.next\n            \n            # perform swap\n            prev.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            # update pointers\n            prev = first_node\n            curr = first_node.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr and curr.next:\n            # save pointers\n            first_node = curr\n            second_node = curr.next\n            \n            # perform swap\n            prev.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            # update pointers\n            prev = first_node\n            curr = first_node.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr and curr.next:\n            # save pointers\n            first_node = curr\n            second_node = curr.next\n            \n            # perform swap\n            prev.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            # update pointers\n            prev = first_node\n            curr = first_node.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr and curr.next:\n            # save pointers\n            first_node = curr\n            second_node = curr.next\n            \n            # perform swap\n            prev.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            # update pointers\n            prev = first_node\n            curr = first_node.next\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - rootval"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - rootval"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - rootval"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the linked list\n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        # connect the two lists\n        p2.next = None\n        p1.next = dummy2.next\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            # if the value is less than x, append to dummy1\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the value is greater than or equal to x, append to dummy2\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # set the next of p2 to None\n        p2.next = None\n        \n        # set the next of p1 to the head of dummy2\n        p1.next = dummy2.next\n        \n        # return the head of dummy1\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            # if the value is less than x, append to dummy1\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the value is greater than or equal to x, append to dummy2\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # set the next of the last node of dummy1 to the head of dummy2\n        p1.next = dummy2.next\n        # set the next of the last node of dummy2 to None\n        p2.next = None\n        \n        # return the head of dummy1\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        # connect the two lists\n        p2.next = None\n        p1.next = dummy2.next\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the linked list\n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        # connect the two lists\n        p2.next = None\n        p1.next = dummy2.next\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == v:\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n        \n        return candB"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == v:\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n        \n        return candB"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == v:\n                if candA:\n                    return candA\n                return [u, v]\n        \n        return candB"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == v:\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n        \n        return candB"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == v:\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n        \n        return candB"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return 2 * sum(set(nums)) - sum(nums)\n        \n        # 2. use XOR\n        # a ^ a = 0\n        # a ^ 0 = a\n        # a ^ b ^ a = b\n        # a ^ b ^ c ^ a = b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c = c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return 2 * sum(set(nums)) - sum(nums)\n        \n        # 2. use XOR\n        # a = 0\n        # for i in nums:\n        #     a ^= i\n        # return a\n        \n        # 3. use reduce\n        return reduce(lambda x, y: x ^ y, nums)"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return 2 * sum(set(nums)) - sum(nums)\n        \n        # 2. use XOR\n        # a ^ a = 0\n        # a ^ 0 = a\n        # a ^ b ^ a = b\n        # a ^ b ^ c ^ a = b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c = c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return 2 * sum(set(nums)) - sum(nums)\n        \n        # 2. use XOR\n        # a ^ a = 0\n        # a ^ 0 = a\n        # a ^ b ^ a = a ^ a ^ b = b\n        # a ^ b ^ c ^ a ^ c = a ^ a ^ b ^ c ^ c = b\n        # a ^ b ^ c ^ a ^ c ^ b = a ^ a ^ b ^ c ^ c ^ b = a ^ b ^ c ^ b ^ c ^ c = a ^ b ^ c ^ 0 = a ^ b ^ c\n        # a ^ b ^ c ^ a ^ c ^ b ^ c = a ^ a ^ b ^ c ^ c ^ b ^ c = a ^ b ^ c ^ 0 ^ 0 ^ c = a ^ b ^ c ^ c = a ^ b ^ 0 = a ^ b\n        # a ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c = a ^ b ^ c ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = a ^ b ^ c ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # a ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^ b ^ c ^ a ^ c ^"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return 2*sum(set(nums)) - sum(nums)\n        \n        # 2. use XOR\n        # a = 0\n        # for i in nums:\n        #     a ^= i\n        # return a\n        \n        # 3. use hashmap\n        # dic = {}\n        # for i in nums:\n        #     dic[i] = dic.get(i, 0) + 1\n        # for i in dic:\n        #     if dic[i] == 1:\n        #         return i\n        \n        # 4. use bit manipulation\n        a = 0\n        for i in nums:\n            a ^= i\n        return a"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # if the list is empty, return 0\n        if not words:\n            return 0\n        \n        # return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Split the string into a list of words\n        words = s.split()\n        \n        # 2. Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Split the string into a list of words\n        words = s.split()\n        \n        # 2. Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # if the list is empty, return 0\n        if not words:\n            return 0\n        \n        # return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Split the string into a list of words\n        # 2. Return the length of the last word\n        # 3. If the last word is empty, return 0\n        \n        # 1. Split the string into a list of words\n        words = s.split()\n        \n        # 2. Return the length of the last word\n        if words:\n            return len(words[-1])\n        \n        # 3. If the last word is empty, return 0\n        return 0"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for a in range(i, min(n, i + 2)):\n                    for b in range(j, min(n, j + 2)):\n                        if grid[a][b] == -1:\n                            continue\n                        res = dp[a][b][k - 1]\n                        if i:\n                            res = max(res, dp[i - 1][j][k - 1])\n                        if j:\n                            res = max(res, dp[i][j - 1"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for i1 in range(i, min(n, i + 2)):\n                    j1 = k - i1\n                    if grid[i1][j1] == -1:\n                        continue\n                    res = dp[i][j][k - 1] + grid[i1][j1]\n                    if i1 != i:\n                        res = max(res, dp[i1][j1][k - 1] + grid[i][j])\n                    if j1 != j:\n                        res = max(res, dp[i][j1][k - 1] + grid[i][j])\n                    if i1 != i and j1 != j:\n                        res = max(res, dp[i1][j1][k - 1] + grid[i][j])\n                    dp[i1][j1][k] = res\n        \n        return max(0, dp[n - 1][n - 1][2 * n - 2])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for x in (i - 1, i):\n                    for y in (j - 1, j):\n                        if x < 0 or y < 0:\n                            continue\n                        if dp[x][y][k - 1] == -1:\n                            continue\n                        dp[i][j][k] = max(dp[i][j][k], dp[x][y][k - 1] + grid[i][j])\n        \n        return max(0, dp[n - 1][n - 1][2 * n - 2])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for ii in range(i, min(n, i + 2)):\n                    for jj in range(j, min(n, j + 2)):\n                        if grid[ii][jj] == -1:\n                            continue\n                        dp[ii][jj][i] = max(dp[ii][jj][i], dp[i][j][k - 1] + grid[ii][jj])\n        \n        return max(dp[n - 1][n - 1][-1], 0)"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for ii in range(i, min(n, i + 2)):\n                    for jj in range(j, min(n, j + 2)):\n                        if grid[ii][jj] == -1:\n                            continue\n                        cherries = grid[ii][jj]\n                        if i != ii or j != jj:\n                            cherries += dp[i][j][k - 1]\n                        if cherries >= 0:\n                            dp[ii][jj][k] = max(dp[ii][jj][k], cherries)\n        \n        return max(0, dp[n - 1][n - 1][-1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        # dp[7] = 81\n        # dp[8] = 149\n        # dp[9] = 274\n        # dp[10] = 504\n        # dp[11] = 927\n        # dp[12] = 1705\n        # dp[13] = 3136\n        # dp[14] = 5768\n        # dp[15] = 10609\n        # dp[16] = 19513\n        # dp[17] = 35890\n        # dp[18] = 66012\n        # dp[19] = 121415\n        # dp[20] = 223317\n        # dp[21] = 410744\n        # dp[22] = 755476\n        # dp[23] = 1389037\n        # dp[24] = 2555757\n        # dp[25] = 4700770\n        # dp[26] = 8646064\n        # dp[27] = 15902591\n        # dp[28] = 29249425\n        # dp[29] = 53798080\n        # dp[30] = 98950096\n        # dp[31] = 181997601\n        # dp[32] = 334745777\n        # dp[33] = 615693474\n        # dp[34] = 1132436852\n        # dp[35] = 2082876103\n        \n        # 2.\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        # dp[7] = 81\n        # dp[8] = 149\n        # dp[9] = 274\n        # dp[10] = 504\n        # dp[11] = 927\n        # dp[12] = 1705\n        # dp[13] = 3136\n        # dp[14] = 5768\n        # dp[15] = 10609\n        # dp[16] = 19513\n        # dp[17] = 35890\n        # dp[18] = 66012\n        # dp[19] = 121415\n        # dp[20] = 223317\n        # dp[21] = 410744\n        # dp[22] = 755476\n        # dp[23] = 1389037\n        # dp[24] = 2555757\n        # dp[25] = 4700770\n        # dp[26] = 8646064\n        # dp[27] = 15902591\n        # dp[28] = 29249425\n        # dp"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] = number of attendance records of length i with j As and k consecutive Ls\n        # dp[i][j][k] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2] + dp[i-1][j-1][0] + dp[i-1][j][k-1]\n        # dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2] + dp[i-1][j-1][0]\n        # dp[i][j][1] = dp[i-1][j][1] + dp[i-1][j][2]\n        # dp[i][j][2] = dp[i-1][j][2]\n        \n        MOD = 10**9 + 7\n        \n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n+1)]\n        dp[0][0][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(2):\n                for k in range(3):\n                    dp[i][j][0] = (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2] + dp[i-1][j-1][0]) % MOD\n                    dp[i][j][1] = (dp[i-1][j][1] + dp[i-1][j][2]) % MOD\n                    dp[i][j][2] = dp[i-1][j][2]\n        \n        return sum(dp[n][j][0] + dp[n][j][1] + dp[n][j][2] for j in range(2)) % MOD"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j][k-1] + dp[i-1][j-1][k-1]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j][k-1] + dp[i-1][j-1][k-1]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j][k-1] + dp[i-1][j-1][k]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j][k-1] + dp[i-1][j-1][k] - dp[i-1][j-1][k-1]\n        \n        # 2. \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] - dp[i-1][j-3]\n        \n        # 3. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        \n        # 4. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        \n        # 5. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        \n        # 6. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        # d"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        \n        # 2. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        \n        # 3. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        \n        # 4. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        \n        # 5. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        \n        # 6. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        # dp[7] = 81\n        \n        # 7. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        # dp[7] = 81\n        # dp[8] = 149\n        \n        # 8. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        # dp[7] = 81\n        # dp[8] = 149\n        # dp[9] = 274\n        \n        # 9. \n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[0] = 1\n        # dp[1] = 2\n        # dp[2] = 4\n        # dp[3] = 7\n        # dp[4] = 13\n        # dp[5] = 24\n        # dp[6] = 44\n        # dp[7] = 81\n        # dp[8] = 149\n        # dp[9] = 274\n        # dp"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j][k] = number of attendance records of length i with j As and k consecutive Ls\n        # dp[i][j][k] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2] + dp[i-1][j-1][0] + dp[i-1][j][0]\n        # dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]\n        # dp[i][j][1] = dp[i-1][j][0]\n        # dp[i][j][2] = dp[i-1][j][1]\n        \n        MOD = 10**9 + 7\n        \n        dp = [[[0] * 3 for _ in range(2)] for _ in range(n+1)]\n        dp[0][0][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(2):\n                for k in range(3):\n                    dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]) % MOD\n                    dp[i][j][1] = (dp[i][j][1] + dp[i-1][j][0]) % MOD\n                    dp[i][j][2] = (dp[i][j][2] + dp[i-1][j][1]) % MOD\n                    \n        return (dp[n][0][0] + dp[n][0][1] + dp[n][0][2] + dp[n][1][0] + dp[n][1][1] + dp[n][1][2]) % MOD"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary Search\n        # Time: O(log n)\n        # Space: O(1)\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. Initialize the maximum index we can reach\n        max_index = 0\n        \n        # 2. Iterate through the array\n        for i in range(len(nums)):\n            # 3. If the current index is greater than the maximum index, return False\n            if i > max_index:\n                return False\n            # 4. Update the maximum index\n            max_index = max(max_index, i + nums[i])\n        # 5. If we reach the end of the array, return True\n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,n):\n            grid[0][i] += grid[0][i-1]\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,n):\n            grid[0][i] += grid[0][i-1]\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,n):\n            grid[0][i] += grid[0][i-1]\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev) - 1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev) - 1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev) - 1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+1 and right\n        # 6. if yes, binary search between left and mid\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+1 and right\n        # 6. if yes, binary search between left and mid\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+1 and right\n        # 6. if yes, binary search between left and mid\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+1 and right\n        # 6. if yes, binary search between left and mid\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+1 and right\n        # 6. if yes, binary search between left and mid\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+1 and right\n        # 6. if yes, binary search between left and mid\n        \n        # binary search\n        # 1. find the max value in nums\n        # 2. find the sum of nums\n        # 3. binary search between max value and sum\n        # 4. check if the mid value can be the answer\n        # 5. if not, binary search between mid+"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def canSplit(mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                currSum += num\n                if currSum > mid:\n                    count += 1\n                    currSum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if canSplit(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def canSplit(mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                currSum += num\n                if currSum > mid:\n                    count += 1\n                    currSum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if canSplit(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def canSplit(maxSum):\n            currSum = 0\n            splitCount = 1\n            for num in nums:\n                currSum += num\n                if currSum > maxSum:\n                    currSum = num\n                    splitCount += 1\n            return splitCount <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if canSplit(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u8d2a\u5fc3\n        # 3. \u52a8\u6001\u89c4\u5212\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # \u4e8c\u5206\u67e5\u627e\u7684\u8303\u56f4\u662f\u6570\u7ec4\u7684\u6700\u5927\u503c\u548c\u6570\u7ec4\u7684\u548c\n        # \u4e8c\u5206\u67e5\u627e\u7684\u76ee\u6807\u662f\u627e\u5230\u4e00\u4e2a\u503c\uff0c\u4f7f\u5f97\u6570\u7ec4\u53ef\u4ee5\u88ab\u5206\u6210k\u4e2a\u5b50\u6570\u7ec4\uff0c\u5e76\u4e14\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u90fd\u4e0d\u8d85\u8fc7\u8fd9\u4e2a\u503c\n        # \u5982\u679c\u6570\u7ec4\u53ef\u4ee5\u88ab\u5206\u6210k\u4e2a\u5b50\u6570\u7ec4\uff0c\u90a3\u4e48\u8fd9\u4e2a\u503c\u5c31\u592a\u5927\u4e86\uff0c\u5426\u5219\u5c31\u592a\u5c0f\u4e86\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u76f8\u7b49\n        # \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        pivot = left\n        \n        if nums[pivot] == target:\n            return pivot\n        \n        if nums[0] <= target:\n            return self.binary_search(nums, 0, pivot - 1, target)\n        else:\n            return self.binary_search(nums, pivot, len(nums) - 1, target)\n        \n    def binary_search(self, nums, left, right, target):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        pivot = left\n        \n        if nums[pivot] == target:\n            return pivot\n        elif nums[pivot] < target <= nums[-1]:\n            left = pivot\n            right = len(nums) - 1\n        else:\n            left = 0\n            right = pivot - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        pivot = self.findPivot(nums)\n        \n        if pivot == -1:\n            return self.binarySearch(nums, target, 0, len(nums)-1)\n        \n        if nums[pivot] == target:\n            return pivot\n        elif nums[0] <= target:\n            return self.binarySearch(nums, target, 0, pivot-1)\n        else:\n            return self.binarySearch(nums, target, pivot+1, len(nums)-1)\n        \n        \n    def findPivot(self, nums):\n        start = 0\n        end = len(nums)-1\n        \n        while start <= end:\n            mid = start + (end-start)//2\n            \n            if mid < end and nums[mid] > nums[mid+1]:\n                return mid\n            elif mid > start and nums[mid] < nums[mid-1]:\n                return mid-1\n            elif nums[start] >= nums[mid]:\n                end = mid - 1\n            else:\n                start = mid + 1\n                \n        return -1\n    \n    def binarySearch(self, nums, target, start, end):\n        while start <= end:\n            mid = start + (end-start)//2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n                \n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        pivot = left\n        \n        if nums[pivot] == target:\n            return pivot\n        \n        if nums[0] <= target:\n            return self.binary_search(nums, 0, pivot - 1, target)\n        else:\n            return self.binary_search(nums, pivot, len(nums) - 1, target)\n        \n    def binary_search(self, nums, left, right, target):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                digit = next_digits[0]\n                for letter in mapping[digit]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                digit = next_digits[0]\n                for letter in mapping[digit]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = []\n        self.backtrack(digits, 0, '', result, mapping)\n        return result\n    \n    def backtrack(self, digits, index, current, result, mapping):\n        if len(current) == len(digits):\n            result.append(current)\n            return\n        \n        for i in range(index, len(digits)):\n            letters = mapping[digits[i]]\n            for letter in letters:\n                self.backtrack(digits, i + 1, current + letter, result, mapping)"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                digit = next_digits[0]\n                for letter in mapping[digit]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def dfs(candidates, target, path):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]])\n        dfs(candidates, target, [])\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def dfs(candidates, target, path):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]])\n        dfs(candidates, target, [])\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def dfs(candidates, target, path):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]])\n        dfs(candidates, target, [])\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 1.1 find the middle of the number\n        # 1.2 find the next palindrome\n        # 1.3 if the number is odd, then the middle number is the same\n        # 1.4 if the number is even, then the middle number is the same\n        # 1.5 if the number is odd, then the middle number is the next number\n        # 1.6 if the number is even, then the middle number is the next number\n        # 1.7 if the number is odd, then the middle number is the previous number\n        # 1.8 if the number is even, then the middle number is the previous number\n        # 1.9 if the number is odd, then the middle number is the previous number\n        # 1.10 if the number is even, then the middle number is the previous number\n        # 1.11 if the number is odd, then the middle number is the previous number\n        # 1.12 if the number is even, then the middle number is the previous number\n        # 1.13 if the number is odd, then the middle number is the previous number\n        # 1.14 if the number is even, then the middle number is the previous number\n        # 1.15 if the number is odd, then the middle number is the previous number\n        # 1.16 if the number is even, then the middle number is the previous number\n        # 1.17 if the number is odd, then the middle number is the previous number\n        # 1.18 if the number is even, then the middle number is the previous number\n        # 1.19 if the number is odd, then the middle number is the previous number\n        # 1.20 if the number is even, then the middle number is the previous number\n        # 1.21 if the number is odd, then the middle number is the previous number\n        # 1.22 if the number is even, then the middle number is the previous number\n        # 1.23 if the number is odd, then the middle number is the previous number\n        # 1.24 if the number is even, then the middle number is the previous number\n        # 1.25 if the number is odd, then the middle number is the previous number\n        # 1.26 if the number is even, then the middle number is the previous number\n        # 1.27 if the number is odd, then the middle number is the previous number\n        # 1.28 if the number is even, then the middle number is the previous number\n        # 1.29 if the number is odd, then the middle number is the previous number\n        # 1.30 if the number is even, then the middle number is the previous number\n        # 1.31 if the number is odd, then the middle number is the previous number\n        # 1.32 if the number is even, then the middle number is the previous number\n        # 1.33 if the number is odd, then the middle number is the previous number\n        # 1.34 if the number is even, then the middle number is the previous number\n        # 1.35 if the number is odd, then the middle number is the previous number\n        # 1.36 if the number is even, then the middle number is the previous number\n        # 1.37 if the number is odd, then the middle number is the previous number\n        # 1.38 if the number is even, then the middle number is the previous number\n        # 1.39 if the number is odd, then the middle number is the previous number\n        # 1.40 if the number is even, then the middle number is the previous number\n        # 1.41 if the number is odd, then the middle number is the previous number\n        # 1.42 if the number is even, then the middle number is the previous number\n        # 1.43 if the number is odd, then the middle number is the previous number\n        # 1.44 if the number is even, then the middle number is the previous number\n        # 1.45 if the number is odd, then the middle number is"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 1.1 find the middle of the number\n        # 1.2 find the next number\n        # 1.3 find the next palindrome\n        # 1.4 return the next palindrome\n        \n        # 2. find the previous palindrome\n        # 2.1 find the middle of the number\n        # 2.2 find the previous number\n        # 2.3 find the previous palindrome\n        # 2.4 return the previous palindrome\n        \n        # 3. compare the absolute difference\n        # 3.1 find the absolute difference of the next palindrome\n        # 3.2 find the absolute difference of the previous palindrome\n        # 3.3 return the smaller one\n        \n        # 4. return the smaller one\n        # 4.1 return the next palindrome if the absolute difference of the next palindrome is smaller than the absolute difference of the previous palindrome\n        # 4.2 return the previous palindrome if the absolute difference of the next palindrome is greater than the absolute difference of the previous palindrome\n        # 4.3 return the next palindrome if the absolute difference of the next palindrome is equal to the absolute difference of the previous palindrome\n        \n        # 1. find the next palindrome\n        # 1.1 find the middle of the number\n        # 1.2 find the next number\n        # 1.3 find the next palindrome\n        # 1.4 return the next palindrome\n        \n        # 1.1 find the middle of the number\n        # 1.1.1 find the length of the number\n        # 1.1.2 find the middle of the number\n        # 1.1.3 return the middle of the number\n        \n        # 1.2 find the next number\n        # 1.2.1 find the length of the number\n        # 1.2.2 find the middle of the number\n        # 1.2.3 find the next number\n        # 1.2.4 return the next number\n        \n        # 1.3 find the next palindrome\n        # 1.3.1 find the length of the number\n        # 1.3.2 find the middle of the number\n        # 1.3.3 find the next number\n        # 1.3.4 find the next palindrome\n        # 1.3.5 return the next palindrome\n        \n        # 1.4 return the next palindrome\n        # 1.4.1 return the next palindrome\n        \n        # 2. find the previous palindrome\n        # 2.1 find the middle of the number\n        # 2.2 find the previous number\n        # 2.3 find the previous palindrome\n        # 2.4 return the previous palindrome\n        \n        # 2.1 find the middle of the number\n        # 2.1.1 find the length of the number\n        # 2.1.2 find the middle of the number\n        # 2.1.3 return the middle of the number\n        \n        # 2.2 find the previous number\n        # 2.2.1 find the length of the number\n        # 2.2.2 find the middle of the number\n        # 2.2.3 find the previous number\n        # 2.2.4 return the previous number\n        \n        # 2.3 find the previous palindrome\n        # 2.3.1 find the length of the number\n        # 2.3.2 find the middle of the number\n        # 2.3.3 find the previous number\n        # 2.3.4 find the previous palindrome\n        # 2.3.5 return the previous palindrome\n        \n        # 2.4 return the previous palindrome\n        # 2.4.1 return the previous palindrome\n        \n        # 3. compare the absolute difference\n        # 3.1 find the absolute difference of the next palindrome\n        # 3.2 find the absolute difference of the previous palindrome\n        # 3.3 return the smaller one"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2. find the previous palindrome\n        # 3. compare the absolute difference between the two palindromes\n        # 4. return the smaller one\n        \n        # 1. find the next palindrome\n        # 2."}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is the same as n, then we need to find the closest palindrome with one digit different\n        # 3. if the closest palindrome is not the same as n, then we need to find the closest palindrome with one digit different\n        # 4. if the closest palindrome is not the same as n, then we need to find the closest palindrome with two digits different\n        # 5. if the closest palindrome is not the same as n, then we need to find the closest palindrome with three digits different\n        # 6. if the closest palindrome is not the same as n, then we need to find the closest palindrome with four digits different\n        # 7. if the closest palindrome is not the same as n, then we need to find the closest palindrome with five digits different\n        # 8. if the closest palindrome is not the same as n, then we need to find the closest palindrome with six digits different\n        # 9. if the closest palindrome is not the same as n, then we need to find the closest palindrome with seven digits different\n        # 10. if the closest palindrome is not the same as n, then we need to find the closest palindrome with eight digits different\n        # 11. if the closest palindrome is not the same as n, then we need to find the closest palindrome with nine digits different\n        # 12. if the closest palindrome is not the same as n, then we need to find the closest palindrome with ten digits different\n        # 13. if the closest palindrome is not the same as n, then we need to find the closest palindrome with eleven digits different\n        # 14. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twelve digits different\n        # 15. if the closest palindrome is not the same as n, then we need to find the closest palindrome with thirteen digits different\n        # 16. if the closest palindrome is not the same as n, then we need to find the closest palindrome with fourteen digits different\n        # 17. if the closest palindrome is not the same as n, then we need to find the closest palindrome with fifteen digits different\n        # 18. if the closest palindrome is not the same as n, then we need to find the closest palindrome with sixteen digits different\n        # 19. if the closest palindrome is not the same as n, then we need to find the closest palindrome with seventeen digits different\n        # 20. if the closest palindrome is not the same as n, then we need to find the closest palindrome with eighteen digits different\n        # 21. if the closest palindrome is not the same as n, then we need to find the closest palindrome with nineteen digits different\n        # 22. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty digits different\n        # 23. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-one digits different\n        # 24. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-two digits different\n        # 25. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-three digits different\n        # 26. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-four digits different\n        # 27. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-five digits different\n        # 28. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-six digits different\n        # 29. if the closest palindrome is not the same as n, then we need to find the closest palindrome with twenty-seven digits different\n        # 30. if the closest palindrome is not the same as n, then"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with 0\n        matrix = [[0] * n for _ in range(n)]\n        \n        # initialize the starting row, column, and the number of elements to be filled\n        row, col = 0, 0\n        num = 1\n        \n        # iterate until the number of elements to be filled is less than or equal to n^2\n        while num <= n * n:\n            # fill the top row from left to right\n            while col < n and matrix[row][col] == 0:\n                matrix[row][col] = num\n                num += 1\n                col += 1\n            row += 1\n            col -= 1\n            \n            # fill the right column from top to bottom\n            while row < n and matrix[row][col] == 0:\n                matrix[row][col] = num\n                num += 1\n                row += 1\n            row -= 1\n            col -= 1\n            \n            # fill the bottom row from right to left\n            while col >= 0 and matrix[row][col] == 0:\n                matrix[row][col] = num\n                num += 1\n                col -= 1\n            row -= 1\n            col += 1\n            \n            # fill the left column from bottom to top\n            while row >= 0 and matrix[row][col] == 0:\n                matrix[row][col] = num\n                num += 1\n                row -= 1\n            row += 1\n            col += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with all 0's\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the row and column indices\n        row_start, row_end = 0, n-1\n        col_start, col_end = 0, n-1\n        \n        # initialize the counter\n        counter = 1\n        \n        # traverse the matrix in a spiral order\n        while row_start <= row_end and col_start <= col"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with 0\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the row and column index\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        # initialize the number to be filled\n        num = 1\n        \n        # fill the matrix in spiral order\n        while row_start <= row_end and col_start <= col_end:\n            # fill the top row\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            # fill the right column\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            # fill the bottom row\n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            # fill the left column\n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][colcol_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with zeros\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        \n        # initialize the starting row, column, and direction\n        row, col = 0, 0\n        direction = 0\n        \n        # initialize the number to be filled in the matrix\n        num = 1\n        \n        # loop until all elements are filled\n        while num <= n * n:\n            # fill the current element\n            matrix[row][col] = num\n            \n            # move to the next element based on the current direction\n            if direction == 0:\n                col += 1\n                if col == n or matrix[row][col] != 0:\n                    col -= 1\n                    row += 1\n                    direction = 1\n            elif direction == 1:\n                row += 1\n                if row == n or matrix[row][col] != 0:\n                    row -= 1\n                    col -= 1\n                    direction = 2\n            elif direction == 2:\n                col -= 1\n                if col == -1 or matrix[row][col] != 0:\n                    col += 1\n                    row -= 1\n                    direction = 3\n            else:\n                row -= 1\n                if row == -1 or matrix[row][col] != 0:\n                    row += 1\n                    col += 1\n                    direction = 0\n            \n            # increment the number to be filled\n            num += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with zeros\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        \n        # initialize the starting row, column, and direction\n        row, col = 0, 0\n        dr, dc = 0, 1\n        \n        # loop through the numbers from 1 to n^2\n        for i in range(1, n**2 + 1):\n            # set the current cell to the current number\n            matrix[row][col] = i\n            \n            # check if the next cell is out of bounds or already filled\n            if row + dr < 0 or row + dr >= n or col + dc < 0 or col + dc >= n or matrix[row + dr][col + dc] != 0:\n                # if so, change the direction\n                dr, dc = dc, -dr\n            \n            # update the row and column\n            row += dr\n            col += dc\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        \n        return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        \n        return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for row in matrix:\n            row.reverse()"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first negative number\n        ## 2. find the last negative number\n        ## 3. if the first negative number is before the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 4. if the first negative number is after the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 5. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 6. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 7. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 8. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 9. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 10. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 11. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 12. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 13. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 14. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 15. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 16. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 17. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 18. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 19. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 20. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 21. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 22. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 23. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 24. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 25. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 26. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 27. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ##"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. keep track of the max and min product\n        ## 2. if we encounter a negative number, swap the max and min\n        ## 3. if we encounter a 0, reset the max and min to 1\n        ## 4. if we encounter a positive number, update the max and min\n        ## 5. return the max\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. keep track of the max and min product\n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        ## 2. if we encounter a negative number, swap the max and min\n        ## 3. if we encounter a 0, reset the max and min to 1\n        ## 4. if we encounter a positive number, update the max and min\n        ## 5. return the max\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointers\n        ## 2 variables to keep track of the max and min\n        ## max_so_far = max(max_so_far * nums[i], nums[i])\n        ## min_so_far = min(min_so_far * nums[i], nums[i])\n        ## max_so_far = max(max_so_far, max_so_far)\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        result = max_so_far\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n            min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n            \n            max_so_far = temp_max\n            \n            result = max(max_so_far, result)\n            \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first negative number\n        ## 2. find the last negative number\n        ## 3. if the first negative number is before the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 4. if the first negative number is after the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 5. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 6. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 7. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 8. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 9. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 10. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 11. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 12. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 13. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 14. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 15. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 16. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 17. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 18. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 19. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 20. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 21. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 22. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 23. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 24. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 25. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 26. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ## 27. if the first negative number is the same as the last negative number, then the product of the subarray between the first and last negative number is the maximum product\n        ##"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointers\n        ## 2 variables to keep track of the max and min\n        ## max_so_far = max(max_so_far * nums[i], nums[i])\n        ## min_so_far = min(min_so_far * nums[i], nums[i])\n        ## max_so_far = max(max_so_far, max_so_far)\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        max_so_far = nums[0]\n        min_so_far = nums[0]\n        result = max_so_far\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_so_far * curr, min_so_far * curr)\n            min_so_far = min(curr, max_so_far * curr, min_so_far * curr)\n            \n            max_so_far = temp_max\n            \n            result = max(max_so_far, result)\n            \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, s in enumerate(score_sorted):\n            if i == 0:\n                rank_dict[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[s] = \"Bronze Medal\"\n            else:\n                rank_dict[s] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for s in score:\n            rank_list.append(rank_dict[s])\n        \n        return rank_list"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, s in enumerate(score_sorted):\n            if i == 0:\n                rank_dict[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[s] = \"Bronze Medal\"\n            else:\n                rank_dict[s] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for s in score:\n            rank_list.append(rank_dict[s])\n        \n        return rank_list"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, s in enumerate(score_sorted):\n            if i == 0:\n                rank_dict[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[s] = \"Bronze Medal\"\n            else:\n                rank_dict[s] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for s in score:\n            rank_list.append(rank_dict[s])\n        \n        return rank_list"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, s in enumerate(score_sorted):\n            if i == 0:\n                rank_dict[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[s] = \"Bronze Medal\"\n            else:\n                rank_dict[s] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for s in score:\n            rank_list.append(rank_dict[s])\n        \n        return rank_list"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, s in enumerate(score_sorted):\n            if i == 0:\n                rank_dict[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[s] = \"Bronze Medal\"\n            else:\n                rank_dict[s] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for s in score:\n            rank_list.append(rank_dict[s])\n        \n        return rank_list"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # keep track of the longest substring\n        # keep track of the current substring\n        # keep track of the current substring length\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # keep track of the longest substring\n        # keep track of the current substring\n        # keep track of the current substring length\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # keep track of the longest substring\n        # keep track of the current substring\n        # keep track of the current substring length\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # keep track of the longest substring\n        # keep track of the current substring\n        # keep track of the current substring length\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # keep track of the longest substring\n        # keep track of the current substring\n        # keep track of the current substring length\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring end\n        # keep track of the current substring start\n        # keep track of the current substring"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            count = 0\n            curr_dict = {}\n            for j in range(i, s_len - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word in word_dict:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n                else:\n                    curr_dict = {}\n                    count = 0\n                    left = j + word_len\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            count = 0\n            curr_dict = {}\n            for j in range(i, s_len - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word in word_dict:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n                else:\n                    curr_dict = {}\n                    count = 0\n                    left = j + word_len\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            count = 0\n            curr_dict = {}\n            for j in range(i, s_len - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word in word_dict:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n                else:\n                    left = j + word_len\n                    curr_dict = {}\n                    count = 0\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            count = 0\n            curr_dict = {}\n            for j in range(i, s_len - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word in word_dict:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n                else:\n                    curr_dict = {}\n                    count = 0\n                    left = j + word_len\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            count = 0\n            curr_dict = {}\n            for j in range(i, s_len - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word in word_dict:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n                else:\n                    curr_dict = {}\n                    count = 0\n                    left = j + word_len\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(1)\n        # 2. \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1)\n        # 2.\n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1.\n        # Time: O(n)\n        # Space: O(1"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        \n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        \n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        \n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        curr = dummy\n        \n        # iterate through the linked list\n        while curr.next and curr.next.next:\n            # if the current node and the next node have the same value\n            if curr.next.val == curr.next.next.val:\n                # store the value of the current node\n                val = curr.next.val\n                # iterate through the linked list until we find a node with a different value\n                while curr.next and curr.next.val == val:\n                    curr.next = curr.next.next\n            else:\n                # if the current node and the next node do not have the same value, move to the next node\n                curr = curr.next\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        curr = dummy\n        \n        # iterate through the linked list\n        while curr.next and curr.next.next:\n            # if the current node and the next node have the same value\n            if curr.next.val == curr.next.next.val:\n                # store the value of the current node\n                val = curr.next.val\n                # iterate through the linked list until we find a node with a different value\n                while curr.next and curr.next.val == val:\n                    curr.next = curr.next.next\n            else:\n                # if the current node and the next node do not have the same value, move to the next node\n                curr = curr.next\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        \n        # while curr and curr.next:\n        #     if curr.val == curr.next.val:\n        #         while curr and curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #     else:\n        #         prev = curr\n        #     curr = curr.next\n        \n        # return dummy.next\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                break\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0]*(n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n            \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                    \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0]*(n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (word1[i-1] != word2[j-1]))\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (word1[i-1] != word2[j-1]))\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count differences\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count the number of different bits\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count the number of different bits\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) < len(y):\n            x = '0'*(len(y)-len(x)) + x\n        elif len(y) < len(x):\n            y = '0'*(len(x)-len(y)) + y\n        \n        # count differences\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count differences\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            if not root.left and not root.right:\n                paths.append(path + str(root.val))\n                return\n            dfs(root.left, path + str(root.val) + \"->\")\n            dfs(root.right, path + str(root.val) + \"->\")\n        \n        paths = []\n        dfs(root, \"\")\n        return paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(node, path):\n            if not node:\n                return\n            path.append(str(node.val))\n            if not node.left and not node.right:\n                paths.append('->'.join(path))\n            else:\n                dfs(node.left, path)\n                dfs(node.right, path)\n            path.pop()\n        \n        paths = []\n        dfs(root, [])\n        return paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                paths.append(path + str(node.val))\n                return\n            dfs(node.left, path + str(node.val) + '->')\n            dfs(node.right, path + str(node.val) + '->')\n        \n        paths = []\n        dfs(root, '')\n        return paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path.append(str(root.val))\n            if not root.left and not root.right:\n                paths.append('->'.join(path))\n            dfs(root.left, path)\n            dfs(root.right, path)\n            path.pop()\n        \n        paths = []\n        dfs(root, [])\n        return paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            if not root.left and not root.right:\n                paths.append(path + str(root.val))\n                return\n            dfs(root.left, path + str(root.val) + \"->\")\n            dfs(root.right, path + str(root.val) + \"->\")\n        \n        paths = []\n        dfs(root, \"\")\n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= 2 * right[j]:\n                    i += 1\n                else:\n                    self.count += len(left) - i\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        self.count = 0\n        mergeSort(nums)\n        return self.count"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i = j = 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= 2 * right[j]:\n                    i += 1\n                else:\n                    self.count += len(left) - i\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        self.count = 0\n        mergeSort(nums)\n        return self.count"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= 2 * right[j]:\n                    i += 1\n                else:\n                    self.count += len(left) - i\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        self.count = 0\n        mergeSort(nums)\n        return self.count"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = 0\n            while i < len(left) and j < len(right):\n                if left[i] > 2 * right[j]:\n                    res += len(left) - i\n                    j += 1\n                else:\n                    i += 1\n            return res + merge_sort(left) + merge_sort(right)\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return 0\n            mid = len(nums) // 2\n            left = nums[:mid]\n            right = nums[mid:]\n            return merge(left, right)\n        \n        return merge_sort(nums)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = 0\n            while i < len(left) and j < len(right):\n                if left[i] > 2 * right[j]:\n                    res += len(left) - i\n                    j += 1\n                else:\n                    i += 1\n            return res + merge_sort(left) + merge_sort(right)\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return 0\n            mid = len(nums) // 2\n            left = nums[:mid]\n            right = nums[mid:]\n            return merge(left, right)\n        \n        return merge_sort(nums)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy <= ty and (ty - sy) % sx == 0:\n            return True\n        if sy == ty and sx <= tx and (tx - sx) % sy == 0:\n            return True\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy <= ty and (ty - sy) % sx == 0:\n            return True\n        if sy == ty and sx <= tx and (tx - sx) % sy == 0:\n            return True\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy <= ty and (ty - sy) % sx == 0:\n            return True\n        if sy == ty and sx <= tx and (tx - sx) % sy == 0:\n            return True\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy <= ty and (ty - sy) % sx == 0:\n            return True\n        if sy == ty and sx <= tx and (tx - sx) % sy == 0:\n            return True\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if tx == sx and ty == sy:\n            return True\n        elif tx == sx:\n            return ty > sy and (ty - sy) % sx == 0\n        elif ty == sy:\n            return tx > sx and (tx - sx) % sy == 0\n        else:\n            return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            d1 = v1[i] if i < len(v1) else 0\n            d2 = v2[i] if i < len(v2) else 0\n            if d1 != d2:\n                return 1 if d1 > d2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i+1], then we buy and sell\n        # 3. if prices[i] < prices[i+1], then we do nothing\n        # 4. if prices[i] == prices[i+1], then we do nothing\n        # 5. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy and sell\n        # 6. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we do nothing\n        # 7. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 8. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy and sell\n        # 9. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we do nothing\n        # 10. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy and sell\n        # 11. if prices[i] == prices and prices[i+1] < prices[i+2], then we do nothing\n        # 12. if prices[i] > prices[i+1] and prices[i+1] == prices[i+2], then we buy and sell\n        # 13. if prices[i] < prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 14. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy and sell\n        # 15. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy and sell\n        # 16. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we do nothing\n        # 17. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy and sell\n        # 18. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy and sell\n        # 19. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we do nothing\n        # 20. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 21. if prices[i] > prices[i+1] and prices[i+1] == prices[i+2], then we buy and sell\n        # 22. if prices[i] < prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 23. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy and sell\n        # 24. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy and sell\n        # 25. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we do nothing\n        # 26. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 27. if prices[i] > prices[i+1] and prices[i+1] == prices[i+2], then we buy and sell\n        # 28. if prices[i] < prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 29. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy and sell\n        # 30. if prices[i] > prices[i+1"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 3. if prices[i] < prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 4. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 5. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i+1] and sell at prices[i+2]\n        # 6. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 7. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i+1] and sell at prices[i+2]\n        # 8. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2] and prices[i+2] > prices[i+3], then we buy at prices[i] and sell at prices[i+3]\n        # 9. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2] and prices[i+2] < prices[i+3], then we buy at prices[i+1] and sell at prices[i+3]\n        # 10. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2] and prices[i+2] < prices[i+3], then we buy at prices[i] and sell at prices[i+3]\n        # 11. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2] and prices[i+2] > prices[i+3], then we buy at prices[i+1] and sell at prices[i+3]\n        # 12. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2] and prices[i+2] > prices[i+3], then we buy at prices[i] and sell at prices[i+3]\n        # 13. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2] and prices[i+2] < prices[i+3], then we buy at prices[i+1] and sell at prices[i+3]\n        # 14. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2] and prices[i+2] < prices[i+3], then we buy at prices[i] and sell at prices[i+3]\n        # 15. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2] and prices[i+2] > prices[i+3], then we buy at prices[i+1] and sell at prices[i+3]\n        # 16. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2] and prices[i+2] > prices[i+3] and prices[i+3] > prices[i+4], then we buy at prices[i] and sell at prices[i+4]\n        # 17. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2] and prices[i+2] < prices[i+3] and prices[i+3] < prices[i+4], then we buy at prices[i+1] and sell at prices[i+4]\n        # 18. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2] and prices[i+2] < prices[i+3] and prices[i+3] > prices[i+4], then we buy at prices[i"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 3. if prices[i] < prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 4. if prices[i] == prices[i+1], then we do nothing\n        # 5. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+1]\n        # 6. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+1]\n        # 7. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 8. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 9. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 10. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 11. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 12. if prices[i] > prices[i+1] and prices[i+1] == prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 13. if prices[i] < prices[i+1] and prices[i+1] == prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 14. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 15. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 16. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 17. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 18. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 19. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 20. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 21. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 22. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 23. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 24. if prices[i] == prices[i"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i-1], add prices[i] - prices[i-1] to profit\n        # 3. return profit\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        #"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 3. if prices[i] < prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 4. if prices[i] == prices[i+1], then we do nothing\n        # 5. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+1]\n        # 6. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+1]\n        # 7. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 8. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 9. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 10. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 11. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 12. if prices[i] > prices[i+1] and prices[i+1] == prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 13. if prices[i] < prices[i+1] and prices[i+1] == prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 14. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 15. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 16. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 17. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 18. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 19. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 20. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 21. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 22. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 23. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 24. if prices[i] == prices[i"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for c in courses:\n            if time + c[0] <= c[1]:\n                time += c[0]\n                heapq.heappush(heap, -c[0])\n            elif heap and -heap[0] > c[0]:\n                time += c[0] + heap[0]\n                heapq.heappush(heap, -c[0])\n                time += heapq.heappop(heap)\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                time += course[0]\n                heapq.heappush(heap, -course[0])\n            elif heap and -heap[0] > course[0]:\n                time += course[0] + heap[0]\n                heapq.heappush(heap, -course[0])\n                time += heapq.heappop(heap)\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for c in courses:\n            if time + c[0] <= c[1]:\n                time += c[0]\n                heapq.heappush(heap, -c[0])\n            elif heap and -heap[0] > c[0]:\n                time += c[0] + heap[0]\n                heapq.heappush(heap, -c[0])\n                time += heapq.heappop(heap)\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for c in courses:\n            if time + c[0] <= c[1]:\n                time += c[0]\n                heapq.heappush(heap, -c[0])\n            elif heap and -heap[0] > c[0]:\n                time += c[0] + heapq.heappop(heap)\n                heapq.heappush(heap, -c[0])\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for c in courses:\n            if time + c[0] <= c[1]:\n                time += c[0]\n                heapq.heappush(heap, -c[0])\n            elif heap and -heap[0] > c[0]:\n                time += c[0] + heap[0]\n                heapq.heappush(heap, -c[0])\n                time += heapq.heappop(heap)\n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        count = 0\n        \n        while cur:\n            count += 1\n            if count % k == 0:\n                pre = self.reverse(pre, cur.next)\n                cur = pre.next\n            else:\n                cur = cur.next\n        \n        return dummy.next\n    \n    def reverse(self, pre, next):\n        last = pre.next\n        cur = last.next\n        \n        while cur != next:\n            last.next = cur.next\n            cur.next = pre.next\n            pre.next = cur\n            cur = last.next\n        \n        return last"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        count = 0\n        \n        while cur:\n            count += 1\n            if count % k == 0:\n                pre = self.reverse(pre, cur.next)\n                cur = pre.next\n            else:\n                cur = cur.next\n        \n        return dummy.next\n    \n    def reverse(self, pre, next):\n        last = pre.next\n        cur = last.next\n        \n        while cur != next:\n            last.next = cur.next\n            cur.next = pre.next\n            pre.next = cur\n            cur = last.next\n        \n        return last"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        count = 0\n        \n        while cur:\n            count += 1\n            if count % k == 0:\n                pre = self.reverse(pre, cur.next)\n                cur = pre.next\n            else:\n                cur = cur.next\n        \n        return dummy.next\n    \n    def reverse(self, pre, next):\n        last = pre.next\n        cur = last.next\n        \n        while cur != next:\n            last.next = cur.next\n            cur.next = pre.next\n            pre.next = cur\n            cur = last.next\n        \n        return last"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        prev = dummy\n        \n        # create a pointer to the head node\n        curr = head\n        \n        # create a counter\n        count = 0\n        \n        # traverse the linked list\n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr.next)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        # return the next node of the dummy node\n        return dummy.next\n    \n    def reverse(self, prev, next):\n        # create a pointer to the previous node\n        last = prev.next\n        \n        # create a pointer to the current node\n        curr = last.next\n        \n        # reverse the linked list\n        while curr != next:\n            last.next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = last.next\n        \n        # return the previous node\n        return last"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        prev = dummy\n        \n        # create a pointer to the head node\n        curr = head\n        \n        # create a counter\n        count = 0\n        \n        # traverse the linked list\n        while curr:\n            # increment the counter\n            count += 1\n            \n            # if the counter is equal to k\n            if count == k:\n                # reverse the linked list\n                prev = self.reverse(prev, curr.next)\n                \n                # reset the counter\n                count = 0\n                \n            # move to the next node\n            curr = curr.next\n            \n        # return the next node of the dummy node\n        return dummy.next\n    \n    def reverse(self, prev, next):\n        # create a pointer to the previous node\n        last = prev.next\n        \n        # create a pointer to the current node\n        curr = last.next\n        \n        # reverse the linked list\n        while curr != next:\n            last.next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = last.next\n            \n        # return the last node\n        return last"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # half = len(s) // 2\n        # return s[:half] * 2 == s\n        \n        # 2.\n        return s in (s + s)[1:-1]"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # return s in (s+s)[1:-1]\n        \n        # 2.\n        # return s in (s+s)[1:-1]\n        \n        # 3.\n        return s in (s+s)[1:-1]"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # half = len(s) // 2\n        # return s[:half] * 2 == s\n        \n        # 2.\n        return s in (s + s)[1:-1]"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # return s in (s+s)[1:-1]\n        \n        # 2.\n        # return s in (s+s)[1:-1]\n        \n        # 3.\n        return s in (s+s)[1:-1]"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # return s in (s+s)[1:-1]\n        \n        # 2.\n        # return s in (s+s)[1:-1]\n        \n        # 3.\n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        \n        return dp[n]\n    \n        # 2. Catalan Number\n        # Time: O(n)\n        # Space: O(1)\n        return math.factorial(2 * n) // math.factorial(n) // math(n + 1)"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        \n        return dp[n]\n        \n        \n        # 2. Catalan Number\n        # Time: O(n)\n        # Space: O(1)\n        return math.factorial(2 * n) // math.factorial(n) // math(n + 1)"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n                \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. return the number that has count 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # 1. use a hashmap to store the count of each number"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u52a8\u6001\u89c4\u5212\n        dp = [float('inf')] * (1 << len(target))\n        dp[0] = 0\n        \n        for code in range(1, len(dp)):\n            for sticker_count in sticker_counts:\n                # 4. \u8ba1\u7b97\u5f53\u524d\u72b6\u6001code\u9700\u8981\u7684sticker\u6570\u91cf\n                remaining = code\n                for char, count in sticker_count.items():\n                    if char in target_count and target_count[char] > 0:\n                        need = min(target_count[char], remaining // (1 << (ord(char) - ord('a'))))\n                        remaining -= need * (1 << (ord(char) - ord('a')))\n                if remaining < code:\n                    dp[code] = min(dp[code], dp[code - remaining] + 1)\n        \n        return dp[-1] if dp[-1] < float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u52a8\u6001\u89c4\u5212\n        dp = [float('inf')] * (1 << len(target))\n        dp[0] = 0\n        \n        for code in range(1, len(dp)):\n            for sticker_count in sticker_counts:\n                # 4. \u8ba1\u7b97\u5f53\u524dsticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u5728target\u4e2d\u7684\u4e2a\u6570\n                remaining = target_count.copy()\n                for char, count in sticker_count.items():\n                    if char in remaining and remaining[char] > 0:\n                        remaining[char] -= min(count, remaining[char])\n                \n                # 5. \u8ba1\u7b97\u5269\u4f59\u5b57\u7b26\u7684\u7f16\u7801\n                remaining_code = 0\n                for i, char in enumerate(target):\n                    if remaining[char] > 0 and code & (1 << i):\n                        remaining_code |= 1 << i\n                        remaining[char] -= 1\n                \n                # 6. \u66f4\u65b0dp\n                dp[code | remaining_code] = min(dp[code | remaining_code], dp[code] + 1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u52a8\u6001\u89c4\u5212\n        dp = [float('inf')] * (1 << len(target))\n        dp[0] = 0\n        \n        for code in range(1, len(dp)):\n            for sticker_count in sticker_counts:\n                # 4. \u8ba1\u7b97\u5f53\u524dsticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u5728target\u4e2d\u7684\u4e2a\u6570\n                remaining_count = target_count.copy()\n                for char, count in sticker_count.items():\n                    if char in remaining_count:\n                        remaining_count[char] -= min(count, remaining_count[char])\n                \n                # 5. \u8ba1\u7b97\u5269\u4f59\u5b57\u7b26\u7684\u72b6\u6001\u7801\n                remaining_code = 0\n                for i, char in enumerate(target):\n                    if remaining_count[char] > 0 and code & (1 << i):\n                        remaining_code |= 1 << i\n                        remaining_count[char] -= 1\n                \n                # 6. \u66f4\u65b0dp\n                dp[code | remaining_code] = min(dp[code | remaining_code], dp[code] + 1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u52a8\u6001\u89c4\u5212\n        dp = [float('inf')] * (1 << len(target))\n        dp[0] = 0\n        \n        for code in range(1, len(dp)):\n            for sticker_count in sticker_counts:\n                # 4. \u8ba1\u7b97\u5f53\u524dsticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u5728target\u4e2d\u7684\u4e2a\u6570\n                remaining_count = target_count.copy()\n                for char, count in sticker_count.items():\n                    if char in remaining_count:\n                        remaining_count[char] -= min(remaining_count[char], count)\n                \n                # 5. \u8ba1\u7b97\u5269\u4f59\u5b57\u7b26\u7684\u72b6\u6001\u7801\n                remaining_code = 0\n                for i, char in enumerate(target):\n                    if remaining_count[char] > 0 and code & (1 << i):\n                        remaining_code |= 1 << i\n                        remaining_count[char] -= 1\n                \n                # 6. \u66f4\u65b0dp\n                dp[code | remaining_code] = min(dp[code | remaining"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u5b9a\u4e49dp\u6570\u7ec4\uff0cdp[i]\u8868\u793atarget\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3ai\u65f6\u7684\u6700\u5c0f\u8d34\u7eb8\u6570\n        dp = [float('inf')] * (max(target_count.values()) + 1)\n        dp[0] = 0\n        \n        # 4. \u52a8\u6001\u89c4\u5212\n        for i in range(1, len(dp)):\n            for sticker_count in sticker_counts:\n                if i - sticker_count[target[i - 1]] >= 0:\n                    dp[i] = min(dp[i], dp[i - sticker_count[target[i - 1]]] + 1)\n        \n        # 5. \u5982\u679ctarget\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u90fd\u5927\u4e8e\u7b49\u4e8edp\u6570\u7ec4\u4e2d\u7684\u503c\uff0c\u5219\u8fd4\u56de-1\uff0c\u5426\u5219\u8fd4\u56dedp\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u503c\n        return -1 if dp[-1] == float('inf') else dp[-1]"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k-1] + dp[k+1][j]) + 1, where k is the last character of the substring s[i:j+1]\n        # dp[i][j] = dp[i][j-1] + 1, if s[j] == s[j-1]\n        # dp[i][j] = 1, if i == j\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                    for k in range(i, j):\n                        if s[k] == s[j]:\n                            dp[i][j] = min(dp[i][j], dp[i][k-1] + dp[k+1][j])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if s[i] == s[j]\n        # dp[i][j] = 2 if s[i] != s[j]\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            if i < n - 1:\n                dp[i][i + 1] = 2 if s[i] != s[i + 1] else 1\n        \n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                dp[i][j] = dp[i + 1][j] + 1\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n                    else:\n                        dp[i][j] = min(dp"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    for k in range(i, j):\n                        if s[k] == s[j]:\n                            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j - 1])\n        \n        return dp[0][n - 1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if s[i] == s[j]\n        # dp[i][j] = 2 if s[i] != s[j]\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            if i < n - 1:\n                dp[i][i + 1] = 2 if s[i] != s[i + 1] else 1\n        \n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                dp[i][j] = dp[i + 1][j] + 1\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n                    else:\n                        dp[i][j] = min(dp"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    for k in range(i, j):\n                        if s[k] == s[j]:\n                            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j - 1])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        i = 0\n        while i < len(s):\n            if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                total += roman_dict[s[i]]\n                i += 1\n        return total"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        prev = 0\n        \n        for i in s[::-1]:\n            if roman_dict[i] >= prev:\n                result += roman_dict[i]\n            else:\n                result -= roman_dict[i]\n            prev = roman"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman[s[i]] > roman[s[i-1]]:\n                result += roman[s[i]] - 2 * roman[s[i-1]]\n            else:\n                result += roman[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        prev_val = 0\n        \n        for i in range(len(s)-1, -1, -1):\n            curr_val = roman_dict[s[i]]\n            if curr_val < prev_val:\n                result -= curr_val\n            else:\n                result += curr_val\n            prev_val = curr"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 600 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 11.11% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 27.27% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 21.5 MB, less than 50.00% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 360 ms, faster than 33.33% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 21.5 MB, less than 50.00% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 360 ms, faster than 33.33% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 21.5 MB, less than 50.0"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 600 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 122.5% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 12.25% of Python online submissions for Contains Duplicate.\n        ##return len(nums) != len(set(nums))\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 400 ms, faster"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. use set\n        # return len(set(nums)) != len(nums)\n        \n        # 2. use hashmap\n        # hashmap = {}\n        # for num in nums:\n        #     if num in hashmap:\n        #         return True\n        #     hashmap[num] = 1\n        # return False\n        \n        # 3. use sort\n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 2:\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.99% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 9"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 600 ms, faster than 5.02% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 480 ms, faster than 10.18% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 3:\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9 of Python online submissions for Contains Duplicate.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains Duplicate.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 440 ms, faster than 13.17% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 25.9 MB, less than 9.22% of Python online submissions for Contains D"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the deque and output\n        dq, output = collections.deque(), []\n        \n        # Helper function to maintain the deque in the given constraints\n        def clean_deque(i):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[i] > nums[dq[-1]]:\n                dq.pop()\n        \n        # Build output\n        for i in range(k):\n            clean_deque(i)\n            dq.append(i)\n        output.append(nums[dq[0]])\n        \n        for i in range(k, len(nums)):\n            clean_deque(i)\n            dq.append(i)\n            output.append(nums[dq[0]])\n        \n        return output"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Initialize the deque and output\n        dq = collections.deque()\n        out = []\n        \n        # 2. Iterate through the first k elements in the array\n        for i in range(k):\n            while dq and nums[i] >= nums[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n        \n        # 3. Add the first max element to the output\n        out.append(nums[dq[0]])\n        \n        # 4. Iterate through the rest of the array\n        for i in range(k, len(nums)):\n            # 5. Remove the element at the front of the deque if it is outside the current window\n            if dq[0] <= i - k:\n                dq.popleft()\n            \n            # 6. Remove any elements from the back of the deque that are smaller than the current element\n            while dq and nums[i] >= nums[dq[-1]]:\n                dq.pop()\n            \n            # 7. Add the current element to the back of the deque\n            dq.append(i)\n            \n            # 8. Add the maximum element from this window to the output\n            out.append(nums[dq[0]])\n        \n        # 9. Return the output\n        return out"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Initialize the deque and output\n        dq = collections.deque()\n        out = []\n        \n        # 2. Iterate through the first k elements in the array\n        for i in range(k):\n            while dq and nums[i] >= nums[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n        \n        # 3. Add the first max element to the output\n        out.append(nums[dq[0]])\n        \n        # 4. Iterate through the rest of the array\n        for i in range(k, len(nums)):\n            # 5. Remove the element at the front of the deque if it is outside the current window\n            if dq[0] <= i - k:\n                dq.popleft()\n            \n            # 6. Remove any elements from the back of the deque that are smaller than the current element\n            while dq and nums[i] >= nums[dq[-1]]:\n                dq.pop()\n            \n            # 7. Add the current element to the back of the deque\n            dq.append(i)\n            \n            # 8. Add the maximum element from the deque to the output\n            out.append(nums[dq[0]])\n        \n        return out"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque and add the first k elements to the deque\n        # 2. for each element in the deque, if the element is greater than the current element, pop it\n        # 3. append the current element to the deque\n        # 4. if the index of the first element in the deque is less than the current index minus k, pop it\n        # 5. append the first element in the deque to the result\n        # 6. return the result\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        from collections import deque\n        q = deque()\n        res = []\n        \n        for i in range(k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n        \n        for i in range(k, len(nums)):\n            res.append(nums[q[0]])\n            while q and q[0] <= i - k:\n                q.popleft()\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n        \n        res.append(nums[q[0]])\n        \n        return res"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the deque and output\n        dq, output = collections.deque(), []\n        \n        # Helper function to maintain the deque in the given constraints\n        def clean_deque(i):\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            while dq and nums[i] > nums[dq[-1]]:\n                dq.pop()\n        \n        # Build output\n        for i in range(k):\n            clean_deque(i)\n            dq.append(i)\n        output.append(nums[dq[0]])\n        \n        for i in range(k, len(nums)):\n            clean_deque(i)\n            dq.append(i)\n            output.append(nums[dq[0]])\n        \n        return output"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 > \u53f3\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 < \u53f3\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 6. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 > \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 7. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 < \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 8. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 9. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 12. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 13. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 14. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 15. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 16. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 17. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 18. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 19. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 20. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 21. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 22. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 23. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 24. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 25. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 26. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 27. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 28. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 29. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 30. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 31. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 32. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 33. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 34. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 35. \u5982\u679c\u4e2d\u95f4\u5143\u7d20 == \u53f3\u8fb9\u754c\u5143\u7d20 == \u5de6\u8fb9\u754c\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u4e2d\u95f4\n        # 36. \u5982\u679c\u4e2d\u95f4"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u627e\u5230\u6700\u5c0f\u503c\n        # 3. \u5982\u679c\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5219\u5728\u5de6\u8fb9\u67e5\u627e\n        # 4. \u5982\u679c\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5219\u5728\u53f3\u8fb9\u67e5\u627e\n        # 5. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 6. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 7. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 8. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 9. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 10. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 11. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 12. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 13. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 14. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 15. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 16. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 17. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 18. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 19. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 20. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 21. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 22. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 23. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 24. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 25. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 26. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 27. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 28. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 29. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 30. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 31. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 32. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 33. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 34. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 35. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 36. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 37. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 38. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 39. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 40. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 41. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 42. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 43. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 44. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 45. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 46. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 47. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 48. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 49. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c\n        # 50. \u5982\u679c\u6700\u5c0f\u503c\u5728\u4e2d\u95f4\uff0c\u5219\u8fd4\u56de\u6700\u5c0f\u503c"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 3. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 4. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\n        # 5. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 6. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 7. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 8. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\n        # 9. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 10. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 11. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 12. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\n        # 13. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 14. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 15. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 16. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\n        # 17. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 18. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 19. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 20. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\n        # 21. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 22. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 23. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 24. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\n        # 25. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\u6216\u53f3\u534a\u90e8\u5206\n        # 26. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\n        # 2"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 6. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 7. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 8. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 9. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 12. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 13. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 14. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 15. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 18. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 19. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 20. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 21. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 24. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 25. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 26. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 27. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 30. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 31. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 32. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 33. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 36. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700\u5c0f\u503c\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 37. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u503c\uff0c\u5219\u6700"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f left == right\n        # 3. \u5faa\u73af\u6761\u4ef6\u662f left <= right\n        # 4. \u5faa\u73af\u4e2d\u9700\u8981\u505a\u7684\u4e8b\u60c5\u662f \u5224\u65ad mid \u548c right \u7684\u5173\u7cfb\uff0c\u5982\u679c mid \u5927\u4e8e right\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u8fb9\uff0c\u5426\u5219\u5728 mid \u7684\u5de6\u8fb9\n        # 5. \u5faa\u73af\u7ed3\u675f\u540e\uff0c\u8fd4\u56de left \u6216\u8005 right \u90fd\u53ef\u4ee5\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 2. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 3. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 4. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 5. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 6. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 7. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 8. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 9. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 10. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res.append(1)\n        #     for j in range(i, 0, -1):\n        #         res[j] += res[j-1]\n        # return res\n        \n        # 11. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        prev = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            curr = [1]\n            for j in range(1, i):\n                curr.append(prev[j-1] + prev[j])\n            curr.append(1)\n            prev = curr\n        \n        return curr"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        prev = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            curr = [1]\n            for j in range(1, i):\n                curr.append(prev[j-1] + prev[j])\n            curr.append(1)\n            prev = curr\n        \n        return curr"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        prev = [1,1]\n        for i in range(2, rowIndex+1):\n            curr = [1]\n            for j in range(1, i):\n                curr.append(prev[j-1] + prev[j])\n            curr.append(1)\n            prev = curr\n        return curr"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 2. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 3. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 4. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 5. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 6. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 7. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 8. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 9. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 10. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 11. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 12. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res ="}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and target == node.val:\n                res.append(path[:])\n            dfs(node.left, target - node.val, path)\n            dfs(node.right, target - node.val, path)\n            path.pop()\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and node.val == target:\n                res.append(path[:])\n            dfs(node.left, target - node.val, path)\n            dfs(node.right, target - node.val, path)\n            path.pop()\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and target == node.val:\n                res.append(path[:])\n            dfs(node.left, target - node.val, path)\n            dfs(node.right, target - node.val, path)\n            path.pop()\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and target == node.val:\n                res.append(path[:])\n            dfs(node.left, target - node.val, path)\n            dfs(node.right, target - node.val, path)\n            path.pop()\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right and target == node.val:\n                res.append(path[:])\n            dfs(node.left, target - node.val, path)\n            dfs(node.right, target - node.val, path)\n            path.pop()\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.add(beginWord)\n        wordSet.add(endWord)\n        \n        # BFS\n        queue = collections.deque([(beginWord, [beginWord])])\n        res = []\n        visited = set()\n        found = False\n        while queue:\n            if found:\n                break\n            size = len(queue)\n            visited.update(queue)\n            for _ in range(size):\n                curr, path = queue.popleft()\n                if curr == endWord:\n                    res.append(path)\n                    found = True\n                else:\n                    for i in range(len(curr)):\n                        for c in string.ascii_lowercase:\n                            nextWord = curr[:i] + c + curr[i+1:]\n                            if nextWord in wordSet and nextWord not in visited:\n                                queue.append((nextWord, path + [nextWord]))\n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        wordList.add(beginWord)\n        wordList.add(endWord)\n        \n        # BFS\n        queue = [(beginWord, [beginWord])]\n        res = []\n        visited = set()\n        found = False\n        while queue:\n            if found:\n                break\n            for _ in range(len(queue)):\n                word, path = queue.pop(0)\n                if word == endWord:\n                    res.append(path)\n                    found = True\n                else:\n                    for i in range(len(word)):\n                        for c in string.ascii_lowercase:\n                            new_word = word[:i] + c + word[i+1:]\n                            if new_word in wordList and new_word not in visited:\n                                queue.append((new_word, path + [new"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        wordList.add(beginWord)\n        wordList.add(endWord)\n        \n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        queue = collections.deque([(beginWord, [beginWord])])\n        visited = set([beginWord])\n        res = []\n        found = False\n        while queue:\n            if found:\n                break\n            for _ in range(len(queue)):\n                word, path = queue.popleft()\n                if word == endWord:\n                    res.append(path)\n                    found = True\n                else:\n                    for i in range(len(word)):\n                        for next_word in graph[word[:i] + '*' + word[i+1:]]:\n                            if next_word not in visited:\n                                visited.add(next_word)\n                                queue.append((next, path + [next_word]))\n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        wordList.add(beginWord)\n        wordList.add(endWord)\n        \n        # BFS\n        queue = collections.deque([(beginWord, [beginWord])])\n        res = []\n        visited = set()\n        found = False\n        while queue:\n            if found:\n                break\n            size = len(queue)\n            visited.update(queue)\n            for _ in range(size):\n                curr, path = queue.popleft()\n                if curr == endWord:\n                    res.append(path)\n                    found = True\n                else:\n                    for i in range(len(curr)):\n                        for c in string.ascii_lowercase:\n                            nextWord = curr[:i] + c + curr[i+1:]\n                            if nextWord in wordList and nextWord not in visited:\n                                queue.append((nextWord, path + [nextWord]))\n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        wordList.add(beginWord)\n        wordList.add(endWord)\n        \n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        queue = collections.deque([(beginWord, [beginWord])])\n        visited = set([beginWord])\n        res = []\n        found = False\n        while queue:\n            if found:\n                break\n            for _ in range(len(queue)):\n                word, path = queue.popleft()\n                if word == endWord:\n                    res.append(path)\n                    found = True\n                else:\n                    for i in range(len(word)):\n                        for next_word in graph[word[:i] + '*' + word[i+1:]]:\n                            if next_word not in visited:\n                                visited.add(next_word)\n                                queue.append((next, path + [next_word]))\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return 1 + max(left, right)\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            \n            left = dfs(root.left)\n            right = dfs(root.right)\n            \n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            \n            return 1 + max(left, right)\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return 1 + max(left, right)\n        \n        return dfs(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        if n == 1:\n            return True\n        else:\n            return False"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n/2)"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n/2)"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n/2)"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n/2)"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5355\u8c03\u6808\n        # 2. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 3. \u6808\u5e95\u5230\u6808\u9876\u5355\u8c03\u9012\u589e\n        # 4. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 5. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 6. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 7. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 8. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 9. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 10. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 11. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 12. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 13. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 14. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 15. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 16. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 17. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 18. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 19. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 20. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 21. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 22. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 23. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 24. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 25. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 26. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 27. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 28. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 29. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 30. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 31. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 32. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 33. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 34. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 35. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 36. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 37. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 38. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 39. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 40. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 41. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 42. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 43. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 44. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 45. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 46. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 47. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 48. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 49. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 50. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 51. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 52. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 53. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 54. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 55. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5355\u8c03\u6808\n        # 2. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 3. \u6808\u5e95\u5230\u6808\u9876\u5355\u8c03\u9012\u589e\n        # 4. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 5. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 6. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 7. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 8. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 9. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 10. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 11. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 12. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 13. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 14. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 15. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 16. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 17. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 18. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 19. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 20. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 21. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 22. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 23. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 24. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 25. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 26. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 27. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 28. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 29. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 30. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 31. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 32. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 33. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 34. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 35. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 36. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 37. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 38. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 39. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 40. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 41. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 42. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 43. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 44. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 45. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 46. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 47. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 48. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 49. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 50. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 51. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 52. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 53. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 54. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 55. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5355\u8c03\u6808\n        # 2. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 3. \u6808\u5e95\u5230\u6808\u9876\u5355\u8c03\u9012\u589e\n        # 4. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 5. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 6. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 7. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 8. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 9. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 10. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 11. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 12. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 13. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 14. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 15. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 16. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 17. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 18. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 19. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 20. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 21. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 22. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 23. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 24. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 25. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 26. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 27. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 28. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 29. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 30. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 31. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 32. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 33. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 34. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 35. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 36. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 37. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 38. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 39. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 40. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 41. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 42. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 43. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 44. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 45. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 46. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 47. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 48. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 49. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 50. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 51. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 52. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 53. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 54. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9ad8\u5ea6\n        # 55. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5355\u8c03\u6808\n        # 2. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 3. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 4. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 5. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 6. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 7. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 8. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 9. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 10. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 11. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 12. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 13. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 14. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 15. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 16. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 17. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 18. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 19. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 20. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 21. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 22. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 23. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 24. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 25. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 26. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 27. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 28. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 29. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 30. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 31. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 32. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 33. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 34. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 35. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 36. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 37. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 38. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 39. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 40. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 41. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 42. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 43. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 44. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 45. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 46. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 47. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 48. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 49. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u503c\n        # 50. \u5355\u8c03\u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5355\u8c03\u6808\n        # 2. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 3. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 4. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 5. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 6. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 7. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 8. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 9. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 10. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 11. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 12. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 13. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 14. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 15. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 16. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 17. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 18. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 19. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 20. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 21. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 22. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 23. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 24. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 25. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 26. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 27. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 28. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 29. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 30. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 31. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 32. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 33. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 34. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 35. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 36. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 37. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 38. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 39. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 40. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 41. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 42. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 43. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 44. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 45. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 46. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 47. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 48. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 49. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 50. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 51. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 52. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 53. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 54. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 55. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 56. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 57. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012\u589e\u7684\n        # 58. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # 59. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9ad8\u5ea6\uff0c\u800c\u4e0d\u662f\u4e0b\u6807\n        # 60. \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u9012"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        \n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == \"+\":\n                    stack.append(num1 + num2)\n                elif token == \"-\":\n                    stack.append(num1 - num2)\n                elif token == \"*\":\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(float(num1) / num2))\n        \n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        \n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == \"+\":\n                    stack.append(num1 + num2)\n                elif token == \"-\":\n                    stack.append(num1 - num2)\n                elif token == \"*\":\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(float(num1) / num2))\n        \n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a+b)\n                elif token == \"-\":\n                    stack.append(a-b)\n                elif token == \"*\":\n                    stack.append(a*b)\n                else:\n                    stack.append(int(float(a)/b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle\n        # 4. if the area of the whole rectangle is not equal to the area of the rectangle, return False\n        # 5. if the area of the whole rectangle is equal to the area of the rectangle, return True\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the rectangle\n        rectangle_area = 0\n        for x, y, a, b in rectangles:\n            rectangle_area += (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle is not equal to the area of the rectangle, return False\n        if area != rectangle_area:\n            return False\n        \n        # 5. if the area of the whole rectangle is equal to the area of the rectangle, return True\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle covered by the rectangles\n        # 4. if the area of the whole rectangle covered by the rectangles is equal to the area of the whole rectangle, then return True\n        # 5. else return False\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle covered by the rectangles\n        area_covered = 0\n        for x, y, a, b in rectangles:\n            area_covered += (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle covered by the rectangles is equal to the area of the whole rectangle, then return True\n        # 5. else return False\n        return area_covered == area"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the area of the union of all rectangles\n        # 2. Find the area of the union of all rectangles\n        # 3. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 4. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 5. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 6. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 7. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 8. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 9. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 10. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 11. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 12. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 13. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 14. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 15. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 16. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 17. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 18. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 19. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 20. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 21. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 22. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 23. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 24. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 25. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 26. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 27. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 28. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 29. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 30. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 31. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 32. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 33. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 34. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 35. Check if the area of the union of all rectangles is equal to the area of the union of all rectangles\n        # 36. Check if the"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle covered by the rectangles\n        # 4. if the area of the whole rectangle covered by the rectangles is equal to the area of the whole rectangle, return True\n        # 5. else, return False\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle covered by the rectangles\n        area_covered = 0\n        for x, y, a, b in rectangles:\n            area_covered += (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle covered by the rectangles is equal to the area of the whole rectangle, return True\n        # 5. else, return False\n        return area_covered == area"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle\n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle\n        for x, y, a, b in rectangles:\n            area -= (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        if area != 0:\n            return False\n        \n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1.\n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1."}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1."}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u7684\u9006\u8fc7\u7a0b\n        # 1."}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for num in nums[1:]:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for num in nums[1:]:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(s, i, j):\n            s = list(s)\n            s[i], s[j] = s[j], s[i]\n            return ''.join(s)\n        \n        def bfs(board):\n            start = ''.join(str(c) for row in board for c in row)\n            queue = collections.deque([(start, start.index('0'))])\n            visited = set([start])\n            step = 0\n            while queue:\n                for _ in range(len(queue)):\n                    cur, idx = queue.popleft()\n                    if cur == '123450': return step\n                    for i in [1, 0, -1]:\n                        if idx % 3 == 0 and i == -1 or idx % 3 == 2 and i == 1: continue\n                        new_idx = idx + i\n                        new_cur = swap(cur, idx, new_idx)\n                        if new_cur not in visited:\n                            visited.add(new_cur)\n                            queue.append((new_cur, new_idx))\n                step += 1\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(s, i, j):\n            s = list(s)\n            s[i], s[j] = s[j], s[i]\n            return ''.join(s)\n        \n        def bfs(board):\n            start = ''.join(str(c) for row in board for c in row)\n            queue = collections.deque([(start, start.index('0'))])\n            visited = set([start])\n            step = 0\n            while queue:\n                for _ in range(len(queue)):\n                    cur, idx = queue.popleft()\n                    if cur == '123450': return step\n                    for i in [1, 0, -1]:\n                        if idx % 3 == 0 and i == -1 or idx % 3 == 2 and i == 1: continue\n                        new_idx = idx + i\n                        new_cur = swap(cur, idx, new_idx)\n                        if new_cur not in visited:\n                            visited.add(new_cur)\n                            queue.append((new_cur, new_idx))\n                step += 1\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(s, i, j):\n            s = list(s)\n            s[i], s[j] = s[j], s[i]\n            return ''.join(s)\n        \n        def bfs(s):\n            q = collections.deque([(s, 0)])\n            seen = set([s])\n            while q:\n                s, step = q.popleft()\n                if s == '123450':\n                    return step\n                i = s.index('0')\n                for j in [i-1, i+1, i-3, i+3]:\n                    if 0 <= j < 6 and (j == 3 or i%3 != j%3):\n                        t = swap(s, i, j)\n                        if t not in seen:\n                            q.append((t, step+1))\n                            seen.add(t)\n            return -1\n        \n        s = ''.join(str(i) for row in board for i in row)\n        return bfs(s)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(s, i, j):\n            s = list(s)\n            s[i], s[j] = s[j], s[i]\n            return ''.join(s)\n        \n        def bfs(board):\n            start = ''.join(str(c) for row in board for c in row)\n            queue = collections.deque([(start, start.index('0'))])\n            visited = set([start])\n            step = 0\n            while queue:\n                for _ in range(len(queue)):\n                    cur, idx = queue.popleft()\n                    if cur == '123450': return step\n                    for i in [1, 0, -1]:\n                        if idx % 3 == 0 and i == -1 or idx % 3 == 2 and i == 1: continue\n                        new_idx = idx + i\n                        new_cur = swap(cur, idx, new_idx)\n                        if new_cur not in visited:\n                            visited.add(new_cur)\n                            queue.append((new_cur, new_idx))\n                step += 1\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(s, i, j):\n            s = list(s)\n            s[i], s[j] = s[j], s[i]\n            return ''.join(s)\n        \n        def bfs(board):\n            start = ''.join(str(c) for row in board for c in row)\n            queue = collections.deque([(start, start.index('0'))])\n            visited = set([start])\n            step = 0\n            while queue:\n                for _ in range(len(queue)):\n                    cur, idx = queue.popleft()\n                    if cur == '123450': return step\n                    for i in [1, 0, -1]:\n                        if idx % 3 == 0 and i == -1 or idx % 3 == 2 and i == 1: continue\n                        new_idx = idx + i\n                        new_cur = swap(cur, idx, new_idx)\n                        if new_cur not in visited:\n                            visited.add(new_cur)\n                            queue.append((new_cur, new_idx))\n                step += 1\n            return -1\n        \n        return bfs(board)"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of s and t are not equal, return False\n        if len(s) != len(t):\n            return False\n        \n        # create a dictionary to store the mapping of characters in s to characters in t\n        s_to_t = {}\n        t_to_s = {}\n        \n        # iterate through the characters in s and t\n        for i in range(len(s)):\n            # if the character in s is not in the dictionary, add it to the dictionary with the corresponding character in t\n            if s[i] not in s_to_t:\n                s_to_t[s[i]] = t[i]\n            # if the character in t is not in the dictionary, add it to the dictionary with the corresponding character in s\n            if t[i] not in t_to_s:\n                t_to_s[t[i]] = s[i]\n            # if the character in s is in the dictionary and the corresponding character in t is not the same, return False\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            # if the character in t is in the dictionary and the corresponding character in s is not the same, return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n        \n        # if all characters in s and t are mapped correctly, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of s and t are not equal, return False\n        if len(s) != len(t):\n            return False\n        \n        # create a dictionary to store the mapping of characters in s to t\n        s_to_t = {}\n        # create a set to store the characters in t that have already been mapped\n        t_set = set()\n        \n        # iterate through the characters in s and t\n        for i in range(len(s)):\n            # if the character in s is not in the dictionary, add it to the dictionary with the corresponding character in t\n            if s[i] not in s_to_t:\n                # if the character in t has already been mapped, return False\n                if t[i] in t_set:\n                    return False\n                # add the mapping to the dictionary and add the character in t to the set\n                s_to_t[s[i]] = t[i]\n                t_set.add(t[i])\n            # if the character in s is in the dictionary, check if the corresponding character in t is the same\n            else:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n        \n        # if all characters in s have been mapped to unique characters in t, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the mapping of characters in s to t\n        s_to_t = {}\n        # create a set to store the characters in t that have already been mapped\n        t_set = set()\n        \n        # iterate through the characters in s and t\n        for i in range(len(s)):\n            # if the character in s is not in the dictionary, add it to the dictionary with the corresponding character in t\n            if s[i] not in s_to_t:\n                # if the character in t has already been mapped, return False\n                if t[i] in t_set:\n                    return False\n                # add the mapping to the dictionary and add the character in t to the set\n                s_to_t[s[i]] = t[i]\n                t_set.add(t[i])\n            # if the character in s is in the dictionary, check if the corresponding character in t is the same\n            else:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n        \n        # if all characters in s have been mapped to unique characters in t, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = t[i]\n            if t[i] not in t_dict:\n                t_dict[t[i]] = s[i]\n            if s_dict[s[i]] != t[i] or t_dict[t[i]] != s[i]:\n                return False\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_map:\n                s_map[s[i]] = t[i]\n            if t[i] not in t_map:\n                t_map[t[i]] = s[i]\n            if s_map[s[i]] != t[i] or t_map[t[i]] != s[i]:\n                return False\n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        if nums[0] < nums[-1]:\n            return target in nums\n        \n        l, r = 0, len(nums) - 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid\n        \n        pivot = l\n        \n        if target >= nums[0]:\n            l, r = 0, pivot - 1\n        else:\n            l, r = pivot, len(nums) - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if not nums:\n            return False\n        \n        l, r = 0, len(nums) - 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        \n        pivot = l\n        \n        l, r = 0, len(nums) - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            real_mid = (mid + pivot) % len(nums)\n            if nums[real_mid] == target:\n                return True\n            elif nums[real_mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if not nums:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < numsright"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        if not nums:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        l, r = 0, len(nums) - 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid\n        \n        pivot = l\n        \n        if target >= nums[0]:\n            l, r = 0, pivot - 1\n        else:\n            l, r = pivot, len(nums) - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # find the pivot\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid\n        \n        pivot = l\n        \n        # binary search\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[(mid + pivot) % len(nums)] == target:\n                return True\n            elif nums[(mid + pivot) % len(nums)] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[1] = 1 if s[0] != '0' else 0\n        # dp[i] = dp[i-1] if s[i-1] != '0' else 0\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26 else 0\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[1] = 1 if s[0] != '0' else 0\n        # dp[i] = dp[i-1] if s[i-1] != '0' else 0\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26 else 0\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            j = i + 1\n            k = n - 1\n            while j < k:\n                curr_sum = nums[i] + nums[j] + nums[k]\n                if curr_sum == target:\n                    return target\n                if abs(curr_sum - target) < abs(closest - target):\n                    closest = currum\n                if curr_sum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            l, r = i+1, n-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s-target) < abs(res-target):\n                    res = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return target\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            l, r = i+1, n-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return target\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            l, r = i+1, n-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return target\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            l, r = i+1, n-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s-target) < abs(res-target):\n                    res = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return target\n        return res"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are equal, add to the result and increment both pointers\n        # 4. if the values are not equal, increment the pointer of the array with the smaller value\n        # 5. return the result\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are the same, add to the result and increment both pointers\n        # 4. if the values are not the same, increment the pointer of the array with the smaller value\n        # 5. return the result\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. sort both arrays\n        nums1.sort()\n        nums2.sort()\n        \n        ## 2. use two pointers to iterate through both arrays\n        p1, p2 = 0, 0\n        res = []\n        \n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] == nums2[p2]:\n                res.append(nums1[p1])\n                p1 += 1\n                p2 += 1\n            elif nums1[p1] < nums2[p2]:\n                p1 += 1\n            else:\n                p2 += 1\n                \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are equal, add to result and increment both pointers\n        # 4. if the values are not equal, increment the pointer of the array with the smaller value\n        # 5. return result\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are equal, add to the result and increment both pointers\n        # 4. if the values are not equal, increment the pointer of the array with the smaller value\n        # 5. return the result\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.res.append(root.val)\n                inorder(root.right)\n        \n        self.res = []\n        inorder(root)\n        return min(self.res[i+1] - self.res[i] for i in range(len(self.res)-1))"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.res.append(root.val)\n                inorder(root.right)\n        \n        self.res = []\n        inorder(root)\n        return min(self.res[i+1] - self.res[i] for i in range(len(self.res)-1))"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # Inorder traversal of BST gives sorted array\n        # Find the min difference between adjacent elements\n        \n        # Inorder traversal\n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.res.append(root.val)\n                inorder(root.right)\n        \n        self.res = []\n        inorder(root)\n        \n        min_diff = float('inf')\n        for i in range(1, len(self.res)):\n            min_diff = min(min_diff, self.res[i] - self.res[i-1])\n        \n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            return inorder(root.left) + [root.val] + inorder(root.right) if root else []\n        \n        l = inorder(root)\n        return min(l[i+1] - l[i] for i in range(len(l)-1))"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # Inorder traversal of BST gives sorted array\n        # Find the min difference between adjacent elements in the sorted array\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.res.append(root.val)\n                inorder(root.right)\n        \n        self.res = []\n        inorder(root)\n        \n        min_diff = float('inf')\n        for i in range(1, len(self.res)):\n            min_diff = min(min_diff, self.res[i] - self.res[i-1])\n        \n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                if root.val == prev:\n                    count += 1\n                else:\n                    count = 1\n                prev = root.val\n                if count == max_count:\n                    modes.append(root.val)\n                elif count > max_count:\n                    max_count = count\n                    modes = [root.val]\n                inorder(root.right)\n        \n        prev = float('-inf')\n        max_count = 0\n        modes = []\n        inorder(root)\n        return modes"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. inorder traversal\n        # 2. count the frequency of each node\n        # 3. find the max frequency\n        # 4. return all nodes with max frequency\n        \n        # 1. inorder traversal\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            inorder_list.append(root.val)\n            inorder(root.right)\n        \n        inorder_list = []\n        inorder(root)\n        \n        # 2. count the frequency of each node\n        freq = {}\n        for node in inorder_list:\n            if node in freq:\n                freq[node] += 1\n            else:\n                freq[node] = 1\n        \n        # 3. find the max frequency\n        max_freq = max(freq.values())\n        \n        # 4. return all nodes with max frequency\n        return [node for node in freq if freq[node] == max_freq]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. inorder traversal\n        # 2. count the frequency of each node\n        # 3. find the max frequency\n        # 4. return all nodes with max frequency\n        \n        # inorder traversal\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.inorder.append(root.val)\n            inorder(root.right)\n        \n        # count the frequency of each node\n        def count(root):\n            if root is None:\n                return\n            count(root.left)\n            self.count[root.val] += 1\n            count(root.right)\n        \n        # find the max frequency\n        def find_max():\n            max_count = max(self.count.values())\n            return [k for k, v in self.count.items() if v == max_count]\n        \n        self.inorder = []\n        self.count = collections.defaultdict(int)\n        inorder(root)\n        count(root)\n        return find_max()"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. inorder traversal\n        # 2. count the frequency of each node\n        # 3. find the max frequency\n        # 4. return all nodes with max frequency\n        \n        # 1. inorder traversal\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            inorder_list.append(root.val)\n            inorder(root.right)\n        \n        inorder_list = []\n        inorder(root)\n        \n        # 2. count the frequency of each node\n        freq = {}\n        for node in inorder_list:\n            if node in freq:\n                freq[node] += 1\n            else:\n                freq[node] = 1\n        \n        # 3. find the max frequency\n        max_freq = max(freq.values())\n        \n        # 4. return all nodes with max frequency\n        return [node for node in freq if freq[node] == max_freq]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. inorder traversal\n        # 2. count the frequency of each node\n        # 3. find the max frequency\n        # 4. return all nodes with max frequency\n        \n        # 1. inorder traversal\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            inorder_list.append(root.val)\n            inorder(root.right)\n        \n        inorder_list = []\n        inorder(root)\n        \n        # 2. count the frequency of each node\n        freq = {}\n        for node in inorder_list:\n            if node in freq:\n                freq[node] += 1\n            else:\n                freq[node] = 1\n        \n        # 3. find the max frequency\n        max_freq = max(freq.values())\n        \n        # 4. return all nodes with max frequency\n        return [node for node in freq if freq[node] == max_freq]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle:\n            return 0\n        \n        if not haystack:\n            return -1\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle:\n            return 0\n        \n        if not haystack:\n            return -1\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle:\n            return 0\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle:\n            return 0\n        \n        if not haystack:\n            return -1\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle:\n            return 0\n        \n        if not haystack:\n            return -1\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        missing_type = 3\n        if any('a'<=c<='z' for c in password): missing_type -= 1\n        if any('A'<=c<='Z' for c in password): missing_type -= 1\n        if any(c.isdigit() for c in password): missing_type -= 1\n        \n        change = 0\n        one, two = 0, 0\n        pw_len = len(password)\n        i = 2\n        while i < pw_len:\n            if password[i] == password[i-1] == password[i-2]:\n                length = 2\n                while i < pw_len and password[i] == password[i-1]:\n                    length += 1\n                    i += 1\n                change += length / 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                i += 1\n        \n        if pw_len < 6:\n            return max(missing_type, 6 - pw_len)\n        elif pw_len <= 20:\n            return max(missing_type, change)\n        else:\n            delete = pw_len - 20\n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n            return delete + max(missing_type, change)"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        missing_type = 3\n        if any('a'<=c<='z' for c in password): missing_type -= 1\n        if any('A'<=c<='Z' for c in password): missing_type -= 1\n        if any(c.isdigit() for c in password): missing_type -= 1\n        \n        change = 0\n        one, two = 0, 0\n        pw_len = len(password)\n        i = 2\n        while i < pw_len:\n            if password[i] == password[i-1] == password[i-2]:\n                length = 2\n                while i < pw_len and password[i] == password[i-1]:\n                    length += 1\n                    i += 1\n                change += length / 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                i += 1\n        \n        if pw_len < 6:\n            return max(missing_type, 6 - pw_len)\n        elif pw_len <= 20:\n            return max(missing_type, change)\n        else:\n            delete = pw_len - 20\n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n            return delete + max(missing_type, change)"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        missing_type = 3\n        if any('a'<=c<='z' for c in password): missing_type -= 1\n        if any('A'<=c<='Z' for c in password): missing_type -= 1\n        if any(c.isdigit() for c in password): missing_type -= 1\n        \n        change = 0\n        one, two = 0, 0\n        pw_len = len(password)\n        i = 2\n        while i < pw_len:\n            if password[i] == password[i-1] == password[i-2]:\n                length = 2\n                while i < pw_len and password[i] == password[i-1]:\n                    length += 1\n                    i += 1\n                change += length // 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                i += 1\n        \n        if pw_len < 6:\n            return max(missing_type, 6 - pw_len)\n        elif pw_len <= 20:\n            return max(missing_type, change)\n        else:\n            delete = pw_len - 20\n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) // 2\n            change -= max(delete - one - 2 * two, 0) // 3\n            return delete + max(missing_type, change)"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        missing_type = 3\n        if any('a'<=c<='z' for c in password): missing_type -= 1\n        if any('A'<=c<='Z' for c in password): missing_type -= 1\n        if any(c.isdigit() for c in password): missing_type -= 1\n        \n        change = 0\n        one, two = 0, 0\n        pw_len = len(password)\n        i = 2\n        while i < pw_len:\n            if password[i] == password[i-1] == password[i-2]:\n                length = 2\n                while i < pw_len and password[i] == password[i-1]:\n                    length += 1\n                    i += 1\n                change += length / 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                i += 1\n        \n        if pw_len < 6:\n            return max(missing_type, 6 - pw_len)\n        elif pw_len <= 20:\n            return max(missing_type, change)\n        else:\n            delete = pw_len - 20\n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n            return delete + max(missing_type, change)"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        missing_type = 3\n        if any('a'<=c<='z' for c in password): missing_type -= 1\n        if any('A'<=c<='Z' for c in password): missing_type -= 1\n        if any(c.isdigit() for c in password): missing_type -= 1\n        \n        change = 0\n        one, two = 0, 0\n        pw_len = len(password)\n        i = 2\n        while i < pw_len:\n            if password[i] == password[i-1] == password[i-2]:\n                length = 2\n                while i < pw_len and password[i] == password[i-1]:\n                    length += 1\n                    i += 1\n                change += length / 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                i += 1\n        \n        if pw_len < 6:\n            return max(missing_type, 6 - pw_len)\n        elif pw_len <= 20:\n            return max(missing_type, change)\n        else:\n            delete = pw_len - 20\n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) / 2\n            change -= max(delete - one - 2 * two, 0) / 3\n            return delete + max(missing_type, change)"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315 320 325 330 335 340 345 350 355 360 365 370 375 380 385 390 395 400 405 410 415 420 425 430 435 440 445 450 455 460 465 470 475 480 485 490 495 500 505 510 515 520 525 530 535 540 545 550 555 560 565 570 575 580 585 590 595 600 605 610 615 620 625 630 635 640 645 650 655 660 665 670 675 680 685 690 695 700 705 710 715 720 725 730 735 740 745 750 755 760 765 770 775 780 785 790 795 800 805 810 815 820 825 830 835 840 845 850 855 860 865 870 875 880 885 890 895 900 905 910 915 920 925 930 935 940 945 950 955 960 965 970 975 980 985 990 995 1000\n        \n        # 2. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 3"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315 320 325 330 335 340 345 350 355 360 365 370 375 380 385 390 395 400 405 410 415 420 425 430 435 440 445 450 455 460 465 470 475 480 485 490 495 500 505 510 515 520 525 530 535 540 545 550 555 560 565 570 575 580 585 590 595 600 605 610 615 620 625 630 635 640 645 650 655 660 665 670 675 680 685 690 695 700 705 710 715 720 725 730 735 740 745 750 755 760 765 770 775 780 785 790 795 800 805 810 815 820 825 830 835 840 845 850 855 860 865 870 875 880 885 890 895 900 905 910 915 920 925 930 935 940 945 950 955 960 965 970 975 980 985 990 995 1000\n        \n        # 2. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 3"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315 320 325 330 335 340 345 350 355 360 365 370 375 380 385 390 395 400 405 410 415 420 425 430 435 440 445 450 455 460 465 470 475 480 485 490 495 500 505 510 515 520 525 530 535 540 545 550 555 560 565 570 575 580 585 590 595 600 605 610 615 620 625 630 635 640 645 650 655 660 665 670 675 680 685 690 695 700 705 710 715 720 725 730 735 740 745 750 755 760 765 770 775 780 785 790 795 800 805 810 815 820 825 830 835 840 845 850 855 860 865 870 875 880 885 890 895 900 905 910 915 920 925 930 935 940 945 950 955 960 965 970 975 980 985 990 995 1000\n        # 2. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315 320 325 330 335 340 345 350 355 360 365 370 375 380 385 390 395 400 405 410 415 420 425 430 435 440 445 450 455 460 465 470 475 480 485 490 495 500 505 510 515 520 525 530 535 540 545 550 555 560 565 570 575 580 585 590 595 600 605 610 615 620 625 630 635 640 645 650 655 660 665 670 675 680 685 690 695 700 705 710 715 720 725 730 735 740 745 750 755 760 765 770 775 780 785 790 795 800 805 810 815 820 825 830 835 840 845 850 855 860 865 870 875 880 885 890 895 900 905 910 915 920 925 930 935 940 945 950 955 960 965 970 975 980 985 990 995 1000\n        \n        # 2. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 3"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 3. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 5. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 6. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 7. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 8. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 9. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 10. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 11. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 12. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 13. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 14. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 15. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 16. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        # 17. 5 10 15 20 25 30 35 40 45"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row, step = 0, 1\n        \n        for c in s:\n            res[row] += c\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\"] * numRows\n        currRow = 0\n        goingDown = False\n        \n        for c in s:\n            rows[currRow] += c\n            if currRow == 0 or currRow == numRows - 1:\n                goingDown = not goingDown\n            currRow += 1 if goingDown else -1\n        \n        return \"\".join(rows)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row, step = 0, 1\n        \n        for c in s:\n            res[row] += c\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row, step = 0, 1\n        \n        for c in s:\n            res[row] += c\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row, step = 0, 1\n        \n        for c in s:\n            res[row] += c\n            if row == 0:\n                step = 1\n            elif row == numRows - 1:\n                step = -1\n            row += step\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n        \n        return res"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 2 variables\n        # 3. stack\n        # 4. 2 pointers, 2 variables, 1 variable\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # left, right = 0, len(height) - 1\n        # left_max, right_max = 0, 0\n        # res = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] >= left_max:\n        #             left_max = height[left]\n        #         else:\n        #             res += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         if height[right] >= right_max:\n        #             right_max = height[right]\n        #         else:\n        #             res += right_max - height[right]\n        #         right -= 1\n        # return res\n        \n        # 2. 2 pointers, 2 variables\n        # Time: O(n)\n        # Space: O(1)\n        # left, right = 0, len(height) - 1\n        # left_max, right_max = 0, 0\n        # res = 0\n        # while left <= right:\n        #     left_max = max(left_max, height[left])\n        #     right_max = max(right_max, height[right])\n        #     if left_max < right_max:\n        #         res += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         res += right_max - height[right]\n        #         right -= 1\n        # return res\n        \n        # 3. stack\n        # Time: O(n)\n        # Space: O(n)\n        # stack = []\n        # res = 0\n        # for i in range(len(height)):\n        #     while stack and height[i] > height[stack[-1]]:\n        #         top = stack.pop()\n        #         if not stack:\n        #             break\n        #         distance = i - stack[-1] - 1\n        #         bounded_height = min(height[i], height[stack[-1]]) - height[top]\n        #         res += distance * bounded_height\n        #     stack.append(i)\n        # return res\n        \n        # 4. 2 pointers, 2 variables, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(height) - 1\n        left_max, right_max = 0, 0\n        res = 0\n        while left <= right:\n            if height[left] <= height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    res += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    res += right_max - height[right]\n                right -= 1\n        return res"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 2 variables\n        # 3. stack\n        \n        # 1. 2 pointers\n        # time: O(n)\n        # space: O(1)\n        \n        # 2. 2 pointers, 2 variables\n        # time: O(n)\n        # space: O(1)\n        \n        # 3. stack\n        # time: O(n)\n        # space: O(n)\n        \n        # 1. 2 pointers\n        left, right = 0, len(height) - 1\n        left_max, right_max = 0, 0\n        res = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    res += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    res += right_max - height[right]\n                right -= 1\n        \n        return res"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n                \n        return res"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n                \n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time, O(1) space\n        # for i in range(len(nums)):\n        #     index = abs(nums[i]) - 1\n        #     if nums[index] > 0:\n        #         nums[index] *= -1\n        \n        # return [i + 1 for i in range(len(nums)) if nums[i] > 0]\n        \n        # O(n) time, O(n) space\n        # return list(set(range(1, len(nums) + 1)) - set(nums))\n        \n        # O(n) time, O(1) space\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3."}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time | O(1) space\n        # for i in range(len(nums)):\n        #     index = abs(nums[i]) - 1\n        #     if nums[index] > 0:\n        #         nums[index] *= -1\n        # return [i + 1 for i in range(len(nums)) if nums[i] > 0]\n        \n        # O(n) time | O(n) space\n        # return list(set(range(1, len(nums) + 1)) - set(nums))\n        \n        # O(n) time | O(1) space\n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time, O(1) space\n        # for i in range(len(nums)):\n        #     index = abs(nums[i]) - 1\n        #     if nums[index] > 0:\n        #         nums[index] *= -1\n        # return [i + 1 for i in range(len(nums)) if nums[i] > 0]\n        \n        # O(n) time, O(n) space\n        # return list(set(range(1, len(nums) + 1)) - set(nums))\n        \n        # O(n) time, O(1) space\n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time | O(1) space\n        # for i in range(len(nums)):\n        #     index = abs(nums[i]) - 1\n        #     if nums[index] > 0:\n        #         nums[index] *= -1\n        # return [i + 1 for i in range(len(nums)) if nums[i] > 0]\n        \n        # O(n) time | O(n) space\n        # return list(set(range(1, len(nums) + 1)) - set(nums))\n        \n        # O(n) time | O(1) space\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            res = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(num, i) for i, num in enumerate(nums)])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            res = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(num, i) for i, num in enumerate(nums)])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(num, i) for i, num in enumerate(nums)])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            res = []\n            i, j = 0, 0\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(num, i) for i, num in enumerate(nums)])\n        return count"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = 0\n        a = b = -1\n        for x, y in intervals:\n            if x > b:\n                ans += 2\n                a, b = y - 1, y\n            elif x > a:\n                ans += 1\n                a, b = b, y\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = 0\n        a = b = -1\n        for x, y in intervals:\n            if x > b:\n                ans += 2\n                a = y - 1\n                b = y\n            elif x > a:\n                ans += 1\n                a = b\n                b = y\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = 0\n        a = b = -1\n        for x, y in intervals:\n            if x > b:\n                ans += 2\n                a = y - 1\n                b = y\n            elif x > a:\n                ans += 1\n                a = b\n                b = y\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = []\n        for a, b in intervals:\n            if not ans or ans[-1] < a:\n                ans.append(b - 1)\n                ans.append(b)\n            elif ans[-1] == a:\n                ans.append(b)\n            elif ans[-2] < a:\n                ans.append(b)\n        return len(ans)"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = 0\n        a = b = -1\n        for x, y in intervals:\n            if x > b:\n                ans += 2\n                a = y - 1\n                b = y\n            elif x > a:\n                ans += 1\n                a = b\n                b = y\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                cnt = 1\n                i = 1\n                while cnt > 0:\n                    if formula[i] == '(':\n                        cnt += 1\n                    elif formula[i] == ')':\n                        cnt -= 1\n                    i += 1\n                return parse(formula[1:i-1])\n            else:\n                i = 0\n                while i < len(formula) and formula[i].islower():\n                    i += 1\n                cnt = int(formula[i:]) if i < len(formula) else 1\n                return {formula[:i]: cnt}\n        \n        d = {}\n        for atom in formula.replace('(', ' ( ').replace(')', ' ) ').split():\n            if atom.islower():\n                d[atom] = d.get(atom, 0) + 1\n            else:\n                d.update(parse(atom))\n        return ''.join(k + (str(v) if v > 1 else '') for k, v in sorted(d.items()))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                cnt = 1\n                i = 1\n                while cnt:\n                    if formula[i] == '(':\n                        cnt += 1\n                    elif formula[i] == ')':\n                        cnt -= 1\n                    i += 1\n                return parse(formula[1:i-1]) * int(formula[i:]) if formula[i] != ')' else parse(formula[1:i-1]) * int(formula[i+1:])\n            i = 0\n            while i < len(formula) and formula[i].islower():\n                i += 1\n            cnt = int(formula[i:]) if i < len(formula) else 1\n            return {formula[:i]: cnt}\n        \n        d = {}\n        for k, v in parse(formula).items():\n            d[k] = d.get(k, 0) + v\n        return ''.join(k + (str(v) if v > 1 else '') for k, v in sorted(d.items()))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                cnt = 1\n                i = 1\n                while cnt > 0:\n                    if formula[i] == '(':\n                        cnt += 1\n                    elif formula[i] == ')':\n                        cnt -= 1\n                    i += 1\n                return parse(formula[1:i-1])\n            else:\n                i = 0\n                while i < len(formula) and formula[i].islower():\n                    i += 1\n                cnt = 0\n                if i < len(formula) and formula[i].isdigit():\n                    cnt = int(formula[i:])\n                    i = len(formula)\n                return {formula[:i]: cnt}\n        \n        d = {}\n        for f in formula.replace('(', ' ( ').replace(')', ' ) ').split():\n            d = merge(d, parse(f))\n        return ''.join(k + (str(v) if v > 1 else '') for k, v in sorted(d.items()))\n    \n    def merge(self, d1, d2):\n        for k, v in d2.items():\n            d1[k] = d1.get(k, 0) + v\n        return d1"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                cnt = 1\n                i = 1\n                while cnt:\n                    if formula[i] == '(':\n                        cnt += 1\n                    elif formula[i] == ')':\n                        cnt -= 1\n                    i += 1\n                return parse(formula[1:i-1]) * int(formula[i:]) if formula[i] != ')' else parse(formula[1:i-1]) * int(formula[i+1:])\n            else:\n                i = 1\n                while i < len(formula) and formula[i].islower():\n                    i += 1\n                return {formula[:i]: int(formula[i:]) if formula[i:] else 1}\n        \n        d = parse(formula)\n        return ''.join(k + (str(v) if v > 1 else '') for k, v in sorted(d.items()))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                cnt = 1\n                i = 1\n                while cnt > 0:\n                    if formula[i] == '(':\n                        cnt += 1\n                    elif formula[i] == ')':\n                        cnt -= 1\n                    i += 1\n                return parse(formula[1:i-1])\n            else:\n                i = 0\n                while i < len(formula) and formula[i].islower():\n                    i += 1\n                cnt = 0\n                if i < len(formula) and formula[i].isdigit():\n                    cnt = int(formula[i:])\n                    i = len(formula)\n                return {formula[:i]: cnt}\n        \n        d = {}\n        for f in formula.replace(')', ') ').split():\n            d = {k: v + d.get(k, 0) for k, v in parse(f).items()}\n        return ''.join(k + (str(v) if v > 1 else '') for k, v in sorted(d.items()))"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 4:\n            return False\n        \n        while n > 4:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        \n        return n == 4"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap the children\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap the children\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap the children\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap the children\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left:         generate(p + '(', left-1, right)\n            if right > left:  generate(p + ')', left, right-1)\n            if not right:     parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left:         generate(p + '(', left-1, right)\n            if right > left:  generate(p + ')', left, right-1)\n            if not right:     parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left:         generate(p + '(', left-1, right)\n            if right > left:  generate(p + ')', left, right-1)\n            if not right:     parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left:         generate(p + '(', left-1, right)\n            if right > left:  generate(p + ')', left, right-1)\n            if not right:     parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left:         generate(p + '(', left-1, right)\n            if right > left:  generate(p + ')', left, right-1)\n            if not right:     parens += p,\n            return parens\n        \n        return generate('', n, n)"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\n        # 2. 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295\n        # 3. 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296\n        # 4. 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295, 8589934591, 17179869183, 34359738367, 68719476735, 137438953471, 274877906943, 549755813887, 1099511627775, 2199023255551, 4398046511103, 8796093022207, 17592186044415, 35184372088831, 7036"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\n        # 2. 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295\n        # 3. 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296\n        # 4. 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295, 8589934591, 17179869183, 34359738367, 68719476735, 137438953471, 274877906943, 549755813887, 1099511627775, 2199023255551, 4398046511103, 8796093022207, 17592186044415, 35184372088831, 7036"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        stack.append(-1)\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(n)\n        # stack = [-1]\n        # res = 0\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         stack.append(i)\n        #     else:\n        #         stack.pop()\n        #         if not stack:\n        #             stack.append(i)\n        #         else:\n        #             res = max(res, i - stack[-1])\n        # return res\n        \n        # 2. \n        # Time: O(n)\n        # Space: O(1)\n        left = right = 0\n        res = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                left += 1\n            else:\n                right += 1\n            if left == right:\n                res = max(res, 2 * right)\n            elif right > left:\n                left = right = 0\n        left = right = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == '(':\n                left += 1\n            else:\n                right += 1\n            if left == right:\n                res = max(res, 2 * left)\n            elif left > right:\n                left = right = 0\n        return res"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        left = right = max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                left += 1\n            else:\n                right += 1\n            \n            if left == right:\n                max_len = max(max_len, left + right)\n            elif right > left:\n                left = right = 0\n        \n        left = right = 0\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == '(':\n                left += 1\n            else:\n                right += 1\n            \n            if left == right:\n                max_len = max(max_len, left + right)\n            elif left > right:\n                left = right = 0\n        \n        return max_len\n    \n        # 2. stack\n        # Time: O(n)\n        # Space: O(n)\n        \n        stack = [-1]\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len\n    \n        # 3. dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        dp = [0] * len(s)\n        max_len = 0\n        \n        for i in range(1, len(s)):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = (dp[i - 2] if i >= 2 else 0) + 2\n                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0) + 2\n                max_len = max(max_len, dp[i])\n        \n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        left, right = 0, 0\n        max_len = 0\n        \n        for c in s:\n            if c == '(':\n                left += 1\n            else:\n                right += 1\n            \n            if left == right:\n                max_len = max(max_len, left + right)\n            elif right > left:\n                left, right = 0, 0\n        \n        left, right = 0, 0\n        for c in s[::-1]:\n            if c == '(':\n                left += 1\n            else:\n                right += 1\n            \n            if left == right:\n                max_len = max(max_len, left + right)\n            elif left > right:\n                left, right = 0, 0\n        \n        return max_len\n    \n        # 2. stack\n        # Time: O(n)\n        # Space: O(n)\n        \n        stack = [-1]\n        max_len = 0\n        \n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len\n    \n        # 3. dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        dp = [0] * len(s)\n        max_len = 0\n        \n        for i in range(1, len(s)):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = (dp[i - 2] if i >= 2 else 0) + 2\n                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0) + 2\n                max_len = max(max_len, dp[i])\n        \n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        stack.append(-1)\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res = sign + str(numerator // denominator)\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return res\n        \n        res += \".\"\n        dic = {}\n        while remainder != 0:\n            if remainder in dic:\n                res = res[:dic[remainder]] + \"(\" + res[dic[remainder]:] + \")\"\n                return res\n            dic[remainder] = len(res)\n            remainder *= 10\n            res += str(remainder // denominator)\n            remainder %= denominator\n        \n        return res"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0 or denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + self.fractionToDecimal(numerator, denominator)\n        \n        res = \"\"\n        if numerator >= denominator:\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        else:\n            res += \"0\"\n        \n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        dic = {}\n        while numerator != 0:\n            if numerator in dic:\n                res = res[:dic[numerator]] + \"(\" + res[dic[numerator]:] + \")\"\n                return res\n            dic[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        \n        return res"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            sign = \"\"\n        elif numerator < 0 or denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return sign + str(quotient)\n        \n        result = sign + str(quotient) + \".\"\n        \n        seen = {}\n        i = len(result)\n        \n        while remainder != 0:\n            if remainder in seen:\n                result = result[:seen[remainder]] + \"(\" + result[seen[remainder]:] + \")\"\n                return result\n            \n            seen[remainder] = i\n            remainder *= 10\n            result += str(remainder // denominator)\n            remainder %= denominator\n            i += 1\n        \n        return result"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res = sign + str(numerator // denominator)\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return res\n        \n        res += \".\"\n        dic = {}\n        while remainder != 0:\n            if remainder in dic:\n                res = res[:dic[remainder]] + \"(\" + res[dic[remainder]:] + \")\"\n                return res\n            dic[remainder] = len(res)\n            remainder *= 10\n            res += str(remainder // denominator)\n            remainder %= denominator\n        \n        return res"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            sign = \"\"\n        elif numerator < 0 or denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return sign + str(quotient)\n        \n        result = sign + str(quotient) + \".\"\n        \n        seen = {}\n        while remainder != 0:\n            if remainder in seen:\n                result += \")\"\n                result = result[:seen[remainder]] + \"(\" + result[seen[remainder]:]\n                break\n            seen[remainder] = len(result)\n            remainder *= 10\n            result += str(remainder // denominator)\n            remainder %= denominator\n        \n        return result"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n            \n        prev.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(slow)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n            \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n            \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n            \n        prev.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(slow)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n            \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n            \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            i = bisect_left(dp, h)\n            if i == len(dp):\n                dp.append(h)\n            else:\n                dp[i] = h\n        return len(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width in ascending order\n        # if widths are equal, sort by height in descending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # create a list to store the heights of the envelopes\n        heights = [envelope[1] for envelope in envelopes]\n        \n        # use the Longest Increasing Subsequence algorithm to find the longest increasing subsequence of the heights\n        # this will give us the maximum number of envelopes that can be Russian dolled\n        return self.lengthOfLIS(heights)\n    \n    def lengthOfLIS(self, nums):\n        # create a list to store the longest increasing subsequence\n        dp = []\n        \n        # iterate through the nums list\n        for num in nums:\n            # if the num is greater than the last element in the dp list, append it to the dp list\n            if not dp or num > dp[-1]:\n                dp.append(num)\n            # otherwise, find the first element in the dp list that is greater than or equal to the num\n            # and replace it with the num\n            else:\n                left = 0\n                right = len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < num:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = num\n        \n        # the length of the dp list is the length of the longest increasing subsequence\n        return len(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            i = bisect_left(dp, h)\n            if i == len(dp):\n                dp.append(h)\n            else:\n                dp[i] = h\n        return len(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            i = bisect_left(dp, h)\n            if i == len(dp):\n                dp.append(h)\n            else:\n                dp[i] = h\n        return len(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for w, h in envelopes:\n            i = bisect.bisect_left(dp, h)\n            if i == len(dp):\n                dp.append(h)\n            else:\n                dp[i] = h\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. \u904d\u5386\u77e9\u9635\uff0c\u8bb0\u5f55\u4e0b\u6240\u67090\u7684\u4f4d\u7f6e\n        # 2. \u904d\u5386\u8bb0\u5f55\u76840\u7684\u4f4d\u7f6e\uff0c\u5c06\u5bf9\u5e94\u884c\u5217\u7f6e0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        zero_pos = []\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    zero_pos.append((i, j))\n        \n        for i, j in zero_pos:\n            matrix[i] = [0] * n\n            for k in range(m):\n                matrix[k][j] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        col_zero = False\n        \n        for i in range(m):\n            if matrix[i][0] == 0:\n                col_zero = True\n                break\n        \n        for j in range(n):\n            if matrix[0][j] == 0:\n                row_zero = True\n                break\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if col_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n        \n        if row_zero:\n            for j in range(n):\n                matrix[0][j] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # O(1) space solution\n        # O(m*n) time solution\n        \n        # 1. find the first row and column that has a zero\n        # 2. mark the first row and column that has a zero\n        # 3. mark the rest of the rows and columns that have a zero\n        # 4. mark the first row and column that has a zero\n        # 5. mark the rest of the rows and columns that have a zero\n        # 6. mark the first row and column that has a zero\n        # 7. mark the rest of the rows and columns that have a zero\n        # 8. mark the first row and column that has a zero\n        # 9. mark the rest of the rows and columns that have a zero\n        # 10. mark the first row and column that has a zero\n        # 11. mark the rest of the rows and columns that have a zero\n        # 12. mark the first row and column that has a zero\n        # 13. mark the rest of the rows and columns that have a zero\n        # 14. mark the first row and column that has a zero\n        # 15. mark the rest of the rows and columns that have a zero\n        # 16. mark the first row and column that has a zero\n        # 17. mark the rest of the rows and columns that have a zero\n        # 18. mark the first row and column that has a zero\n        # 19. mark the rest of the rows and columns that have a zero\n        # 20. mark the first row and column that has a zero\n        # 21. mark the rest of the rows and columns that have a zero\n        # 22. mark the first row and column that has a zero\n        # 23. mark the rest of the rows and columns that have a zero\n        # 24. mark the first row and column that has a zero\n        # 25. mark the rest of the rows and columns that have a zero\n        # 26. mark the first row and column that has a zero\n        # 27. mark the rest of the rows and columns that have a zero\n        # 28. mark the first row and column that has a zero\n        # 29. mark the rest of the rows and columns that have a zero\n        # 30. mark the first row and column that has a zero\n        # 31. mark the rest of the rows and columns that have a zero\n        # 32. mark the first row and column that has a zero\n        # 33. mark the rest of the rows and columns that have a zero\n        # 34. mark the first row and column that has a zero\n        # 35. mark the rest of the rows and columns that have a zero\n        # 36. mark the first row and column that has a zero\n        # 37. mark the rest of the rows and columns that have a zero\n        # 38. mark the first row and column that has a zero\n        # 39. mark the rest of the rows and columns that have a zero\n        # 40. mark the first row and column that has a zero\n        # 41. mark the rest of the rows and columns that have a zero\n        # 42. mark the first row and column that has a zero\n        # 43. mark the rest of the rows and columns that have a zero\n        # 44. mark the first row and column that has a zero\n        # 45. mark the rest of the rows and columns that have a zero\n        # 46. mark the first row and column that has a zero\n        # 47. mark the rest of the rows and columns that have a zero\n        # 48. mark the first row and column that has a zero\n        # 49. mark the rest of the rows and columns that have a zero\n        # 50. mark the first row and column that has a zero\n        # 51. mark the rest of the rows and columns that have a zero\n        # 52. mark the first row and column that has a zero\n        # 53. mark the rest of the rows and columns that have a zero\n        # 54. mark the first row and column that has a zero\n        # 55. mark the rest of the rows and columns that have a zero\n        # 56. mark the first row and column that has a zero\n        # 57"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = [False] * m\n        col = [False] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = True\n                    col[j] = True\n        \n        for i in range(m):\n            for j in range(n):\n                if row[i] or col[j]:\n                    matrix[i][j] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. \u904d\u5386\u77e9\u9635\uff0c\u5c060\u6240\u5728\u7684\u884c\u548c\u5217\u8bb0\u5f55\u4e0b\u6765\n        # 2. \u5c06\u8bb0\u5f55\u7684\u884c\u548c\u5217\u7f6e\u4e3a0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        rows = set()\n        cols = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        \n        for i in range(m):\n            for j in range(n):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n        \n        # 2. find the node to be deleted\n        if length == n:\n            return head.next\n        \n        current = head\n        for i in range(length - n - 1):\n            current = current.next\n        \n        # 3. delete the node\n        current.next = current.next.next\n        \n        # 4. return the head\n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. find the node to be deleted\n        if length == n:\n            return head.next\n        \n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        # 3. delete the node\n        curr.next = curr.next.next\n        \n        # 4. return the head\n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        \n        # 1. find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. find the node to be deleted\n        # 3. delete the node\n        if length == n:\n            return head.next\n        else:\n            curr = head\n            for i in range(length - n - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n            return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        \n        # 1. find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. find the node to be deleted\n        if length == n:\n            return head.next\n        \n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        # 3. delete the node\n        curr.next = curr.next.next\n        \n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0, head)\n        \n        # 2. create two pointers\n        left = dummy\n        right = head\n        \n        # 3. move the right pointer n steps ahead\n        while n > 0 and right:\n            right = right.next\n            n -= 1\n        \n        # 4. move the left and right pointers until the right pointer reaches the end\n        while right:\n            left = left.next\n            right = right.next\n        \n        # 5. delete the nth node\n        left.next = left.next.next\n        \n        # 6. return the head of the list\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. convert to set\n        # 2. use set intersection\n        # 3. convert back to list\n        \n        return list(set(nums1) & set(nums2))"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert to set\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # return intersection\n        return list(set1 & set2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert to set\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # return intersection\n        return list(set1 & set2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set for nums1\n        # 2. create a set for nums2\n        # 3. return the intersection of the two sets\n        \n        return set(nums1) & set(nums2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert to set\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        # return intersection\n        return list(set1 & set2)"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        res = cur = 0\n        for m in machines:\n            m -= avg\n            cur += m\n            res = max(res, abs(cur), m)\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        res = cur = 0\n        for m in machines:\n            m -= avg\n            cur += m\n            res = max(res, abs(cur), m)\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        res = cur = 0\n        for m in machines:\n            m -= avg\n            cur += m\n            res = max(res, abs(cur), m)\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        res = cur = 0\n        for m in machines:\n            m -= avg\n            cur += m\n            res = max(res, abs(cur), m)\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        res = cur = 0\n        for m in machines:\n            m -= avg\n            cur += m\n            res = max(res, abs(cur), m)\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x//i, n) for i in range(1, m+1))\n        \n        lo, hi = 1, m*n\n        while lo < hi:\n            mi = lo + (hi - lo)//2\n            if count(mi) < k:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x//i, n) for i in range(1, m+1))\n        \n        lo, hi = 1, m*n\n        while lo < hi:\n            mi = lo + (hi - lo)//2\n            if count(mi) < k:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if count(mi) < k:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x//i, n) for i in range(1, m+1))\n        \n        lo, hi = 1, m*n\n        while lo < hi:\n            mi = lo + (hi-lo)//2\n            if count(mi) >= k:\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x//i, n) for i in range(1, m+1))\n        \n        lo, hi = 1, m*n\n        while lo < hi:\n            mi = lo + (hi - lo)//2\n            if count(mi) < k:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow, fast = head, head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            if prev:\n                prev.next = None\n            return slow\n        \n        if not head:\n            return None\n        mid = get_mid(head)\n        root = TreeNode(mid.val)\n        if head == mid:\n            return root\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow, fast = head, head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            if prev:\n                prev.next = None\n            return slow\n        \n        if not head:\n            return None\n        mid = get_mid(head)\n        root = TreeNode(mid.val)\n        if head == mid:\n            return root\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow, fast = head, head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            if prev:\n                prev.next = None\n            return slow\n        \n        if not head:\n            return None\n        mid = get_mid(head)\n        root = TreeNode(mid.val)\n        if head == mid:\n            return root\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow = head\n            fast = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            return prev\n        \n        def helper(head):\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            mid = get_mid(head)\n            root = TreeNode(mid.next.val)\n            mid.next = mid.next.next\n            root.left = helper(head)\n            root.right = helper(mid.next)\n            return root\n        \n        return helper(head)"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow = head\n            fast = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            return prev\n        \n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        mid = get_mid(head)\n        root = TreeNode(mid.next.val)\n        mid.next = mid.next.next\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        tail = dummy\n        \n        # while both lists are not empty\n        while list1 and list2:\n            # if the value of the first list is less than or equal to the value of the second list\n            if list1.val <= list2.val:\n                # set the next node of the tail to the first list\n                tail.next = list1\n                # move the first list to the next node\n                list1 = list1.next\n            else:\n                # set the next node of the tail to the second list\n                tail.next = list2\n                # move the second list to the next node\n                list2 = list2.next\n            # move the tail to the next node\n            tail = tail.next\n        \n        # if the first list is not empty\n        if list1:\n            # set the next node of the tail to the first list\n            tail.next = list1\n        # if the second list is not empty\n        elif list2:\n            # set the next node of the tail to the second list\n            tail.next = list2\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        \n        # create a pointer to the dummy node\n        tail = dummy\n        \n        # while both lists are not empty\n        while list1 and list2:\n            # if the value of the first list is less than or equal to the value of the second list\n            if list1.val <= list2.val:\n                # set the next node of the tail to the first list\n                tail.next = list1\n                # move the first list to the next node\n                list1 = list1.next\n            else:\n                # set the next node of the tail to the second list\n                tail.next = list2\n                # move the second list to the next node\n                list2 = list2.next\n            # move the tail to the next node\n            tail = tail.next\n        \n        # if the first list is not empty\n        if list1:\n            # set the next node of the tail to the first list\n            tail.next = list1\n        # if the second list is not empty\n        elif list2:\n            # set the next node of the tail to the second list\n            tail.next = list2\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        \n        # create a pointer to the dummy node\n        tail = dummy\n        \n        # while both lists are not empty\n        while list1 and list2:\n            # if the value of the first list is less than or equal to the value of the second list\n            if list1.val <= list2.val:\n                # set the next node of the tail to the first list\n                tail.next = list1\n                # move the first list to the next node\n                list1 = list1.next\n            else:\n                # set the next node of the tail to the second list\n                tail.next = list2\n                # move the second list to the next node\n                list2 = list2.next\n            # move the tail to the next node\n            tail = tail.next\n        \n        # if the first list is not empty\n        if list1:\n            # set the next node of the tail to the first list\n            tail.next = list1\n        # if the second list is not empty\n        elif list2:\n            # set the next node of the tail to the second list\n            tail.next = list2\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # if either list is empty, return the other list\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        # create a dummy node to store the head of the merged list\n        dummy = ListNode()\n        # create a pointer to the head of the merged list\n        curr = dummy\n        \n        # loop through both lists until one of them is empty\n        while list1 and list2:\n            # if the value of the current node in list1 is less than or equal to the value of the current node in list2\n            if list1.val <= list2.val:\n                # set the next pointer of the current node in the merged list to the current node in list1\n                curr.next = list1\n                # move to the next node in list1\n                list1 = list1.next\n            else:\n                # set the next pointer of the current node in the merged list to the current node in list2\n                curr.next = list2\n                # move to the next node in list2\n                list2 = list2.next\n            # move to the next node in the merged list\n            curr = curr.next\n        \n        # if list1 is not empty, append the remaining nodes to the merged list\n        if list1:\n            curr.next = list1\n        # if list2 is not empty, append the remaining nodes to the merged list\n        if list2:\n            curr.next = list2\n        \n        # return the head of the merged list\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # if either list is empty, return the other list\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        # create a dummy node to store the head of the merged list\n        dummy = ListNode()\n        # create a pointer to the head of the merged list\n        curr = dummy\n        \n        # loop through both lists until one of them is empty\n        while list1 and list2:\n            # if the value of the current node in list1 is less than or equal to the value of the current node in list2\n            if list1.val <= list2.val:\n                # set the next pointer of the current node in the merged list to the current node in list1\n                curr.next = list1\n                # move to the next node in list1\n                list1 = list1.next\n            else:\n                # set the next pointer of the current node in the merged list to the current node in list2\n                curr.next = list2\n                # move to the next node in list2\n                list2 = list2.next\n            # move to the next node in the merged list\n            curr = curr.next\n        \n        # if list1 is not empty, set the next pointer of the current node in the merged list to the remaining nodes in list1\n        if list1:\n            curr.next = list1\n        # if list2 is not empty, set the next pointer of the current node in the merged list to the remaining nodes in list2\n        if list2:\n            curr.next = list2\n        \n        # return the head of the merged list\n        return dummy.next"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            stack = [-1]\n            for j in range(n + 1):\n                while heights[j] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    ans = max(ans, h * w)\n                stack.append(j)\n        \n        return ans"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            stack = [-1]\n            for j in range(n + 1):\n                while heights[j] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    ans = max(ans, h * w)\n                stack.append(j)\n        \n        return ans"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            stack = [-1]\n            for j in range(n + 1):\n                while heights[j] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    ans = max(ans, h * w)\n                stack.append(j)\n        \n        return ans"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            \n            stack = [-1]\n            for j in range(n + 1):\n                while heights[j] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    ans = max(ans, h * w)\n                stack.append(j)\n        \n        return ans"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            stack = [-1]\n            for j in range(n + 1):\n                while heights[j] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    ans = max(ans, h * w)\n                stack.append(j)\n        \n        return ans"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u5982\u679c nums[mid] == nums[right] \u8bf4\u660e\u91cd\u590d\uff0cright \u5de6\u79fb\n        # 3. \u5982\u679c nums[mid] > nums[right] \u8bf4\u660e\u6700\u5c0f\u503c\u5728\u53f3\u534a\u90e8\u5206\uff0cleft = mid + 1\n        # 4. \u5982\u679c nums[mid] < nums[right] \u8bf4\u660e\u6700\u5c0f\u503c\u5728\u5de6\u534a\u90e8\u5206\uff0cright = mid\n        # 5. \u5982\u679c nums[mid] == nums[left] \u8bf4\u660e\u91cd\u590d\uff0cleft \u53f3\u79fb\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < numsright"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u5982\u679cnums[mid] == nums[right]\uff0c\u5219right = right - 1\n        # 3. \u5982\u679cnums[mid] > nums[right]\uff0c\u5219left = mid + 1\n        # 4. \u5982\u679cnums[mid] < nums[right]\uff0c\u5219right = mid\n        # 5. \u5982\u679cnums[mid] == nums[left]\uff0c\u5219left = left + 1\n        # 6. \u5982\u679cnums[mid] < nums[left]\uff0c\u5219right = mid\n        # 7. \u5982\u679cnums[mid] > nums[left]\uff0c\u5219left = mid + 1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        if nums[right] > nums[0]:\n            return nums[0]\n        \n        while right >= left:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u5982\u679cnums[mid] == nums[right]\uff0c\u5219right = right - 1\n        # 3. \u5982\u679cnums[mid] > nums[right]\uff0c\u5219left = mid + 1\n        # 4. \u5982\u679cnums[mid] < nums[right]\uff0c\u5219right = mid\n        # 5. \u5982\u679cnums[mid] == nums[left]\uff0c\u5219left = left + 1\n        # 6. \u5982\u679cnums[mid] < nums[left]\uff0c\u5219right = mid\n        # 7. \u5982\u679cnums[mid] > nums[left]\uff0c\u5219left = mid + 1\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u5982\u679cnums[mid] == nums[right]\uff0c\u5219right = right - 1\n        # 3. \u5982\u679cnums[mid] > nums[right]\uff0c\u5219left = mid + 1\n        # 4. \u5982\u679cnums[mid] < nums[right]\uff0c\u5219right = mid\n        # 5. \u5982\u679cnums[mid] == nums[left]\uff0c\u5219left = left + 1\n        # 6. \u5982\u679cnums[mid] < nums[left]\uff0c\u5219right = mid\n        # 7. \u5982\u679cnums[mid] > nums[left]\uff0c\u5219left = mid + 1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            parts = s.split('e')\n            if len(parts) != 2:\n                return False\n            return self.isNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            parts = s.split('.')\n            if len(parts) != 2:\n                return False\n            return selfisNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 18. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 19. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 20. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 21. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 22. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 23. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8bb0\u5f55\u662f\u5426\u51fa\u73b0\u8fc7\u5c0f\u6570\u70b9\n        is_dot = False\n        \n        # 4. \u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8bb0\u5f55\u662f\u5426\u51fa\u73b0\u8fc7e\n        is_e = False\n        \n        # 5. \u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8bb0\u5f55\u662f\u5426\u51fa\u73b0\u8fc7+/-\n        is_sign = False\n        \n        # 6. \u904d\u5386\u5b57\u7b26\u4e32\n        for i in range(len(s)):\n            # 6.1 \u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e3a\u6570\u5b57\uff0c\u7ee7\u7eed\u904d\u5386\n            if s[i].isdigit():\n                continue\n            # 6.2 \u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e3a\u5c0f\u6570\u70b9\uff0c\u5982\u679c\u4e4b\u524d\u5df2\u7ecf\u51fa\u73b0\u8fc7\u5c0f\u6570\u70b9\uff0c\u8fd4\u56deFalse\n            elif s[i] == '.':\n                if is_dot or is_e:\n                    return False\n                is_dot = True\n            # 6.3 \u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e3ae\uff0c\u5982\u679c\u4e4b\u524d\u5df2\u7ecf\u51fa\u73b0\u8fc7e\uff0c\u8fd4\u56deFalse\n            elif s[i] == 'e':\n                if is_e or not is_dot:\n                    return False\n                is_e = True\n                is_dot = False\n                is_sign = False\n            # 6.4 \u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e3a+/-\uff0c\u5982\u679c\u4e4b\u524d\u5df2\u7ecf\u51fa\u73b0\u8fc7+/-\uff0c\u8fd4\u56deFalse\n            elif s[i] in ['+', '-']:\n                if is_sign or i > 0:\n                    return False\n                is_sign = True\n            # 6.5 \u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e3a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            else:\n                return False\n        \n        # 7. \u5982\u679c\u904d\u5386\u5b8c\u5b57\u7b26\u4e32\uff0c\u8fd4\u56deTrue\n        return True"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            parts = s.split('e')\n            if len(parts) != 2:\n                return False\n            return self.isNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            parts = s.split('.')\n            if len(parts) != 2:\n                return False\n            return selfisNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 18. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 19. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 20. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 21. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 22. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 23. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            parts = s.split('e')\n            if len(parts) != 2:\n                return False\n            return self.isNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            parts = s.split('.')\n            if len(parts) != 2:\n                return False\n            return selfisNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 18. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 19. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 20. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 21. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 22. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 23. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u6389\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            parts = s.split('e')\n            if len(parts) != 2:\n                return False\n            return self.isNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            parts = s.split('.')\n            if len(parts) != 2:\n                return False\n            return selfisNumber(parts[0]) and self.isNumber(parts[1])\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 18. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 19. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 20. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 21. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '+-':\n            return self.isNumber(s[:-1])\n        \n        # 22. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in '+-':\n            return self.isNumber(s[1:])\n        \n        # 23. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in '"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X,"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2. \n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 2.\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1.\n        ## Time: O("}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. sort both strings\n        # 2. iterate through both strings and compare each character\n        # 3. if the characters are not equal, return the character from t\n        # 4. if the characters are equal, continue\n        # 5. if the characters are equal, return the last character from t\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        return t[-1]"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in s:\n            if i in s_dict:\n                s_dict[i] += 1\n            else:\n                s_dict[i] = 1\n        \n        for i in t:\n            if i in t_dict:\n                t_dict[i] += 1\n            else:\n                t_dict[i] = 1\n        \n        for i in t_dict:\n            if i not in s_dict:\n                return i\n            elif t_dict[i] > s_dict[i]:\n                return i"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        \n        ## 1. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 2. Sort\n        ## Time: O(nlogn)"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. use hashmap to store the count of each character in s\n        # 2. iterate through t and decrement the count of each character in the hashmap\n        # 3. if the count of a character in the hashmap is negative, return the character\n        # 4. if the count of a character in the hashmap is positive, return the character\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # create a hashmap to store the count of each character in s\n        hashmap = {}\n        for char in s:\n            if char in hashmap:\n                hashmap[char] += 1\n            else:\n                hashmap[char] = 1\n        \n        # iterate through t and decrement the count of each character in the hashmap\n        for char in t:\n            if char in hashmap:\n                hashmap[char] -= 1\n            else:\n                return char\n        \n        # if the count of a character in the hashmap is negative, return the character\n        for char in hashmap:\n            if hashmap[char] < 0:\n                return char\n        \n        # if the count of a character in the hashmap is positive, return the character\n        for char in hashmap:\n            if hashmap[char] > 0:\n                return char"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve():\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve()"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, val):\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n                if board[i][col] == val:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == val:\n                    return False\n            return True\n        \n        def backtrack():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for val in range(1, 10):\n                            if isValid(i, j, str(val)):\n                                board[i][j] = str(val)\n                                if backtrack():\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        backtrack()"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve():\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve()"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        # 2. Find the first and second elements in the list that are out of order.\n        # 3. Swap the values of the first and second elements.\n        \n        # Inorder traversal of the tree\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.nodes.append(root)\n            inorder(root.right)\n        \n        # Find the first and second elements in the list that are out of order\n        def find_two_swapped(nodes):\n            x = None\n            y = None\n            prev = nodes[0]\n            for i in range(1, len(nodes)):\n                if prev.val > nodes[i].val:\n                    y = nodes[i]\n                    if x is None:\n                        x = prev\n                    else:\n                        break\n                prev = nodes[i]\n            return x, y\n        \n        # Swap the values of the first and second elements\n        def recover(root, x, y):\n            if root is None:\n                return\n            if root.val == x.val:\n                root.val = y.val\n            elif root.val == y.val:\n                root.val = x.val\n            recover(root.left, x, y)\n            recover(root.right, x, y)\n        \n        self.nodes = []\n        inorder(root)\n        x, y = find_two_swapped(self.nodes)\n        recover(root, x, y)"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the values in a list.\n        # 2. Find the two elements that are out of order.\n        # 3. Swap the values of the two elements.\n        \n        # Inorder traversal of the tree\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.nodes.append(root)\n            inorder(root.right)\n        \n        # Find the two elements that are out of order\n        self.nodes = []\n        inorder(root)\n        x = None\n        y = None\n        for i in range(len(self.nodes)-1):\n            if self.nodes[i].val > self.nodes[i+1].val:\n                y = self.nodes[i+1]\n                if x is None:\n                    x = self.nodes[i]\n                else:\n                    break\n        \n        # Swap the values of the two elements\n        x.val, y.val = y.val, x.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list\n        # 2. Find the two elements that are out of order\n        # 3. Swap the values of the two elements\n        \n        # Inorder traversal of the tree\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.nodes.append(root)\n            inorder(root.right)\n        \n        # Find the two elements that are out of order\n        self.nodes = []\n        inorder(root)\n        x = None\n        y = None\n        for i in range(len(self.nodes)-1):\n            if self.nodes[i].val > self.nodes[i+1].val:\n                y = self.nodes[i+1]\n                if x is None:\n                    x = self.nodes[i]\n                else:\n                    break\n        \n        # Swap the values of the two elements\n        x.val, y.val = y.val, x.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree\n        # 2. Find the two nodes that are out of order\n        # 3. Swap the values of the two nodes\n        \n        # Inorder traversal of the tree\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            inorder_list.append(root)\n            inorder(root.right)\n        \n        inorder_list = []\n        inorder(root)\n        \n        # Find the two nodes that are out of order\n        first = None\n        second = None\n        for i in range(len(inorder_list)-1):\n            if inorder_list[i].val > inorder_list[i+1].val:\n                if first is None:\n                    first = inorder_list[i]\n                second = inorder_list[i+1]\n        \n        # Swap the values of the two nodes\n        first.val, second.val = second.val, first.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree\n        # 2. Find the two nodes that are out of order\n        # 3. Swap the values of the two nodes\n        \n        # Inorder traversal of the tree\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            inorder_list.append(root)\n            inorder(root.right)\n        \n        inorder_list = []\n        inorder(root)\n        \n        # Find the two nodes that are out of order\n        first = None\n        second = None\n        for i in range(len(inorder_list)-1):\n            if inorder_list[i].val > inorder_list[i+1].val:\n                if first is None:\n                    first = inorder_list[i]\n                second = inorder_list[i+1]\n        \n        # Swap the values of the two nodes\n        first.val, second.val = second.val, first.val"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            slow.next, slow, prev = prev, slow.next, slow\n        \n        # compare the first half and the reversed second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head, prev = head.next, prev.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        \n        # \u4e8c\u5206\u67e5\u627e\n        left, right = 0, num\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n        \n        # \u725b\u987f\u8fed\u4ee3\u6cd5\n        if num < 2:\n            return True\n        \n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        \n        # \u4e8c\u5206\u67e5\u627e\n        left, right = 0, num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n        \n        # \u725b\u987f\u8fed\u4ee3\u6cd5\n        if num < 2:\n            return True\n        \n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        # 3. \u6570\u5b66\u65b9\u6cd5\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if num < 2:\n            return True\n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num\n    \n        # 3. \u6570\u5b66\u65b9\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        i = 1\n        while num > 0:\n            num -= i\n            i += 2\n        return num == 0"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        # 3. \u6570\u5b66\u65b9\u6cd5\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, num\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if num < 2:\n            return True\n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num\n    \n        # 3. \u6570\u5b66\u65b9\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        i = 1\n        while num > 0:\n            num -= i\n            i += 2\n        return num == 0"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u725b\u987f\u8fed\u4ee3\u6cd5\n        \n        # \u4e8c\u5206\u67e5\u627e\n        left, right = 0, num\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n        \n        # \u725b\u987f\u8fed\u4ee3\u6cd5\n        if num < 2:\n            return True\n        \n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 0 -> 0\n        # 1 -> 1\n        # 2 -> 10\n        # 3 -> 11\n        # 4 -> 100\n        # 5 -> 101\n        # 6 -> 110\n        # 7 -> 111\n        # 8 -> 1000\n        # 9 -> 1001\n        # 10 -> 1010\n        # 11 -> 1011\n        # 12 -> 1100\n        # 13 -> 1101\n        # 14 -> 1110\n        # 15 -> 1111\n        # 16 -> 10000\n        # 17 -> 10001\n        # 18 -> 10010\n        # 19 -> 10011\n        # 20 -> 10100\n        # 21 -> 10101\n        # 22 -> 10110\n        # 23 -> 10111\n        # 24 -> 11000\n        # 25 -> 11001\n        # 26 -> 11010\n        # 27 -> 11011\n        # 28 -> 11100\n        # 29 -> 11101\n        # 30 -> 11110\n        # 31 -> 11111\n        # 32 -> 100000\n        # 33 -> 100001\n        # 34 -> 100010\n        # 35 -> 100011\n        # 36 -> 100100\n        # 37 -> 100101\n        # 38 -> 100110\n        # 39 -> 100111\n        # 40 -> 101000\n        # 41 -> 101001\n        # 42 -> 101010\n        # 43 -> 101011\n        # 44 -> 101100\n        # 45 -> 101101\n        # 46 -> 101110\n        # 47 -> 101111\n        # 48 -> 110000\n        # 49 -> 110001\n        # 50 -> 110010\n        # 51 -> 110011\n        # 52 -> 110100\n        # 53 -> 110101\n        # 54 -> 110110\n        # 55 -> 110111\n        # 56 -> 111000\n        # 57 -> 111001\n        # 58 -> 111010\n        # 59 -> 111011\n        # 60 -> 111100\n        # 61 -> 111101\n        # 62 -> 111110\n        # 63 -> 111111\n        # 64 -> 1000000\n        # 65 -> 1000001\n        # 66 -> 1000010\n        # 67 -> 1000011\n        # 68 -> 1000100\n        # 69 -> 1000101\n        # 70 -> 1000110\n        # 71 -> 1000111\n        # 72 -> 1001000\n        # 73 -> 1001001\n        # 74 -> 1001010\n        # 75 -> 1001011\n        # 76 -> 1001100\n        # 77"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 0 -> 0\n        # 1 -> 1\n        # 2 -> 10\n        # 3 -> 11\n        # 4 -> 100\n        # 5 -> 101\n        # 6 -> 110\n        # 7 -> 111\n        # 8 -> 1000\n        # 9 -> 1001\n        # 10 -> 1010\n        # 11 -> 1011\n        # 12 -> 1100\n        # 13 -> 1101\n        # 14 -> 1110\n        # 15 -> 1111\n        # 16 -> 10000\n        # 17 -> 10001\n        # 18 -> 10010\n        # 19 -> 10011\n        # 20 -> 10100\n        # 21 -> 10101\n        # 22 -> 10110\n        # 23 -> 10111\n        # 24 -> 11000\n        # 25 -> 11001\n        # 26 -> 11010\n        # 27 -> 11011\n        # 28 -> 11100\n        # 29 -> 11101\n        # 30 -> 11110\n        # 31 -> 11111\n        # 32 -> 100000\n        # 33 -> 100001\n        # 34 -> 100010\n        # 35 -> 100011\n        # 36 -> 100100\n        # 37 -> 100101\n        # 38 -> 100110\n        # 39 -> 100111\n        # 40 -> 101000\n        # 41 -> 101001\n        # 42 -> 101010\n        # 43 -> 101011\n        # 44 -> 101100\n        # 45 -> 101101\n        # 46 -> 101110\n        # 47 -> 101111\n        # 48 -> 110000\n        # 49 -> 110001\n        # 50 -> 110010\n        # 51 -> 110011\n        # 52 -> 110100\n        # 53 -> 110101\n        # 54 -> 110110\n        # 55 -> 110111\n        # 56 -> 111000\n        # 57 -> 111001\n        # 58 -> 111010\n        # 59 -> 111011\n        # 60 -> 111100\n        # 61 -> 111101\n        # 62 -> 111110\n        # 63 -> 111111\n        # 64 -> 1000000\n        # 65 -> 1000001\n        # 66 -> 1000010\n        # 67 -> 1000011\n        # 68 -> 1000100\n        # 69 -> 1000101\n        # 70 -> 1000110\n        # 71 -> 1000111\n        # 72 -> 1001000\n        # 73 -> 1001001\n        # 74 -> 1001010\n        # 75 -> 1001011\n        # 76 -> 1001100\n        # 77"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 0 -> 0\n        # 1 -> 1\n        # 2 -> 10\n        # 3 -> 11\n        # 4 -> 100\n        # 5 -> 101\n        # 6 -> 110\n        # 7 -> 111\n        # 8 -> 1000\n        # 9 -> 1001\n        # 10 -> 1010\n        # 11 -> 1011\n        # 12 -> 1100\n        # 13 -> 1101\n        # 14 -> 1110\n        # 15 -> 1111\n        # 16 -> 10000\n        # 17 -> 10001\n        # 18 -> 10010\n        # 19 -> 10011\n        # 20 -> 10100\n        # 21 -> 10101\n        # 22 -> 10110\n        # 23 -> 10111\n        # 24 -> 11000\n        # 25 -> 11001\n        # 26 -> 11010\n        # 27 -> 11011\n        # 28 -> 11100\n        # 29 -> 11101\n        # 30 -> 11110\n        # 31 -> 11111\n        # 32 -> 100000\n        # 33 -> 100001\n        # 34 -> 100010\n        # 35 -> 100011\n        # 36 -> 100100\n        # 37 -> 100101\n        # 38 -> 100110\n        # 39 -> 100111\n        # 40 -> 101000\n        # 41 -> 101001\n        # 42 -> 101010\n        # 43 -> 101011\n        # 44 -> 101100\n        # 45 -> 101101\n        # 46 -> 101110\n        # 47 -> 101111\n        # 48 -> 110000\n        # 49 -> 110001\n        # 50 -> 110010\n        # 51 -> 110011\n        # 52 -> 110100\n        # 53 -> 110101\n        # 54 -> 110110\n        # 55 -> 110111\n        # 56 -> 111000\n        # 57 -> 111001\n        # 58 -> 111010\n        # 59 -> 111011\n        # 60 -> 111100\n        # 61 -> 111101\n        # 62 -> 111110\n        # 63 -> 111111\n        # 64 -> 1000000\n        # 65 -> 1000001\n        # 66 -> 1000010\n        # 67 -> 1000011\n        # 68 -> 1000100\n        # 69 -> 1000101\n        # 70 -> 1000110\n        # 71 -> 1000111\n        # 72 -> 1001000\n        # 73 -> 1001001\n        # 74 -> 1001010\n        # 75 -> 1001011\n        # 76 -> 1001100\n        # 77"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 0 -> 0\n        # 1 -> 1\n        # 2 -> 10\n        # 3 -> 11\n        # 4 -> 100\n        # 5 -> 101\n        # 6 -> 110\n        # 7 -> 111\n        # 8 -> 1000\n        # 9 -> 1001\n        # 10 -> 1010\n        # 11 -> 1011\n        # 12 -> 1100\n        # 13 -> 1101\n        # 14 -> 1110\n        # 15 -> 1111\n        # 16 -> 10000\n        # 17 -> 10001\n        # 18 -> 10010\n        # 19 -> 10011\n        # 20 -> 10100\n        # 21 -> 10101\n        # 22 -> 10110\n        # 23 -> 10111\n        # 24 -> 11000\n        # 25 -> 11001\n        # 26 -> 11010\n        # 27 -> 11011\n        # 28 -> 11100\n        # 29 -> 11101\n        # 30 -> 11110\n        # 31 -> 11111\n        # 32 -> 100000\n        # 33 -> 100001\n        # 34 -> 100010\n        # 35 -> 100011\n        # 36 -> 100100\n        # 37 -> 100101\n        # 38 -> 100110\n        # 39 -> 100111\n        # 40 -> 101000\n        # 41 -> 101001\n        # 42 -> 101010\n        # 43 -> 101011\n        # 44 -> 101100\n        # 45 -> 101101\n        # 46 -> 101110\n        # 47 -> 101111\n        # 48 -> 110000\n        # 49 -> 110001\n        # 50 -> 110010\n        # 51 -> 110011\n        # 52 -> 110100\n        # 53 -> 110101\n        # 54 -> 110110\n        # 55 -> 110111\n        # 56 -> 111000\n        # 57 -> 111001\n        # 58 -> 111010\n        # 59 -> 111011\n        # 60 -> 111100\n        # 61 -> 111101\n        # 62 -> 111110\n        # 63 -> 111111\n        # 64 -> 1000000\n        # 65 -> 1000001\n        # 66 -> 1000010\n        # 67 -> 1000011\n        # 68 -> 1000100\n        # 69 -> 1000101\n        # 70 -> 1000110\n        # 71 -> 1000111\n        # 72 -> 1001000\n        # 73 -> 1001001\n        # 74 -> 1001010\n        # 75 -> 1001011\n        # 76 -> 1001100\n        # 77"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 0 -> 0\n        # 1 -> 1\n        # 2 -> 10\n        # 3 -> 11\n        # 4 -> 100\n        # 5 -> 101\n        # 6 -> 110\n        # 7 -> 111\n        # 8 -> 1000\n        # 9 -> 1001\n        # 10 -> 1010\n        # 11 -> 1011\n        # 12 -> 1100\n        # 13 -> 1101\n        # 14 -> 1110\n        # 15 -> 1111\n        # 16 -> 10000\n        # 17 -> 10001\n        # 18 -> 10010\n        # 19 -> 10011\n        # 20 -> 10100\n        # 21 -> 10101\n        # 22 -> 10110\n        # 23 -> 10111\n        # 24 -> 11000\n        # 25 -> 11001\n        # 26 -> 11010\n        # 27 -> 11011\n        # 28 -> 11100\n        # 29 -> 11101\n        # 30 -> 11110\n        # 31 -> 11111\n        # 32 -> 100000\n        # 33 -> 100001\n        # 34 -> 100010\n        # 35 -> 100011\n        # 36 -> 100100\n        # 37 -> 100101\n        # 38 -> 100110\n        # 39 -> 100111\n        # 40 -> 101000\n        # 41 -> 101001\n        # 42 -> 101010\n        # 43 -> 101011\n        # 44 -> 101100\n        # 45 -> 101101\n        # 46 -> 101110\n        # 47 -> 101111\n        # 48 -> 110000\n        # 49 -> 110001\n        # 50 -> 110010\n        # 51 -> 110011\n        # 52 -> 110100\n        # 53 -> 110101\n        # 54 -> 110110\n        # 55 -> 110111\n        # 56 -> 111000\n        # 57 -> 111001\n        # 58 -> 111010\n        # 59 -> 111011\n        # 60 -> 111100\n        # 61 -> 111101\n        # 62 -> 111110\n        # 63 -> 111111\n        # 64 -> 1000000\n        # 65 -> 1000001\n        # 66 -> 1000010\n        # 67 -> 1000011\n        # 68 -> 1000100\n        # 69 -> 1000101\n        # 70 -> 1000110\n        # 71 -> 1000111\n        # 72 -> 1001000\n        # 73 -> 1001001\n        # 74 -> 1001010\n        # 75 -> 1001011\n        # 76 -> 1001100\n        # 77"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None, return None\n        if head is None:\n            return None\n        \n        # if head.val == val, return removeElements(head.next, val)\n        if head.val == val:\n            return self.removeElements(head.next, val)\n        \n        # if head.val != val, return ListNode(head.val, self.removeElements(head.next, val))\n        return ListNode(head.val, self.removeElements(head.next, val))"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. skip the current node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. skip the current node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. skip the current node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. skip the current node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and selfcramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and selfcramble(s1[i:], s2[:-i]):\n                return True\n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        def dfs(i, j, node, word):\n            if '#' in node:\n                res.add(word)\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            tmp = board[i][j]\n            if tmp in node:\n                board[i][j] = '.'\n                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    dfs(i + di, j + dj, node[tmp], word + tmp)\n                board[i][j] = tmp\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    dfs(i, j, trie[board[i][j]], board[i][j])\n        return list(res)"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        m, n = len(board), len(board[0])\n        res = []\n        def dfs(i, j, node, word):\n            if '#' in node:\n                res.append(word)\n                del node['#']\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in node:\n                return\n            char = board[i][j]\n            board[i][j] = '.'\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                dfs(x, y, node[char], word+char)\n            board[i][j] = char\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    dfs(i, j, trie, '')\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        def dfs(i, j, node, pre, visited):\n            if '#' in node:\n                res.add(pre)\n            if not (0 <= i < len(board) and 0 <= j < len(board[0])) or (i, j) in visited or board[i][j] not in node:\n                return\n            visited.add((i, j))\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                dfs(x, y, node[board[i][j]], pre + board[i][j], visited)\n            visited.remove((i, j))\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, trie, '', set())\n        return list(res)"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        m, n = len(board), len(board[0])\n        res = []\n        def dfs(i, j, node, word):\n            if '#' in node:\n                res.append(word)\n                del node['#']\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in node:\n                return\n            char = board[i][j]\n            board[i][j] = '.'\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                dfs(x, y, node[char], word+char)\n            board[i][j] = char\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    dfs(i, j, trie[board[i][j]], board[i][j])\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        m, n = len(board), len(board[0])\n        res = []\n        def dfs(i, j, node, word):\n            if '#' in node:\n                res.append(word)\n                del node['#']\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in node:\n                return\n            char = board[i][j]\n            board[i][j] = '.'\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                dfs(x, y, node[char], word+char)\n            board[i][j] = char\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    dfs(i, j, trie, '')\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        return s_dict == t_dict"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        return s_dict == t_dict"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        return s_dict == t_dict"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        return s_dict == t_dict"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        return s_dict == t_dict"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the list with the string representation of 1.\n        answer = ['1']\n        \n        # Loop from 2 to n, appending the appropriate string representation to the list.\n        for i in range(2, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        \n        return answer"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of strings\n        # iterate through the list\n        # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # if the index is divisible by 3, append \"Fizz\"\n        # if the index is divisible by 5, append \"Buzz\"\n        # if the index is not divisible by 3 or 5, append the index as a string\n        # return the list\n        \n        # create a list of strings\n        result = []\n        \n        # iterate through the list\n        for i in range(1, n+1):\n            # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # if the index is not divisible by 3 or 5, append the index as a string\n            else:\n                result.append(str(i))\n        \n        # return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of strings\n        # iterate through the list\n        # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # if the index is divisible by 3, append \"Fizz\"\n        # if the index is divisible by 5, append \"Buzz\"\n        # if the index is not divisible by 3 or 5, append the index as a string\n        # return the list\n        \n        # create a list of strings\n        result = []\n        \n        # iterate through the list\n        for i in range(1, n + 1):\n            # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # if the index is not divisible by 3 or 5, append the index as a string\n            else:\n                result.append(str(i))\n        \n        # return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of strings\n        # iterate through the list\n        # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # if the index is divisible by 3, append \"Fizz\"\n        # if the index is divisible by 5, append \"Buzz\"\n        # if the index is not divisible by 3 or 5, append the index as a string\n        # return the list\n        \n        # create a list of strings\n        result = []\n        \n        # iterate through the list\n        for i in range(1, n + 1):\n            # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # if the index is not divisible by 3 or 5, append the index as a string\n            else:\n                result.append(str(i))\n        \n        # return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the list with the string representation of 1.\n        answer = ['1']\n        \n        # Loop from 2 to n, appending to the list each time.\n        for i in range(2, n + 1):\n            # If i is divisible by 3 and 5, append FizzBuzz.\n            if i % 15 == 0:\n                answer.append('FizzBuzz')\n            # Else if i is divisible by 3, append Fizz.\n            elif i % 3 == 0:\n                answer.append('Fizz')\n            # Else if i is divisible by 5, append Buzz.\n            elif i % 5 == 0:\n                answer.append('Buzz')\n            # Otherwise, append the string representation of i.\n            else:\n                answer.append(str(i))\n        \n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the reversed list of words with a single space\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the reversed list of words with a single space\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. reverse the list\n        # 3. join the list\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. reverse the list\n        words.reverse()\n        \n        # 3. join the list\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. reverse the list\n        # 3. join the list\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. reverse the list\n        words.reverse()\n        \n        # 3. join the list\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the reversed list of words with a single space\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        \n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                left[i] = left[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                right[i] = right[i+1] + 1\n        \n        return sum(max(left[i], right[i]) for i in range(n))"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        \n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                left[i] = left[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                right[i] = right[i+1] + 1\n        \n        return sum(max(left[i], right[i]) for i in range(n))"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        \n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n            else:\n                if d[pattern[i]] != s[i]:\n                    return False\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n            else:\n                if d[pattern[i]] != s[i]:\n                    return False\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern is not equal to the length of the words, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between pattern and words\n        mapping = {}\n        \n        # create a set to store the words that have already been mapped\n        seen = set()\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern character is not in the mapping, add it to the mapping\n            if pattern[i] not in mapping:\n                # if the word has already been seen, return False\n                if words[i] in seen:\n                    return False\n                # add the mapping and the word to the set\n                mapping[pattern[i]] = words[i]\n                seen.add(words[i])\n            # if the pattern character is in the mapping, check if the mapping is correct\n            else:\n                # if the mapping is not correct, return False\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the mappings are correct, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words and characters in the pattern are the same\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between characters and words\n        char_to_word = {}\n        word_to_char = {}\n        \n        # iterate through the characters and words\n        for i in range(len(pattern)):\n            char = pattern[i]\n            word = words[i]\n            \n            # check if the character is already in the dictionary\n            if char in char_to_word:\n                # check if the corresponding word is the same as the one we have stored\n                if char_to_word[char] != word:\n                    return False\n            else:\n                # check if the word is already in the dictionary\n                if word in word_to_char:\n                    return False\n                # add the mapping to the dictionaries\n                char_to_word[char] = word\n                word_to_char[word] = char\n        \n        # if we have made it through the entire string, the pattern is valid\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n            else:\n                if d[pattern[i]] != s[i]:\n                    return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if target == mid_element:\n                return True\n            elif target < mid_element:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if target == mid_element:\n                return True\n            elif target < mid_element:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if target == mid_element:\n                return True\n            elif target < mid_element:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if target == mid_element:\n                return True\n            elif target < mid_element:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if target == mid_element:\n                return True\n            elif target < mid_element:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # loop through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            total = val1 + val2 + carry\n            \n            # update the carry\n            carry = total // 10\n            \n            # create a new node with the last digit of the sum\n            curr.next = ListNode(total % 10)\n            \n            # move to the next node in each linked list\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the result linked list (excluding the dummy node)\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result linked list\n        result = ListNode(0)\n        result_tail = result\n        carry = 0\n        \n        # While both lists exist\n        while l1 or l2 or carry:\n            # Get the value of the current node in each list\n            val1 = (l1.val if l1 else 0)\n            val2 = (l2.val if l2 else 0)\n            \n            # Calculate the sum of the values and the carry\n            carry, out = divmod(val1 + val2 + carry, 10)\n            \n            # Create a new node with the sum value\n            result_tail.next = ListNode(out)\n            result_tail = result_tail.next\n            \n            # Move to the next node in each list\n            l1 = (l1.next if l1 else None)\n            l2 = (l2.next if l2 else None)\n        \n        return result.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # loop through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            total = val1 + val2 + carry\n            \n            # update the carry\n            carry = total // 10\n            \n            # create a new node with the last digit of the sum\n            curr.next = ListNode(total % 10)\n            \n            # move to the next node in each linked list\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the next node of the dummy node (which is the head of the result linked list)\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # iterate through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            total = val1 + val2 + carry\n            \n            # update the carry\n            carry = total // 10\n            \n            # create a new node with the last digit of the sum\n            curr.next = ListNode(total % 10)\n            \n            # move to the next node in each linked list\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the next node of the dummy node (which is the head of the result linked list)\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # iterate through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            total = val1 + val2 + carry\n            \n            # update the carry\n            carry = total // 10\n            \n            # create a new node with the last digit of the sum\n            curr.next = ListNode(total % 10)\n            \n            # move to the next node in each linked list\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the next node of the dummy node (which is the head of the result linked list)\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = ''.join(['1' if x == '0' else '0' for x in binary])\n        \n        # convert back to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = ''.join(['1' if x == '0' else '0' for x in binary])\n        \n        # convert back to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert num to binary\n        # 2. flip all 0s to 1s and all 1s to 0s\n        # 3. convert binary to decimal\n        \n        # convert num to binary\n        binary = bin(num)[2:]\n        \n        # flip all 0s to 1s and all 1s to 0s\n        binary = binary.replace('0', 'x')\n        binary = binary.replace('1', '0')\n        binary = binary.replace('x', '1')\n        \n        # convert binary to decimal\n        return int(binary, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = ''.join(['1' if x == '0' else '0' for x in binary])\n        \n        # convert back to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = ''.join(['1' if x == '0' else '0' for x in binary])\n        \n        # convert back to decimal\n        return int(flipped, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 3. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 4. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 5. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 6. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 7. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 8. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 9. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 10. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 11. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 12. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 13. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 14. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 15. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 16. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 17. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 18. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 19. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 20. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 21. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 22. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 23. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 24. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 25. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 26. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 27. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 28. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 29. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 30. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 31. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 32. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 33. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 3. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 4. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 5. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 6. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 7. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 8. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 9. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 10. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 11. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 12. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 13. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 14. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 15. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 16. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 17. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 18. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 19. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 20. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 21. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 22. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 23. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 24. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 25. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 26. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 27. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 28. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 29. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 30. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 31. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 32. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5426\u5219\u53f3\u5bf9\u9f50\n        # 33. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u5bf9\u9f50\uff0c\u4e2d\u95f4\u8865\u7a7a\u683c\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8865\u7a7a\u683c\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff1b\u5982\u679c\u5b50\u6570\u7ec4\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5c3d\u91cf\u5e73\u5747\u5206\u914d\n        # 3. \u5bf9\u4e8e\u6700\u540e\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u5de6\u5bf9\u9f50\uff0c\u53f3\u8fb9\u8865\u7a7a\u683c\uff0c\u7a7a\u683c\u5168\u90e8\u8865\u5728\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u53f3\u8fb9\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5c06words\u5206\u7ec4\n        # 2. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 3. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 4. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 5. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 6. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 7. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 8. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 9. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 10. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 11. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 12. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 13. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 14. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 15. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 16. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 17. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 18. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 19. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 20. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 21. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 22. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 23. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 24. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 25. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 26. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 27. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 28. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 29. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 30. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 31. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 32. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 33. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 34. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 35. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 36. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 37. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 38. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 39. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 40. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 41. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a\u683c\u6570\n        # 42. \u8ba1\u7b97\u6bcf\u7ec4\u7684\u7a7a"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        \n        left, right = 0, len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        \n        left, right = 0, len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        \n        left, right = 0, len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        \n        left, right = 0, len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        \n        left, right = 0, len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        wordSet = set()\n        res = []\n        \n        for word in words:\n            if self.dfs(word, wordSet):\n                res.append(word)\n            wordSet.add(word)\n        return res\n    \n    def dfs(self, word, wordSet):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in wordSet and suffix in wordSet:\n                return True\n            if prefix in wordSet and self.dfs(suffix, wordSet):\n                return True\n        return False"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=len)\n        word_set = set()\n        res = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                res.append(word)\n            word_set.add(word)\n        \n        return res\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and suffix in word_set:\n                return True\n            if prefix in word_set and self.dfs(suffix, word_set):\n                return True\n        \n        return False"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=len)\n        word_set = set()\n        res = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                res.append(word)\n            word_set.add(word)\n        return res\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and suffix in word_set:\n                return True\n            if prefix in word_set and self.dfs(suffix, word_set):\n                return True\n        return False"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        words_set = set(words)\n        res = []\n        \n        def dfs(word):\n            if word in words_set:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words_set and dfs(suffix):\n                    return True\n            return False\n        \n        for word in words:\n            if dfs(word):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=len)\n        words_set = set(words)\n        res = []\n        \n        def dfs(word):\n            if word in words_set:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words_set and dfs(suffix):\n                    return True\n            return False\n        \n        for word in words:\n            if dfs(word):\n                res.append(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        res = \"\"\n        if num < 0:\n            res += \"-\"\n            num = -num\n        \n        while num > 0:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        res = \"\"\n        if num < 0:\n            res += \"-\"\n            num = -num\n        \n        while num > 0:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_diff, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_diff and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_diff+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            tmp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = tmp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            tmp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = tmp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 3. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 4. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 5. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 6. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 7. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 8. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 9. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 10. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 11. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 12. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 13. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 14. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 15. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 16. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 17. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 18. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 19. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 20. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 21. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 22. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 23. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 24. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 25. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 26. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 27. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 28. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 29. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 30. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 31. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 32. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 33. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 34. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 35. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 36. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 37. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 38. 2 pointers,"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 3. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 4. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 5. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 6. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 7. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 8. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 9. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 10. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 11. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 12. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 13. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 14. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 15. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 16. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 17. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 18. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 19. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 20. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 21. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 22. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 23. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 24. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 25. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 26. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 27. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 28. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 29. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 30. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 31. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 32. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 33. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 34. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 35. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 36. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 37. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 38. 2 pointers,"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 2 pointers\n        # 1. start from the end of nums1\n        # 2. compare the last element of nums1 and nums2\n        # 3. if nums1 > nums2, then move nums1 to the end\n        # 4. if nums1 < nums2, then move nums2 to the end\n        # 5. if nums1 == nums2, then move nums2 to the end\n        # 6. if nums2 is empty, then stop\n        # 7. if nums1 is empty, then move nums2 to nums1\n        # 8. if nums1 is not empty and nums2 is empty, then stop\n        \n        # 1. start from the end of nums1\n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        # 2. compare the last element of nums1 and nums2\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        # 7. if nums1 is empty, then move nums2 to nums1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 3. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 4. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 5. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 6. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 7. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 8. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 9. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 10. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 11. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 12. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 13. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 14. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 15. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 16. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 17. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 18. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 19. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 20. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 21. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 22. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 23. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 24. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 25. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 26. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 27. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 28. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 29. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 30. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 31. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 32. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 33. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 34. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 35. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 36. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 37. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 38. 2 pointers,"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 3. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 4. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 5. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 6. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 7. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 8. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 9. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 10. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 11. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 12. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 13. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 14. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 15. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 16. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 17. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 18. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 19. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 20. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 21. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 22. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 23. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 24. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 25. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 26. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 27. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 28. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 29. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 30. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 31. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 32. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 33. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 34. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 35. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 36. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 37. 2 pointers, 1 pointer for nums1, 1 pointer for nums2\n        # 38. 2 pointers,"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current element is not equal to the previous element, increment the count\n        # 4. if the count is 3, return the current element\n        # 5. if the count is 3 and the current element is less than the previous element, return the previous element\n        # 6. if the count is 3 and the current element is greater than the previous element, return the current element\n        # 7. if the count is less than 3, return the current element\n        \n        nums.sort(reverse=True)\n        count = 1\n        prev = nums[0]\n        for num in nums:\n            if num != prev:\n                count += 1\n                prev = num\n                if count == 3:\n                    return num\n        return nums[0]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # nums = set(nums)\n        # nums = list(nums)\n        # nums.sort(reverse=True)\n        # if len(nums) < 3:\n        #     return nums[0]\n        # else:\n        #     return nums[2]\n        \n        # 2.\n        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums)\n        nums.remove(max(nums))\n        nums.remove(max(nums))\n        return max(nums)"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # nums = set(nums)\n        # nums = list(nums)\n        # nums.sort(reverse=True)\n        # if len(nums) < 3:\n        #     return nums[0]\n        # else:\n        #     return nums[2]\n        \n        # 2.\n        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums)\n        nums.remove(max(nums))\n        nums.remove(max(nums))\n        return max(nums)"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5 \uc81c\uac70\n        # 2. \uc815\ub82c\n        # 3. \uae38\uc774\uac00 3 \uc774\uc0c1\uc774\uba74 3\ubc88\uc9f8 \uc6d0\uc18c \ubc18\ud658\n        # 4. \uae38\uc774\uac00 3 \ubbf8\ub9cc\uc774\uba74 \uac00\uc7a5 \ud070 \uc6d0\uc18c \ubc18\ud658\n        \n        nums = set(nums)\n        nums = list(nums)\n        nums.sort(reverse=True)\n        \n        if len(nums) >= 3:\n            return nums[2]\n        else:\n            return nums[0]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5 \uc81c\uac70\n        nums = list(set(nums))\n        \n        # 2. \uc815\ub82c\n        nums.sort(reverse=True)\n        \n        # 3. \uc870\uac74\uc5d0 \ub9de\uac8c \ubc18\ud658\n        if len(nums) < 3:\n            return nums[0]\n        else:\n            return nums[2]"}]}