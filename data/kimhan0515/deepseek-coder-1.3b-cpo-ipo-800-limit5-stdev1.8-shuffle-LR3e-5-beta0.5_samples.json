{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Find the first positive number\n        # 3. Iterate through the array and check if the number is in the range [1, len(nums)]\n        # 4. If the number is not in the range, return it\n        # 5. If the number is in the range, swap it with the number at the index of the number - 1\n        # 6. Repeat steps 3-5 until the number at the index of the number - 1 is not in the range [1, len(nums)]\n        # 7. Return the length of the array + 1\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Find the first positive number\n        i = 0\n        while i < len(nums) and nums[i] <= 0:\n            i += 1\n        \n        # 3. Iterate through the array and check if the number is in the range [1, len(nums)]\n        # 4. If the number is not in the range, return it\n        # 5. If the number is in the range, swap it with the number at the index of the number - 1\n        # 6. Repeat steps 3-5 until the number at the index of the number - 1 is not in the range [1, len(nums)]\n        # 7. Return the length of the array + 1\n        if i == len(nums):\n            return 1\n        \n        j = 0\n        while j < len(nums):\n            if nums[j] <= 0:\n                j += 1\n            elif nums[j] == j + 1:\n                j += 1\n            else:\n                if nums[j] > len(nums) or nums[j] <= 0:\n                    j += 1\n                else:\n                    temp = nums[j]\n                    nums[j] = nums[nums[j] - 1]\n                    nums[temp - 1] = temp\n        \n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # 1. set left and right pointers\n        # 2. if the sum is greater than target, move right pointer to the left\n        # 3. if the sum is less than target, move left pointer to the right\n        # 4. if the sum is equal to target, return the indices\n        # 5. if the sum is not equal to target, move left pointer to the right\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                left += 1\n        \n        return [left + 1, right + 1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            if curr != 0:\n                backtrack(i + 1, curr * 10 + int(num[i]), prev, res, op + '*' + num[i])\n            if curr != 0:\n                backtrack(i + 1, curr + int(num[i]), int(num[i]), res, op + '+' + num[i])\n            if curr != 0:\n                backtrack(i + 1, curr - int(num[i]), -int(num[i]), res, op + '-' + num[i])\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left = dfs(root.left, curr_sum * 10 + root.val)\n            right = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left + right\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        if len(s) <= k:\n            return s\n        else:\n            return '-'.join(s[i:i+k] for i in range(0, len(s), k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if digits[-1] < 9:\n            digits[-1] += 1\n            return digits\n        else:\n            digits[-1] = 0\n            for i in range(len(digits)-2,-1,-1):\n                if digits[i] < 9:\n                    digits[i] += 1\n                    return digits\n                else:\n                    digits[i] = 0\n            digits.insert(0,1)\n            return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return false if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', check if the first character of s is '*' or the first character of s is not '*'\n            if p[0] == '*' and self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is '*' or the first character of s is not '*'\n            elif p[0] == '*' and self.isMatch(s[1:], p[2:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            elif p[0] != '*' and s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p[1:])\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            else:\n                return False\n        # if p is not empty, check if the first character of p is '*'\n        elif p[0] == '*':\n            # if the first character of p is '*', check if the first character of s is '*' or the first character of s is not '*'\n            if p[0] == '*' and self.isMatch(s, p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is '*' or the first character of s is not '*'\n            elif p[0] == '*' and self.isMatch(s[1:], p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            elif p[0] != '*' and s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p[1:])\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            else:\n                return False\n        # if p is not empty, check if the first character of p is '*'\n        elif p[0] == '*':\n            # if the first character of p is '*', check if the first character of s is '*' or the first character of s is not '*'\n            if p[0] == '*' and self.isMatch(s, p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is '*' or the first character of s is not '*'\n            elif p[0] == '*' and self.isMatch(s[1:], p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            elif p[0] != '*' and s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p[1:])\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            else:\n                return False\n        # if p is not empty, check if the first character of p is '*'\n        elif p[0] == '*':\n            # if the first character of p is '*', check if the first character of s is '*' or the first character of s is not '*'\n            if p[0] == '*' and self.isMatch(s, p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is '*' or the first character of s is not '*'\n            elif p[0] == '*' and self.isMatch(s[1:], p[1:]):\n                return True\n            # if the first character of p is not"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            res = []\n            for i in range(len(nums)):\n                if len(res) > k:\n                    break\n                if nums[i] > res[-1]:\n                    res.append(nums[i])\n            return res\n        \n        if len(nums1) > k:\n            return pick(nums1, k)\n        if len(nums2) > k:\n            return pick(nums2, k)\n        \n        res = []\n        for i in range(k):\n            if len(nums1) > i and len(nums2) > k - i:\n                if nums1[i] > nums2[i]:\n                    res.append(nums1[i])\n                else:\n                    res.append(nums2[i])\n            elif len(nums1) > i:\n                res.append(nums1[i])\n            else:\n                res.append(nums2[i])\n        return res"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                sum += i\n                if i * i < num:\n                    sum += num // i\n            i += 1\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[m][n-1] = dp[m-1][n] = 1\n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j],1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while nums[i] - nums[j] > mid:\n                    j += 1\n                count += i - j\n            if count >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = []\n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowel_indices.append(i)\n        \n        vowel_indices.reverse()\n        vowel_indices_set = set(vowel_indices)\n        vowel_indices_set.discard(len(s)-1)\n        vowel_indices_set.discard(0)\n        vowel_indices_set = list(vowel_indices_set)\n        vowel_indices_set.sort()\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices_set.append(len(s)-1)\n        vowel_indices_set.insert(0, 0)\n        vowel_indices"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums_set:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## XOR all the numbers from 0 to n\n        ## XOR all the numbers from 0 to n+1\n        ## XOR all the numbers from 0 to n+2\n        ## XOR all the numbers from 0 to n+3\n        ## XOR all the numbers from 0 to n+4\n        ## XOR all the numbers from 0 to n+5\n        ## XOR all the numbers from 0 to n+6\n        ## XOR all the numbers from 0 to n+7\n        ## XOR all the numbers from 0 to n+8\n        ## XOR all the numbers from 0 to n+9\n        ## XOR all the numbers from 0 to n+10\n        ## XOR all the numbers from 0 to n+11\n        ## XOR all the numbers from 0 to n+12\n        ## XOR all the numbers from 0 to n+13\n        ## XOR all the numbers from 0 to n+14\n        ## XOR all the numbers from 0 to n+15\n        ## XOR all the numbers from 0 to n+16\n        ## XOR all the numbers from 0 to n+17\n        ## XOR all the numbers from 0 to n+18\n        ## XOR all the numbers from 0 to n+19\n        ## XOR all the numbers from 0 to n+20\n        ## XOR all the numbers from 0 to n+21\n        ## XOR all the numbers from 0 to n+22\n        ## XOR all the numbers from 0 to n+23\n        ## XOR all the numbers from 0 to n+24\n        ## XOR all the numbers from 0 to n+25\n        ## XOR all the numbers from 0 to n+26\n        ## XOR all the numbers from 0 to n+27\n        ## XOR all the numbers from 0 to n+28\n        ## XOR all the numbers from 0 to n+29\n        ## XOR all the numbers from 0 to n+30\n        ## XOR all the numbers from 0 to n+31\n        ## XOR all the numbers from 0 to n+32\n        ## XOR all the numbers from 0 to n+33\n        ## XOR all the numbers from 0 to n+34\n        ## XOR all the numbers from 0 to n+35\n        ## XOR all the numbers from 0 to n+36\n        ## XOR all the numbers from 0 to n+37\n        ## XOR all the numbers from 0 to n+38\n        ## XOR all the numbers from 0 to n+39\n        ## XOR all the numbers from 0 to n+40\n        ## XOR all the numbers from 0 to n+41\n        ## XOR all the numbers from 0 to n+42\n        ## XOR all the numbers from 0 to n+43\n        ## XOR all the numbers from 0 to n+44\n        ## XOR all the numbers from 0 to n+45\n        ## XOR all the numbers from 0 to n+46\n        ## XOR all the numbers from 0 to n+47\n        ## XOR all the numbers from 0 to n+48\n        ## XOR all the numbers from 0 to n+49\n        ## XOR all the numbers from 0 to n+50\n        ## XOR all the numbers from 0 to n+51\n        ## XOR all the numbers from 0 to n+52\n        ## XOR all the numbers from 0 to n+53\n        ## XOR all the numbers from 0 to n+54\n        ## XOR all the numbers from 0 to n+55\n        ## XOR all the numbers from 0 to n+56\n        ## XOR all the numbers from 0 to n+57\n        ## XOR all"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n * m)\n        # Space Complexity: O(n)\n        \n        # Create a set of words from the wordList\n        wordSet = set(wordList)\n        \n        # Add beginWord to the set\n        wordSet.add(beginWord)\n        \n        # Create a queue and add beginWord\n        queue = collections.deque([beginWord])\n        \n        # Create a set to keep track of visited words\n        visited = set()\n        \n        # Create a variable to keep track of the number of words in the queue\n        numWords = 1\n        \n        # While the queue is not empty\n        while queue:\n            # Get the number of words in the queue\n            numWords = len(queue)\n            \n            # For each word in the queue\n            for _ in range(numWords):\n                # Pop the first word from the queue\n                word = queue.popleft()\n                \n                # If the word is the endWord, return the number of words in the queue\n                if word == endWord:\n                    return numWords\n                \n                # Add the word to the visited set\n                visited.add(word)\n                \n                # For each character in the word\n                for i in range(len(word)):\n                    # For each letter in the alphabet\n                    for letter in string.ascii_lowercase:\n                        # If the letter is not the current character\n                        if letter != word[i]:\n                            # Create a new word by replacing the i-th character with the letter\n                            newWord = word[:i] + letter + word[i+1:]\n                            \n                            # If the new word is in the set of words, add it to the queue\n                            if newWord in wordSet:\n                                # Add the new word to the queue\n                                queue.append(newWord)\n                                # Remove the new word from the set of words\n                                wordSet.remove(newWord)\n        \n        # If the endWord is not in the set of words, return 0\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = \"\"\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        \n        if carry == 1:\n            res += \"1\"\n        \n        return res[::-1]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1,-1]\n        \n        left = 0\n        right = len(nums)-1\n        while left < right:\n            mid = (left+right)//2\n            if nums[mid] < target:\n                left = mid+1\n            else:\n                right = mid\n        if nums[left] != target:\n            return [-1,-1]\n        else:\n            left_index = left\n            right = len(nums)-1\n            while left < right:\n                mid = (left+right)//2+1\n                if nums[mid] > target:\n                    right = mid-1\n                else:\n                    left = mid\n            return [left_index,right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] != nums[j]:\n                i += 1\n                nums[i] = nums[j]\n            j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(1, n):\n            if i > max_reach:\n                jumps += 1\n                max_reach = curr_reach\n            curr_reach = max(curr_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(0,len(prices)-1)) for i in range(0,len(prices)-1,2))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        for i in range(1,len(prices)):\n            for j in range(1,k+1):\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j][0]-prices[i])\n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_str = \"\"\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_str = str(remainder) + hex_str\n            else:\n                hex_str = hex_dict[remainder] + hex_str\n            num = num // 16\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # Iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the index of the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if indexDiff < 0 or valueDiff < 0:\n            return False\n        \n        if len(nums) < 2:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= nums[-1] - nums[0]:\n            return True\n        \n        nums.sort()\n        \n        for i in range(len(nums)-1):\n            if nums[i+1] - nums[i] <= valueDiff:\n                if abs(nums[i+1] - nums[i]) <= valueDiff:\n                    return True\n                else:\n                    if i+indexDiff < len(nums):\n                        if abs(nums[i+1] - nums[i+indexDiff]) <= valueDiff:\n                            return True\n                    else:\n                        return False\n        \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i] == ' ':\n                continue\n            if s[i] == '+':\n                num = num * sign\n                sign = 1\n            elif s[i] == '-':\n                num = num * sign\n                sign = -1\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num = num * sign\n                num += stack.pop()\n                num *= stack.pop()\n            else:\n                num = num * 10 + int(s[i])\n        return num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # if capital[i] <= w, then profits[i] is the profit\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w, then profits[i] is 0\n        # if capital[i] > w,"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is bigger than the number that is smaller\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller\n        # if the number that is smaller is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if the number that is smaller is the last number, reverse the whole list\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # find the number that is bigger than the number that is smaller\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the number that is smaller\n        left, right = i+1, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        return"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Store the index of the number in the hashmap\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 2:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(1, n//2):\n            if couples[i][0] != couples[i-1][1]:\n                swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            for c in word:\n                if c not in row:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next or left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        for _ in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        tail = curr\n        for _ in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the reverse string to the end of the string\n        # return the string\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # find the longest palindrome that is a prefix of the string\n        # add the reverse string to the end of the string\n        # return the string\n        for i in range(len(s)):\n            if s[:i+1] == s[i::-1]:\n                return s[i::-1] + s\n        \n        return s"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        # Create a hashmap for the characters in t\n        # and their frequencies\n        t_map = {}\n        for char in t:\n            if char not in t_map:\n                t_map[char] = 1\n            else:\n                t_map[char] += 1\n        \n        # Create a hashmap for the characters in s\n        # and their frequencies\n        s_map = {}\n        for char in s:\n            if char not in s_map:\n                s_map[char] = 1\n            else:\n                s_map[char] += 1\n        \n        # Initialize the window\n        left = 0\n        right = 0\n        min_window = \"\"\n        min_length = float('inf')\n        \n        # Iterate through the characters in s\n        while right < len(s):\n            # If the character is in t, add it to the window\n            if s[right] in t_map:\n                if s[right] in s_map:\n                    s_map[s[right]] -= 1\n                else:\n                    s_map[s[right]] = 1\n                if s_map[s[right]] <= t_map[s[right]]:\n                    if right - left + 1 < min_length:\n                        min_window = s[left:right+1]\n                        min_length = right - left + 1\n                right += 1\n            else:\n                right += 1\n        \n        return min_window"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) < 4:\n            return False\n        \n        if distance[0] == distance[3] and distance[1] == distance[2]:\n            return True\n        \n        if distance[1] == distance[3] and distance[0] + distance[4] >= distance[2]:\n            return True\n        \n        if distance[0] == distance[2] and distance[1] + distance[3] >= distance[4]:\n            return True\n        \n        if distance[1] + distance[3] == distance[5] and distance[0] == distance[4]:\n            return True\n        \n        if distance[0] + distance[2] == distance[4] and distance[1] == distance[3]:\n            return True\n        \n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\uc5d0\ufffd"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find all the trees in the forest\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i, j))\n        \n        # 2. Sort the trees by height\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        \n        # 3. Start from the starting point and cut off the trees\n        start = (0, 0)\n        steps = 0\n        for tree in trees:\n            steps += self.cutOffTreeHelper(forest, start, tree)\n            if steps == -1:\n                return -1\n            start = tree\n        \n        return steps\n    \n    def cutOffTreeHelper(self, forest, start, end):\n        # 1. Calculate the distance between the start and end points\n        i, j = start\n        j, k = end\n        distance = abs(i - j) + abs(j - k)\n        \n        # 2. Move the start point to the end point\n        while i != j:\n            if i < j:\n                i += 1\n            else:\n                j += 1\n        \n        # 3. Check if the start point is within the forest boundaries\n        if i < 0 or i >= len(forest) or j < 0 or j >= len(forest[0]):\n            return -1\n        \n        # 4. Check if the start point is a tree\n        if forest[i][j] == 0:\n            return -1\n        \n        # 5. Cut off the tree and return the distance\n        return distance"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u524d\u7f00\u548c\u7684\u9891\u7387\n        # 3. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 4. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 5. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 6. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 7. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 8. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 9. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 10. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 11. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 12. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 13. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 14. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 15. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 16. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 17. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 18. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 19. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 20. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 21. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 22. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 23. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 24. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 25. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 26. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 27. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 28. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 29. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 30. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 31. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 32. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 33. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 34. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 35. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 36. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 37. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 38. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 39. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 40. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 41. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 42. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 43. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 44. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 45. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 46. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 47. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 48. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 49. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 50. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 51. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 52. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 53. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 54. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 55. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 56. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 57. \u904d\u5386\u524d\u7f00\u548c\uff0c\u7edf\u8ba1\u9891\u7387\n        # 58. \u904d\u5386\u524d"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k = k(k+1)/2\n        # k^2 + k - 2n = 0\n        # k = (-1 + sqrt(1 + 8n))/2\n        return int((-1 + sqrt(1 + 8*n))/2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n            res.append(temp)\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        temp = x\n        while temp > 0:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        return rev == x"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0]\n        for i in range(1,n):\n            res.append(res[-1] + (1<<i))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (node.val <= left or node.val >= right):\n                return False\n            \n            return valid(node.left, left, node.val) and valid(node.right, node.val, right)\n        \n        return valid(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not empty\n        # if newInterval is smaller than the first interval in intervals\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if newInterval is larger than the last interval in intervals\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1]:\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is not overlapping with the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] < intervals[-1][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] >= intervals[-1][0]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is not overlapping with the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] >= intervals[-1][0] and newInterval[1] < intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] >= intervals[-1][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] >= intervals[-1][0] and newInterval[1] >= intervals[-1][1] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] >= intervals[-1][0] and newInterval[1] >= intervals[-1][1] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is larger than the first interval in intervals\n        # and smaller than the last interval in intervals\n        # and the newInterval is overlapping with the last interval in intervals\n        #"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            \n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    backtrack(s, i+1, path + [s[start:i+1]], res)\n        \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ufffd"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 1000 / 15 = 62.5\n        # 62.5 + 1 = 63\n        # 63 - 1 = 62\n        # 62 / 3 = 21.666666666666668\n        # 21.666666666666668 - 1 = 21\n        # 21 + 1 = 22\n        # 22 / 3 = 7.333333333333334\n        # 7.333333333333334 - 1 = 7\n        # 7 + 1 = 8\n        # 8 / 3 = 2.6666666666666665\n        # 2.6666666666666665 - 1 = 2\n        # 2 + 1 = 3\n        # 3 / 3 = 1\n        # 1 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.33333333333333337\n        # 0.33333333333333337 - 1 = 0\n        # 0 + 1 = 1\n        # 1 / 3 = 0.333333333333"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        heap = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        \n        while heap:\n            time, x, y = heapq.heappop(heap)\n            res = max(res, time)\n            if x == n - 1 and y == n - 1:\n                return res\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or nx >= n or ny < 0 or ny >= n or (nx, ny) in visited:\n                    continue\n                heapq.heappush(heap, (grid[nx][ny], nx, ny))\n                visited.add((nx, ny))\n        \n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper():\n            return False\n        else:\n            return True"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3."}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n        \n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1:\n            curr.next = list1\n        elif list2:\n            curr.next = list2\n        \n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j in range(i)\n        # dp[i] = 0 if s[i] is palindrome\n        # dp[0] = -1\n        # dp[1] = 0\n        # dp[2] = 1\n        # dp[3] = 2\n        # dp[4] = 3\n        # dp[5] = 4\n        # dp[6] = 5\n        # dp[7] = 6\n        # dp[8] = 7\n        # dp[9] = 8\n        # dp[10] = 9\n        # dp[11] = 10\n        # dp[12] = 11\n        # dp[13] = 12\n        # dp[14] = 13\n        # dp[15] = 14\n        # dp[16] = 15\n        # dp[17] = 16\n        # dp[18] = 17\n        # dp[19] = 18\n        # dp[20] = 19\n        # dp[21] = 20\n        # dp[22] = 21\n        # dp[23] = 22\n        # dp[24] = 23\n        # dp[25] = 24\n        # dp[26] = 25\n        # dp[27] = 26\n        # dp[28] = 27\n        # dp[29] = 28\n        # dp[30] = 29\n        # dp[31] = 30\n        # dp[32] = 31\n        # dp[33] = 32\n        # dp[34] = 33\n        # dp[35] = 34\n        # dp[36] = 35\n        # dp[37] = 36\n        # dp[38] = 37\n        # dp[39] = 38\n        # dp[40] = 39\n        # dp[41] = 40\n        # dp[42] = 41\n        # dp[43] = 42\n        # dp[44] = 43\n        # dp[45] = 44\n        # dp[46] = 45\n        # dp[47] = 46\n        # dp[48] = 47\n        # dp[49] = 48\n        # dp[50] = 49\n        # dp[51] = 50\n        # dp[52] = 51\n        # dp[53] = 52\n        # dp[54] = 53\n        # dp[55] = 54\n        # dp[56] = 55\n        # dp[57] = 56\n        # dp[58] = 57\n        # dp[59] = 58\n        # dp[60] = 59\n        # dp[61] = 60\n        # dp[62] = 61\n        # dp[63] = 62\n        # dp[64] = 63\n        # dp[65] = 64\n        # dp[66] = 65\n        # dp[67] = 66\n        # dp[68] = 67\n        # dp[69] = 68\n        # dp[70] = 69\n        # dp[71] = 70\n        # dp[72] = 71\n        # dp[73] = 72\n        # dp[74] = 73\n        # dp[75] = 74\n        # dp[76] = 75\n        # dp[77] = 76\n        # dp[78] = 77\n        # dp[79] = 78\n        # dp[80] = 79\n        # dp[81] = 80\n        # dp[82] = 81\n        # d"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Create a hashmap to store the reverse of each word\n        # and its index\n        reverse_map = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # Create a list to store the result\n        result = []\n        \n        # Iterate over the words in the words list\n        for i, word in enumerate(words):\n            # Check if the reverse of the word is in the hashmap\n            if word[::-1] in reverse_map:\n                # If it is, check if the index of the word is not the same as the index of the reverse\n                if i != reverse_map[word[::-1]]:\n                    # If it is, add the index of the word and the index of the reverse to the result\n                    result.append([i, reverse_map[word[::-1]]])\n            # Check if the reverse of the word is not in the hashmap\n            if word in reverse_map:\n                # If it is, check if the index of the word is not the same as the index of the reverse\n                if i != reverse_map[word]:\n                    # If it is, add the index of the reverse and the index of the word to the result\n                    result.append([reverse_map[word], i])\n        \n        # Return the result\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        res = 0\n        while True:\n            # 1. \u611f\u67d3\u533a\u57df\n            infected = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.add((i, j))\n            # 2. \u611f\u67d3\u533a\u57df\u5468\u56f4\u7684\u5899\n            walls = set()\n            for i, j in infected:\n                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                        walls.add((ni, nj))\n            # 3. \u611f\u67d3\u533a\u57df\u5468\u56f4\u7684\u5899\n            for i, j in walls:\n                isInfected[i][j] = 1\n            # 4. \u611f\u67d3\u533a\u57df\u5468\u56f4\u7684\u5899\n            res += 1\n            # 5. \u611f\u67d3\u533a\u57df\u5468\u56f4\u7684\u5899\n            if self.surrounded(isInfected):\n                break\n        return res\n\n    def surrounded(self, isInfected):\n        m, n = len(isInfected), len(isInfected[0])\n        for i in range(m):\n            for j in range(n):\n                if isInfected[i][j] == 1:\n                    return False\n        return True"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n        \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        max_len = 1\n        \n        for d in dirs:\n            x = i + d[0]\n            y = j + d[1]\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                level_nodes.reverse()\n            result.append(level_nodes)\n            level += 1\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn == 0:\n            return ['0:00']\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append(str(h) + ':' + '0'*(1 if m < 10 else 0) + str(m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j] + res[i-1][j-1])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 3 != 0:\n            return False\n        return self.isPowerOfThree(n//3)"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left_gain + right_gain + node.val)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    if heightMap[ni][nj] < h:\n                        ans += h - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n                    visited.add((ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Find the median\n        # 3. Return the median\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Find the median\n        # 2.1 If the length of the array is odd, return the middle element\n        # 2.2 If the length of the array is even, return the average of the middle two elements\n        if len(nums) % 2 == 1:\n            return nums[len(nums) // 2]\n        else:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        curr.next = head\n        \n        k = k % length\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n                if max_sum == k:\n                    return k\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        seen = {0: -1}\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            if prefix_sum - k in seen:\n                max_sum = max(max_sum, prefix_sum - seen[prefix_sum - k])\n            if prefix_sum not in seen:\n                seen[prefix_sum] = i\n            max_sum = max(max_sum, prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        if dividend == -2**31 and divisor == 1:\n            return -2**31\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend/divisor)\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend)/divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend)/abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i,j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(m):\n            dfs(i,0)\n            dfs(i,n-1)\n            \n        for j in range(n):\n            dfs(0,j)\n            dfs(m-1,j)\n            \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards = [a+b, a-b, a*b, float(a)/b] if b != 0 else [a+b, a-b, a*b]\n                        elif op == '-':\n                            new_cards = [a-b, a+b, a*b, float(a)/b] if b != 0 else [a-b, a+b, a*b]\n                        elif op == '*':\n                            new_cards = [a+b, a-b, a*b, float(a)/b] if b != 0 else [a+b, a-b, a*b]\n                        elif op == '/':\n                            new_cards = [a+b, a-b, a*b, float(a)/b] if b != 0 else [a+b, a-b, a*b]\n                        if dfs(new_cards, target):\n                            return True\n            return False\n        \n        return dfs(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if s is empty\n        if not s:\n            if p[0] == '*':\n                return self.isMatch(s, p[1:])\n            else:\n                return False\n        \n        # if p is not empty, check if s is not empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or self.isMatch(s[1:], p)\n        elif p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        elif s[0] == p[0]:\n            return self.isMatch(s[1:], p[1:])\n        else:\n            return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = [ticket[1]]\n            else:\n                graph[ticket[0]].append(ticket[1])\n        \n        # sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # dfs\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l<r:\n                    if nums[i]+nums[j]+nums[l]+nums[r]==target:\n                        res.append([nums[i],nums[j],nums[l],nums[r]])\n                        l+=1\n                        r-=1\n                        while l<r and nums[l]==nums[l-1]:\n                            l+=1\n                        while l<r and nums[r]==nums[r+1]:\n                            r-=1\n                    elif nums[i]+nums[j]+nums[l]+nums[r]<target:\n                        l+=1\n                    else:\n                        r-=1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result list\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[1] != building[1]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result list\n                    result.append([current_building[0], current_building[2]])\n                # set current building to building\n                current_building = building\n            # if current building is not None\n            else:\n                # if building height is greater than current building height\n                if building[2] > current_building[2]:\n                    # set current building to building\n                    current_building = building\n                # if building height is less than current building height\n                else:\n                    # set current building to None\n                    current_building = None\n            # if current building is not None\n            if current_building is not None:\n                # if current building height is greater than max height\n                if current_building[2] > max_height:\n                    # set max height to current building height\n                    max_height = current_building[2]\n                # if current building height is less than max height\n                elif current_building[2] < max_height:\n                    # add current building to result list\n                    result.append([current_building[0], max_height])\n\n        # add last building to result list\n        if current_building is not None:\n            result.append([current_building[0], current_building[2]])\n\n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        dp = triangle[-1]\n        for i in range(len(triangle)-2,-1,-1):\n            for j in range(len(triangle[i])):\n                dp[j] = min(dp[j],dp[j+1]) + triangle[i][j]\n        return dp[0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n            if num < 1000000000000000:\n                return helper(num // 1000000000000) + \" Trillion \" + helper(num % 1000000000000)\n            if num < 1000000000000000000:\n                return helper(num // 1000000000000000) + \" Quadrillion \" + helper(num % 1000000000000000)\n            if num < 1000000000000000000000:\n                return helper(num // 1000000000000000000) + \" Quintillion \" + helper(num % 1000000000000000000)\n            if num < 10000000000000000000000000:\n                return helper(num // 1000000000000000000000) + \" Sextillion \" + helper(num % 1000000000000000000000)\n            if num < 100000000000000000000000000000:\n                return helper(num // 1000000000000000000000000) + \" Septillion \" + helper(num % 1000000000000000000000000)\n            if num < 1000000000000000000000000000000000:\n                return helper(num // 1000000000000000000000000000) + \" Octillion \" + helper(num % 10000000000000000000000000000)\n            if num < 100000000000000000000000000000000000"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            for j in range(min(k, i*(i-1)//2), -1, -1):\n                dp[i][j] = (dp[i][j+1] + dp[i-1][j]) % mod\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i-1][j-i] + mod) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            temp = curr.next\n            curr.next = curr.next.next\n            temp.next = curr.next.next\n            curr.next.next = temp\n            curr = curr.next.next\n        \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # traverse the linked list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        self.backtrack(nums, visited, [], res)\n        return res\n        \n    def backtrack(self, nums, visited, path, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            visited[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, visited, path, res)\n            visited[i] = False\n            path.pop()"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR\n        # 2^2 = 0\n        # 2^0 = 2\n        # 0^2 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        # 2^2 = 0\n        # 2^0 = 2\n        #"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n            dp[0][i] = dp[0][i - 1] + grid[0][i]\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n                if i != j:\n                    dp[i][j] += grid[n - j - 1][n - i - 1]\n                if i != 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1])\n                if j != 0:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n                if i != n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1])\n        return dp[n - 1][n - 1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 2\n        dp[2] = 4\n        for i in range(3, n+1):\n            dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % mod\n        return dp[n]"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 2021 - 2022\n        # 2. 2022 - 2023\n        # 3. 2023 - 2024\n        # 4. 2024 - 2025\n        # 5. 2025 - 2026\n        # 6. 2026 - 2027\n        # 7. 2027 - 2028\n        # 8. 2028 - 2029\n        # 9. 2029 - 2030\n        # 10. 2030 - 2031\n        # 11. 2031 - 2032\n        # 12. 2032 - 2033\n        # 13. 2033 - 2034\n        # 14. 2034 - 2035\n        # 15. 2035 - 2036\n        # 16. 2036 - 2037\n        # 17. 2037 - 2038\n        # 18. 2038 - 2039\n        # 19. 2039 - 2040\n        # 20. 2040 - 2041\n        # 21. 2041 - 2042\n        # 22. 2042 - 2043\n        # 23. 2043 - 2044\n        # 24. 2044 - 2045\n        # 25. 2045 - 2046\n        # 26. 2046 - 2047\n        # 27. 2047 - 2048\n        # 28. 2048 - 2049\n        # 29. 2049 - 2050\n        # 30. 2050 - 2051\n        # 31. 2051 - 2052\n        # 32. 2052 - 2053\n        # 33. 2053 - 2054\n        # 34. 2054 - 2055\n        # 35. 2055 - 2056\n        # 36. 2056 - 2057\n        # 37. 2057 - 2058\n        # 38. 2058 - 2059\n        # 39. 2059 - 2060\n        # 40. 2060 - 2061\n        # 41. 2061 - 2062\n        # 42. 2062 - 2063\n        # 43. 2063 - 2064\n        # 44. 2064 - 2065\n        # 45. 2065 - 2066\n        # 46. 2066 - 2067\n        # 47. 2067 - 2068\n        # 48. 2068 - 2069\n        # 49. 2069 - 2070\n        # 50. 2070 - 2071\n        # 51. 2071 - 2072\n        # 52. 2072 - 2073\n        # 53. 2073 - 2074\n        # 54. 2074 - 2075\n        # 55. 2075 - 2076\n        # 56. 2076 - 2077\n        # 57. 2077 - 2078\n        # 58."}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 1:\n        #     return True\n        # if nums[0] == 2:\n        #     return True\n        # if nums[0] == 3:\n        #     return True\n        # if nums[0] == 4:\n        #     return True\n        # if nums[0] == 5:\n        #     return True\n        # if nums[0] == 6:\n        #     return True\n        # if nums[0] == 7:\n        #     return True\n        # if nums[0] == 8:\n        #     return True\n        # if nums[0] == 9:\n        #     return True\n        # if nums[0] == 10:\n        #     return True\n        # if nums[0] == 11:\n        #     return True\n        # if nums[0] == 12:\n        #     return True\n        # if nums[0] == 13:\n        #     return True\n        # if nums[0] == 14:\n        #     return True\n        # if nums[0] == 15:\n        #     return True\n        # if nums[0] == 16:\n        #     return True\n        # if nums[0] == 17:\n        #     return True\n        # if nums[0] == 18:\n        #     return True\n        # if nums[0] == 19:\n        #     return True\n        # if nums[0] == 20:\n        #     return True\n        # if nums[0] == 21:\n        #     return True\n        # if nums[0] == 22:\n        #     return True\n        # if nums[0] == 23:\n        #     return True\n        # if nums[0] == 24:\n        #     return True\n        # if nums[0] == 25:\n        #     return True\n        # if nums[0] == 26:\n        #     return True\n        # if nums[0] == 27:\n        #     return True\n        # if nums[0] == 28:\n        #     return True\n        # if nums[0] == 29:\n        #     return True\n        # if nums[0] == 30:\n        #     return True\n        # if nums[0] == 31:\n        #     return True\n        # if nums[0] == 32:\n        #     return True\n        # if nums[0] == 33:\n        #     return True\n        # if nums[0] == 34:\n        #     return True\n        # if nums[0] == 35:\n        #     return True\n        # if nums[0] == 36:\n        #     return True\n        # if nums[0] == 37:\n        #     return True\n        # if nums[0] == 38:\n        #     return True\n        # if nums[0] == 39:\n        #     return True\n        # if nums[0] == 40:\n        #     return True\n        # if nums[0] == 41:\n        #     return True\n        # if nums[0] == 42:\n        #     return True\n        # if nums[0] == 43:\n        #     return True\n        # if nums[0] == 44:\n        #     return True\n        # if nums[0] == 45:\n        #     return True\n        # if nums[0] == 46:\n        #     return True\n        # if nums[0] == 47:\n        #     return True\n        # if nums[0] == 48:\n        #     return True\n        # if nums[0] == 49:\n        #     return True\n        # if nums[0] == 50:\n        #     return True\n        # if nums[0] == 51:\n        #     return True\n        # if"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        \n        for j in range(1,n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"3113112221232132112131211131221\"\n        \n        if n == 13:\n            return \"13211311123113112221232132112131211131221\"\n        \n        if n == 14:\n            return \"111312211331121321332112311312211211\"\n        \n        if n == 15:\n            return \"31131122212321321121312111312212311312211211\"\n        \n        if n == 16:\n            return \"132113111231131122212321321121312111312212311312211211\"\n        \n        if n == 17:\n            return \"11131221133112132133211231131221232132112131211131221232132112131211131221\"\n        \n        if n == 18:\n            return \"3113112221232132112131211131221232132112131211131221232132112131211131221\"\n        \n        if n == 19:\n            return \"13211311123113112221232132112131211131221232132112131211131221232132112131211131221\"\n        \n        if n == 20:\n            return \"11131221133112132133211231131221232132112131211131221232132112131211131221\"\n        \n        if n == 21:\n            return \"3113112221232132112131211131221232132112131211131221232132112131211131221\"\n        \n        if n == 22:\n            return \"1321131112311311222123213211"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # binary search on the range of the largest number in nums\n        # binary search on the range of the sum of the largest number in nums\n        # binary search on the range of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the largest number in nums\n        # binary search on the range of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the largest number in nums\n        # binary search on the range of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of the smallest number in nums\n        # binary search on the range of the sum of the sum of the sum of"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums)-1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] >= nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = []\n        curr = []\n        \n        def backtrack(i):\n            if i == len(digits):\n                res.append(''.join(curr))\n                return\n            \n            for c in phone[digits[i]]:\n                curr.append(c)\n                backtrack(i+1)\n                curr.pop()\n        \n        backtrack(0)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert n to int\n        # 2. convert n to string\n        # 3. convert n to list\n        # 4. reverse the list\n        # 5. convert the list to string\n        # 6. convert the string to int\n        # 7. convert the int to string\n        # 8. convert the string to list\n        # 9. reverse the list\n        # 10. convert the list to string\n        # 11. convert the string to int\n        # 12. convert the int to string\n        # 13. convert the string to list\n        # 14. reverse the list\n        # 15. convert the list to string\n        # 16. convert the string to int\n        # 17. convert the int to string\n        # 18. convert the string to list\n        # 19. reverse the list\n        # 20. convert the list to string\n        # 21. convert the string to int\n        # 22. convert the int to string\n        # 23. convert the string to list\n        # 24. reverse the list\n        # 25. convert the list to string\n        # 26. convert the string to int\n        # 27. convert the int to string\n        # 28. convert the string to list\n        # 29. reverse the list\n        # 30. convert the list to string\n        # 31. convert the string to int\n        # 32. convert the int to string\n        # 33. convert the string to list\n        # 34. reverse the list\n        # 35. convert the list to string\n        # 36. convert the string to int\n        # 37. convert the int to string\n        # 38. convert the string to list\n        # 39. reverse the list\n        # 40. convert the list to string\n        # 41. convert the string to int\n        # 42. convert the int to string\n        # 43. convert the string to list\n        # 44. reverse the list\n        # 45. convert the list to string\n        # 46. convert the string to int\n        # 47. convert the int to string\n        # 48. convert the string to list\n        # 49. reverse the list\n        # 50. convert the list to string\n        # 51. convert the string to int\n        # 52. convert the int to string\n        # 53. convert the string to list\n        # 54. reverse the list\n        # 55. convert the list to string\n        # 56. convert the string to int\n        # 57. convert the int to string\n        # 58. convert the string to list\n        # 59. reverse the list\n        # 60. convert the list to string\n        # 61. convert the string to int\n        # 62. convert the int to string\n        # 63. convert the string to list\n        # 64. reverse the list\n        # 65. convert the list to string\n        # 66. convert the string to int\n        # 67. convert the int to string\n        # 68. convert the string to list\n        # 69. reverse the list\n        # 70. convert the list to string\n        # 71. convert the string to int\n        # 72. convert the int to string\n        # 73. convert the string to list\n        # 74. reverse the list\n        # 75. convert the list to string\n        # 76. convert the string to int\n        # 77. convert the int to string\n        # 78. convert the string to list\n        # 79. reverse the list\n        # 80. convert the list to string\n        # 81. convert the string to int\n        # 82. convert the int to string\n        # 83. convert the string to list\n        # 84. reverse the list\n        # 85. convert the list to string\n        # 86. convert the string to int\n        # 87. convert the int to string\n        # 88. convert the string to list\n        # 89. reverse the list\n        # 9"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        left, right = 0, n-1\n        top, bottom = 0, n-1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = temp\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = max_prod\n        \n        for i in range(1, len(nums)):\n            curr_max = max_prod\n            max_prod = max(nums[i], nums[i] * max_prod, nums[i] * min_prod)\n            min_prod = min(nums[i], nums[i] * curr_max, nums[i] * min_prod)\n            result = max(result, max_prod)\n            \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is a way to jump to the ith stone\n        # dp[i] = False if there is no way to jump to the ith stone\n        # dp[i] = True if there is"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to its rank\n        score_rank = {}\n        for i, s in enumerate(score_sorted):\n            score_rank[s] = i + 1\n        \n        # map the score to its rank and return the result\n        return [score_rank[s] if s in score_rank else str(i + 1) for s in score]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # 2 pointers\n        # 1 pointer for the start of the window\n        # 1 pointer for the end of the window\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        # 1 pointer for the current substring length\n        # 1 pointer for the current character\n        # 1 pointer for the longest substring length\n        #"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n                else:\n                    break\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        chunks = 1\n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                chunks += 1\n                max_val = arr[i]\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            nums[left:right + 1] = temp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid)\n            count += mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    tx = tx - (ty - sy)\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    ty = ty - (tx - sx)\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # max_profit = 0\n        # min_price = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] < min_price:\n        #         min_price = prices[i]\n        #     elif prices[i] - min_price > max_profit:\n        #         max_profit = prices[i] - min_price\n        # return max_profit\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # max_profit = 0\n        # min_price = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] < min_price:\n        #         min_price = prices[i]\n        #     elif prices[i] - min_price > max_profit:\n        #         max_profit = prices[i] - min_price\n        # return max_profit\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # max_profit = 0\n        # min_price = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] < min_price:\n        #         min_price = prices[i]\n        #     elif prices[i] - min_price > max_profit:\n        #         max_profit = prices[i] - min_price\n        # return max_profit\n        \n        if len(prices) < 2:\n            return 0\n        \n        max_profit = 0\n        min_price = prices[0]\n        \n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            elif prices[i] - min_price > max_profit:\n                max_profit = prices[i] - min_price\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # priority queue\n        pq = []\n        # total time\n        total = 0\n        # iterate over courses\n        for duration, lastDay in courses:\n            # add course to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            # add course to total time\n            total += duration\n            # if total time exceeds last day\n            if total > lastDay:\n                # remove course from priority queue\n                total += heapq.heappop(pq)[0]\n                # if priority queue is empty\n                if not pq:\n                    # return number of courses\n                    return len(pq)\n        # return number of courses\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return tail"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if len(s) % len(set(s)) != 0:\n            return False\n        \n        return s in s*2[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2 + dp[i-2]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*dp[i-1]\n        # dp[i] = dp[i-1]*dp[i-1] + dp[i-2]*dp[i-2]\n        # dp[i] = dp[i-1]*dp[i-1]*2 + dp[i-2]*dp[i-2]*2 + dp[i-3]*dp[i-3]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*2\n        # dp[i] = dp[i-1]*dp[i-1]*dp[0]*2 + dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2\n        # dp[i] = dp[i-1]*dp[i-1]*dp[i-1]*2 + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2\n        # dp[i] = dp[i-1]*dp[i-1]*dp[i-1]*2 + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2\n        # dp[i] = dp[i-1]*dp[i-1]*dp[i-1]*2 + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i-1]*dp[i-3]*dp[0]*2 + ... + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2\n        # dp[i] = dp[i-1]*dp[i-1]*dp[i-1]*2 + dp[i-1]*dp[i-1]*dp[i-2]*dp[0]*2 + dp[i-1]*dp[i"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers\n        # 2. XOR the number with itself\n        # 3. XOR the number with the number with itself\n        # 4. XOR the number with the number with the number with itself\n        # 5. XOR the number with the number with the number with the number with itself\n        # 6. XOR the number with the number with the number with the number with the number with itself\n        # 7. XOR the number with the number with the number with the number with the number with the number with itself\n        # 8. XOR the number with the number with the number with the number with the number with the number with the number with itself\n        # 9. XOR the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 10. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 11. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 12. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 13. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 14. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 15. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with itself\n        # 16. XOR the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with the number with"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to spell out target[0:i]\n        # dp[i] = min(dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])] = stickers[k]\n        # dp[i] = min(dp[i], dp[j] + 1) where target[j:j+len(stickers[k])]"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                    for k in range(i,j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        i = 0\n        \n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                total += roman_dict[s[i]]\n                i += 1\n        \n        return total"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # set() is used to remove duplicates\n        # if len(nums) == len(set(nums)):\n        #     return False\n        # return True\n\n        # sorting the array and then checking for adjacent elements\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # use deque\n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-3,5,3,6,7]\n        # deque: [5,3,6,7]\n        # deque: [6,7]\n        # deque: [7]\n        # return [3,3,5,5,6,7]\n        \n        # deque: [1,3,-1,-3,5,3,6,7]\n        # deque: [3,-1,-"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        def dfs(root, targetSum, path):\n            if not root:\n                return\n            \n            path.append(root.val)\n            if root.val == targetSum and not root.left and not root.right:\n                res.append(path[:])\n            else:\n                dfs(root.left, targetSum - root.val, path)\n                dfs(root.right, targetSum - root.val, path)\n            path.pop()\n        \n        dfs(root, targetSum, [])\n        return res"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area // 2) = area\n        # 2. 2 * (area // 2) + 1 = area\n        # 3. 2 * (area // 2) + 1 = area\n        # 4. 2 * (area // 2) + 1 = area\n        # 5. 2 * (area // 2) + 1 = area\n        # 6. 2 * (area // 2) + 1 = area\n        # 7. 2 * (area // 2) + 1 = area\n        # 8. 2 * (area // 2) + 1 = area\n        # 9. 2 * (area // 2) + 1 = area\n        # 10. 2 * (area // 2) + 1 = area\n        # 11. 2 * (area // 2) + 1 = area\n        # 12. 2 * (area // 2) + 1 = area\n        # 13. 2 * (area // 2) + 1 = area\n        # 14. 2 * (area // 2) + 1 = area\n        # 15. 2 * (area // 2) + 1 = area\n        # 16. 2 * (area // 2) + 1 = area\n        # 17. 2 * (area // 2) + 1 = area\n        # 18. 2 * (area // 2) + 1 = area\n        # 19. 2 * (area // 2) + 1 = area\n        # 20. 2 * (area // 2) + 1 = area\n        # 21. 2 * (area // 2) + 1 = area\n        # 22. 2 * (area // 2) + 1 = area\n        # 23. 2 * (area // 2) + 1 = area\n        # 24. 2 * (area // 2) + 1 = area\n        # 25. 2 * (area // 2) + 1 = area\n        # 26. 2 * (area // 2) + 1 = area\n        # 27. 2 * (area // 2) + 1 = area\n        # 28. 2 * (area // 2) + 1 = area\n        # 29. 2 * (area // 2) + 1 = area\n        # 30. 2 * (area // 2) + 1 = area\n        # 31. 2 * (area // 2) + 1 = area\n        # 32. 2 * (area // 2) + 1 = area\n        # 33. 2 * (area // 2) + 1 = area\n        # 34. 2 * (area // 2) + 1 = area\n        # 35. 2 * (area // 2) + 1 = area\n        # 36. 2 * (area // 2) + 1 = area\n        # 37. 2 * (area // 2) + 1 = area\n        # 38. 2 * (area // 2) + 1 = area\n        # 39. 2 * (area // 2) + 1 = area\n        # 40. 2 * (area // 2) + 1 = area\n        # 41. 2 * (area // 2) + 1 = area\n        # 42. 2 * (area // 2) + 1 = area\n        # 43. 2 * (area // 2) + 1 = area\n        # 44. 2 * (area // 2) + 1 = area\n        # 45. 2 * (area // 2) + 1 = area\n        # 46. 2 * (area // 2) + 1 = area\n        # 47. 2 * (area // 2) + 1 = area\n        # 48. 2 * (area // 2) + 1 = area\n        # 49. 2 * (area // 2) + 1 = area\n        # 50. 2 * (area // 2) + 1 = area\n        # 51. 2 * (area // 2) + 1 = area\n        # 52. 2 * (area // 2)"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    neighbor = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word == endWord:\n                            res.append([beginWord, neighbor_word] + [neighbor_word]*(level-1))\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        while i < len(nums):\n            j = i\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            k = len(res)\n            while k < j:\n                res.append(res[k-len(res)] + [nums[i]])\n                k += 1\n            i = j\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                if not stack:\n                    area = h * i\n                else:\n                    area = h * (i - stack[-1] - 1)\n                max_area = max(max_area, area)\n            stack.append(i)\n        while stack:\n            h = heights[stack.pop()]\n            if not stack:\n                area = h * len(heights)\n            else:\n                area = h * (len(heights) - stack[-1] - 1)\n            max_area = max(max_area, area)\n        return max_area"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in [\"+\", \"-\", \"*\", \"/\"]:\n                stack.append(int(token))\n            else:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == \"+\":\n                    stack.append(num1 + num2)\n                elif token == \"-\":\n                    stack.append(num1 - num2)\n                elif token == \"*\":\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(float(num1) / num2))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        xmin, xmax, ymin, ymax = float('inf'), float('-inf'), float('inf'), float('-inf')\n        area = 0\n        seen = set()\n        \n        for x1, y1, x2, y2 in rectangles:\n            xmin = min(xmin, x1)\n            xmax = max(xmax, x2)\n            ymin = min(ymin, y1)\n            ymax = max(ymax, y2)\n            area += (x2 - x1) * (y2 - y1)\n            seen.add((x1, y1))\n            seen.add((x1, y2))\n            seen.add((x2, y1))\n            seen.add((x2, y2))\n        \n        if (xmin, ymin) not in seen or (xmin, ymax) not in seen or (xmax, ymin) not in seen or (xmax, ymax) not in seen:\n            return False\n        \n        return area == (xmax - xmin) * (ymax - ymin)"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 3,4,5,0,1,2\n        # 4,5,0,1,2,3\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,0,4,5\n        # 1,2,0,3,4,5\n        # 1,0,2,3,4,5\n        # 0,1,2,3,4,5\n        \n        # 1,2,3,4,5"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                if t[i] in t_map:\n                    return False\n                s_map[s[i]] = t[i]\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l, r = 0, len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return True\n            if nums[mid] == nums[l]:\n                l += 1\n            elif nums[mid] > nums[l]:\n                if nums[mid] > target and nums[l] <= target:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target and nums[r] >= target:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        dp[m-1][n-1] = 1\n        \n        for i in range(m-2,-1,-1):\n            if obstacleGrid[i][n-1] == 1:\n                dp[i][n-1] = 0\n            else:\n                dp[i][n-1] = dp[i+1][n-1]\n        \n        for j in range(n-2,-1,-1):\n            if obstacleGrid[m-1][j] == 1:\n                dp[m-1][j] = 0\n            else:\n                dp[m-1][j] = dp[m-1][j+1]\n        \n        for i in range(m-2,-1,-1):\n            for j in range(n-2,-1,-1):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1]\n        \n        return dp[0][0]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root is None:\n                return\n            \n            inorder(root.left, min_diff, prev)\n            \n            if prev is not None:\n                min_diff = min(min_diff, root.val - prev)\n            \n            prev = root.val\n            \n            inorder(root.right, min_diff, prev)\n            \n            return min_diff\n        \n        return inorder(root, float('inf'), None)"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.mode = []\n        self.prev = None\n        self.count = 0\n        \n        self.inorder(root)\n        \n        return self.mode\n        \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.prev == root.val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_count:\n            self.max_count = self.count\n            self.mode = [root.val]\n        elif self.count == self.max_count:\n            self.mode.append(root.val)\n        \n        self.prev = root.val\n        \n        self.inorder(root.right)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        if len(haystack) == len(needle):\n            if haystack == needle:\n                return 0\n            else:\n                return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 5. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 6. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 7. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 8. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 9. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 10. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 11. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 12. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 13. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 14. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 15. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 16. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 17. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 18. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 19. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790,"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n//5\n            n = n//5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        down = True\n        \n        for c in s:\n            res[i] += c\n            if i == 0:\n                down = True\n            elif i == numRows - 1:\n                down = False\n            if down:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers\n        # 3. 2 pointers\n        # 4. 2 pointers\n        # 5. 2 pointers\n        # 6. 2 pointers\n        # 7. 2 pointers\n        # 8. 2 pointers\n        # 9. 2 pointers\n        # 10. 2 pointers\n        # 11. 2 pointers\n        # 12. 2 pointers\n        # 13. 2 pointers\n        # 14. 2 pointers\n        # 15. 2 pointers\n        # 16. 2 pointers\n        # 17. 2 pointers\n        # 18. 2 pointers\n        # 19. 2 pointers\n        # 20. 2 pointers\n        # 21. 2 pointers\n        # 22. 2 pointers\n        # 23. 2 pointers\n        # 24. 2 pointers\n        # 25. 2 pointers\n        # 26. 2 pointers\n        # 27. 2 pointers\n        # 28. 2 pointers\n        # 29. 2 pointers\n        # 30. 2 pointers\n        # 31. 2 pointers\n        # 32. 2 pointers\n        # 33. 2 pointers\n        # 34. 2 pointers\n        # 35. 2 pointers\n        # 36. 2 pointers\n        # 37. 2 pointers\n        # 38. 2 pointers\n        # 39. 2 pointers\n        # 40. 2 pointers\n        # 41. 2 pointers\n        # 42. 2 pointers\n        # 43. 2 pointers\n        # 44. 2 pointers\n        # 45. 2 pointers\n        # 46. 2 pointers\n        # 47. 2 pointers\n        # 48. 2 pointers\n        # 49. 2 pointers\n        # 50. 2 pointers\n        # 51. 2 pointers\n        # 52. 2 pointers\n        # 53. 2 pointers\n        # 54. 2 pointers\n        # 55. 2 pointers\n        # 56. 2 pointers\n        # 57. 2 pointers\n        # 58. 2 pointers\n        # 59. 2 pointers\n        # 60. 2 pointers\n        # 61. 2 pointers\n        # 62. 2 pointers\n        # 63. 2 pointers\n        # 64. 2 pointers\n        # 65. 2 pointers\n        # 66. 2 pointers\n        # 67. 2 pointers\n        # 68. 2 pointers\n        # 69. 2 pointers\n        # 70. 2 pointers\n        # 71. 2 pointers\n        # 72. 2 pointers\n        # 73. 2 pointers\n        # 74. 2 pointers\n        # 75. 2 pointers\n        # 76. 2 pointers\n        # 77. 2 pointers\n        # 78. 2 pointers\n        # 79. 2 pointers\n        # 80. 2 pointers\n        # 81. 2 pointers\n        # 82. 2 pointers\n        # 83. 2 pointers\n        # 84. 2 pointers\n        # 85. 2 pointers\n        # 86. 2 pointers"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Create a hashmap with the number as key and value as 1\n        ## 2. Iterate through the array and for each number, check if the number is present in the hashmap. If it is not present, add it to the result array\n        ## 3. Iterate through the hashmap and add the keys to the result array\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        hashmap = {}\n        result = []\n        \n        for num in nums:\n            hashmap[num] = 1\n        \n        for i in range(1, len(nums) + 1):\n            if i not in hashmap:\n                result.append(i)\n        \n        return result"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # sort the array\n        sorted_nums = sorted(nums)\n        # create a dictionary to store the index of each element\n        num_to_index = {num: i for i, num in enumerate(sorted_nums)}\n        # create a dictionary to store the count of smaller elements to the right of each element\n        count = {num: 0 for num in sorted_nums}\n        # create a dictionary to store the count of smaller elements to the right of each element\n        res = [0] * len(nums)\n        # loop through the array in reverse order\n        for i in range(len(nums) - 1, -1, -1):\n            # get the index of the current element\n            num = nums[i]\n            # get the index of the next element\n            next_num = num + 1\n            # if the next element exists, increment the count of smaller elements to the right of the next element\n            if next_num in num_to_index:\n                count[next_num] += 1\n            # increment the count of smaller elements to the right of the current element\n            res[i] = count[num]\n        return res"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = 0\n        prev = -1\n        for interval in intervals:\n            if interval[0] > prev:\n                res += 2\n                prev = interval[1] - 1\n            else:\n                res += 1\n                prev -= 1\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            if left.val != right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        if not root:\n            return True\n        return isMirror(root.left, root.right)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                i += 1\n                while stack and stack[-1] != '(':\n                    i = stack.pop()\n                if stack:\n                    stack.pop()\n            else:\n                j = i\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                count = int(formula[i:j]) if i else 1\n                i = j\n                if stack:\n                    stack[-1] += count\n                else:\n                    stack.append(count)\n        count_dict = {}\n        for i in range(len(stack)-1, -1, -1):\n            count = stack[i]\n            if count_dict:\n                if count_dict[stack[i]]:\n                    count_dict[stack[i]] += count\n                else:\n                    count_dict[stack[i]] = count\n            else:\n                count_dict[stack[i]] = count\n        res = []\n        for k, v in count_dict.items():\n            if v > 1:\n                res.append(str(v) + k)\n            else:\n                res.append(k)\n        return ''.join(res[::-1])"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n            \n            if node.left:\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n-i-1)\n            for l in left:\n                for r in right:\n                    res.append('({}){}'.format(l,r))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] + 1 == n:\n            return 1\n        \n        # edge case\n        if nums[-1] + 1 > n:\n            return 1\n        \n        # edge case\n        if nums[-1] + 2 == n:\n            return 2\n        \n        # edge case\n        if nums[-1] + 2 > n:\n            return 2\n        \n        # edge case\n        if nums[-1] + 3 == n:\n            return 3\n        \n        # edge case\n        if nums[-1] + 3 > n:\n            return 3\n        \n        # edge case\n        if nums[-1] + 4 == n:\n            return 4\n        \n        # edge case\n        if nums[-1] + 4 > n:\n            return 4\n        \n        # edge case\n        if nums[-1] + 5 == n:\n            return 5\n        \n        # edge case\n        if nums[-1] + 5 > n:\n            return 5\n        \n        # edge case\n        if nums[-1] + 6 == n:\n            return 6\n        \n        # edge case\n        if nums[-1] + 6 > n:\n            return 6\n        \n        # edge case\n        if nums[-1] + 7 == n:\n            return 7\n        \n        # edge case\n        if nums[-1] + 7 > n:\n            return 7\n        \n        # edge case\n        if nums[-1] + 8 == n:\n            return 8\n        \n        # edge case\n        if nums[-1] + 8 > n:\n            return 8\n        \n        # edge case\n        if nums[-1] + 9 == n:\n            return 9\n        \n        # edge case\n        if nums[-1] + 9 > n:\n            return 9\n        \n        # edge case\n        if nums[-1] + 10 == n:\n            return 10\n        \n        # edge case\n        if nums[-1] + 10 > n:\n            return 10\n        \n        # edge case\n        if nums[-1] + 11 == n:\n            return 11\n        \n        # edge case\n        if nums[-1] + 11 > n:\n            return 11\n        \n        # edge case\n        if nums[-1] + 12 == n:\n            return 12\n        \n        # edge case\n        if nums[-1] + 12 > n:\n            return 12\n        \n        # edge case\n        if nums[-1] + 13 == n:\n            return 13\n        \n        # edge case\n        if nums[-1] + 13 > n:\n            return 13\n        \n        # edge case\n        if nums[-1] + 14 == n:\n            return 14\n        \n        # edge case\n        if nums[-1] + 14 > n:\n            return 14\n        \n        # edge case\n        if nums[-1] + 15 == n:\n            return 15\n        \n        # edge case\n        if nums[-1] + 15 > n:\n            return 15\n        \n        # edge case\n        if nums[-1] + 16 == n:\n            return 16\n        \n        # edge case\n        if nums[-1] + 16 > n:\n            return 16\n        \n        # edge case\n        if nums[-1] + 17 == n:\n            return 17\n        \n        # edge case\n        if nums[-1] + 17 > n:\n            return 17\n        \n        # edge case\n        if nums[-1] + 18 == n:\n            return 18\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 stack\n        # 3. 2 stack with a counter\n        # 4. 2 stack with a counter and a flag\n        # 5. 2 stack with a counter and a flag and a variable\n        # 6. 2 stack with a counter and a flag and a variable and a variable\n        # 7. 2 stack with a counter and a flag and a variable and a variable and a variable\n        # 8. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable\n        # 9. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable\n        # 10. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable\n        # 11. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 12. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 13. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 14. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 15. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 16. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 17. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 18. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 19. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 20. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 21. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 22. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 23. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 24. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable and a variable\n        # 25. 2 stack with a counter and a flag and a variable and a variable and a variable and a variable and a variable and a"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = \"-\"\n        elif numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        if numerator < 0:\n            numerator = -numerator\n        if denominator < 0:\n            denominator = -denominator\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return sign + str(quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder_str += str(quotient)\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = remainder_str[:remainder_dict[remainder]] + \"(\" + remainder_str[remainder_dict[remainder]:] + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n        \n        return sign + str(quotient) + \".\" + remainder_str"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the left and right halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add the remaining nodes from the left half\n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [envelopes[0][1]]\n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = envelopes[i][1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = set()\n        cols = set()\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0\n        \n        return matrix"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if the list is empty\n        if not head:\n            return None\n        \n        # if the list has only one node\n        if not head.next:\n            return None\n        \n        # if the list has two nodes\n        if not head.next.next:\n            head = head.next\n            return head\n        \n        # if the list has more than two nodes\n        # set the slow pointer to the head\n        slow = head\n        # set the fast pointer to the head\n        fast = head\n        \n        # move the fast pointer n nodes ahead\n        for i in range(n):\n            fast = fast.next\n        \n        # if the fast pointer is None, it means that the list has less than n nodes\n        # return the head\n        if not fast:\n            return head\n        \n        # move the slow pointer and fast pointer until the fast pointer is None\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # if the slow pointer is the head, it means that the list has n nodes\n        # return the head\n        if not slow:\n            return head\n        \n        # set the slow pointer's next to the slow pointer's next's next\n        slow.next = slow.next.next\n        \n        # return the head\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        res = 0\n        curr = 0\n        for i in machines:\n            curr += i - avg\n            res = max(res, abs(curr))\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1:\n            curr.next = list1\n        if list2:\n            curr.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        heights = [0] * cols\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[i] < heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            width = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for i in nums:\n            res += [j + [i] for j in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        # if nums[0] == nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        # return nums[left]\n        \n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        if s[0] in ['+','-']:\n            s = s[1:]\n        if not s:\n            return False\n        \n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        if not s:\n            return False\n        \n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            if not s[0].isdigit() and s[0][0] != '-':\n                return False\n            if not s[1].isdigit():\n                return False\n            if s[0][0] == '-':\n                s[0] = s[0][1:]\n            if s[1][0] == '-':\n                s[1] = s[1][1:]\n            if not s[0] or not s[1]:\n                return False\n            return True\n        else:\n            if not s.isdigit():\n                return False\n            return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: \"M\",\n            900: \"CM\",\n            500: \"D\",\n            400: \"CD\",\n            100: \"C\",\n            90: \"XC\",\n            50: \"L\",\n            40: \"XL\",\n            10: \"X\",\n            9: \"IX\",\n            5: \"V\",\n            4: \"IV\",\n            1: \"I\",\n        }\n        \n        roman_num = \"\"\n        \n        for key in roman_dict.keys():\n            roman_num += roman_dict[key] * (num // key)\n            num %= key\n        \n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # 26 bit integer\n        # 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1,10):\n                            if isValid(i,j,str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # if the node is not None, then it is not None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None\n        # if the node is None, then it is None"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        left = 0\n        right = num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        i = 2\n        while i <= n:\n            res.append(res[i//2] + i%2)\n            i += 1\n        \n        return res"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0, head)\n        curr = dummy\n        \n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        if len(set(s1)) == 1:\n            return True\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        path = path.split('/')\n        for i in path:\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['$'] = True\n        \n        m = len(board)\n        n = len(board[0])\n        visited = set()\n        res = []\n        \n        def dfs(i, j, node):\n            if '$' in node:\n                res.append(node.pop('$'))\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, node.get(board[i][j], {}))\n            dfs(i - 1, j, node.get(board[i][j], {}))\n            dfs(i, j + 1, node.get(board[i][j], {}))\n            dfs(i, j - 1, node.get(board[i][j], {}))\n            visited.remove((i, j))\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, trie)\n        \n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        subboxes = [set() for _ in range(9)]\n        \n        # 2. iterate through the board\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    # 2.1 add the number to the corresponding set\n                    rows[i].add(board[i][j])\n                    cols[j].add(board[i][j])\n                    subbox_idx = (i // 3) * 3 + j // 3\n                    subboxes[subbox_idx].add(board[i][j])\n        \n        # 3. check if any set has more than 1 number\n        for s in rows + cols + subboxes:\n            if len(s) > 1:\n                return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res += (ord(columnTitle[i]) - ord('A') + 1) * (26 ** (len(columnTitle) - i - 1))\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        \n        second = self.reverse(second)\n        \n        first = head\n        \n        while second:\n            temp = first.next\n            first.next = second\n            second = second.next\n            first.next.next = temp\n            first = temp\n        \n        return head\n        \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern and the length of the words are not the same, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between the pattern and the words\n        mapping = {}\n        \n        # iterate through the pattern and the words\n        for i in range(len(pattern)):\n            # if the pattern and the word are not in the mapping, add them to the mapping\n            if pattern[i] not in mapping:\n                if words[i] not in mapping.values():\n                    mapping[pattern[i]] = words[i]\n                else:\n                    return False\n            # if the pattern and the word are in the mapping, check if they are the same\n            else:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the words and the pattern are in the mapping, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            temp = nums[:i] + nums[i+1:]\n            for j in self.permute(temp):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        \n        # binary search\n        # O(m + n"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        head = ListNode()\n        curr = head\n        \n        # Initialize a variable to track the carry\n        carry = 0\n        \n        # Iterate over the two linked lists\n        while l1 or l2 or carry:\n            # Calculate the sum of the current nodes\n            sum = carry\n            if l1:\n                sum += l1.val\n            if l2:\n                sum += l2.val\n            \n            # Calculate the new node value\n            val = sum % 10\n            \n            # Create a new node with the calculated value\n            curr.next = ListNode(val)\n            \n            # Update the carry\n            carry = sum // 10\n            \n            # Move to the next node\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n            curr = curr.next\n        \n        # Return the new linked list\n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        binary = bin(num)[2:]\n        \n        # 2. Reverse the binary string\n        reversed_binary = binary[::-1]\n        \n        # 3. Convert the reversed binary string to decimal\n        decimal = int(reversed_binary, 2)\n        \n        # 4. Return the complement of the decimal number\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        i = 2\n        while i < len(nums):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n                i += 1\n            else:\n                diff = nums[i] - nums[i-1]\n                i += 1\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur_len = 0\n        cur_words = []\n        for word in words:\n            if cur_len + len(word) + len(cur_words) > maxWidth:\n                if len(cur_words) == 1:\n                    res.append(cur_words[0] + ' ' * (maxWidth - cur_len))\n                else:\n                    num_spaces = (maxWidth - cur_len) // (len(cur_words) - 1)\n                    extra_spaces = (maxWidth - cur_len) % (len(cur_words) - 1)\n                    res.append(''.join([cur_words[i] + ' ' * num_spaces + (' ' if i < extra_spaces else '') for i in range(len(cur_words))]))\n                cur_len = 0\n                cur_words = []\n            cur_len += len(word)\n            cur_words.append(word)\n        if cur_words:\n            res.append(' '.join(cur_words) + ' ' * (maxWidth - cur_len - len(cur_words) + 1))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N*W)\n        # Space Complexity: O(N)\n        \n        # Hashmap to store the words\n        word_map = set(words)\n        \n        # Hashmap to store the concatenated words\n        concatenated_words = set()\n        \n        # Loop through the words\n        for word in words:\n            # If the word is in the hashmap, add it to the concatenated words\n            if word in word_map:\n                concatenated_words.add(word)\n                continue\n            \n            # Initialize the word as a pointer\n            word_ptr = word\n            \n            # Loop through the word\n            for i in range(1, len(word)):\n                # If the prefix is in the hashmap, add the suffix to the word\n                if word[:i] in word_map:\n                    word_ptr += word[i:]\n                    \n                    # If the suffix is in the hashmap, add the prefix to the word\n                    if word_ptr in word_map:\n                        concatenated_words.add(word)\n                        break\n                    \n                    # If the suffix is not in the hashmap, set the word pointer to the prefix\n                    word_ptr = word[:i]\n                    \n        return list(concatenated_words)"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row + col}, diag2 | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if not word:\n            return False\n        \n        if len(board) == 1 and len(board[0]) == 1:\n            return word in board[0]\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word, i, j, 0):\n                        return True\n        \n        return False\n        \n    def dfs(self, board, word, i, j, k):\n        if k == len(word):\n            return True\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n            return False\n        \n        temp = board[i][j]\n        board[i][j] = '#'\n        \n        res = self.dfs(board, word, i+1, j, k+1) or self.dfs(board, word, i-1, j, k+1) or self.dfs(board, word, i, j+1, k+1) or self.dfs(board, word, i, j-1, k+1)\n        \n        board[i][j] = temp\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}