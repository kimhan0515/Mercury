{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, n-1, 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and all numbers greater than n as 0\n        # 2. iterate through the array and mark the numbers as negative\n        # 3. iterate through the array again and return the first number that is not negative\n        # 4. if all numbers are negative, return n + 1\n        \n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        nums = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            fact //= i\n            idx = k // fact\n            ans += str(nums[idx])\n            nums.pop(idx)\n            k %= fact\n        \n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        left, right = 0, len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            if curr != 0:\n                backtrack(i + 1, curr * 10 + int(num[i]), prev * 10 + int(num[i]), res, op + '*' + num[i])\n                backtrack(i + 1, curr, prev, res, op + '+' + num[i])\n                backtrack(i + 1, curr, prev, res, op + '-' + num[i])\n            else:\n                backtrack(i + 1, int(num[i]), int(num[i]), res, op + num[i])\n        \n        if not num:\n            return []\n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    (first_match and self.isMatch(s[1:], p)))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            removed = len(nums) - k\n            out = []\n            for n in nums:\n                while removed and out and out[-1] < n:\n                    out.pop()\n                    removed -= 1\n                out.append(n)\n            return out\n        \n        def merge(nums1, nums2, k):\n            out = []\n            i1, i2 = 0, 0\n            while i1 < len(nums1) and i2 < len(nums2) and len(out) < k:\n                if nums1[i1] > nums2[i2]:\n                    out.append(nums1[i1])\n                    i1 += 1\n                else:\n                    out.append(nums2[i2])\n                    i2 += 1\n            out.extend(nums1[i1:])\n            out.extend(nums2[i2:])\n            return out\n        \n        if len(nums1) > len(nums2):\n            return self.maxNumber(nums2, nums1, k)\n        \n        if len(nums2) == 0:\n            return []\n        \n        if k == 0:\n            return []\n        \n        if k == len(nums1):\n            return nums1\n        \n        if k == len(nums2):\n            return nums2\n        \n        out = []\n        for i in range(k):\n            if i <= len(nums1) and k - i <= len(nums2):\n                out = merge(pick(nums1, i), pick(nums2, k - i), k)\n            else:\n                out = merge(pick(nums1, k - i), nums2, k)\n            if len(out) == k:\n                break\n        return out"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if sum(bisect_right(nums, mid) - bisect_left(nums, mid) for x in nums) >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and s[l] not in vowels:\n                l += 1\n            while l < r and s[r] not in vowels:\n                r -= 1\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_length = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_length = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_length += 1\n                    \n                max_length = max(max_length, curr_length)\n                \n        return max_length"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        \n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            \n            for i in range(len(word)):\n                for j in range(ord('a'), ord('z') + 1):\n                    new_word = word[:i] + chr(j) + word[i+1:]\n                    if new_word in wordList:\n                        queue.append((new_word, length + 1))\n                        wordList.remove(new_word)\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        res = []\n        for i in range(len(a)-1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if i < len(b):\n                if b[i] == '1':\n                    carry += 1\n            res.append(str(carry % 2))\n            carry //= 2\n        if carry:\n            res.append(str(carry))\n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] != target:\n            return [-1, -1]\n        else:\n            left = right\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(len(nums)-1):\n            if i + nums[i] > max_reach:\n                max_reach = i + nums[i]\n            if i == curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n                \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for i in range(0, len(prices) - 1, 2))\n        \n        dp = [[0] * (k + 1) for _ in range(2)]\n        for i in range(len(prices) - 1):\n            for j in range(1, k + 1):\n                dp[i % 2][j] = max(dp[(i - 1) % 2][j] - prices[i], dp[(i - 1) % 2][j - 1] + prices[i])\n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = 2 ** 32 + num\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hashmap, add it to the list\n        # if the character is in the hashmap, update its frequency to -1\n        # if the character is not in the hash"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        if valueDiff < 0:\n            return False\n        \n        if indexDiff < 0:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff == 0:\n            return False\n        \n        if valueDiff == 0:\n            return False\n        \n        if indexDiff == 1:\n            return True\n        \n        if valueDiff == 1:\n            return False\n        \n        if indexDiff == 2:\n            return self.containsNearbyAlmostDuplicate(nums, 1, 1)\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff == 1:\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n            \n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = list(num1), list(num2)\n        \n        carry = 0\n        for i in range(len(num1)):\n            sum = int(num1[-i - 1]) + int(num2[-i - 1]) + carry\n            carry = sum // 10\n            num1[-i - 1] = str(sum % 10)\n        \n        for i in range(len(num1) - 1, -1, -1):\n            sum = int(num1[i]) + carry\n            carry = sum // 10\n            num1[i] = str(sum % 10)\n        \n        if carry:\n            num1.insert(0, str(carry))\n        \n        return ''.join(num1)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i] == ' ':\n                continue\n            elif s[i] == '+':\n                num += sign\n            elif s[i] == '-':\n                num += sign\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num += sign\n                num *= stack.pop()\n                num += stack.pop()\n            else:\n                num = num * 10 + int(s[i])\n        return num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # greedy\n        # O(nlogn)\n        # O(1)\n        # 1. sort capital and profits\n        # 2. greedy\n        # 3. iterate over capital\n        # 4. if k > 0, add profit to w\n        # 5. else, add capital to w\n        # 6. if capital > w, return w\n        # 7. else, k--\n        # 8. else, return w\n        \n        # sort capital and profits\n        sorted_profits = sorted(zip(profits, capital))\n        \n        # greedy\n        # iterate over capital\n        for c in sorted(capital):\n            # if k > 0, add profit to w\n            if k > 0:\n                w += sorted_profits[k-1][0]\n            # else, add capital to w\n            else:\n                return w\n        \n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and i == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the number to its right\n        # find the first number that is bigger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number\n        \n        # find the first number that is smaller than the number to its right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # find the first number that is bigger than the number to its right\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers to the right of the number\n        nums[i+1:] = nums[i+1:][::-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        \n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        \n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        \n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        \n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        \n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[0] == nums[7]\n        \n        if len(nums) == 9:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[0] == nums[8]\n        \n        if len(nums) == 10:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[0] == nums[9]\n        \n        if len(nums) == 11:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[9] == nums[10] or nums[0] == nums[10]\n        \n        if len(nums) == 12:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n            queue = queue[len(level):]\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        res = 0\n        for i in range(1, len(couples)):\n            if couples[i][0] != couples[i-1][1]:\n                res += 1\n        return res"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        firstRow = set(\"qwertyuiop\")\n        secondRow = set(\"asdfghjkl\")\n        thirdRow = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if word[0] in firstRow:\n                row = firstRow\n            elif word[0] in secondRow:\n                row = secondRow\n            else:\n                row = thirdRow\n            \n            if all(word[i] in row for i in range(len(word))):\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        # create a hashmap for the characters in t\n        # and their counts\n        count_t = collections.Counter(t)\n        \n        # create a hashmap for the characters in s\n        # and their counts\n        count_s = collections.Counter()\n        \n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the characters in s\n        # and their counts\n        # create a hashmap for the"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 2] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of each letter\n        # 2. if the number is odd, add 1 to the result\n        # 3. if the number is even, add it to the result\n        # 4. return the result\n        \n        # 1.\n        letter_count = {}\n        for letter in s:\n            if letter not in letter_count:\n                letter_count[letter] = 1\n            else:\n                letter_count[letter] += 1\n        \n        # 2.\n        result = 0\n        for letter in letter_count:\n            if letter_count[letter] % 2 == 1:\n                result += 1\n        \n        # 3.\n        return result + (1 if result < len(s) else 0)"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # get all the trees in the forest\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        \n        # sort the trees by height\n        trees.sort()\n        \n        # start from the top left corner\n        steps = 0\n        curr_pos = (0, 0)\n        for tree, i, j in trees:\n            steps += self.bfs(forest, curr_pos, (i, j))\n            if steps == -1:\n                return -1\n            curr_pos = (i, j)\n        \n        return steps\n    \n    def bfs(self, forest, start, end):\n        \"\"\"\n        BFS to find the shortest path from start to end\n        \"\"\"\n        m, n = len(forest), len(forest[0])\n        visited = [[False] * n for _ in range(m)]\n        q = collections.deque([(start, 0)])\n        while q:\n            curr, steps = q.popleft()\n            if curr == end:\n                return steps\n            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                r, c = curr[0] + dr, curr[1] + dc\n                if 0 <= r < m and 0 <= c < n and not visited[r][c] and forest[r][c] > 0:\n                    visited[r][c] = True\n                    q.append(((r, c), steps + 1))"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0, 1]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            res += [res[-1] + (1 << i)]\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for word in wordDict:\n                if s[i:i+len(word)] == word:\n                    dp[i+len(word)] = dp[i]\n                    \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the min and max of all the numbers in the list\n        min_num = float('inf')\n        max_num = float('-inf')\n        for num in nums:\n            min_num = min(min_num, num[0])\n            max_num = max(max_num, num[-1])\n        \n        # find the range of the list\n        range_ = max_num - min_num\n        \n        # find the range of the list with the smallest difference\n        range_list = [(nums[0][0], nums[0][0])]\n        for nums_ in nums[1:]:\n            range_list.append((nums_[0], max(range_list[-1][0], nums_[0])))\n            range_list.append((nums_[-1], min(range_list[-1][1], nums_[-1])))\n        \n        # find the range of the list with the smallest difference\n        range_ = range_list[1] - range_list[0]\n        for i in range(1, len(range_list) - 1):\n            range_ = min(range_, range_list[i + 1] - range_list[i])\n        \n        return range_list[0:2]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 2. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 3. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 4. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 5. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 6. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 7. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 8. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 9. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 10. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 11. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 12. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 13. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 14. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 15. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 16. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 17. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 18. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 19. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 20. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 21. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 22. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 23. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 24. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 25. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 26. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 27. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 28. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 29. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 30. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 31. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 32. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 33. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 34. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 35. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 36. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 37. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 38. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 39. 1 pig can be fed 10^4 times in 10^9 minutes\n        # 40. 1 pig can be fed 10^4 times in"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set()\n        seen.add((0, 0))\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # return self.uniquePaths(m-1, n) + self.uniquePaths(m, n-1)\n        \n        # return reduce(lambda x, y: x*y, range(m+n-2, m+n-2-min(m,n)-1, -1)) // math.factorial(min(m,n)-1)\n        \n        # return math.comb(m+n-2, m-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)\n        \n        # return math.factorial(m+"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = ''.join(res[::-1]).lstrip('0')\n        \n        return res or '0'"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        # 6. 5 pass\n        # 7. 6 pass\n        # 8. 7 pass\n        # 9. 8 pass\n        # 10. 9 pass\n        # 11. 10 pass\n        # 12. 11 pass\n        # 13. 12 pass\n        # 14. 13 pass\n        # 15. 14 pass\n        # 16. 15 pass\n        # 17. 16 pass\n        # 18. 17 pass\n        # 19. 18 pass\n        # 20. 19 pass\n        # 21. 20 pass\n        # 22. 21 pass\n        # 23. 22 pass\n        # 24. 23 pass\n        # 25. 24 pass\n        # 26. 25 pass\n        # 27. 26 pass\n        # 28. 27 pass\n        # 29. 28 pass\n        # 30. 29 pass\n        # 31. 30 pass\n        # 32. 31 pass\n        # 33. 32 pass\n        # 34. 33 pass\n        # 35. 34 pass\n        # 36. 35 pass\n        # 37. 36 pass\n        # 38. 37 pass\n        # 39. 38 pass\n        # 40. 39 pass\n        # 41. 40 pass\n        # 42. 41 pass\n        # 43. 42 pass\n        # 44. 43 pass\n        # 45. 44 pass\n        # 46. 45 pass\n        # 47. 46 pass\n        # 48. 47 pass\n        # 49. 48 pass\n        # 50. 49 pass\n        # 51. 50 pass\n        # 52. 51 pass\n        # 53. 52 pass\n        # 54. 53 pass\n        # 55. 54 pass\n        # 56. 55 pass\n        # 57. 56 pass\n        # 58. 57 pass\n        # 59. 58 pass\n        # 60. 59 pass\n        # 61. 60 pass\n        # 62. 61 pass\n        # 63. 62 pass\n        # 64. 63 pass\n        # 65. 64 pass\n        # 66. 65 pass\n        # 67. 66 pass\n        # 68. 67 pass\n        # 69. 68 pass\n        # 70. 69 pass\n        # 71. 70 pass\n        # 72. 71 pass\n        # 73. 72 pass\n        # 74. 73 pass\n        # 75. 74 pass\n        # 76. 75 pass\n        # 77. 76 pass\n        # 78. 77 pass\n        # 79. 78 pass\n        # 80. 79 pass\n        # 81. 80 pass\n        # 82. 81 pass\n        # 83. 82 pass\n        # 84. 83 pass\n        # 85. 84 pass\n        # 86. 85 pass\n        # 87. 86 pass\n        # 88. 87 pass\n        # 89. 88 pass\n        # 90. 89 pass\n        # 91. 90 pass\n        # 92. 91 pass\n        # 93. 92 pass\n        # 94. 93 pass\n        # 95. 9"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the left and right parentheses\n        # 2. remove the left and right parentheses\n        # 3. find the valid parentheses\n        # 4. add the valid parentheses to the result\n        \n        # 1. find the left and right parentheses\n        left_count = 0\n        right_count = 0\n        for c in s:\n            if c == '(':\n                left_count += 1\n            elif c == ')':\n                if left_count > 0:\n                    left_count -= 1\n                else:\n                    right_count += 1\n        # 2. remove the left and right parentheses\n        left_removed = right_removed = 0\n        for c in s:\n            if c == '(':\n                left_removed += 1\n            elif c == ')':\n                if left_removed > 0:\n                    left_removed -= 1\n                else:\n                    right_removed += 1\n        # 3. find the valid parentheses\n        left_removed = min(left_removed, right_removed)\n        right_removed = max(left_removed, right_removed)\n        # 4. add the valid parentheses to the result\n        result = []\n        self.dfs(s, 0, left_removed, right_removed, '', result)\n        return result\n    \n    def dfs(self, s, start, left_removed, right_removed, path, result):\n        if left_removed == 0 and right_removed == 0:\n            if path not in result:\n                result.append(path)\n            return\n        for i in range(start, len(s)):\n            if i > start and s[i] == s[i - 1]:\n                continue\n            if s[i] == '(' or s[i] == ')':\n                if left_removed > 0 and s[i] == '(':\n                    self.dfs(s, i + 1, left_removed - 1, right_removed, path + s[i], result)\n                elif right_removed > 0 and s[i] == ')':\n                    self.dfs(s, i + 1, left_removed, right_removed - 1, path + s[i], result)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i+1] if i+1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^n - 1\n        # 4. 3 * 10^n - 1\n        # 5. 2 * 10^n - 1\n        # 6. 1 * 10^n - 1\n        # 7. 0\n        \n        # 1. 10^n - 1\n        # 2. 5 * 10^n - 1\n        # 3. 4 * 10^"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a hashmap to store the reverse of each word\n        # and the index of the word\n        word_map = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # create a list to store the result\n        result = []\n        \n        # iterate over each word in the words list\n        for i, word in enumerate(words):\n            # if the word is a palindrome\n            if word in word_map:\n                # if the word is the same as its reverse\n                if i != word_map[word]:\n                    # add the pair to the result\n                    result.append([i, word_map[word]])\n            # iterate over each character in the word\n            for j in range(len(word)):\n                # get the prefix and suffix of the word\n                prefix, suffix = word[:j], word[j:]\n                # if the suffix is a palindrome and the prefix is a reversed word\n                if suffix[::-1] in word_map and prefix == word_map[suffix[::-1]][1:]:\n                    # add the pair to the result\n                    result.append([i, word_map[suffix[::-1]][0]])\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        def spread(i, j):\n            if isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 1\n            return 1 + spread(i-1, j) + spread(i+1, j) + spread(i, j-1) + spread(i, j+1)\n        \n        def build(i, j):\n            if isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 2\n            return 1 + build(i-1, j) + build(i+1, j) + build(i, j-1) + build(i, j+1)\n        \n        ans = 0\n        while True:\n            infected = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.add((i, j))\n            if not infected:\n                break\n            infected = list(infected)\n            for i, j in infected:\n                isInfected[i][j] = 0\n            ans += spread(i, j)\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        ans += build(i, j)\n        return ans"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_len = 1\n        \n        for d in dirs:\n            x, y = i + d[0], j + d[1]\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += n // (i * 10) * i + min(max(n % (i * 10) - i + 1, 0), i)\n            i *= 10\n        \n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            result.append(level)\n            left_to_right = not left_to_right\n            \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return \"%d:%02d\" % (h, m)\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.append(get_time(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, len(res[-1])):\n                row.append(res[-1][j] + res[-1][j-1])\n            row.append(1)\n            res.append(row)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left_gain + right_gain + node.val)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set((0, 0)) | set((m-1, n-1))\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(0, h - heightMap[ni][nj])\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n                    seen.add((ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # O(n) time, O(n) space\n        # Use a max heap to store the first half of the array\n        # Use a min heap to store the second half of the array\n        # If the size of the heaps is uneven, the median is the max of the two heaps\n        # If the size of the heaps is even, the median is the average of the two maxes\n        # If the size of the heaps is even, the median is the average of the two min\n        # If the size of the heaps is uneven, the median is the min of the two heaps\n        \n        if len(nums) == 0:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        # Initialize the heaps\n        max_heap = []\n        min_heap = []\n        \n        # Initialize the median\n        median = (nums[0] + nums[k - 1]) / 2.0\n        \n        # Initialize the result\n        result = [median]\n        \n        # Initialize the index\n        i = 0\n        \n        # Iterate over the array\n        for j in range(k, len(nums)):\n            # Add the current element to the max heap\n            heapq.heappush(max_heap, -nums[j])\n            # Remove the smallest element from the max heap\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            # If the size of the heaps is uneven, the median is the max of the two heaps\n            if len(max_heap) > len(min_heap):\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            # If the size of the heaps is even, the median is the average of the two maxes\n            if len(max_heap) == len(min_heap):\n                median = (max_heap[0] + min_heap[0]) / 2.0\n            # If the size of the heaps is even, the median is the average of the two min\n            if len(max_heap) == len(min_heap) + 1:\n                median = min_heap[0]\n            # Add the median to the result\n            result.append(median)\n            # Remove the element at the beginning of the array\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n            # If the size of the heaps is uneven, the median is the min of the two heaps\n            if len(max_heap) > len(min_heap):\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            # If the size of the heaps is even, the median is the average of the two maxes\n            if len(max_heap) == len(min_heap):\n                median = (max_heap[0] + min_heap[0]) / 2.0\n            # Remove the element at the beginning of the array\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n            # If the size of the heaps is uneven, the median is the min of the two heaps\n            if len(max_heap) > len(min_heap):\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            # If the size of the heaps is even, the median is the average of the two maxes\n            if len(max_heap) == len(min_heap) + 1:\n                median = min_heap[0]\n            # Add the median to the result\n            result.append(median)\n            # Increment the index\n            i += 1\n        \n        # Return the result\n        return result"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head\n        k = k % length\n        if k == 0:\n            return head\n        \n        # find the new tail\n        new_tail = head\n        for _ in range(length - k - 1):\n            new_tail = new_tail.next\n        \n        # find the new head\n        new_head = new_tail.next\n        \n        # break the list\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                res = max(res, self.maxSubArray(sums, k))\n                if res == k:\n                    return k\n        return res\n    \n    def maxSubArray(self, sums, k):\n        s = 0\n        res = float('-inf')\n        seen = {0: -1}\n        for i, v in enumerate(sums):\n            s += v\n            if s - k in seen:\n                res = max(res, s - seen[s - k])\n            if s not in seen:\n                seen[s] = i\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return min(2**31-1, max(-2**31, dividend//divisor))\n        \n        if dividend > 0 and divisor < 0:\n            return min(2**31-1, max(-2**31, dividend//divisor))\n        \n        if dividend < 0 and divisor > 0:\n            return min(2**31-1, max(-2**31, dividend//divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return min(2**31-1, max(-2**31, dividend//divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n            \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n            \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n            \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the number and its index\n        num_dict = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            \n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                \n                # return the index of the number and the index of the difference\n                return [num_dict[target - num], i]\n            \n            # add the number to the dictionary\n            num_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_a, new_b = a + b, a - b\n                        elif op == '-':\n                            new_a, new_b = a - b, b - a\n                        elif op == '*':\n                            new_a, new_b = a * b, a / b\n                        else:\n                            new_a, new_b = b / a, a / b\n                        if new_b > 0 and backtrack([new_a] + cards[1:], target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if p[0] != '*':\n            return s and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        while s and (s[0] == p[0] or p[0] == '?'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        return self.isMatch(s, p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100208/Python-O(n)-time-O"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n            \n        # dfs\n        res = []\n        def dfs(from_city):\n            # if there is no more city to visit, add to the result\n            if len(graph[from_city]) == 0:\n                res.append(from_city)\n                return\n            # visit all the next city\n            for i in range(len(graph[from_city])):\n                next_city = graph[from_city][i]\n                # remove the edge\n                graph[from_city].pop(i)\n                # dfs\n                dfs(next_city)\n                \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = [[0, 0]]\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the building is ending\n            if building[1] < 0:\n                # add the building to the result\n                result.append([building[0], -building[1]])\n            else:\n                # find the index of the building in the result\n                i = 0\n                while i < len(result) and result[i][0] < building[0]:\n                    i += 1\n                # if the building is ending\n                if building[1] < 0:\n                    # remove the building from the result\n                    result.pop(i)\n                else:\n                    # update the height of the building in the result\n                    result[i][1] = max(result[i][1], -building[1])\n        \n        # sort the result by height\n        result.sort(key=lambda x: x[1])\n        \n        # return the result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + (\" \" + helper(num % 10))\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(0, k+1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if j >= i:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % MOD\n        \n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. find the node that creates a cycle\n        \n        # 1. find the node with two parents\n        parent = {}\n        child = {}\n        for edge in edges:\n            if edge[0] in parent:\n                if edge[1] in child:\n                    return [edge[1], edge[0]]\n                else:\n                    child[edge[1]] = True\n            else:\n                parent[edge[0]] = True\n                child[edge[1]] = True\n        \n        # 2. find the edge that creates a cycle\n        for edge in edges:\n            if edge[0] in parent and edge[1] in child:\n                return edge\n        \n        # 3. find the node that creates a cycle\n        for edge in edges:\n            if edge[0] not in parent and edge[1] not in child:\n                return edge"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n                \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        elif num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2*sum(set(nums))-sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split()[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    p1 = max(j1 - 1, 0)\n                    p2 = min(j1 + 1, n - 1)\n                    p3 = max(j2 - 1, 0)\n                    p4 = min(j2 + 1, n - 1)\n                    if grid[i][j1] == -1 or grid[i][j2] == -1:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2]\n                    elif j1 == j2:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1]\n                    else:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + grid[i][j2]\n                    if j1 != j2:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][p1][p2] + dp[i - 1][p3][p4])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if grid[n - 1][j1] * grid[n - 1][j2] > 0)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # edge case\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        #     else:\n        #         nums[i] = nums[i - 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i + 1]:\n        #         nums[i] = nums[i + 1]\n        #     else:\n        #         nums[i] = nums[i + 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i + 1]:\n        #         nums[i] = nums[i + 1]\n        #     else:\n        #         nums[i] = nums[i + 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i + 1]:\n        #         nums[i] = nums[i + 1]\n        #     else:\n        #         nums[i] = nums[i + 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i + 1]:\n        #         nums[i] = nums[i + 1]\n        #     else:\n        #         nums[i] = nums[i + 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i + 1"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        \n        for j in range(1,n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = self.countAndSay(n-1)\n        res = ''\n        count = 1\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i-1]:\n                count += 1\n            else:\n                res += str(count) + prev[i-1]\n                count = 1\n        res += str(count) + prev[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max element in the array\n        # find the min element in the array\n        # find the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array\n        # find the sum of the mid element in the array"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        pivot = l\n        \n        # find the target\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[(m + pivot) % len(nums)] < target:\n                l = m + 1\n            elif nums[(m + pivot) % len(nums)] > target:\n                r = m - 1\n            else:\n                return (m + pivot) % len(nums)\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            # base case: no more digits to check\n            if not next_digits:\n                # completed combination\n                output.append(combination)\n                return\n            \n            # get the next digit\n            first, rest = next_digits[0], next_digits[1:]\n            \n            # recurse using a different combination\n            for letter in digit_to_letters[first]:\n                backtrack(combination + letter, rest)\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            self.dfs(nums, target - nums[i], i, path + [nums[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the string\n        length = len(n)\n        \n        # 2. get the left and right part of the string\n        left = n[:length//2]\n        right = n[length//2:]\n        \n        # 3. get the list of all possible palindromes\n        palindromes = [int(left + str(i) + right) for i in [int(left), int(right) - 1, int(right) + 1]]\n        \n        # 4. get the closest palindrome\n        closest = min(palindromes, key=lambda x: (abs(x - int(n)), x))\n        \n        # 5. return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        \n        return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n // 2):\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum product and the current maximum product\n        max_product = nums[0]\n        curr_max = nums[0]\n        \n        # Iterate through the array from the second element\n        for i in range(1, len(nums)):\n            # If the current element is positive, update the current maximum product\n            if nums[i] > 0:\n                curr_max = max(nums[i], curr_max * nums[i])\n            # If the current element is negative, update the maximum product\n            else:\n                curr_max = max(nums[i], curr_max * nums[i])\n                max_product = max(max_product, curr_max)\n        \n        return max_product"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a hashmap\n        # 2. iterate through the stones\n        # 3. if the stone is 0, return False\n        # 4. if the stone is 1, return True\n        # 5. if the stone is 2, return True\n        # 6. if the stone is 3, return True\n        # 7. if the stone is 4, return True\n        # 8. if the stone is 5, return True\n        # 9. if the stone is 6, return True\n        # 10. if the stone is 7, return True\n        # 11. if the stone is 8, return True\n        # 12. if the stone is 9, return True\n        # 13. if the stone is 10, return True\n        # 14. if the stone is 11, return True\n        # 15. if the stone is 12, return True\n        # 16. if the stone is 13, return True\n        # 17. if the stone is 14, return True\n        # 18. if the stone is 15, return True\n        # 19. if the stone is 16, return True\n        # 20. if the stone is 17, return True\n        # 21. if the stone is 18, return True\n        # 22. if the stone is 19, return True\n        # 23. if the stone is 20, return True\n        # 24. if the stone is 21, return True\n        # 25. if the stone is 22, return True\n        # 26. if the stone is 23, return True\n        # 27. if the stone is 24, return True\n        # 28. if the stone is 25, return True\n        # 29. if the stone is 26, return True\n        # 30. if the stone is 27, return True\n        # 31. if the stone is 28, return True\n        # 32. if the stone is 29, return True\n        # 33. if the stone is 30, return True\n        # 34. if the stone is 31, return True\n        # 35. if the stone is 32, return True\n        # 36. if the stone is 33, return True\n        # 37. if the stone is 34, return True\n        # 38. if the stone is 35, return True\n        # 39. if the stone is 36, return True\n        # 40. if the stone is 37, return True\n        # 41. if the stone is 38, return True\n        # 42. if the stone is 39, return True\n        # 43. if the stone is 40, return True\n        # 44. if the stone is 41, return True\n        # 45. if the stone is 42, return True\n        # 46. if the stone is 43, return True\n        # 47. if the stone is 44, return True\n        # 48. if the stone is 45, return True\n        # 49. if the stone is 46, return True\n        # 50. if the stone is 47, return True\n        # 51. if the stone is 48, return True\n        # 52. if the stone is 49, return True\n        # 53. if the stone is 50, return True\n        # 54. if the stone is 51, return True\n        # 55. if the stone is 52, return True\n        # 56. if the stone is 53, return True\n        # 57. if the stone is 54, return True\n        # 58. if the stone is 55, return True\n        # 59. if the stone is 56, return True\n        # 60. if the stone is 57, return True\n        # 61. if the stone is 58, return True\n        # 62. if the stone is 59, return True"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in en.umerate(score_sorted):\n            score_rank[s] = i + 1\n        \n        # map the score to the rank\n        return [score_rank[s] if s in score_rank else str(len(score_sorted) + 1) for s in score]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 1\n        start = 0\n        end = 1\n        seen = set()\n        seen.add(s[0])\n        \n        while end < len(s):\n            if s[end] not in seen:\n                seen.add(s[end])\n                end += 1\n                max_len = max(max_len, end - start)\n            else:\n                seen.remove(s[start])\n                start += 1\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    left = j + word_len\n                    word_dict_copy = word_dict.copy()\n                if not word_dict_copy:\n                    res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        res = 1\n        \n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                res += 1\n                \n        return res"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            l, r = i+1, len(nums)-1\n            \n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                \n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    \n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    \n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                    \n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i, j = left, mid\n            while i < mid:\n                while j < right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - mid\n                i += 1\n            nums[left:right] = sorted(nums[left:right])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left + 1 >= right:\n                return 0\n            mid = (left + right) // 2\n            return merge(nums, left, mid, right) + mergeSort(nums, mid, right) + mergeSort(nums, left, mid)\n        \n        return mergeSort(nums, 0, len(nums))"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # greedy\n        # max heap\n        heap = []\n        \n        # sum of durations\n        total = 0\n        \n        for duration, end in courses:\n            # add to heap\n            heapq.heappush(heap, duration)\n            # add duration to total\n            total += duration\n            # if total exceeds end date, remove from heap\n            if total > end:\n                total -= heapq.heappop(heap)\n        \n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    break\n                kth = kth.next\n            if not kth:\n                break\n            # reverse the nodes in the range\n            curr = prev.next\n            nxt = curr.next\n            for i in range(k - 1):\n                curr.next = nxt.next\n                nxt.next = prev.next\n                prev.next = nxt\n                nxt = curr.next\n            # update the pointers\n            prev = curr\n        \n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers\n        # 2. XOR all the numbers again\n        # 3. The remaining number is the answer\n        \n        a = 0\n        for num in nums:\n            a ^= num\n            \n        return a"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. for each letter in target, check if it can be made from stickers\n        # 4. if it can, add 1 to the count\n        # 5. if it can't, check if it can be made from stickers with one less sticker\n        # 6. if it can't, return -1\n        \n        sticker_dict = {}\n        for sticker in stickers:\n            sticker_dict[sticker] = sticker_dict.get(sticker, 0) + 1\n        \n        target_dict = {}\n        for letter in target:\n            target_dict[letter] = target_dict.get(letter, 0) + 1\n        \n        queue = [(target_dict, 0)]\n        visited = set()\n        while queue:\n            target_dict, count = queue.pop(0)\n            if target_dict == sticker_dict:\n                return count\n            if target_dict in visited:\n                continue\n            visited.add(target_dict)\n            for letter in target_dict:\n                if target_dict[letter] > 0:\n                    for sticker in sticker_dict:\n                        if sticker[target_dict[letter]] > 0:\n                            new_dict = target_dict.copy()\n                            new_dict[sticker] -= 1\n                            if new_dict[sticker] == 0:\n                                del new_dict[sticker]\n                            queue.append((new_dict, count + 1))\n        return -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        \n        for i in range(len(s)):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n                \n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if k == 1:\n            return nums\n        \n        max_list = []\n        max_num = max(nums[0:k])\n        max_list.append(max_num)\n        \n        for i in range(k, len(nums)):\n            if nums[i] > max_num:\n                max_num = nums[i]\n            if i >= k:\n                if nums[i-k] == max_num:\n                    max_num = max(nums[i-k+1:i+1])\n                else:\n                    max_num = max(max_num, nums[i-k+1])\n            max_list.append(max_num)\n        \n        return max_list"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge nums1 and nums2 into a single sorted list\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 1:\n            return nums1[len(nums1) // 2]\n        else:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] > nums[mid + 1]:\n        #         return nums[mid + 1]\n        #     if nums[mid] < nums[mid - 1]:\n        #         return nums[mid]\n        #     if nums[mid] > nums[0]:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            if nums[mid] < nums[mid - 1]:\n                return nums[mid]\n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and root.val == targetSum:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area / 2) = area\n        # 2. 2 * (area / 2) + 1 = area\n        # 3. 2 * (area / 2) + 1 - 1 = area\n        # 4. 2 * (area / 2) + 1 - 2 = area - 1\n        # 5. 2 * (area / 2) + 1 - 3 = area - 2\n        # 6. 2 * (area / 2) + 1 - 4 = area - 3\n        # 7. 2 * (area / 2) + 1 - 5 = area - 4\n        # 8. 2 * (area / 2) + 1 - 6 = area - 5\n        # 9. 2 * (area / 2) + 1 - 7 = area - 6\n        # 10. 2 * (area / 2) + 1 - 8 = area - 7\n        # 11. 2 * (area / 2) + 1 - 9 = area - 8\n        # 12. 2 * (area / 2) + 1 - 10 = area - 9\n        # 13. 2 * (area / 2) + 1 - 11 = area - 10\n        # 14. 2 * (area / 2) + 1 - 12 = area - 11\n        # 15. 2 * (area / 2) + 1 - 13 = area - 12\n        # 16. 2 * (area / 2) + 1 - 14 = area - 13\n        # 17. 2 * (area / 2) + 1 - 15 = area - 14\n        # 18. 2 * (area / 2) + 1 - 16 = area - 15\n        # 19. 2 * (area / 2) + 1 - 17 = area - 16\n        # 20. 2 * (area / 2) + 1 - 18 = area - 17\n        # 21. 2 * (area / 2) + 1 - 19 = area - 18\n        # 22. 2 * (area / 2) + 1 - 20 = area - 19\n        # 23. 2 * (area / 2) + 1 - 21 = area - 20\n        # 24. 2 * (area / 2) + 1 - 22 = area - 21\n        # 25. 2 * (area / 2) + 1 - 23 = area - 22\n        # 26. 2 * (area / 2) + 1 - 24 = area - 23\n        # 27. 2 * (area / 2) + 1 - 25 = area - 24\n        # 28. 2 * (area / 2) + 1 - 26 = area - 25\n        # 29. 2 * (area / 2) + 1 - 27 = area - 26\n        # 30. 2 * (area / 2) + 1 - 28 = area - 27\n        # 31. 2 * (area / 2) + 1 - 29 = area - 28\n        # 32. 2 * (area / 2) + 1 - 30 = area - 29\n        # 33. 2 * (area / 2) + 1 - 31 = area - 30\n        # 34. 2 * (area / 2) + 1 - 32 = area - 31\n        # 35. 2 * (area / 2) + 1 - 33 = area - 32\n        # 36. 2 * (area / 2) + 1 - 34 = area - 33\n        # 37. 2 * (area / 2) + 1 - 35 = area - 34\n        # 38. 2 * (area / 2) + 1 - 36 = area - 35\n        # 39. 2 *"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build queue and visited\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        \n        # BFS\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for neighbor in graph[word[:i] + '*' + word[i+1:]]:\n                    if neighbor not in visited:\n                        visited[neighbor] = word\n                        queue.append(neighbor)\n        \n        # build path\n        path = []\n        while endWord:\n            path.append(endWord)\n            endWord = visited[endWord]\n        return path[::-1]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n            else:\n                res += [nums[i]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles or (x_max, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        \n        for num in nums:\n            if cur_sum < 0:\n                cur_sum = num\n            else:\n                cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [0] * 12\n        for i in range(2):\n            for j in range(3):\n                board_1d[i*3 + j] = board[i][j]\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set(board_tuple)\n        \n        # convert board_set to a list\n        board_list = list(board_set)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[i]: i for i in range(len(board_list))}\n        \n        # convert board_dict to a tuple\n        board_tuple = tuple(board_dict)\n        \n        # convert board_tuple to a string\n        board_str = ''.join(str(x) for x in board_tuple)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set(board_tuple)\n        \n        # convert board_set to a list\n        board_list = list(board_set)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[i]: i for i in range(len(board_list))}\n        \n        # convert board_dict to a tuple\n        board_tuple = tuple(board_dict)\n        \n        # convert board_tuple to a string\n        board_str = ''.join(str(x) for x in board_tuple)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set(board_tuple)\n        \n        # convert board_set to a list\n        board_list = list(board_set)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[i]: i for i in range(len(board_list))}\n        \n        # convert board_dict to a tuple\n        board_tuple = tuple(board_dict)\n        \n        # convert board_tuple to a string\n        board_str = ''.join(str(x) for x in board_tuple)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set(board_tuple)\n        \n        # convert board_set to a list\n        board_list = list(board_set)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[i]: i for i in range(len(board_list))}\n        \n        # convert board_dict to a tuple\n        board_tuple = tuple(board_dict)\n        \n        # convert board_tuple to a string\n        board_str = ''.join(str(x) for x in board_tuple)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set(board_tuple)\n        \n        # convert board_set to a list\n        board_list = list(board_set)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[i]: i for i in range(len(board_list))}\n        \n        # convert board_dict to a tuple\n        board_tuple = tuple(board_dict)\n        \n        # convert board_tuple to a string\n        board_str = ''.join(str(x) for x in board_tuple)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set(board_tuple)\n        \n        # convert board_set to a"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if target is in the first half\n        if nums[pivot] == target:\n            return True\n        \n        # if target is in the second half\n        if nums[0] <= target:\n            return self.binary_search(nums, 0, pivot - 1, target)\n        \n        # if target is in the first half\n        return self.binary_search(nums, pivot + 1, len(nums) - 1, target)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n        \n    def binary_search(self, nums, left, right, target):\n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.prev_val = None\n        self.max_val = None\n        self.curr_count = 0\n        \n        self.dfs(root)\n        \n        return [self.max_val] if self.max_count == 1 else [self.max_val, self.prev_val]\n        \n    def dfs(self, node):\n        if not node:\n            return\n        \n        if node.val == self.prev_val:\n            self.curr_count += 1\n        else:\n            self.curr_count = 1\n            \n        if self.curr_count > self.max_count:\n            self.max_count = self.curr_count\n            self.max_val = node.val\n        elif self.curr_count == self.max_count:\n            self.max_val = node.val\n            \n        self.prev_val = node.val\n        \n        self.dfs(node.left)\n        self.dfs(node.right)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check length\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        if len(password) > 20:\n            return max(20 - len(password), 3)\n        \n        # 2. check for repeating characters\n        # 2.1 check for 3 repeating characters in a row\n        # 2.2 check for 2 repeating characters in a row\n        # 2.3 check for 1 repeating character in a row\n        # 2.4 check for 0 repeating characters in a row\n        # 2.5 check for 0 repeating characters\n        # 2.6 check for 1 repeating character\n        # 2.7 check for 2 repeating characters\n        # 2.8 check for 3 repeating characters\n        # 2.9 check for 4 repeating characters\n        # 2.10 check for 5 repeating characters\n        # 2.11 check for 6 repeating characters\n        # 2.12 check for 7 repeating characters\n        # 2.13 check for 8 repeating characters\n        # 2.14 check for 9 repeating characters\n        # 2.15 check for 10 repeating characters\n        # 2.16 check for 11 repeating characters\n        # 2.17 check for 12 repeating characters\n        # 2.18 check for 13 repeating characters\n        # 2.19 check for 14 repeating characters\n        # 2.20 check for 15 repeating characters\n        # 2.21 check for 16 repeating characters\n        # 2.22 check for 17 repeating characters\n        # 2.23 check for 18 repeating characters\n        # 2.24 check for 19 repeating characters\n        # 2.25 check for 20 repeating characters\n        # 2.26 check for 21 repeating characters\n        # 2.27 check for 22 repeating characters\n        # 2.28 check for 23 repeating characters\n        # 2.29 check for 24 repeating characters\n        # 2.30 check for 25 repeating characters\n        # 2.31 check for 26 repeating characters\n        # 2.32 check for 27 repeating characters\n        # 2.33 check for 28 repeating characters\n        # 2.34 check for 29 repeating characters\n        # 2.35 check for 30 repeating characters\n        # 2.36 check for 31 repeating characters\n        # 2.37 check for 32 repeating characters\n        # 2.38 check for 33 repeating characters\n        # 2.39 check for 34 repeating characters\n        # 2.40 check for 35 repeating characters\n        # 2.41 check for 36 repeating characters\n        # 2.42 check for 37 repeating characters\n        # 2.43 check for 38 repeating characters\n        # 2.44 check for 39 repeating characters\n        # 2.45 check for 40 repeating characters\n        # 2.46 check for 41 repeating characters\n        # 2.47 check for 42 repeating characters\n        # 2.48 check for 43 repeating characters\n        # 2.49 check for 44 repeating characters\n        # 2.50 check for 45 repeating characters\n        # 2.51 check for 46 repeating characters\n        # 2.52 check for 47 repeating characters\n        # 2.53 check for 48 repeating characters\n        # 2.54 check for 49 repeating characters\n        # 2.55 check for 50 repeating characters\n        # 2.56 check for 51 repeating characters\n        # 2.57 check for 52 repeating characters\n        # 2.58 check for 53 repeating characters\n        # 2.59 check for 54 repeating characters\n        # 2.60 check for 55 repeating characters\n        # 2.61 check for 56 repeating characters\n        # 2.62 check for 57 repeating characters\n        # 2.63 check for 58 repeating characters\n        # 2.64 check for 59 repeating characters\n        # 2."}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        return n / 5 + self.trailingZeroes(n / 5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row = 0\n        down = True\n        \n        for c in s:\n            res[row] += c\n            if row == 0:\n                down = True\n            elif row == numRows - 1:\n                down = False\n            if down:\n                row += 1\n            else:\n                row -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        # 6. 5 pass\n        # 7. 6 pass\n        # 8. 7 pass\n        # 9. 8 pass\n        # 10. 9 pass\n        # 11. 10 pass\n        # 12. 11 pass\n        # 13. 12 pass\n        # 14. 13 pass\n        # 15. 14 pass\n        # 16. 15 pass\n        # 17. 16 pass\n        # 18. 17 pass\n        # 19. 18 pass\n        # 20. 19 pass\n        # 21. 20 pass\n        # 22. 21 pass\n        # 23. 22 pass\n        # 24. 23 pass\n        # 25. 24 pass\n        # 26. 25 pass\n        # 27. 26 pass\n        # 28. 27 pass\n        # 29. 28 pass\n        # 30. 29 pass\n        # 31. 30 pass\n        # 32. 31 pass\n        # 33. 32 pass\n        # 34. 33 pass\n        # 35. 34 pass\n        # 36. 35 pass\n        # 37. 36 pass\n        # 38. 37 pass\n        # 39. 38 pass\n        # 40. 39 pass\n        # 41. 40 pass\n        # 42. 41 pass\n        # 43. 42 pass\n        # 44. 43 pass\n        # 45. 44 pass\n        # 46. 45 pass\n        # 47. 46 pass\n        # 48. 47 pass\n        # 49. 48 pass\n        # 50. 49 pass\n        # 51. 50 pass\n        # 52. 51 pass\n        # 53. 52 pass\n        # 54. 53 pass\n        # 55. 54 pass\n        # 56. 55 pass\n        # 57. 56 pass\n        # 58. 57 pass\n        # 59. 58 pass\n        # 60. 59 pass\n        # 61. 60 pass\n        # 62. 61 pass\n        # 63. 62 pass\n        # 64. 63 pass\n        # 65. 64 pass\n        # 66. 65 pass\n        # 67. 66 pass\n        # 68. 67 pass\n        # 69. 68 pass\n        # 70. 69 pass\n        # 71. 70 pass\n        # 72. 71 pass\n        # 73. 72 pass\n        # 74. 73 pass\n        # 75. 74 pass\n        # 76. 75 pass\n        # 77. 76 pass\n        # 78. 77 pass\n        # 79. 78 pass\n        # 80. 79 pass\n        # 81. 80 pass\n        # 82. 81 pass\n        # 83. 82 pass\n        # 84. 83 pass\n        # 85. 84 pass\n        # 86. 85 pass\n        # 87. 86 pass\n        # 88. 87 pass\n        # 89. 88 pass\n        # 90. 89 pass\n        # 91. 90 pass\n        # 92. 91 pass\n        # 93. 92 pass\n        # 94. 93 pass\n        # 95."}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Mark the number as negative if it is present in the array\n        ## 2. Iterate over the array and return the numbers that are not negative\n        ## 3. If the number is not negative, it is missing\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use binary search to find the index of the number in the sorted array\n        # 3. count the number of numbers smaller than the current number\n        # 4. return the count\n        \n        # 1. sort the array\n        nums = [(num, i) for i, num in enumerate(nums)]\n        nums.sort()\n        \n        # 2. use binary search to find the index of the number in the sorted array\n        # 3. count the number of numbers smaller than the current number\n        # 4. return the count\n        res = [0] * len(nums)\n        for num, i in nums:\n            res[i] = sum(1 for n in nums if n[0] < num[0])\n        return res"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = cur = 2\n        for i in intervals:\n            if i[0] > cur:\n                cur += 2\n            else:\n                cur = i[1] + 1\n            ans += cur - i[1] - 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # iterate through nums\n        while i < len(nums):\n            # if nums[i] is greater than n, then we need to add a patch\n            if nums[i] > n:\n                patches += 1\n                n += nums[i]\n            else:\n                # if nums[i] is less than n, then we can add it to n\n                n += nums[i]\n                i += 1\n        \n        # return the number of patches needed\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = []\n        if numerator < 0 == denominator < 0:\n            res.append('-')\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res.append(str(numerator // denominator))\n        numerator %= denominator\n        \n        if numerator == 0:\n            return ''.join(res)\n        \n        res.append('.')\n        seen = {}\n        while numerator:\n            if numerator in seen:\n                res.insert(seen[numerator], '(')\n                res.append(')')\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res.append(str(numerator // denominator))\n            numerator %= denominator\n        \n        return ''.join(res)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        dp = []\n        \n        for i in envelopes:\n            if not dp or i[1] > dp[-1]:\n                dp.append(i[1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < i[1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = i[1]\n        \n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        \n        for i in range(m):\n            if matrix[i][0] == 0:\n                row_zero = True\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if matrix[0][0] == 0:\n            for i in range(m):\n                matrix[i][0] = 0\n        \n        if row_zero:\n            for i in range(m):\n                matrix[i][0] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = head\n        \n        # move fast pointer n steps\n        for i in range(n):\n            fast = fast.next\n        \n        # move both pointers until fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node\n        slow.next = slow.next.next\n        \n        # return the modified head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) / len(machines)\n        ans = 0\n        curr = 0\n        for m in machines:\n            curr += m - avg\n            ans = max(ans, abs(curr))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(n, x // i)\n            return cnt\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [curr + [num] for curr in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[right]:\n                right = mid - 1\n            else:\n                left = mid + 1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in {'+', '-'}:\n            return self.isValid(s)\n        \n        # 3. check if it is a valid number\n        return self.isValid(s[1:])\n        \n    def isValid(self, s):\n        # 1. check if it is a valid integer\n        if not s or s[0] not in {'+', '-'}:\n            return self.isValidInteger(s)\n        \n        # 2. check if it is a valid decimal\n        return self.isValidDecimal(s)\n        \n    def isValidInteger(self, s):\n        # 1. check if it is a valid integer\n        if not s or s[0] not in {'+', '-'}:\n            return False\n        \n        # 2. check if it is a valid integer\n        return self.isValidInteger(s[1:])\n        \n    def isValidDecimal(self, s):\n        # 1. check if it is a valid decimal\n        if not s:\n            return False\n        \n        # 2. check if it is a valid decimal\n        return self.isValidInteger(s)\n        \n        # 3. check if it is a valid decimal\n        return self.isValidDecimal(s[1:])"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet\n        ## 26 alphabet"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            \n            row = l[0]\n            col = l[1]\n            \n            for num in range(1, 10):\n                if is_valid(board, row, col, str(num)):\n                    board[row][col] = str(num)\n                    \n                    if solve_sudoku(board):\n                        return True\n                    \n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        if not head:\n            return True\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left, right = 0, num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        ans = [0]\n        for i in range(1, n + 1):\n            ans.append(ans[i >> 1] + (i & 1))\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['#'] = word\n        \n        def dfs(i, j, node):\n            letter = board[i][j]\n            if letter not in node:\n                return set()\n            word = node.pop(letter)\n            res.add(word)\n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                if 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] in node:\n                    dfs(x, y, node[board[x][y]])\n            node[letter] = word\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    dfs(i, j, trie[board[i][j]])\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 squares\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(square)) != len(square):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 1440000\n        # 26^5 = 73720000\n        # 26^6 = 3689600000\n        # 26^7 = 195312000000\n        # 26^8 = 1125899906842624\n        # 26^9 = 677626319032390624\n        # 26^10 = 4294967296000000000\n        # 26^11 = 274877906944000000000\n        # 26^12 = 1905386313850000000000\n        # 26^13 = 12814816257600000000000\n        # 26^14 = 85899345920000000000000\n        # 26^15 = 6291459001600000000000000\n        # 26^16 = 48628170105600000000000000\n        # 26^17 = 377516542432000000000000000\n        # 26^18 = 2958362612160000000000000000\n        # 26^19 = 23882812500000000000000000000\n        # 26^20 = 199323264000000000000000000000\n        # 26^21 = 1747673600000000000000000000000\n        # 26^22 = 15761631600000000000000000000000\n        # 26^23 = 143428509600000000000000000000000\n        # 26^24 = 1314816752000000000000000000000000\n        # 26^25 = 12155292160000000000000000000000000\n        # 26^26 = 113421772800000000000000000000000000\n        # 26^27 = 1072861536000000000000000000000000000\n        # 26^28 = 10293932800000000000000000000000000000\n        # 26^29 = 99841612800000000000000000000000000000\n        # 26^30 = 978848640000000000000000000000000000000\n        # 26^31 = 9614745"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            tmp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = tmp\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first.next, second.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for c, w in zip(pattern, words):\n            # if the word is not in the mapping, add it\n            if w not in mapping:\n                mapping[w] = c\n            # if the word is in the mapping, check if it matches the pattern\n            elif mapping[w] != c:\n                return False\n        \n        # if we reach here, all words have been mapped, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 or l2 or carry:\n            val1 = (l1.val if l1 else 0)\n            val2 = (l2.val if l2 else 0)\n            \n            carry, out = divmod(val1 + val2 + carry, 10)\n            \n            curr.next = ListNode(out)\n            curr = curr.next\n            \n            l1 = (l1.next if l1 else None)\n            l2 = (l2.next if l2 else None)\n            \n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        binary = ''.join('1' if bit == '0' else '0' for bit in binary)\n        \n        # 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        left, right = 0, len(height) - 1\n        max_area = 0\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time: O(N^2)\n        # Space: O(N)\n        # 1. Create a set of words\n        # 2. Iterate through each word in words\n        # 3. If word is in set, then check if it can be formed by concatenating other words\n        # 4. If it can, then add it to the result\n        # 5. If it cannot, then add it to the set\n        \n        word_set = set(words)\n        result = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                result.append(word)\n            word_set.add(word)\n            \n        return result\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and (suffix in word_set or self.dfs(suffix, word_set)):\n                return True\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row + col}, diag2 | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, word, i, j):\n                    return True\n        \n        return False\n    \n    def dfs(self, board, word, i, j):\n        if len(word) == 0:\n            return True\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n            return False\n        \n        temp = board[i][j]\n        board[i][j] = '#'\n        \n        res = self.dfs(board, word[1:], i + 1, j) or self.dfs(board, word[1:], i - 1, j) or self.dfs(board, word[1:], i, j + 1) or self.dfs(board, word[1:], i, j - 1)\n        \n        board[i][j] = temp\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # O(m+n) time, O(1) space\n        p1 = m - 1\n        p2 = n - 1\n        p = m + n - 1\n        \n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n        \n        if p2 >= 0:\n            nums1[:p2 + 1] = nums2[:p2 + 1]"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. else return the third element\n        \n        nums = sorted(set(nums))\n        return nums[-3] if len(nums) < 3 else nums[-1]"}]}