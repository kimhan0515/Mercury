{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1]\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][j] = dp[i][j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1]\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][j] = dp[i][j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][j] = 0"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the index is equal to the value\n        # 3. if the index is not equal to the value, return the index\n        # 4. if the index is equal to the value, continue\n        # 5. if the index is greater than the value, continue\n        # 6. if the index is less than the value, return the index + 1\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. iterate through the array and check if the index is equal to the value\n        # 3. if the index is not equal to the value, return the index\n        # 4. if the index is equal to the value, continue\n        # 5. if the index is greater than the value, continue\n        # 6. if the index is less than the value, return the index + 1\n        \n        for i in range(len(nums)):\n            if nums[i] > 0:\n                if nums[i] != i + 1:\n                    return i + 1\n        \n        # 7. if the index is less than the value, return the index + 1\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Find the first positive number\n        # 3. Find the first missing positive number\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Find the first positive number\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                break\n        \n        # 3. Find the first missing positive number\n        for i in range(1, len(nums)+1):\n            if i != nums[i-1]:\n                return i\n        \n        # 4. If all numbers are positive, return the length of the array + 1\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Find the first positive number\n        # 3. Iterate through the array and check if the number is in the range [1, len(nums)]\n        # 4. If the number is not in the range, return the index + 1\n        # 5. If the number is in the range, continue\n        # 6. If the array is empty, return 1\n        \n        nums.sort()\n        if not nums:\n            return 1\n        \n        for i in range(len(nums)):\n            if nums[i] > 0:\n                if nums[i] != i + 1:\n                    return i + 1\n        \n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the index is equal to the value\n        # 3. if the index is not equal to the value, return the index\n        # 4. if the index is equal to the value, continue\n        # 5. if the index is greater than the value, continue\n        # 6. if the index is less than the value, return the index + 1\n        \n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                if nums[i] != i + 1:\n                    return i + 1\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        # 3. If the current number is positive and less than the length of the array, swap the current number with the index of the current number\n        # 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        # 5. If the current number is positive and less than the length of the array, return the current number\n        # 6. If the current number is positive and greater than or equal to the length of the array, continue to the next iteration\n        # 7. If the current number is negative, continue to the next iteration\n        # 8. If the current number is 0, continue to the next iteration\n        # 9. If the current number is greater than the length of the array, continue to the next iteration\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                # 3. If the current number is positive and less than the length of the array, swap the current number with the index of the current number\n                temp = nums[i]\n                nums[i] = nums[temp - 1]\n                nums[temp - 1] = temp\n        \n        # 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                # 5. If the current number is positive and less than the length of the array, return the current number\n                return i + 1\n        \n        # 6. If the current number is positive and greater than or equal to the length of the array, continue to the next iteration\n        # 7. If the current number is negative, continue to the next iteration\n        # 8. If the current number is 0, continue to the next iteration\n        # 9. If the current number is greater than the length of the array, continue to the next iteration\n        \n        # 10. If the array is empty, return 1\n        if len(nums) == 0:\n            return 1\n        \n        # 11. If the array is not empty, return the length of the array + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9\n        # 2. 1,2,3,4,5,6,7,8,9\n        # 3. 1,2,3,4,5,6,7,8,9\n        # 4. 1,2,3,4,5,6,7,8,9\n        # 5. 1,2,3,4,5,6,7,8,9\n        # 6. 1,2,3,4,5,6,7,8,9\n        # 7. 1,2,3,4,5,6,7,8,9\n        # 8. 1,2,3,4,5,6,7,8,9\n        # 9. 1,2,3,4,5,6,7,8,9\n        # 10. 1,2,3,4,5,6,7,8,9\n        # 11. 1,2,3,4,5,6,7,8,9\n        # 12. 1,2,3,4,5,6,7,8,9\n        # 13. 1,2,3,4,5,6,7,8,9\n        # 14. 1,2,3,4,5,6,7,8,9\n        # 15. 1,2,3,4,5,6,7,8,9\n        # 16. 1,2,3,4,5,6,7,8,9\n        # 17. 1,2,3,4,5,6,7,8,9\n        # 18. 1,2,3,4,5,6,7,8,9\n        # 19. 1,2,3,4,5,6,7,8,9\n        # 20. 1,2,3,4,5,6,7,8,9\n        # 21. 1,2,3,4,5,6,7,8,9\n        # 22. 1,2,3,4,5,6,7,8,9\n        # 23. 1,2,3,4,5,6,7,8,9\n        # 24. 1,2,3,4,5,6,7,8,9\n        # 25. 1,2,3,4,5,6,7,8,9\n        # 26. 1,2,3,4,5,6,7,8,9\n        # 27. 1,2,3,4,5,6,7,8,9\n        # 28. 1,2,3,4,5,6,7,8,9\n        # 29. 1,2,3,4,5,6,7,8,9\n        # 30. 1,2,3,4,5,6,7,8,9\n        # 31. 1,2,3,4,5,6,7,8,9\n        # 32. 1,2,3,4,5,6,7,8,9\n        # 33. 1,2,3,4,5,6,7,8,9\n        # 34. 1,2,3,4,5,6,7,8,9\n        # 35. 1,2,3,4,5,6,7,8,9\n        # 36. 1,2,3,4,5,6,7,8,9\n        # 37. 1,2,3,4,5,6,7,8,9\n        # 38. 1,2,3,4,5,6,7,8,9\n        # 39. 1,2,3,4,5,6,7,8,9\n        # 40. 1,2,3,4,5,6,7,8,9\n        # 41. 1,2,3,4,5,6,7,8,9\n        # 42. 1"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n\n        # 2. Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        left = 0\n        right = len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n\n        return [-1, -1]"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n\n        # 2. Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        left, right = 0, len(numbers)-1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n\n        return [-1, -1]"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \uc0c1\ud0dc\uc5d0\uc11c \uc591\ucabd \ub05d\uc5d0\uc11c \uc2dc\uc791\ud574\uc11c \ud569\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \ud569\uc774 target\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc67c\ucabd \ud3ec\uc778\ud130\ub97c \uc624\ub978\ucabd\uc73c\ub85c \uc774\ub3d9\ud55c\ub2e4.\n        # 3. \ud569\uc774 target\ubcf4\ub2e4 \ud06c\uba74 \uc624\ub978\ucabd \ud3ec\uc778\ud130\ub97c \uc67c\ucabd\uc73c\ub85c \uc774\ub3d9\ud55c\ub2e4.\n        # 4. \ud569\uc774 target\uacfc \uac19\uc73c\uba74 \ubc18\ud658\ud55c\ub2e4.\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            sum = numbers[left] + numbers[right]\n            if sum == target:\n                return [left + 1, right + 1]\n            elif sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return [-1, -1]"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n\n        # 2. Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        left, right = 0, len(numbers)-1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n\n        return [-1, -1]"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # 1. set left and right pointers\n        # 2. if sum of left and right is less than target, increment left pointer\n        # 3. if sum of left and right is greater than target, decrement right pointer\n        # 4. if sum of left and right is equal to target, return [left+1, right+1]\n        # 5. if left pointer is greater than right pointer, return [-1, -1]\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] < target:\n                left += 1\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                return [left+1, right+1]\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr_num, curr_num, res)\n                else:\n                    backtrack(j+1, curr + prev, curr_num, res)\n                    backtrack(j+1, curr - prev, -curr_num, res)\n                    backtrack(j+1, curr - prev + curr_num, curr_num, res)\n        \n        res = []\n        backtrack(0, 0, 0, res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, curr, prev):\n            if not num:\n                if curr == target:\n                    res.append(op)\n                return\n            for i in range(1, len(num) + 1):\n                if i == 1 or num[0] != '0':\n                    curr = curr * 10 + int(num[:i])\n                    backtrack(num[i:], target, op + '*' + num[:i], res, curr, curr)\n                    curr = (curr - int(num[:i])) // 10\n                if i == 1 or num[0] != '0' and (op == '' or op[-1] != '*'):\n                    curr = curr + int(num[:i])\n                    backtrack(num[i:], target, op + '+' + num[:i], res, curr, curr)\n                    curr = curr - int(num[:i])\n        res = []\n        backtrack(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(\"\".join(path))\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == \"0\":\n                    break\n                curr = int(num[i:j+1])\n                if i == 0:\n                    backtrack(j+1, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, res)\n                    backtrack(j+1, curr, curr, res)\n                    backtrack(j+1, -curr, prev - curr, res)\n                    backtrack(j+1, -curr, curr - prev, res)\n                    backtrack(j+1, curr * prev, curr, res)\n                    backtrack(j+1, curr * prev, -curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr_num, curr_num, res)\n                else:\n                    backtrack(j+1, curr + prev, curr_num, res)\n                    backtrack(j+1, curr - prev, -curr_num, res)\n                    backtrack(j+1, curr - prev + curr_num, curr_num, res)\n        \n        res = []\n        backtrack(0, 0, 0, res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr_num, curr_num, res)\n                else:\n                    backtrack(j+1, curr + prev, curr_num, res)\n                    backtrack(j+1, curr - prev, -curr_num, res)\n                    backtrack(j+1, curr - prev + curr_num, curr_num, res)\n        \n        res = []\n        backtrack(0, 0, 0, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr*10 + root.val\n            return dfs(root.left, curr*10 + root.val) + dfs(root.right, curr*10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr*10 + root.val\n            return dfs(root.left, curr*10 + root.val) + dfs(root.right, curr*10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left = dfs(root.left, curr_sum * 10 + root.val)\n            right = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left + right\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        res = ''\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                res += '-'\n            res += s[i]\n        return res[::-1]"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        if len(s) <= k:\n            return s\n        else:\n            s = s[::-1]\n            s = s[k:]\n            s = s[::-1]\n            s = s.replace('-', '')\n            return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        res = ''\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                res += '-'\n            res += s[i]\n        return res[::-1]"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        if len(s) <= k:\n            return s\n        else:\n            s = s[::-1]\n            s = s[k:]\n            s = s[::-1]\n            s = s.replace('-', '')\n            return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        if n % k == 0:\n            return '-'.join(s[i:i+k] for i in range(0, n, k))\n        else:\n            return '-'.join(s[i:i+k] for i in range(0, n-n%k, k)) + '-' + s[-n%k:]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## TLE\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the gas array and cost array\n        ## 2. If the sum of gas[i] - cost[i] is negative, return -1\n        ## 3. Otherwise, keep track of the sum of gas[i] - cost[i]\n        ## 4. If the sum of gas[i] - cost[i] is negative, reset the sum to 0\n        ## 5. If the sum of gas[i] - cost[i] is positive, return the index\n        ## 6. If the sum of gas[i] - cost[i] is negative, reset the sum to 0\n        ## 7. Repeat steps 2-6 until the sum of gas[i] - cost[i] is positive\n        ## 8. If the sum of gas[i] - cost[i] is positive, return the index\n        ## 9. If the sum of gas[i] - cost[i] is negative, return -1\n        \n        sum_gas = 0\n        sum_cost = 0\n        for i in range(len(gas)):\n            sum_gas += gas[i]\n            sum_cost += cost[i]\n            if sum_gas < sum_cost:\n                sum_gas = 0\n                sum_cost = 0\n                if i == len(gas) - 1:\n                    return -1\n        return 0"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## TLE\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the gas array and cost array\n        ## 2. If the gas at the current station is less than the cost at the current station, then we cannot complete the circuit\n        ## 3. If the gas at the current station is greater than the cost at the current station, then we can complete the circuit\n        ## 4. If the gas at the current station is equal to the cost at the current station, then we can complete the circuit\n        ## 5. If we complete the circuit, then we return the index of the starting station\n        ## 6. If we cannot complete the circuit, then we return -1\n        \n        ## 1. Iterate through the gas array and cost array\n        for i in range(len(gas)):\n            ## 2. If the gas at the current station is less than the cost at the current station, then we cannot complete the circuit\n            if gas[i] < cost[i]:\n                continue\n            ## 3. If the gas at the current station is greater than the cost at the current station, then we can complete the circuit\n            else:\n                ## 4. If the gas at the current station is equal to the cost at the current station, then we can complete the circuit\n                if gas[i] == cost[i]:\n                    return i\n                ## 5. If we complete the circuit, then we return the index of the starting station\n                else:\n                    ## 6. If we cannot complete the circuit, then we return -1\n                    return -1\n        ## 7. If we complete the circuit, then we return the index of the starting station\n        return -1"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## TLE\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the gas array and cost array\n        ## 2. If the sum of gas[i] - cost[i] is negative, return -1\n        ## 3. Otherwise, keep track of the sum of gas[i] - cost[i]\n        ## 4. If the sum of gas[i] - cost[i] is negative, reset the sum to 0\n        ## 5. If the sum of gas[i] - cost[i] is positive, return the index\n        ## 6. If the sum of gas[i] - cost[i] is negative, reset the sum to 0\n        ## 7. Repeat steps 2-6 until the sum of gas[i] - cost[i] is positive\n        ## 8. If the sum of gas[i] - cost[i] is positive, return the index\n        ## 9. If the sum of gas[i] - cost[i] is negative, return -1\n        \n        sum_gas = 0\n        sum_cost = 0\n        for i in range(len(gas)):\n            sum_gas += gas[i]\n            sum_cost += cost[i]\n            if sum_gas < sum_cost:\n                sum_gas = 0\n                sum_cost = 0\n                i = -1\n            sum_gas -= gas[i]\n            sum_gas += cost[i]\n        if sum_gas >= sum_cost:\n            return i\n        else:\n            return -1"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        if total_gas < total_cost:\n            return -1\n        \n        start = 0\n        tank = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## TLE\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the gas array and cost array\n        ## 2. If the gas at the current station is less than the cost at the current station, return -1\n        ## 3. Otherwise, keep track of the total gas and the total cost\n        ## 4. If the total gas is less than the total cost, return -1\n        ## 5. Otherwise, return the index of the starting station\n        \n        total_gas = 0\n        total_cost = 0\n        for i in range(len(gas)):\n            if gas[i] < cost[i]:\n                return -1\n            total_gas += gas[i]\n            total_cost += cost[i]\n        if total_gas < total_cost:\n            return -1\n        else:\n            return 0"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        return dp[0][n-1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        return dp[0][n-1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        return dp[0][n-1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n-1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if len(s) < 1:\n                return False\n            return (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '.'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if len(s) < 1:\n                return False\n            return (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '.'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if len(s) < 1:\n                return False\n            return (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '.'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return s and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    (s and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p)))\n        \n        return self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            else:\n                return False\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] == '*':\n            # if the first character of p is '*', check if the first character of s is '*'\n            if self.isMatch(s, p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            else:\n                return False\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] == '.' and s:\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, check if the first character of p is '*'\n        if s and (p[0] == s[0] or p[0] == '.'):\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            for i in range(len(nums)):\n                while len(stack) > 0 and len(stack) + len(nums) - i > k and stack[-1] < nums[i]:\n                    stack.pop()\n                if len(stack) < k:\n                    stack.append(nums[i])\n            return stack\n        \n        def merge(nums1, nums2):\n            i, j = 0, 0\n            res = []\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    res.append(nums1[i])\n                    i += 1\n                else:\n                    res.append(nums2[j])\n                    j += 1\n            res += nums1[i:]\n            res += nums2[j:]\n            return res\n        \n        def find_max(nums, k):\n            if len(nums) == k:\n                return nums\n            if len(nums) < k:\n                return []\n            if len(nums) == 1:\n                return [nums[0]]\n            if len(nums) == 2:\n                if nums[0] > nums[1]:\n                    return [nums[0]]\n                else:\n                    return [nums[1]]\n            mid = len(nums) // 2\n            left = find_max(nums[:mid], k)\n            right = find_max(nums[mid:], k)\n            return merge(left, right)\n        \n        return find_max(merge(pick_max(nums1, k), pick_max(nums2, k)), k)"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            for i in range(len(nums)):\n                while len(stack) > 0 and len(stack) + len(nums) - i > k and stack[-1] < nums[i]:\n                    stack.pop()\n                if len(stack) < k:\n                    stack.append(nums[i])\n            return stack\n        \n        def merge(nums1, nums2):\n            i, j = 0, 0\n            res = []\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    res.append(nums1[i])\n                    i += 1\n                else:\n                    res.append(nums2[j])\n                    j += 1\n            res += nums1[i:]\n            res += nums2[j:]\n            return res\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums\n            return merge(merge_k(nums[:len(nums)//2]), merge_k(nums[len(nums)//2:]))\n        \n        return merge_k(pick_max(nums1, k) + pick_max(nums2, k))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            for i in range(len(nums)):\n                while len(stack) > 0 and len(stack) + len(nums) - i > k and stack[-1] < nums[i]:\n                    stack.pop()\n                if len(stack) < k:\n                    stack.append(nums[i])\n            return stack\n        \n        def merge(nums1, nums2):\n            i, j = 0, 0\n            res = []\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    res.append(nums1[i])\n                    i += 1\n                else:\n                    res.append(nums2[j])\n                    j += 1\n            res += nums1[i:]\n            res += nums2[j:]\n            return res\n        \n        res = []\n        for i in range(k+1):\n            if i <= len(nums1) and k - i <= len(nums2):\n                res = merge(pick_max(nums1, i), pick_max(nums2, k-i))\n                break\n        return res"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            removed = len(nums) - k\n            out = []\n            for num in nums:\n                while removed and out and out[-1] < num:\n                    out.pop()\n                    removed -= 1\n                if out and out[-1] == num:\n                    continue\n                out.append(num)\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def max_k_nums(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        if len(nums1) < k:\n            return nums2[:k]\n        if len(nums2) < k:\n            return nums1[:k]\n        \n        nums1 = pick(nums1, k)\n        nums2 = pick(nums2, k)\n        \n        return merge(max_k_nums(nums1, len(nums1)), max_k_nums(nums2, len(nums2)))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            removed = len(nums) - k\n            out = []\n            for num in nums:\n                while removed and out and out[-1] < num:\n                    out.pop()\n                    removed -= 1\n                if out and out[-1] == num:\n                    continue\n                out.append(num)\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def max_k_nums(nums, k):\n            out = []\n            for num in nums:\n                while k and out and out[-1] < num:\n                    out.pop()\n                    k -= 1\n                if k:\n                    out.append(num)\n            return out\n        \n        if len(nums1) < k:\n            return max_k_nums(nums2, k)\n        if len(nums2) < k:\n            return max_k_nums(nums1, k)\n        \n        out = []\n        for i in range(k+1):\n            if i <= len(nums1):\n                out = merge(out, pick(nums1, i))\n            if i <= len(nums2):\n                out = merge(out, pick(nums2, k-i))\n        return out"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\n        for i in range(m-2, -1, -1):\n            dp[i][-1] = max(1, dp[i+1][-1] - dungeon[i][-1])\n        for j in range(n-2, -1, -1):\n            dp[-1][j] = max(1, dp[-1][j+1] - dungeon[-1][j])\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\n        for i in range(m - 2, -1, -1):\n            dp[i][-1] = max(1, dp[i + 1][-1] - dungeon[i][-1])\n        for j in range(n - 2, -1, -1):\n            dp[-1][j] = max(1, dp[-1][j + 1] - dungeon[-1][j])\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a','e','i','o','u','A','E','I','O','U']\n        s_list = list(s)\n        i = 0\n        j = len(s_list)-1\n        while i < j:\n            if s_list[i] in vowels and s_list[j] in vowels:\n                s_list[i],s_list[j] = s_list[j],s_list[i]\n                i += 1\n                j -= 1\n            elif s_list[i] not in vowels:\n                i += 1\n            elif s_list[j] not in vowels:\n                j -= 1\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 2. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 3. The missing number will be the result of the subtraction.\n        ## 4. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 5. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 6. The missing number will be the result of the subtraction.\n        ## 7. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 8. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 9. The missing number will be the result of the subtraction.\n        ## 10. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 11. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 12. The missing number will be the result of the subtraction.\n        ## 13. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 14. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 15. The missing number will be the result of the subtraction.\n        ## 16. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 17. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 18. The missing number will be the result of the subtraction.\n        ## 19. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 20. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 21. The missing number will be the result of the subtraction.\n        ## 22. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 23. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 24. The missing number will be the result of the subtraction.\n        ## 25. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 26. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 27. The missing number will be the result of the subtraction.\n        ## 28. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 29. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 30. The missing number will be the result of the subtraction.\n        ## 31. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 32. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array."}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 2. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 3. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 4. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 5. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 6. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 7. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 8. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 9. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 10. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 11. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 12. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 13. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 14. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 15. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 16. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 17. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 18. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 19. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 20. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 21. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 22. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 23. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 24. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 25. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 26. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 27. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 28. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 29. We can use the"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 2. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 3. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 4. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 5. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 6. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 7. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 8. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 9. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 10. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 11. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 12. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 13. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 14. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 15. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 16. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 17. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 18. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 19. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 20. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 21. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 22. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 23. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 24. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum of the numbers in the array.\n        ## 25. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 26. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 27. The missing number will be the difference between the sum of the numbers in the range [0, n] and the sum"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 2. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 3. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 4. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 5. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 6. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 7. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 8. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 9. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 10. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 11. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 12. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 13. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 14. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 15. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 16. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 17. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 18. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 19. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 20. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 21. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 22. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 23. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 24. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array to get the missing number.\n        ## 25. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 26. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can use the property of XOR to solve this problem.\n        ## 2. We can use the property of XOR to solve this problem.\n        ## 3. We can use the property of XOR to solve this problem.\n        \n        ## XOR of all numbers from 0 to n\n        ## XOR of all numbers from 0 to n+1\n        ## XOR of all numbers from 0 to n+2\n        ## XOR of all numbers from 0 to n+3\n        ## XOR of all numbers from 0 to n+4\n        ## XOR of all numbers from 0 to n+5\n        ## XOR of all numbers from 0 to n+6\n        ## XOR of all numbers from 0 to n+7\n        ## XOR of all numbers from 0 to n+8\n        ## XOR of all numbers from 0 to n+9\n        ## XOR of all numbers from 0 to n+10\n        ## XOR of all numbers from 0 to n+11\n        ## XOR of all numbers from 0 to n+12\n        ## XOR of all numbers from 0 to n+13\n        ## XOR of all numbers from 0 to n+14\n        ## XOR of all numbers from 0 to n+15\n        ## XOR of all numbers from 0 to n+16\n        ## XOR of all numbers from 0 to n+17\n        ## XOR of all numbers from 0 to n+18\n        ## XOR of all numbers from 0 to n+19\n        ## XOR of all numbers from 0 to n+20\n        ## XOR of all numbers from 0 to n+21\n        ## XOR of all numbers from 0 to n+22\n        ## XOR of all numbers from 0 to n+23\n        ## XOR of all numbers from 0 to n+24\n        ## XOR of all numbers from 0 to n+25\n        ## XOR of all numbers from 0 to n+26\n        ## XOR of all numbers from 0 to n+27\n        ## XOR of all numbers from 0 to n+28\n        ## XOR of all numbers from 0 to n+29\n        ## XOR of all numbers from 0 to n+30\n        ## XOR of all numbers from 0 to n+31\n        ## XOR of all numbers from 0 to n+32\n        ## XOR of all numbers from 0 to n+33\n        ## XOR of all numbers from 0 to n+34\n        ## XOR of all numbers from 0 to n+35\n        ## XOR of all numbers from 0 to n+36\n        ## XOR of all numbers from 0 to n+37\n        ## XOR of all numbers from 0 to n+38\n        ## XOR of all numbers from 0 to n+39\n        ## XOR of all numbers from 0 to n+40\n        ## XOR of all numbers from 0 to n+41\n        ## XOR of all numbers from 0 to n+42\n        ## XOR of all numbers from 0 to n+43\n        ## XOR of all numbers from 0 to n+44\n        ## XOR of all numbers from 0 to n+45\n        ## XOR of all numbers from 0 to n+46\n        ## XOR of all numbers from 0 to n+47\n        ## XOR of all numbers from 0 to n+48\n        ## XOR of all numbers from 0 to n+49\n        ## XOR of all numbers from 0 to n+50\n        ## XOR of all numbers from 0 to n+51\n        ## XOR of all numbers from 0 to n+52\n        ## XOR of all numbers from 0 to n+53\n        ## XOR of all numbers from 0 to"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N)\n        # Space: O(N)\n        # 1. Build the graph\n        # 2. BFS\n        # 3. Return the distance\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        distance = 1\n        visited = set([beginWord])\n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return distance + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            distance += 1\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n*m)\n        # Space Complexity: O(n)\n        # where n is the number of words in wordList and m is the length of the longest word in wordList\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        \n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    return level\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            level += 1\n        \n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(N * M)\n        # Space Complexity: O(N * M)\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        \n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return level + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(N*M)\n        # Space Complexity: O(N)\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        \n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return level + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(N*M)\n        # Space Complexity: O(N)\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        \n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return level + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                        carry = 1\n                elif a[i] == '1' or b[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n            else:\n                if a[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = \"\"\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        \n        if carry == 1:\n            res += \"1\"\n        \n        return res[::-1]"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = \"\"\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        \n        if carry == 1:\n            res += \"1\"\n        \n        return res[::-1]"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = \"\"\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        \n        if carry == 1:\n            res += \"1\"\n        \n        return res[::-1]"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                        carry = 1\n                elif a[i] == '1' or b[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n            else:\n                if a[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target or (left and nums[mid] == target):\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False) - 1\n        \n        if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n            return [left_index, right_index]\n        return [-1, -1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target or (left and nums[mid] == target):\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False) - 1\n        \n        if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n            return [left_index, right_index]\n        return [-1, -1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                elif nums[mid] > target:\n                    right = mid - 1\n                else:\n                    if left == mid:\n                        return mid\n                    else:\n                        right = mid\n            return -1\n        \n        left = binary_search(nums, target, True)\n        right = binary_search(nums, target, False)\n        return [left, right]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target or (left and nums[mid] == target):\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False) - 1\n        \n        if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n            return [left_index, right_index]\n        return [-1, -1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target or (left and nums[mid] == target):\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n        \n        left_idx = binary_search(nums, target, True)\n        right_idx = binary_search(nums, target, False) - 1\n        \n        if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target:\n            return [left_idx, right_idx]\n        return [-1, -1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Approach: Greedy\n        # We can use a greedy approach to solve this problem.\n        # We can keep track of the farthest we can reach and the number of jumps we have taken.\n        # We can also keep track of the current farthest we can reach.\n        # We can update the farthest we can reach every time we move to a new position.\n        # If the farthest we can reach is greater than the current position, we can move to that position.\n        # If the farthest we can reach is less than the current position, we can't move to that position.\n        # We can increment the number of jumps we have taken.\n        # We can return the number of jumps we have taken.\n        \n        # Initialize the farthest we can reach and the number of jumps we have taken to 0.\n        farthest = 0\n        jumps = 0\n        \n        # Iterate through the array.\n        for i in range(len(nums)):\n            # If the farthest we can reach is greater than the current position, we can move to that position.\n            if i > farthest:\n                # Increment the number of jumps we have taken.\n                jumps += 1\n                # Update the farthest we can reach.\n                farthest = i\n            # If the farthest we can reach is less than the current position, we can't move to that position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that is equal to the current position.\n            # We can't move to a position that is greater than the current position.\n            # We can't move to a position that is less than the current position.\n            # We can't move to a position that"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)-1,-1,-1):\n            for j in range(k):\n                dp[j][0] = max(dp[j][0],dp[j][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices):\n            return sum(prices[i] - prices[i-1] for i in range(1, len(prices)))\n        \n        dp = [[0] * (k+1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j] + prices[i] - prices[i-1], dp[i-1][j-1] + prices[i] - prices[i-1])\n        \n        return dp[-1][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices):\n            return sum(prices[i] - prices[i-1] for i in range(1, len(prices)))\n        \n        dp = [[0] * (k+1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j] + prices[i] - prices[i-1], dp[i-1][j-1] + prices[i] - prices[i-1])\n        \n        return dp[-1][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices):\n            return sum(prices[i] - prices[i-1] for i in range(1, len(prices)))\n        \n        dp = [[0] * (k+1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j] + prices[i] - prices[i-1], dp[i-1][j-1] + prices[i] - prices[i-1])\n        \n        return dp[-1][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)-1,-1,-1):\n            for j in range(k):\n                dp[j][0] = max(dp[j][0],dp[j][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and update the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with frequency 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and update the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with frequency 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and update the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with frequency 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and update the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with a frequency of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string\n        for char in s:\n            # If the character is already in the hashmap, increment its frequency by 1\n            if char in freq:\n                freq[char] += 1\n            # If the character is not in the hashmap, add it with a frequency of 1\n            else:\n                freq[char] = 1\n        \n        # Iterate through the string again\n        for i, char in enumerate(s):\n            # If the character's frequency is 1, return its index\n            if freq[char] == 1:\n                return i\n        \n        # If no unique character is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlog(n))\n        # Space Complexity: O(n)\n        \n        # Sort the array\n        nums.sort()\n        \n        # Iterate through the array\n        for i in range(len(nums)-1):\n            # Check if the difference between the current and next element is less than or equal to indexDiff\n            if abs(nums[i] - nums[i+1]) <= valueDiff:\n                # Return True if the difference is less than or equal to indexDiff\n                return True\n        \n        # Return False if the loop completes without finding a pair\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlogn)\n        # Space Complexity: O(n)\n        \n        # Edge Case\n        if len(nums) <= 1:\n            return False\n        \n        # Sort the array\n        nums.sort()\n        \n        # Iterate through the array\n        for i in range(len(nums)-1):\n            # Check if the absolute difference between the current and next element is less than or equal to indexDiff\n            if abs(nums[i] - nums[i+1]) <= valueDiff:\n                return True\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlogn)\n        # Space Complexity: O(n)\n        \n        # Sort the array\n        nums.sort()\n        \n        # Iterate through the array\n        for i in range(len(nums)-1):\n            # Check if the absolute difference between the current and next element is less than or equal to indexDiff\n            if abs(nums[i] - nums[i+1]) <= valueDiff:\n                # Return True if the absolute difference between the current and next element is less than or equal to indexDiff\n                return True\n        \n        # Return False if the absolute difference between the current and next element is greater than indexDiff\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlog(n))\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # 1. Sort the array\n        # 2. Iterate through the array\n        # 3. Check if the difference between the current and the next element is less than or equal to indexDiff\n        # 4. Check if the absolute difference between the current and the next element is less than or equal to valueDiff\n        # 5. If the conditions are met, return True\n        # 6. If the conditions are not met, return False\n        \n        # Edge Cases:\n        # 1. If the length of the array is 1, return False\n        # 2. If the indexDiff is 0, return False\n        # 3. If the valueDiff is 0, return False\n        \n        if len(nums) == 1:\n            return False\n        \n        if indexDiff == 0:\n            return False\n        \n        if valueDiff == 0:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums) - 1):\n            if abs(nums[i] - nums[i + 1]) <= indexDiff:\n                if abs(nums[i] - nums[i + 1]) <= valueDiff:\n                    return True\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlog(n))\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # 1. Sort the array\n        # 2. Iterate through the array and check if the absolute difference between the current and the next element is less than or equal to indexDiff\n        # 3. If the absolute difference is less than or equal to indexDiff, check if the absolute difference between the current and the next element is less than or equal to valueDiff\n        # 4. If the absolute difference is less than or equal to valueDiff, return True\n        # 5. If the absolute difference is greater than indexDiff, return False\n        \n        # Edge Cases:\n        # 1. If the length of the array is 1, return False\n        # 2. If the indexDiff is 0, return False\n        # 3. If the valueDiff is 0, return False\n        \n        if len(nums) == 1:\n            return False\n        \n        if indexDiff == 0:\n            return False\n        \n        if valueDiff == 0:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums)-1):\n            if abs(nums[i] - nums[i+1]) <= indexDiff:\n                if abs(nums[i] - nums[i+1]) <= valueDiff:\n                    return True\n        \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        left = 0\n        right = len(nums) - 1\n        i = 0\n        while i <= right:\n            if nums[i] == 0:\n                nums[left], nums[i] = nums[i], nums[left]\n                left += 1\n                i += 1\n            elif nums[i] == 2:\n                nums[right], nums[i] = nums[i], nums[right]\n                right -= 1\n            else:\n                i += 1\n\n        return nums"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        # 3 -> left\n        # 4 -> right\n        # 5 -> left\n        # 6 -> right\n        # 7 -> left\n        # 8 -> right\n        # 9 -> left\n        # 10 -> right\n        # 11 -> left\n        # 12 -> right\n        # 13 -> left\n        # 14 -> right\n        # 15 -> left\n        # 16 -> right\n        # 17 -> left\n        # 18 -> right\n        # 19 -> left\n        # 20 -> right\n        # 21 -> left\n        # 22 -> right\n        # 23 -> left\n        # 24 -> right\n        # 25 -> left\n        # 26 -> right\n        # 27 -> left\n        # 28 -> right\n        # 29 -> left\n        # 30 -> right\n        # 31 -> left\n        # 32 -> right\n        # 33 -> left\n        # 34 -> right\n        # 35 -> left\n        # 36 -> right\n        # 37 -> left\n        # 38 -> right\n        # 39 -> left\n        # 40 -> right\n        # 41 -> left\n        # 42 -> right\n        # 43 -> left\n        # 44 -> right\n        # 45 -> left\n        # 46 -> right\n        # 47 -> left\n        # 48 -> right\n        # 49 -> left\n        # 50 -> right\n        # 51 -> left\n        # 52 -> right\n        # 53 -> left\n        # 54 -> right\n        # 55 -> left\n        # 56 -> right\n        # 57 -> left\n        # 58 -> right\n        # 59 -> left\n        # 60 -> right\n        # 61 -> left\n        # 62 -> right\n        # 63 -> left\n        # 64 -> right\n        # 65 -> left\n        # 66 -> right\n        # 67 -> left\n        # 68 -> right\n        # 69 -> left\n        # 70 -> right\n        # 71 -> left\n        # 72 -> right\n        # 73 -> left\n        # 74 -> right\n        # 75 -> left\n        # 76 -> right\n        # 77 -> left\n        # 78 -> right\n        # 79 -> left\n        # 80 -> right\n        # 81 -> left\n        # 82 -> right\n        # 83 -> left\n        # 84 -> right\n        # 85 -> left\n        # 86 -> right\n        # 87 -> left\n        # 88 -> right\n        # 89 -> left\n        # 90 -> right\n        # 91 -> left\n        # 92 -> right\n        # 93 -> left\n        # 94 -> right\n        # 95 -> left\n        # 96 -> right\n        # 97 -> left\n        # 98 -> right\n        # 99 -> left\n        # 100 -> right\n        # 101 -> left\n        # 102 -> right\n        # 103 -> left\n        # 104 -> right\n        # 105 -> left\n        # 106 -> right\n        # 107 -> left\n        # 108 -> right\n        # 109 -> left\n        # 110 -> right\n        # 111 -> left\n        # 112 -> right\n        # 1"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        # 3 -> left\n        # 4 -> right\n        # 5 -> left\n        # 6 -> right\n        # 7 -> left\n        # 8 -> right\n        # 9 -> left\n        # 10 -> right\n        # 11 -> left\n        # 12 -> right\n        # 13 -> left\n        # 14 -> right\n        # 15 -> left\n        # 16 -> right\n        # 17 -> left\n        # 18 -> right\n        # 19 -> left\n        # 20 -> right\n        # 21 -> left\n        # 22 -> right\n        # 23 -> left\n        # 24 -> right\n        # 25 -> left\n        # 26 -> right\n        # 27 -> left\n        # 28 -> right\n        # 29 -> left\n        # 30 -> right\n        # 31 -> left\n        # 32 -> right\n        # 33 -> left\n        # 34 -> right\n        # 35 -> left\n        # 36 -> right\n        # 37 -> left\n        # 38 -> right\n        # 39 -> left\n        # 40 -> right\n        # 41 -> left\n        # 42 -> right\n        # 43 -> left\n        # 44 -> right\n        # 45 -> left\n        # 46 -> right\n        # 47 -> left\n        # 48 -> right\n        # 49 -> left\n        # 50 -> right\n        # 51 -> left\n        # 52 -> right\n        # 53 -> left\n        # 54 -> right\n        # 55 -> left\n        # 56 -> right\n        # 57 -> left\n        # 58 -> right\n        # 59 -> left\n        # 60 -> right\n        # 61 -> left\n        # 62 -> right\n        # 63 -> left\n        # 64 -> right\n        # 65 -> left\n        # 66 -> right\n        # 67 -> left\n        # 68 -> right\n        # 69 -> left\n        # 70 -> right\n        # 71 -> left\n        # 72 -> right\n        # 73 -> left\n        # 74 -> right\n        # 75 -> left\n        # 76 -> right\n        # 77 -> left\n        # 78 -> right\n        # 79 -> left\n        # 80 -> right\n        # 81 -> left\n        # 82 -> right\n        # 83 -> left\n        # 84 -> right\n        # 85 -> left\n        # 86 -> right\n        # 87 -> left\n        # 88 -> right\n        # 89 -> left\n        # 90 -> right\n        # 91 -> left\n        # 92 -> right\n        # 93 -> left\n        # 94 -> right\n        # 95 -> left\n        # 96 -> right\n        # 97 -> left\n        # 98 -> right\n        # 99 -> left\n        # 100 -> right\n        # 101 -> left\n        # 102 -> right\n        # 103 -> left\n        # 104 -> right\n        # 105 -> left\n        # 106 -> right\n        # 107 -> left\n        # 108 -> right\n        # 109 -> left\n        # 110 -> right\n        # 111 -> left\n        # 112 -> right\n        # 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = []\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2):\n            if i < len(num1):\n                val1 = int(num1[i])\n            else:\n                val1 = 0\n            if i < len(num2):\n                val2 = int(num2[i])\n            else:\n                val2 = 0\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            res.append(sum % 10)\n            i += 1\n        if carry:\n            res.append(carry)\n        return ''.join(map(str, res[::-1]))"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2):\n            if i < len(num1):\n                val1 = int(num1[i])\n            else:\n                val1 = 0\n            if i < len(num2):\n                val2 = int(num2[i])\n            else:\n                val2 = 0\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            res += str(sum % 10)\n            i += 1\n        if carry:\n            res += str(carry)\n        return res[::-1]"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = []\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2):\n            if i < len(num1):\n                val1 = int(num1[i])\n            else:\n                val1 = 0\n            if i < len(num2):\n                val2 = int(num2[i])\n            else:\n                val2 = 0\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            res.append(sum % 10)\n            i += 1\n        if carry:\n            res.append(carry)\n        return ''.join(map(str, res[::-1]))"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = []\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res.append(str(carry % 10))\n            carry //= 10\n            i += 1\n        return ''.join(res[::-1])"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = []\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res.append(carry % 10)\n            carry //= 10\n            i += 1\n        return ''.join(map(str, res[::-1]))"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n            if s[i] == '(':\n                stack.append(sign)\n            if s[i] == ')':\n                sign = stack.pop()\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n        return sum(stack)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n            if s[i] == '(':\n                stack.append(sign)\n            if s[i] == ')':\n                sign = stack.pop()\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n        return sum(stack)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                sign = s[i]\n                num = 0\n        return sum(stack)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n            if s[i] == '(':\n                stack.append('(')\n            if s[i] == ')':\n                num = self.calculate(stack)\n                stack.pop()\n                stack.append(num)\n        return sum(stack)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n            if s[i] == '(':\n                stack.append(sign)\n            if s[i] == ')':\n                sign = stack.pop()\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # iterate over capital and profits\n        # if capital is less than or equal to w, add profit to w\n        # if k > 0, subtract 1 from k\n        # else, return w\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # iterate over capital and profits\n        for c, p in sorted_capital:\n            if c <= w:\n                w += p\n            else:\n                break\n            if k > 0:\n                k -= 1\n            else:\n                return w\n        \n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital["}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits = [profits[i] for i in range(len(profits))]\n        # capital = [capital[i] for i in range(len(capital))]\n        # profits.sort()\n        # capital.sort()\n        # print(profits)\n        # print(capital)\n        # print(profits[::-1])\n        # print(capital[::-1])\n        # print(profits[::-1][:k])\n        # print(capital[::-1][:k])\n        # print(profits[::-1][:k][::-1])\n        # print(capital[::-1][:k][::-1])\n        # print(profits[::-1][:k][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital["}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # profits[i] - capital[i] >= 0\n        # profits[i] - capital[i] <= 0\n        # profits[i] - capital[i] > 0\n        # profits[i] - capital[i] < 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i]"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the index of the first number that is smaller than the next number\n        # find the index of the last number that is smaller than the first number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the index of the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # find the index of the last number that is smaller than the first number\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the index\n        left, right = i+1, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is sorted in descending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no such number, then the array is sorted in ascending order\n        # if no"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is larger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # Find the number that is larger than the number to its right\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the numbers to the right of the number that was swapped\n        left, right = 0, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i where nums[i] < nums[i+1]\n        # find the first index j where nums[j] > nums[i]\n        # swap nums[i] and nums[j]\n        # reverse the suffix of nums\n        \n        # find the first index i where nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # find the first index j where nums[j] > nums[i]\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix of nums\n        left, right = 0, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i where nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if i < 0, it means that the array is sorted in descending order\n        if i < 0:\n            nums.reverse()\n            return\n        \n        # find the first index j where nums[j] > nums[i]\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray from i+1 to the end\n        left, right = i+1, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Hashmap stores the value of the element and its index\n        # If the element is already in the hashmap, then we check if the index is within the range of k\n        # If it is, then we return True\n        # If it is not, then we add the element to the hashmap\n        # If the element is not in the hashmap, then we add the element to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Approach: Hashmap\n        # Hashmap:\n        # - Key: nums[i]\n        # - Value: index\n        # - If nums[i] is already in the hashmap, check if abs(i - hashmap[nums[i]]) <= k\n        # - If nums[i] is not in the hashmap, add nums[i] to the hashmap\n        # - Return True if nums[i] is already in the hashmap\n        # - Return False if nums[i] is not in the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(i - hashmap[nums[i]]) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Hashmap stores the value of the element and its index\n        # If the element is already in the hashmap, then we check if the index is within the range of k\n        # If it is, then we return True\n        # If it is not, then we add the element to the hashmap\n        # If the element is not in the hashmap, then we add the element to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Store the index of the number in the hashmap\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Hashmap stores the value of the element and its index\n        # If the element is already in the hashmap, then we check if the index is within the range of k\n        # If it is, then we return True\n        # If it is not, then we add the element to the hashmap\n        # If the element is not in the hashmap, then we add the element to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0] != couples[i+1][0] and couples[i][1] != couples[i+1][1]:\n                couples[i+1] = couples[i]\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = \"qwertyuiop\"\n        row2 = \"asdfghjkl\"\n        row3 = \"zxcvbnm\"\n        res = []\n        for word in words:\n            if word[0] in row1:\n                r = row1\n            elif word[0] in row2:\n                r = row2\n            else:\n                r = row3\n            for c in word:\n                if c not in r:\n                    break\n            else:\n                res.append(word)\n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = \"qwertyuiop\"\n        row2 = \"asdfghjkl\"\n        row3 = \"zxcvbnm\"\n        res = []\n        for word in words:\n            if word[0] in row1:\n                flag = True\n                for i in range(1,len(word)):\n                    if word[i] not in row1:\n                        flag = False\n                        break\n                if flag:\n                    res.append(word)\n            elif word[0] in row2:\n                flag = True\n                for i in range(1,len(word)):\n                    if word[i] not in row2:\n                        flag = False\n                        break\n                if flag:\n                    res.append(word)\n            else:\n                flag = True\n                for i in range(1,len(word)):\n                    if word[i] not in row3:\n                        flag = False\n                        break\n                if flag:\n                    res.append(word)\n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = \"qwertyuiop\"\n        row2 = \"asdfghjkl\"\n        row3 = \"zxcvbnm\"\n        \n        res = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                res.append(word)\n        \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                res.append(word)\n        \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = \"qwertyuiop\"\n        row2 = \"asdfghjkl\"\n        row3 = \"zxcvbnm\"\n        \n        res = []\n        \n        for word in words:\n            if word[0].lower() in row1:\n                flag1 = True\n            else:\n                flag1 = False\n            \n            if word[0].lower() in row2:\n                flag2 = True\n            else:\n                flag2 = False\n            \n            if word[0].lower() in row3:\n                flag3 = True\n            else:\n                flag3 = False\n            \n            for i in range(1,len(word)):\n                if word[i].lower() in row1 and flag1 == False:\n                    flag1 = True\n                elif word[i].lower() in row2 and flag2 == False:\n                    flag2 = True\n                elif word[i].lower() in row3 and flag3 == False:\n                    flag3 = True\n                else:\n                    flag1 = False\n                    flag2 = False\n                    flag3 = False\n                    break\n            \n            if flag1 == True and flag2 == True and flag3 == True:\n                res.append(word)\n        \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        prev.next = None\n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        head = prev\n        \n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        prev.next = None\n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        head = prev\n        \n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed string"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front of the original string\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reversed string to the front"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result\n        \n        # 1. find the longest palindrome substring of s\n        # 2. reverse the substring\n        # 3. add the reversed substring to the front of s\n        # 4. return the result"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        for i in range(len(s)):\n            if s[i] in t_dict:\n                if s_dict[s[i]] < t_dict[s[i]]:\n                    s_dict[s[i]] += 1\n                else:\n                    s_dict[s[i]] -= 1\n            if self.is_valid(s_dict, t_dict):\n                while self.is_valid(s_dict, t_dict):\n                    if s[right] in t_dict:\n                        s_dict[s[right]] -= 1\n                    right += 1\n                if right - left < min_len:\n                    min_len = right - left\n                    min_left = left\n                    min_right = right\n                if s[left] in t_dict:\n                    s_dict[s[left]] += 1\n                left += 1\n        return s[min_left:min_right]\n    \n    def is_valid(self, s_dict, t_dict):\n        for i in t_dict:\n            if i not in s_dict or s_dict[i] < t_dict[i]:\n                return False\n        return True"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        while right < len(s):\n            if s[right] in t_dict:\n                if s[right] in s_dict:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] = 1\n            right += 1\n            \n            while True:\n                if len(s_dict) == len(t_dict):\n                    if right - left < min_len:\n                        min_len = right - left\n                        min_left = left\n                        min_right = right\n                    if s[left] in s_dict:\n                        s_dict[s[left]] += 1\n                    left += 1\n                else:\n                    break\n        \n        return s[min_left:min_right]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for char in t:\n            if char not in t_dict:\n                t_dict[char] = 1\n            else:\n                t_dict[char] += 1\n        \n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        for right in range(len(s)):\n            if s[right] in t_dict:\n                if s_dict[s[right]] < t_dict[s[right]]:\n                    s_dict[s[right]] += 1\n                else:\n                    s_dict[s[right]] -= 1\n            \n            if self.is_valid(s_dict, t_dict):\n                while self.is_valid(s_dict, t_dict):\n                    if right - left + 1 < min_len:\n                        min_len = right - left + 1\n                        min_left = left\n                        min_right = right\n                    if s[left] in s_dict:\n                        s_dict[s[left]] += 1\n                    left += 1\n        \n        return s[min_left:min_right + 1]\n    \n    def is_valid(self, s_dict, t_dict):\n        for key in t_dict:\n            if key not in s_dict or s_dict[key] < t_dict[key]:\n                return False\n        return True"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_count = {}\n        for c in t:\n            t_count[c] = t_count.get(c, 0) + 1\n        \n        s_count = {}\n        for c in s:\n            s_count[c] = s_count.get(c, 0) + 1\n        \n        if t_count == s_count:\n            return t\n        \n        left = 0\n        right = 0\n        min_window = \"\"\n        min_len = float(\"inf\")\n        while right < len(s):\n            c = s[right]\n            if c in t_count:\n                s_count[c] = s_count.get(c, 0) + 1\n                if s_count[c] <= t_count[c]:\n                    if right - left + 1 < min_len:\n                        min_window = s[left:right+1]\n                        min_len = right - left + 1\n                    s_count[c] -= 1\n            right += 1\n        \n        return min_window"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        for i in range(len(s)):\n            if s[i] in t_dict:\n                if s_dict[s[i]] < t_dict[s[i]]:\n                    s_dict[s[i]] += 1\n                else:\n                    s_dict[s[i]] -= 1\n            \n            if i >= len(t):\n                if s_dict[s[left]] < t_dict[s[left]]:\n                    s_dict[s[left]] += 1\n                else:\n                    s_dict[s[left]] -= 1\n                left += 1\n            \n            if i >= len(t) - 1:\n                if s_dict[s[right]] < t_dict[s[right]]:\n                    s_dict[s[right]] += 1\n                else:\n                    s_dict[s[right]] -= 1\n                right += 1\n            \n            if s_dict == t_dict:\n                if right - left < min_len:\n                    min_len = right - left\n                    min_left = left\n                    min_right = right\n            \n        return s[min_left:min_right]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i+4] >= distance[i+2] and distance[i+3] >= distance[i+1]:\n                return True\n            if i >= 4 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] == distance[i+1]:\n                return True\n            if i >= 5 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1]:\n                return True\n            if i >= 6 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6]:\n                return True\n            if i >= 7 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6] and distance[i+7] + distance[i+8] >= distance[i+9]:\n                return True\n            if i >= 8 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6] and distance[i+7] + distance[i+8] >= distance[i+9] and distance[i+9] + distance[i+10] >= distance[i+11]:\n                return True\n            if i >= 9 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6] and distance[i+7] + distance[i+8] >= distance[i+9] and distance[i+9] + distance[i+10] >= distance[i+11] and distance[i+11] + distance[i+12] >= distance[i+13]:\n                return True\n            if i >= 10 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6] and distance[i+7] + distance[i+8] >= distance[i+9] and distance[i+9] + distance[i+10] >= distance[i+11] and distance[i+11] + distance[i+12] >= distance[i+13] and distance[i+13] + distance[i+14] >= distance[i+15]:\n                return True\n            if i >= 11 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6] and distance[i+7] + distance[i+8] >= distance[i+9] and distance[i+9] + distance[i+10] >= distance[i+11] and distance[i+11] + distance[i+12] >= distance[i+13] and distance[i+13] + distance[i+14] >= distance[i+15] and distance[i+15] + distance[i+16] >= distance[i+17]:\n                return True\n            if i >= 12 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6] and distance[i+7]"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i-1] >= distance[i-3] and distance[i-1] == distance[i-4]:\n                return True\n            if i >= 4 and distance[i] + distance[i-1] >= distance[i-4] and distance[i-1] == distance[i-5]:\n                return True\n            if i >= 5 and distance[i] + distance[i-1] >= distance[i-5] and distance[i-1] == distance[i-6]:\n                return True\n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i-1] >= distance[i-3] and distance[i-1] == distance[i-4]:\n                return True\n            if i >= 4 and distance[i] + distance[i-1] >= distance[i-4] and distance[i-1] + distance[i-2] >= distance[i-5] and distance[i-2] == distance[i-3]:\n                return True\n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i-1] >= distance[i-3] and distance[i-1] == distance[i-4]:\n                return True\n            if i >= 4 and distance[i] + distance[i-1] >= distance[i-4] and distance[i-1] + distance[i-2] >= distance[i-5] and distance[i-2] == distance[i-4]:\n                return True\n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] == distance[i+3]:\n                return True\n            if i >= 4 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6]:\n                return True\n            if i >= 5 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6] and distance[i+3] + distance[i+5] >= distance[i+7]:\n                return True\n            if i >= 6 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6] and distance[i+3] + distance[i+5] >= distance[i+7] and distance[i+4] + distance[i+6] >= distance[i+8]:\n                return True\n            if i >= 7 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6] and distance[i+3] + distance[i+5] >= distance[i+7] and distance[i+4] + distance[i+6] >= distance[i+8] and distance[i+5] + distance[i+7] >= distance[i+9]:\n                return True\n            if i >= 8 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6] and distance[i+3] + distance[i+5] >= distance[i+7] and distance[i+4] + distance[i+6] >= distance[i+8] and distance[i+5] + distance[i+7] >= distance[i+9] and distance[i+6] + distance[i+8] >= distance[i+10]:\n                return True\n            if i >= 9 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6] and distance[i+3] + distance[i+5] >= distance[i+7] and distance[i+4] + distance[i+6] >= distance[i+8] and distance[i+5] + distance[i+7] >= distance[i+9] and distance[i+6] + distance[i+8] >= distance[i+10] and distance[i+7] + distance[i+9] >= distance[i+11]:\n                return True\n            if i >= 10 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3] and distance[i+2] + distance[i+4] >= distance[i+6] and distance[i+3] + distance[i+5] >= distance[i+7] and distance[i+4] + distance[i+6] >= distance[i+8] and distance[i+5] + distance[i+7] >= distance[i+9] and distance[i+6] + distance[i+8] >= distance[i+10] and distance[i+7] + distance[i+9] >= distance[i+11] and distance[i+8] + distance[i+10] >= distance[i+12]:\n                return True\n            if i >= 11 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3]"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc9dd\uc218\uc77c \uacbd\uc6b0\n        # 2. \ud640\uc218\uc77c \uacbd\uc6b0\n        # 3. \uc9dd\uc218\uc77c \uacbd\uc6b0\uc640 \ud640\uc218\uc77c \uacbd\uc6b0\ub97c \ub098\ub220\uc11c \uc0dd\uac01\ud558\uba74 \ub41c\ub2e4.\n        # 4. \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0\ub294 \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc774 \uc788\uc73c\ubbc0\ub85c \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc744 \uc81c\uc678\ud558\uace0 \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0 \ub354\ud574\uc900\ub2e4.\n        # 5. \ud640\uc218\uc77c \uacbd\uc6b0\uc5d0\ub294 \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc774 \uc5c6\uc73c\ubbc0\ub85c \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0 \ub354\ud574\uc900\ub2e4.\n        # 6. \uc9dd\uc218\uc77c \uacbd\uc6b0\uc640 \ud640\uc218\uc77c \uacbd\uc6b0\ub97c \ub098\ub220\uc11c \uc0dd\uac01\ud558\uba74 \ub41c\ub2e4.\n        # 7. \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0\ub294 \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc774 \uc788\uc73c\ubbc0\ub85c \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc744 \uc81c\uc678\ud558\uace0 \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0 \ub354\ud574\uc900\ub2e4.\n        # 8. \ud640\uc218\uc77c \uacbd\uc6b0\uc5d0\ub294 \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc774 \uc5c6\uc73c\ubbc0\ub85c \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0 \ub354\ud574\uc900\ub2e4.\n        # 9. \uc9dd\uc218\uc77c \uacbd\uc6b0\uc640 \ud640\uc218\uc77c \uacbd\uc6b0\ub97c \ub098\ub220\uc11c \uc0dd\uac01\ud558\uba74 \ub41c\ub2e4.\n        # 10. \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0\ub294 \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc774 \uc788\uc73c\ubbc0\ub85c \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc744 \uc81c\uc678\ud558\uace0 \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0 \ub354\ud574\uc900\ub2e4.\n        # 11. \ud640\uc218\uc77c \uacbd\uc6b0\uc5d0\ub294 \uc911\uac04\uc5d0 \uc911\ubcf5\ub418\ub294 \uac83\uc774 \uc5c6\uc73c\ubbc0\ub85c \uc9dd\uc218\uc77c \uacbd\uc6b0\uc5d0 \ub354\ud574\uc900\ub2e4.\n        # 12. \ufffd"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc138\uc5b4\uc900\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ub354\ud574\uc900\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 11. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 12. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4."}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc138\uc5b4\uc900\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ube7c\uc900\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ube7c\uc900\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 3\uc744 \ube7c\uc900\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 3\uc744 \ube7c\uc900\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 4\ub97c \ube7c\uc900\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 4\ub97c \ube7c\uc900\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 5\ub97c \ube7c\uc900\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 5\ub97c \ube7c\uc900\ub2e4.\n        # 11. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 6\uc744 \ube7c\uc900\ub2e4.\n        # 12. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 6\uc744 \ube7c\uc900\ub2e4.\n        # 13. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 2. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \ud3ec\ud568\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc758 \uae38\uc774\ub97c \uad6c"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(start, end):\n            visited = [[False] * len(forest[0]) for _ in range(len(forest))]\n            queue = [start]\n            steps = 0\n            while queue:\n                for _ in range(len(queue)):\n                    x, y = queue.pop(0)\n                    if x == end[0] and y == end[1]:\n                        return steps\n                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and forest[nx][ny] and not visited[nx][ny]:\n                            visited[nx][ny] = True\n                            queue.append((nx, ny))\n                steps += 1\n            return -1\n        \n        def get_start_end(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j), (i, j)\n            return None, None\n        \n        start, end = get_start_end(forest)\n        if not start:\n            return 0\n        steps = dfs(start, end)\n        if steps == -1:\n            return -1\n        return steps"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0 and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        start = (0, 0)\n        steps = 0\n        for height, i, j in trees:\n            steps += dfs(start, (i, j))\n            if steps < 0:\n                return -1\n            start = (i, j)\n        return steps"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(forest) or j < 0 or j >= len(forest[0]) or forest[i][j] == 0:\n                return float('inf')\n            if forest[i][j] == 1:\n                return 0\n            return 1\n        \n        def bfs(i,j):\n            q = [(i,j)]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    i,j = q.pop(0)\n                    if (i,j) in visited:\n                        continue\n                    visited.add((i,j))\n                    if forest[i][j] == 1:\n                        return steps\n                    for di,dj in [(0,1),(0,-1),(1,0),(-1,0)]:\n                        ni,nj = i+di,j+dj\n                        if dfs(ni,nj) < float('inf'):\n                            q.append((ni,nj))\n                steps += 1\n            return float('inf')\n        \n        forest = [list(row) for row in forest]\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j],i,j))\n        trees.sort()\n        steps = 0\n        for height,i,j in trees:\n            steps += bfs(i,j)\n            if steps >= float('inf'):\n                return -1\n        return steps"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0], curr[1]+1), (curr[0], curr[1]-1), (curr[0]+1, curr[1]), (curr[0]-1, curr[1])]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i, j))\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        start = (0, 0)\n        steps = 0\n        for tree in trees:\n            steps += dfs(start, tree)\n            if steps < 0:\n                return -1\n            start = tree\n        return steps"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(forest) or j < 0 or j >= len(forest[0]) or forest[i][j] == 0:\n                return float('inf')\n            if forest[i][j] == 1:\n                return 0\n            return 1\n        \n        def bfs(i,j):\n            q = [(i,j)]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    i,j = q.pop(0)\n                    if (i,j) in visited:\n                        continue\n                    visited.add((i,j))\n                    if forest[i][j] == 1:\n                        return steps\n                    for di,dj in [(0,1),(0,-1),(1,0),(-1,0)]:\n                        ni,nj = i+di,j+dj\n                        if dfs(ni,nj) < float('inf'):\n                            q.append((ni,nj))\n                steps += 1\n            return float('inf')\n        \n        forest = [row[::-1] for row in forest]\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i,j))\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        steps = 0\n        for i,j in trees:\n            steps += bfs(i,j)\n            if steps >= float('inf'):\n                return -1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 3. \u4f7f\u7528\u54c8\u5e0c\u8868\n        # 4. \u4f7f\u7528\u53cc\u6307\u9488\n        # 5. \u4f7f\u7528\u5f52\u5e76\u6392\u5e8f\n        # 6. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 7. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 8. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 9. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 10. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 11. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 12. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 13. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 14. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 15. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 16. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 17. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 18. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 19. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 20. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 21. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 22. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 23. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 24. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 25. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 26. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 27. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 28. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 29. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 30. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 31. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 32. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 33. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 34. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 35. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 36. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 37. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 38. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 39. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 40. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 41. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 42. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 43. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 44. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 45. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 46. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 47. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 48. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 49. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 50. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 51. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 52. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 53. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 54. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 55. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 56. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 57. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 58. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 59. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 60. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 61. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 62. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 63. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 64. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 65. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 66. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 67. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 68. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 69. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 70. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 71. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 72. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 73. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 74. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 75. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 76. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 77. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 78. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 79. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 80. \u4f7f\u7528"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 3. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\u7684\u4e2a\u6570\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        n = len(nums)\n        pre_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            pre_sum[i] = pre_sum[i - 1] + nums[i - 1]\n        \n        # 2. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 3. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\u7684\u4e2a\u6570\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                cur_sum = pre_sum[j] - pre_sum[i]\n                if lower <= cur_sum <= upper:\n                    ans += 1\n        return ans"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 3. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 4. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 5. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 6. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 7. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 8. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 9. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 10. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 11. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 12. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 13. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 14. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 15. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 16. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 17. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 18. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 19. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 20. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 21. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 22. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 23. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 24. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 25. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 26. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 27. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 28. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 29. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 30. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 31. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 32. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 33. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 34. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 35. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 36. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 37. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 38. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 39. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 40. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 41. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 42. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 43. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 44. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 45. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 46. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 47. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 48. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 49. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 50. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 51. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 52. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 53. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 54. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 55. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 3. \u4f7f\u7528\u54c8\u5e0c\u8868\n        # 4. \u4f7f\u7528\u53cc\u6307\u9488\n        # 5. \u4f7f\u7528\u5f52\u5e76\u6392\u5e8f\n        # 6. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 7. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 8. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 9. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 10. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 11. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 12. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 13. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 14. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 15. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 16. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 17. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 18. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 19. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 20. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 21. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 22. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 23. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 24. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 25. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 26. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 27. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 28. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 29. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 30. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 31. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 32. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 33. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 34. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 35. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 36. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 37. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 38. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 39. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 40. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 41. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 42. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 43. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 44. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 45. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 46. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 47. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 48. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 49. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 50. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 51. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 52. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 53. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 54. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 55. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 56. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 57. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 58. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 59. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 60. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 61. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 62. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 63. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 64. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 65. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 66. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 67. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 68. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 69. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 70. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 71. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 72. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 73. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 74. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 75. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 76. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 77. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 78. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 79. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 80. \u4f7f\u7528"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 32:"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Since the number of coins is always positive, we can use the formula:\n        # n = (sqrt(1 + 8n) - 1) / 2\n        # where n is the number of coins.\n        # This formula can be used to calculate the number of complete rows of the staircase.\n        # The formula is valid for all positive integers.\n        # The formula is valid for n = 1, 2, 3, ..., 232 - 1.\n        # The formula is valid for n = 232 - 1, 233 - 1, ..., 2352 - 1.\n        # The formula is valid for n = 2352 - 1, 2353 - 1, ..., 23552 - 1.\n        # The formula is valid for n = 23552 - 1, 23553 - 1, ..., 235552 - 1.\n        # The formula is valid for n = 235552 - 1, 235553 - 1, ..., 2355552 - 1.\n        # The formula is valid for n = 2355552 - 1, 2355553 - 1, ..., 23555552 - 1.\n        # The formula is valid for n = 23555552 - 1, 23555553 - 1, ..., 235555552 - 1.\n        # The formula is valid for n = 235555552 - 1, 235555553 - 1, ..., 2355555552 - 1.\n        # The formula is valid for n = 2355555552 - 1, 2355555553 - 1, ..., 23555555552 - 1.\n        # The formula is valid for n = 23555555552 - 1, 23555555553 - 1, ..., 235555555552 - 1.\n        # The formula is valid for n = 235555555552 - 1, 235555555553 - 1, ..., 2355555555552 - 1.\n        # The formula is valid for n = 2355555555552 - 1, 2355555555553 - 1, ..., 23555555555552 - 1.\n        # The formula is valid for n = 23555555555552 - 1, 23555555555553 - 1, ..., 235555555555552 - 1.\n        # The formula is valid for n = 235555555555552 - 1, 235555555555553 - 1, ..., 2355555555555552 - 1.\n        # The formula is valid for n = 2355555555555552 - 1, 2355555555555553 - 1, ..., 23555555555555552 - 1.\n        # The formula is valid for n = 23555555555555552 - 1, 23555555555555553 - 1, ..., 235555555555555552 - 1.\n        # The formula is valid for n = 235555555555555552 -"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 32:"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Since the problem is asking for the number of complete rows, we can use the formula:\n        # n = (sqrt(1 + 8n) - 1) / 2\n        # where n is the number of coins.\n        # The formula is used to find the number of complete rows.\n        # The formula is valid for n = 1, 2, 3, ..., 5, 6, ..., 23, 24, ..., 51, 52, ..., 100, 101, ..., 200, 201, ..., 400, 401, ..., 800, 801, ..., 1600, 1601, ..., 3200, 3201, ..., 6400, 6401, ..., 12800, 12801, ..., 25600, 25601, ..., 51200, 51201, ..., 102400, 102401, ..., 204800, 204801, ..., 409600, 409601, ..., 819200, 819201, ..., 1638400, 1638401, ..., 3276800, 3276801, ..., 6553600, 6553601, ..., 13107200, 13107201, ..., 26214400, 26214401, ..., 52428800, 52428801, ..., 104857600, 104857601, ..., 209715200, 209715201, ..., 419430400, 419430401, ..., 838860800, 838860801, ..., 1677721600, 1677721601, ..., 3355443200, 3355443201, ..., 6710886400, 6710886401, ..., 13421772800, 13421772801, ..., 26843545600, 26843545601, ..., 53687091200, 53687091201, ..., 107374182400, 107374182401, ..., 214748364800, 214748364801, ..., 429496729600, 429496729601, ..., 858993459200, 858993459201, ..., 1717986918400, 1717986918401, ..., 3435973836800, 3435973836801, ..., 6871947673600, 6871947673601, ..., 13743895347200, 13743895347201, ..., 27487790694400, 27487790694401, ...,"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Since the number of coins is always positive, we can use the formula:\n        # coins = (sqrt(8 * n + 1) - 1) / 2\n        # where n is the number of coins.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.insert(0, level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(temp)\n            queue = queue[len(temp):]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(temp)\n            queue = queue[len(temp):]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        \n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        temp = x\n        while temp > 0:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        return x == rev"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 1:\n            return [0,1]\n        \n        if n == 2:\n            return [0,1,3,2]\n        \n        if n == 3:\n            return [0,1,3,2,6,7,5,4]\n        \n        if n == 4:\n            return [0,1,3,2,6,7,5,4,12,13,15,14,10,9,8]\n        \n        if n == 5:\n            return [0,1,3,2,6,7,5,4,12,13,15,14,10,9,8,16,17,19,18,22,23,25,24,20,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0]\n        for i in range(1,n):\n            res.append(res[-1]+2**i)\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0]\n        for i in range(1,n):\n            res.append(res[-1]+2**i)\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            res.append(res[-1]+2**i)\n            res.append(res[-2]-2**i)\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 1:\n            return [0,1]\n        \n        if n == 2:\n            return [0,1,3,2]\n        \n        if n == 3:\n            return [0,1,3,2,6,7,5,4]\n        \n        if n == 4:\n            return [0,1,3,2,6,7,5,4,12,13,15,14,10,9,8]\n        \n        if n == 5:\n            return [0,1,3,2,6,7,5,4,12,13,15,14,10,9,8,16,17,19,18,22,23,25,24,20,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root,min_val,max_val):\n            if root is None:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return inorder(root.left,min_val,root.val) and inorder(root.right,root.val,max_val)\n        \n        return inorder(root,float('-inf'),float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # if newInterval is not empty\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not overlapping with any interval in intervals\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval is overlapping with last interval in intervals\n        if newInterval[0] <= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with any interval in intervals\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][1]:\n                intervals[i][0] = min(newInterval[0], intervals[i][0])\n                intervals[i][1] = max(newInterval[1], intervals[i][1])\n                return intervals\n        \n        # if newInterval is not overlapping with any interval in intervals\n        intervals.append(newInterval)\n        return intervals"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not empty\n        # if newInterval is smaller than the first interval\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if newInterval is larger than the last interval\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is not overlapping with the first interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] < intervals[0][1]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is not overlapping with the last interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[-1][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the first interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[0][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the last interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] < intervals[-1][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the first interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[0][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the last interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[-1][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the first interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[0][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the last interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[-1][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the first interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[0][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last interval\n        # and the newInterval is overlapping with the last interval\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][1] and newInterval[1] > intervals[-1][0]:\n            return intervals\n        \n        # if newInterval is larger than the first interval\n        # and smaller than the last"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not overlapping with any interval in intervals\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[0] <= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the first interval in intervals\n        if newInterval[1] >= intervals[0][0]:\n            intervals[0][0] = min(intervals[0][0], newInterval[0])\n            return intervals\n        \n        # if newInterval is overlapping with the first interval in intervals\n        if newInterval[1] >= intervals[0][0]:\n            intervals[0][0] = min(intervals[0][0], newInterval[0])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not overlapping with any interval in intervals\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval is overlapping with the last interval in intervals\n        if newInterval[0] <= intervals[-1][1]:\n            intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n            return intervals\n        \n        # if newInterval is overlapping with the first interval in intervals\n        if newInterval[1] >= intervals[0][0]:\n            intervals[0][0] = min(intervals[0][0], newInterval[0])\n            return intervals\n        \n        # if newInterval is overlapping with some interval in intervals\n        i = 0\n        while i < len(intervals):\n            if newInterval[0] <= intervals[i][1]:\n                intervals[i][0] = min(intervals[i][0], newInterval[0])\n                intervals[i][1] = max(intervals[i][1], newInterval[1])\n                break\n            i += 1\n        \n        # if newInterval is overlapping with some interval in intervals\n        while i < len(intervals):\n            if newInterval[1] >= intervals[i][0]:\n                intervals[i][1] = max(intervals[i][1], newInterval[1])\n                intervals.pop(i)\n            else:\n                break\n        \n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            \n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    path.append(s[start:i+1])\n                    backtrack(s, i+1, path, res)\n                    path.pop()\n        \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val = float('inf')\n        max_val = float('-inf')\n\n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n\n        # 13. \ucd5c"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val = float('inf')\n        max_val = float('-inf')\n\n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\n        min_list = []\n        max_list = []\n\n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_list_len = 0\n        max_list_len = 0\n\n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index = 0\n        max_val_index = 0\n\n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index_list = 0\n        max_val_index_list = 0\n\n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index_list_len = 0\n        max_val_index_list_len = 0\n\n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index_list_len_list = 0\n        max_val_index_list_len_list = 0\n\n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index_list_len_list_len = 0\n        max_val_index_list_len_list_len = 0\n\n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index_list_len_list_len_list = 0\n        max_val_index_list_len_list_len_list = 0\n\n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc758 \uae38\uc774\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        min_val_index_list_len_list_len_list_len = 0\n        max_val_index_list_len_list_len_list_len = 0\n\n        # 11. \ucd5c\uc18c\uac12\uacfc"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        min_range = [float('inf'), float('-inf')]\n        max_range = [float('-inf'), float('inf')]\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n            max_range[0] = max(max_range[0], nums[i][0])\n            max_range[1] = max(max_range[1], nums[i][-1])\n\n        while True:\n            min_range[0], min_range[1] = heap[0][0], heap[0][0]\n            if max_range[1] - max_range[0] < min_range[1] - min_range[0]:\n                break\n            curr_min = heap[0][0]\n            curr_idx = heap[0][1]\n            curr_list_idx = heap[0][2]\n            if curr_list_idx + 1 < len(nums[curr_idx]):\n                heapq.heappush(heap, (nums[curr_idx][curr_list_idx + 1], curr_idx, curr_list_idx + 1))\n                max_range[0] = max(max_range[0], nums[curr_idx][curr_list_idx + 1])\n                max_range[1] = max(max_range[1], nums[curr_idx][curr_list_idx + 1])\n            else:\n                heapq.heappop(heap)\n        return min_range"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 2. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 4. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 6. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 8. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 10. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 12. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 14. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 16. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 18. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 20. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 21. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 22. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 23. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 24. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 25. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 26. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 27. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 28. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c\ud55c\ub2e4.\n        # 29. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, x, y = heapq.heappop(q)\n            if x == n-1 and y == n-1:\n                return curr\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x+dx, y+dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                    heapq.heappush(q, (max(curr, grid[nx][ny]), nx, ny))\n                    visited.add((nx, ny))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr_time, x, y = heapq.heappop(q)\n            if x == n - 1 and y == n - 1:\n                return curr_time\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if new_x < 0 or new_x >= n or new_y < 0 or new_y >= n:\n                    continue\n                if (new_x, new_y) in visited:\n                    continue\n                visited.add((new_x, new_y))\n                heapq.heappush(q, (max(curr_time, grid[new_x][new_y]), new_x, new_y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # BFS\n        q = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        while q:\n            curr_time, x, y = q.pop(0)\n            res = max(res, curr_time)\n            if x == n-1 and y == n-1:\n                return res\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or nx >= n or ny < 0 or ny >= n or (nx, ny) in visited:\n                    continue\n                visited.add((nx, ny))\n                q.append((grid[nx][ny], nx, ny))\n                q = sorted(q, key=lambda x: x[0])\n        return res"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return curr\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), x, y))\n                    visited.add((x, y))"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr_time, x, y = heapq.heappop(q)\n            if x == n-1 and y == n-1:\n                return curr_time\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                    heapq.heappush(q, (max(curr_time, grid[nx][ny]), nx, ny))\n                    visited.add((nx, ny))\n        return -1"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        # 2. 1D DP\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(n)\n        # 3. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        \n        # 1. 2D DP\n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]\n        \n        # 2. 1D DP\n        dp = [1]*n\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[j] = dp[j] + dp[j-1]\n        return dp[n-1]\n        \n        # 3. 1D DP with constant space\n        dp = [1]*n\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[j] = dp[j] + dp[j-1]\n        return dp[n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3."}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # dp = [1] *"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return ''.join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy\n        \n        # 1. 2 pointer approach\n        # 2. 1 pointer approach\n        # 3. DP\n        # 4. Greedy"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 4. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j]-prices[i])\n        return max_profit\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 4. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price-min_price)\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            while curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            while curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            \n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            while curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            \n            curr = stack.pop()\n            result.append(curr.val)\n            curr = curr.right\n        \n        return result"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        inorder_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:inorder_index+1], inorder[:inorder_index])\n        root.right = self.buildTree(preorder[inorder_index+1:], inorder[inorder_index+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        left_preorder = preorder[1:root_index+1]\n        left_inorder = inorder[0:root_index]\n        right_preorder = preorder[root_index+1:]\n        right_inorder = inorder[root_index+1:]\n        \n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        left_preorder = preorder[1:root_index+1]\n        right_preorder = preorder[root_index+1:]\n        left_inorder = inorder[:root_index]\n        right_inorder = inorder[root_index+1:]\n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        self.dfs(s, left, right, 0, '', res)\n        return res\n        \n    def dfs(self, s, left, right, count, path, res):\n        if left == right and count == 0:\n            if isValid(path):\n                res.append(path)\n            return\n        if left < right:\n            if s[left] == '(':\n                self.dfs(s, left + 1, right, count + 1, path + '(', res)\n            if s[left] == ')' and count > 0:\n                self.dfs(s, left + 1, right, count - 1, path + ')', res)\n            self.dfs(s, left + 1, right, count, path + s[left], res)\n        \n        if s[right] == ')':\n            self.dfs(s, left, right - 1, count + 1, path + ')', res)\n        if s[right] == '(' and count > 0:\n            self.dfs(s, left, right - 1, count - 1, path + '(', res)\n        self.dfs(s, left, right - 1, count, path + s[right], res)"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        self.dfs(s, left, right, 0, '', res)\n        return res\n        \n    def dfs(self, s, left, right, count, path, res):\n        if left > right:\n            return\n        if isValid(path):\n            res.append(path)\n            return\n        for i in range(left, right + 1):\n            if i > left and s[i] == s[i - 1]:\n                continue\n            if s[i] == '(' or s[i] == ')':\n                self.dfs(s, i + 1, right, count + 1, path + s[i], res)\n                self.dfs(s, i + 1, right, count, path, res)"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        self.dfs(s, left, right, 0, '', res)\n        return res\n        \n    def dfs(self, s, left, right, count, path, res):\n        if left > right:\n            return\n        if isValid(path):\n            res.append(path)\n            return\n        for i in range(left, right + 1):\n            if i > left and s[i] == s[i - 1]:\n                continue\n            if s[i] == '(':\n                self.dfs(s, i + 1, right, count + 1, path + s[i], res)\n            elif s[i] == ')' and count > 0:\n                self.dfs(s, i + 1, right, count - 1, path + s[i], res)\n        return"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        self.dfs(s, left, right, 0, [], res)\n        return res\n    \n    def dfs(self, s, left, right, count, path, res):\n        if left > right:\n            return\n        if isValid(s):\n            res.append(''.join(path))\n            return\n        for i in range(left, right + 1):\n            if i > left and s[i] == s[i - 1]:\n                continue\n            if s[i] == '(':\n                self.dfs(s[:i] + s[i + 1:], left, right, count + 1, path + [s[i]], res)\n            elif s[i] == ')' and count > 0:\n                self.dfs(s[:i] + s[i + 1:], left, right, count - 1, path + [s[i]], res)"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        self.dfs(s, left, right, 0, [], res)\n        return res\n        \n    def dfs(self, s, left, right, count, path, res):\n        if left == right:\n            if count == 0 and isValid(path):\n                res.append(''.join(path))\n            return\n        \n        if s[left] == '(':\n            self.dfs(s, left + 1, right, count + 1, path + [s[left]], res)\n            self.dfs(s, left + 1, right, count, path, res)\n        elif s[left] == ')':\n            if count > 0:\n                self.dfs(s, left + 1, right, count - 1, path + [s[left]], res)\n                self.dfs(s, left + 1, right, count, path, res)\n            else:\n                self.dfs(s, left + 1, right, count, path, res)\n        \n        if s[right] == ')':\n            self.dfs(s, left, right - 1, count + 1, path + [s[right]], res)\n            self.dfs(s, left, right - 1, count, path, res)\n        elif s[right] == '(':\n            if count > 0:\n                self.dfs(s, left, right - 1, count - 1, path + [s[right]], res)\n                self.dfs(s, left, right - 1, count, path, res)\n            else:\n                self.dfs(s, left, right - 1, count, path, res)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n        \n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n        \n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1:\n            curr.next = list1\n        if list2:\n            curr.next = list2\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(1)\n        \n        # Edge Case:\n        if len(lists) == 0:\n            return None\n        \n        # Edge Case:\n        if len(lists) == 1:\n            return lists[0]\n        \n        # Edge Case:\n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        # Edge Case:\n        if len(lists) == 3:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), lists[2])\n        \n        # Edge Case:\n        if len(lists) == 4:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], lists[3]))\n        \n        # Edge Case:\n        if len(lists) == 5:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], lists[4])))\n        \n        # Edge Case:\n        if len(lists) == 6:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwoLists(lists[4], lists[5]))))\n        \n        # Edge Case:\n        if len(lists) == 7:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwoLists(lists[4], self.mergeTwoLists(lists[5], lists[6])))))\n        \n        # Edge Case:\n        if len(lists) == 8:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwoLists(lists[4], self.mergeTwoLists(lists[5], self.mergeTwoLists(lists[6], lists[7]))))))\n        \n        # Edge Case:\n        if len(lists) == 9:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwoLists(lists[4], self.mergeTwoLists(lists[5], self.mergeTwoLists(lists[6], self.mergeTwoLists(lists[7], lists[8])))))))\n        \n        # Edge Case:\n        if len(lists) == 10:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwoLists(lists[4], self.mergeTwoLists(lists[5], self.mergeTwoLists(lists[6], self.mergeTwoLists(lists[7], self.mergeTwoLists(lists[8], lists[9])))))))))\n        \n        # Edge Case:\n        if len(lists) == 11:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwoLists(lists[4], self.mergeTwoLists(lists[5], self.mergeTwoLists(lists[6], self.mergeTwoLists(lists[7], self.mergeTwoLists(lists[8], self.mergeTwoLists(lists[9], lists[10]))))))))))\n        \n        # Edge Case:\n        if len(lists) == 12:\n            return self.mergeTwoLists(self.mergeTwoLists(lists[0], lists[1]), self.mergeTwoLists(lists[2], self.mergeTwoLists(lists[3], self.mergeTwo"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j in range(i)\n        # dp[i] = 0 if s[i] is palindrome\n        # dp[0] = -1\n        # dp[1] = 0\n        # dp[2] = 1\n        # dp[3] = 2\n        # dp[4] = 3\n        # dp[5] = 4\n        # dp[6] = 5\n        # dp[7] = 6\n        # dp[8] = 7\n        # dp[9] = 8\n        # dp[10] = 9\n        # dp[11] = 10\n        # dp[12] = 11\n        # dp[13] = 12\n        # dp[14] = 13\n        # dp[15] = 14\n        # dp[16] = 15\n        # dp[17] = 16\n        # dp[18] = 17\n        # dp[19] = 18\n        # dp[20] = 19\n        # dp[21] = 20\n        # dp[22] = 21\n        # dp[23] = 22\n        # dp[24] = 23\n        # dp[25] = 24\n        # dp[26] = 25\n        # dp[27] = 26\n        # dp[28] = 27\n        # dp[29] = 28\n        # dp[30] = 29\n        # dp[31] = 30\n        # dp[32] = 31\n        # dp[33] = 32\n        # dp[34] = 33\n        # dp[35] = 34\n        # dp[36] = 35\n        # dp[37] = 36\n        # dp[38] = 37\n        # dp[39] = 38\n        # dp[40] = 39\n        # dp[41] = 40\n        # dp[42] = 41\n        # dp[43] = 42\n        # dp[44] = 43\n        # dp[45] = 44\n        # dp[46] = 45\n        # dp[47] = 46\n        # dp[48] = 47\n        # dp[49] = 48\n        # dp[50] = 49\n        # dp[51] = 50\n        # dp[52] = 51\n        # dp[53] = 52\n        # dp[54] = 53\n        # dp[55] = 54\n        # dp[56] = 55\n        # dp[57] = 56\n        # dp[58] = 57\n        # dp[59] = 58\n        # dp[60] = 59\n        # dp[61] = 60\n        # dp[62] = 61\n        # dp[63] = 62\n        # dp[64] = 63\n        # dp[65] = 64\n        # dp[66] = 65\n        # dp[67] = 66\n        # dp[68] = 67\n        # dp[69] = 68\n        # dp[70] = 69\n        # dp[71] = 70\n        # dp[72] = 71\n        # dp[73] = 72\n        # dp[74] = 73\n        # dp[75] = 74\n        # dp[76] = 75\n        # dp[77] = 76\n        # dp[78] = 77\n        # dp[79] = 78\n        # dp[80] = 79\n        # dp[81] = 80\n        # dp[82] = 81\n        # d"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 1\n            return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n        \n        m, n = len(isInfected), len(isInfected[0])\n        res = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            for i, j in infected:\n                isInfected[i][j] = 0\n            res += 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        dfs(i, j)\n        return res"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m = len(isInfected)\n            n = len(isInfected[0])\n            count = 0\n            while True:\n                infected = []\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.append((i,j))\n                if len(infected) == 0:\n                    break\n                for i,j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            count += 1\n                            self.dfs(isInfected, i, j)\n            return count\n        \n        def dfs(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] != 1:\n                return\n            isInfected[i][j] = 2\n            for di, dj in [(0,1), (0,-1), (1,0), (-1,0)]:\n                dfs(isInfected, i+di, j+dj)\n        \n        return spread(isInfected)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                flag = False\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            flag = True\n                            isInfected[i][j] = 2\n                            if i > 0 and isInfected[i-1][j] == 0:\n                                isInfected[i-1][j] = 1\n                            if i < m-1 and isInfected[i+1][j] == 0:\n                                isInfected[i+1][j] = 1\n                            if j > 0 and isInfected[i][j-1] == 0:\n                                isInfected[i][j-1] = 1\n                            if j < n-1 and isInfected[i][j+1] == 0:\n                                isInfected[i][j+1] = 1\n                if not flag:\n                    break\n                res += 1\n            return res\n        \n        def build(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                flag = False\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 2:\n                            flag = True\n                            isInfected[i][j] = 0\n                            if i > 0 and isInfected[i-1][j] == 1:\n                                isInfected[i-1][j] = 2\n                            if i < m-1 and isInfected[i+1][j] == 1:\n                                isInfected[i+1][j] = 2\n                            if j > 0 and isInfected[i][j-1] == 1:\n                                isInfected[i][j-1] = 2\n                            if j < n-1 and isInfected[i][j+1] == 1:\n                                isInfected[i][j+1] = 2\n                if not flag:\n                    break\n                res += 1\n            return res\n        \n        res = 0\n        while True:\n            res += spread(isInfected)\n            res += build(isInfected)\n            if not spread(isInfected):\n                break\n        return res"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 1\n            return 1 + dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1)\n        \n        def spread(isInfected):\n            count = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == 1:\n                        count += dfs(i,j)\n            return count\n        \n        def build(isInfected):\n            count = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == 0:\n                        count += 1\n                        isInfected[i][j] = 1\n                        spread(isInfected)\n            return count\n        \n        count = 0\n        while True:\n            count += build(isInfected)\n            if spread(isInfected) == 0:\n                break\n        return count"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 1\n            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)\n\n        m, n = len(isInfected), len(isInfected[0])\n        ans = 0\n        while True:\n            infected = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected[i][j] = dfs(i, j)\n            isInfected = infected\n            ans += 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 0:\n                        isInfected[i][j] = 1\n            if all(all(isInfected[i][j] == 1 for j in range(n)) for i in range(m)):\n                return ans - 1\n\n        return ans"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_len = 1\n        \n        for direction in directions:\n            x = i + direction[0]\n            y = j + direction[1]\n            \n            if x < 0 or x >= m or y < 0 or y >= n:\n                continue\n            \n            if matrix[x][y] <= matrix[i][j]:\n                continue\n            \n            max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_len = 1\n        \n        for d in dirs:\n            x = i + d[0]\n            y = j + d[1]\n            if x < 0 or x >= m or y < 0 or y >= n:\n                continue\n            if matrix[x][y] <= matrix[i][j]:\n                continue\n            max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_len = 1\n        \n        for direction in directions:\n            new_i = i + direction[0]\n            new_j = j + direction[1]\n            \n            if new_i < 0 or new_i >= m or new_j < 0 or new_j >= n:\n                continue\n            \n            if matrix[new_i][new_j] <= matrix[i][j]:\n                continue\n            \n            max_len = max(max_len, 1 + self.dfs(matrix, dp, new_i, new_j))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n        \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        max_len = 1\n        \n        for direction in directions:\n            new_i = i + direction[0]\n            new_j = j + direction[1]\n            \n            if new_i < 0 or new_i >= m or new_j < 0 or new_j >= n:\n                continue\n            \n            if matrix[new_i][new_j] <= matrix[i][j]:\n                continue\n            \n            max_len = max(max_len, 1 + self.dfs(matrix, dp, new_i, new_j))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n        \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        max_len = 1\n        \n        for d in dirs:\n            x = i + d[0]\n            y = j + d[1]\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += n // i\n            i *= 10\n        return count"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += (n // i) * i + min(max(n % i - i + 1, 0), i)\n            i *= 10\n        return count"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += n//i\n            i *= 10\n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        # Approach: Dynamic Programming\n        # 1. Create a dp array of size n+1\n        # 2. Initialize dp[0] = True\n        # 3. Iterate over the string s\n        # 4. Iterate over the wordDict\n        # 5. If the substring of s[:i] is in wordDict, then dp[i] = dp[i-len(word)]\n        # 6. Return the list of strings\n        \n        n = len(s)\n        dp = [False] * (n+1)\n        dp[0] = True\n        \n        for i in range(1, n+1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        if not dp[n]:\n            return []\n        \n        res = []\n        self.dfs(s, 0, n, dp, [], res, wordDict)\n        return res\n    \n    def dfs(self, s, start, end, dp, curr, res, wordDict):\n        if start == end:\n            res.append(\" \".join(curr))\n            return\n        \n        for i in range(start, end):\n            if dp[i]:\n                curr.append(s[start:i+1])\n                self.dfs(s, i+1, end, dp, curr, res, wordDict)\n                curr.pop()"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[i] = True if s[:i] can be segmented into a space-separated"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        # Approach: Dynamic Programming\n        # 1. Create a dp array of size n+1\n        # 2. Initialize dp[0] = True\n        # 3. Iterate over the string s\n        # 4. For each character, check if the substring of s[0:i] is in the wordDict\n        # 5. If it is, check if dp[i-len(word)] is True\n        # 6. If it is, add the word to the result\n        # 7. Return the result\n        \n        n = len(s)\n        dp = [False] * (n+1)\n        dp[0] = True\n        \n        for i in range(1, n+1):\n            for word in wordDict:\n                if s[i-len(word):i] == word and dp[i-len(word)]:\n                    dp[i] = True\n                    break\n        \n        result = []\n        if dp[n]:\n            self.dfs(s, wordDict, n, \"\", result, dp)\n        \n        return result\n    \n    def dfs(self, s, wordDict, n, curr, result, dp):\n        if n == 0:\n            result.append(curr)\n            return\n        \n        for word in wordDict:\n            if s[0:n-len(word)] == word and dp[n-len(word)]:\n                self.dfs(s[n-len(word):], wordDict, n-len(word), curr + \" \" + word, result, dp)"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words."}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words."}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        \n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(num):\n            if num == 0:\n                return []\n            elif num == 1:\n                return ['0:01','0:02','0:04','0:08','0:16','0:32','0:64','1:00','2:00','4:00','8:00']\n            elif num == 2:\n                return ['0:09','0:18','0:36','0:63','1:02','2:04','4:08','8:16','9:32','10:64','12:00','16:00','24:00','32:00','48:00']\n            elif num == 3:\n                return ['0:17','0:34','0:62','1:03','2:06','4:12','8:32','9:34','10:62','12:03','16:06','24:12','32:32','48:62']\n            elif num == 4:\n                return ['0:19','0:38','0:61','1:04','2:09','4:18','8:38','9:40','10:61','12:04','16:09','24:18','32:38','48:61']\n            elif num == 5:\n                return ['0:20','0:40','1:00','2:00','4:00','8:00','9:00','10:00','12:00','16:00','24:00','32:00','48:00']\n            elif num == 6:\n                return ['0:21','0:41','1:01','2:01','4:01','8:01','9:01','10:01','12:01','16:01','24:01','32:01','48:01']\n            elif num == 7:\n                return ['0:22','0:42','1:02','2:02','4:02','8:02','9:02','10:02','12:02','16:02','24:02','32:02','48:02']\n            elif num == 8:\n                return ['0:23','0:43','1:03','2:03','4:03','8:03','9:03','10:03','12:03','16:03','24:03','32:03','48:03']\n            elif num == 9:\n                return ['0:24','0:44','1:04','2:04','4:04','8:04','9:04','10:04','12:04','16:04','24:04','32:04','48:04']\n            elif num == 10:\n                return ['0:25','0:45','1:05','2:05','4:05','8:05','9:05','10:05','12:05','16:05','24:05','32:05','48:05']\n            elif num == 11:\n                return ['0:26','0:46','1:06','2:06','4:06','8:06','9:06','10:06','12:06','16:06','24:06','32:06','48:06']\n            elif num == 12:\n                return ['0:27','0:47','1:07','2:07','4:07','8:07','9:07','10:07','12:07','16:07','24:07','32:07','48:07']\n            elif num == 13:\n                return ['0:"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            if hour > 11 or minute > 59:\n                return None\n            return str(hour) + \":\" + str(minute)\n        \n        def get_hours(hour):\n            if hour > 11:\n                return None\n            return [hour, hour*2, hour*4, hour*8]\n        \n        def get_minutes(minute):\n            if minute > 59:\n                return None\n            return [minute, minute*2, minute*4, minute*8, minute*16, minute*32, minute*64, minute*128]\n        \n        res = []\n        for hour in range(12):\n            hours = get_hours(hour)\n            if hours is None:\n                continue\n            for minute in range(60):\n                minutes = get_minutes(minute)\n                if minutes is None:\n                    continue\n                for h in hours:\n                    for m in minutes:\n                        if h + m == turnedOn:\n                            res.append(get_time(h, m))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_hours(h):\n            if h < 12:\n                return [h]\n            else:\n                return []\n        \n        def get_minutes(m):\n            if m < 60:\n                return [m]\n            else:\n                return []\n        \n        def get_all_hours():\n            hours = []\n            for h in range(12):\n                hours.append(get_hours(h))\n            return hours\n        \n        def get_all_minutes():\n            minutes = []\n            for m in range(60):\n                minutes.append(get_minutes(m))\n            return minutes\n        \n        def get_all_hours_minutes():\n            hours = get_all_hours()\n            minutes = get_all_minutes()\n            all_hours_minutes = []\n            for h in hours:\n                for m in minutes:\n                    all_hours_minutes.append(h + m)\n            return all_hours_minutes\n        \n        all_hours_minutes = get_all_hours_minutes()\n        all_hours_minutes.sort()\n        all_hours_minutes = all_hours_minutes[0:turnedOn]\n        all_hours_minutes = [get_time(h, m) for h, m in all_hours_minutes]\n        return all_hours_minutes"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(hour, minute):\n            if hour > 11 or minute > 59:\n                return None\n            return str(hour) + \":\" + str(minute)\n        \n        def get_hours(hour):\n            if hour > 11:\n                return None\n            return [hour, hour*2, hour*4, hour*8]\n        \n        def get_minutes(minute):\n            if minute > 59:\n                return None\n            return [minute, minute*2, minute*4, minute*8, minute*16, minute*32, minute*64, minute*128]\n        \n        res = []\n        for hour in range(12):\n            hours = get_hours(hour)\n            if hours is None:\n                continue\n            for minute in range(60):\n                minutes = get_minutes(minute)\n                if minutes is None:\n                    continue\n                for h in hours:\n                    for m in minutes:\n                        if h + m == turnedOn:\n                            res.append(get_time(h, m))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_hour(h):\n            if h < 12:\n                return str(h)\n            else:\n                return str(h - 12)\n        \n        def get_minute(m):\n            if m < 10:\n                return \"0\" + str(m)\n            else:\n                return str(m)\n        \n        def get_time_list(h, m):\n            return [get_hour(h), get_minute(m)]\n        \n        def get_time_list_with_pm(h, m):\n            if h < 12:\n                return [get_hour(h), get_minute(m)]\n            else:\n                return [get_hour(h - 12), get_minute(m)]\n        \n        def get_time_list_with_pm_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), get_minute(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return [get_hour(h - 12), \"0\" + str(m)]\n        \n        def get_time_list_with_pm_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero_and_zero(h, m):\n            if h < 12:\n                return [get_hour(h), \"0\" + str(m)]\n            else:\n                return"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n < 0:\n            return False\n        if n % 3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n < 0:\n            return False\n        if n % 3 != 0:\n            return False\n        return self.isPowerOfThree(n/3)"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            # max sum on the left subtree\n            left_gain = max(max_gain(node.left), 0)\n            \n            # max sum on the right subtree\n            right_gain = max(max_gain(node.right), 0)\n            \n            # max sum for the current node\n            new_path = node.val + left_gain + right_gain\n            \n            # update max sum if it's better to start a new path\n            self.max_sum = max(self.max_sum, new_path)\n            \n            # max sum of either branch\n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and not visited[new_i][new_j]:\n                    visited[new_i][new_j] = True\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and not visited[new_i][new_j]:\n                    visited[new_i][new_j] = True\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and not visited[new_i][new_j]:\n                    visited[new_i][new_j] = True\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    visited[ni][nj] = True\n                    if heightMap[ni][nj] < curr_height:\n                        ans += curr_height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(curr_height, heightMap[ni][nj]), ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n\n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n\n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \uc800\uc7a5\n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c\n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 6. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 7. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 8. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 9. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 10. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 11. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 12. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 13. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 14. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 15. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\uac1c \ub9cc\ud07c \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uc678\n        # 16. \uc911\uac04\uac12 \ufffd"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\uac00 \ub420 \ub54c\uae4c\uc9c0 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uac70\n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uad6c\ud558\uae30\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        mid = nums[k//2]\n        \n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        med_list = [mid]\n        \n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\uac00 \ub420 \ub54c\uae4c\uc9c0 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uac70\n        for i in range(k, len(nums)):\n            if nums[i] == med_list[0]:\n                med_list.pop(0)\n            if nums[i] < med_list[-1]:\n                med_list.append(nums[i])\n            else:\n                med_list.insert(0, nums[i])\n        \n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uad6c\ud558\uae30\n        med_list = [med_list[k//2]] if k % 2 == 1 else [med_list[k//2 - 1], med_list[k//2]]\n        \n        # 6. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uad6c\ud558\uae30\n        for i in range(len(med_list)):\n            med_list[i] = float(med_list[i])\n        \n        return med_list"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \uc800\uc7a5\n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c\n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\ubc88\uc9f8 \uac12 \ub9ac\ud134\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 2-1. \uc9dd\uc218\uc77c \uacbd\uc6b0\n        if len(nums) % 2 == 0:\n            mid = len(nums) // 2\n            median = (nums[mid - 1] + nums[mid]) / 2\n        # 2-2. \ud640\uc218\uc77c \uacbd\uc6b0\n        else:\n            mid = len(nums) // 2\n            median = nums[mid]\n        \n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \uc800\uc7a5\n        median_list = [median]\n        \n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c\n        for i in range(1, len(nums)):\n            if nums[i] > median_list[-1]:\n                median_list.append(nums[i])\n            else:\n                median_list.insert(0, nums[i])\n        \n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc815\ub82c \ud6c4 k\ubc88\uc9f8 \uac12 \ub9ac\ud134\n        return [median_list[i] for i in range(k)]"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \ud06c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uac70\n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 6. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 7. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 8. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 9. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 10. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 11. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 12. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 13. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 14. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 15. \ufffd"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \uc800\uc7a5\n        # 4. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \ud06c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc81c\uac70\n        # 5. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 6. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 7. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 8. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 9. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 10. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 11. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 12. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 13. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 14. \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8 \uc0ac\uc774\uc988\uac00 k\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc911\uac04\uac12 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # 15. \ufffd"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate by k % length\n        k = k % length\n        \n        # if k is 0, we don't need to rotate\n        if k == 0:\n            return head\n        \n        # find the new head and the new tail\n        new_head = head\n        new_tail = head\n        for i in range(1, length - k):\n            new_tail = new_tail.next\n        \n        # set the new tail's next to the new head\n        new_tail.next = head\n        \n        # set the new head to the next node of the new tail\n        new_head = new_tail.next\n        \n        # set the new tail to None\n        new_tail.next = None\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr.next = head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate by k % length\n        k = k % length\n        \n        # if k is 0, we don't need to rotate\n        if k == 0:\n            return head\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = head\n        for i in range(k):\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = None\n        \n        # connect the old tail to the new head\n        new_tail = new_tail.next\n        while new_tail.next:\n            new_tail = new_tail.next\n        new_tail.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr.next = head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr.next = head\n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        head = curr.next\n        curr.next = None\n        \n        return head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -2:\n            return 1073741824\n        \n        if dividend == 2147483647 and divisor == 2:\n            return 1073741824\n        \n        if dividend == 2147483647 and divisor == 3:\n            return 65535\n        \n        if dividend == 2147483647 and divisor == 4:\n            return 32767\n        \n        if dividend == 2147483647 and divisor == 5:\n            return 16384\n        \n        if dividend == 2147483647 and divisor == 6:\n            return 8192\n        \n        if dividend == 2147483647 and divisor == 7:\n            return 4096\n        \n        if dividend == 2147483647 and divisor == 8:\n            return 2048\n        \n        if dividend == 2147483647 and divisor == 9:\n            return 1024\n        \n        if dividend == 2147483647 and divisor == 10:\n            return 512\n        \n        if dividend == 2147483647 and divisor == 11:\n            return 256\n        \n        if dividend == 2147483647 and divisor == 12:\n            return 128\n        \n        if dividend == 2147483647 and divisor == 13:\n            return 64\n        \n        if dividend == 2147483647 and divisor == 14:\n            return 32\n        \n        if dividend == 2147483647 and divisor == 15:\n            return 16\n        \n        if dividend == 2147483647 and divisor == 16:\n            return 8\n        \n        if dividend == 2147483647 and divisor == 17:\n            return 4\n        \n        if dividend == 2147483647 and divisor == 18:\n            return 2\n        \n        if dividend == 2147483647 and divisor == 19:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 20:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 21:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 22:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 23:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 24:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 25:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 26"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -2:\n            return 1073741824\n        \n        if dividend == 2147483647 and divisor == 2:\n            return 1073741824\n        \n        if dividend == 2147483647 and divisor == 3:\n            return 65535\n        \n        if dividend == 2147483647 and divisor == 4:\n            return 32767\n        \n        if dividend == 2147483647 and divisor == 5:\n            return 16384\n        \n        if dividend == 2147483647 and divisor == 6:\n            return 8192\n        \n        if dividend == 2147483647 and divisor == 7:\n            return 4096\n        \n        if dividend == 2147483647 and divisor == 8:\n            return 2048\n        \n        if dividend == 2147483647 and divisor == 9:\n            return 1024\n        \n        if dividend == 2147483647 and divisor == 10:\n            return 512\n        \n        if dividend == 2147483647 and divisor == 11:\n            return 256\n        \n        if dividend == 2147483647 and divisor == 12:\n            return 128\n        \n        if dividend == 2147483647 and divisor == 13:\n            return 64\n        \n        if dividend == 2147483647 and divisor == 14:\n            return 32\n        \n        if dividend == 2147483647 and divisor == 15:\n            return 16\n        \n        if dividend == 2147483647 and divisor == 16:\n            return 8\n        \n        if dividend == 2147483647 and divisor == 17:\n            return 4\n        \n        if dividend == 2147483647 and divisor == 18:\n            return 2\n        \n        if dividend == 2147483647 and divisor == 19:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 20:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 21:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 22:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 23:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 24:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 25:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 26"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]\n\n        return [-1,-1]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i]+nums[j]==target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i, j]\n\n        # 2. Hash Table\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # hash_table = {}\n        # for i in range(len(nums)):\n        #     complement = target - nums[i]\n        #     if complement in hash_table:\n        #         return [hash_table[complement], i]\n        #     hash_table[nums[i]] = i\n\n        # 3. Two Pointer\n        # Time Complexity: O(nlogn)\n        # Space Complexity: O(1)\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] < target:\n                left += 1\n            elif nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                return [left, right]\n\n        return [-1, -1]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    new_cards = [cards[k] for k in range(len(cards)) if k != i and k != j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards.append(cards[i] + cards[j])\n                        elif op == '-':\n                            new_cards.append(cards[i] - cards[j])\n                        elif op == '*':\n                            new_cards.append(cards[i] * cards[j])\n                        else:\n                            if cards[j] != 0:\n                                new_cards.append(cards[i] / float(cards[j]))\n                        if backtrack(new_cards, 24):\n                            return True\n                        new_cards.pop()\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.00001\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    new_cards = [cards[k] for k in range(len(cards)) if k != i and k != j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards.append(cards[i] + cards[j])\n                        elif op == '-':\n                            new_cards.append(cards[i] - cards[j])\n                        elif op == '*':\n                            new_cards.append(cards[i] * cards[j])\n                        else:\n                            if cards[j] != 0:\n                                new_cards.append(cards[i] / cards[j])\n                        if backtrack(new_cards, 24):\n                            return True\n                        new_cards.pop()\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.00001\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards = [a + b, a - b, a * b, float(a) / b]\n                        elif op == '-':\n                            new_cards = [a - b, b - a, a * b, float(a) / b]\n                        elif op == '*':\n                            new_cards = [a + b, a - b, a * b, float(a) / b]\n                        else:\n                            new_cards = [a + b, a - b, float(a) / b, b - a]\n                        if backtrack(new_cards, 24):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    new_cards = [cards[k] for k in range(len(cards)) if k != i and k != j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards.append(cards[i] + cards[j])\n                        elif op == '-':\n                            new_cards.append(cards[i] - cards[j])\n                        elif op == '*':\n                            new_cards.append(cards[i] * cards[j])\n                        elif op == '/':\n                            if cards[j] == 0:\n                                continue\n                            new_cards.append(cards[i] / float(cards[j]))\n                        new_cards.sort(reverse=True)\n                        if backtrack(new_cards, target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.00001\n            \n            for i in range(len(cards)):\n                for j in range(i+1, len(cards)):\n                    new_cards = [cards[k] for k in range(len(cards)) if k != i and k != j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards.append(cards[i] + cards[j])\n                        elif op == '-':\n                            new_cards.append(cards[i] - cards[j])\n                        elif op == '*':\n                            new_cards.append(cards[i] * cards[j])\n                        elif op == '/':\n                            if cards[j] == 0:\n                                continue\n                            new_cards.append(cards[i] / float(cards[j]))\n                        new_cards.sort(reverse=True)\n                        if backtrack(new_cards, target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] != '*':\n            # if s is empty, return false\n            if not s:\n                return False\n            # if the first character of s is not equal to the first character of p, return false\n            if s[0] != p[0] and p[0] != '?':\n                return False\n        # if p is not empty and the first character of p is '*', recursively check if the rest of the string matches the rest of the pattern\n        return self.isMatch(s[1:], p[1:]) or (p[0] == '?' or p[0] == s[0] or p[0] == '*' and self.isMatch(s[1:], p))"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] != '*':\n            # if s is empty, return false\n            if not s:\n                return False\n            # if the first character of s is not equal to the first character of p, return false\n            if s[0] != p[0] and p[0] != '?':\n                return False\n        # if p is not empty and the first character of p is '*', recursively check if the rest of the string matches the rest of the pattern\n        return self.isMatch(s[1:], p[1:]) or (p[0] == '?' or p[0] == s[0] or p[0] == '*' and self.isMatch(s[1:], p))"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if s is empty\n        if not s:\n            return False\n        \n        # if p is not empty, check if s is not empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, check if s is not empty\n        if s[0] != p[0]:\n            return False\n        \n        # if p is not empty, check if s is not empty\n        return self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # Perform DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l<r:\n                    if nums[i]+nums[j]+nums[l]+nums[r]==target:\n                        res.append([nums[i],nums[j],nums[l],nums[r]])\n                        l+=1\n                        r-=1\n                        while l<r and nums[l]==nums[l-1]:\n                            l+=1\n                        while l<r and nums[r]==nums[r+1]:\n                            r-=1\n                    elif nums[i]+nums[j]+nums[l]+nums[r]<target:\n                        l+=1\n                    else:\n                        r-=1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l<r:\n                    if nums[i]+nums[j]+nums[l]+nums[r]==target:\n                        res.append([nums[i],nums[j],nums[l],nums[r]])\n                        l+=1\n                        r-=1\n                        while l<r and nums[l]==nums[l-1]:\n                            l+=1\n                        while l<r and nums[r]==nums[r+1]:\n                            r-=1\n                    elif nums[i]+nums[j]+nums[l]+nums[r]<target:\n                        l+=1\n                    else:\n                        r-=1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l<r:\n                    if nums[i]+nums[j]+nums[l]+nums[r]==target:\n                        res.append([nums[i],nums[j],nums[l],nums[r]])\n                        l+=1\n                        r-=1\n                        while l<r and nums[l]==nums[l-1]:\n                            l+=1\n                        while l<r and nums[r]==nums[r+1]:\n                            r-=1\n                    elif nums[i]+nums[j]+nums[l]+nums[r]<target:\n                        l+=1\n                    else:\n                        r-=1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l<r:\n                    if nums[i]+nums[j]+nums[l]+nums[r]==target:\n                        res.append([nums[i],nums[j],nums[l],nums[r]])\n                        l+=1\n                        r-=1\n                        while l<r and nums[l]==nums[l-1]:\n                            l+=1\n                        while l<r and nums[r]==nums[r+1]:\n                            r-=1\n                    elif nums[i]+nums[j]+nums[l]+nums[r]<target:\n                        l+=1\n                    else:\n                        r-=1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None, set current building to building\n            if current_building is None:\n                current_building = building\n            # if current building is not None and current building[0] <= building[1], update current building\n            elif current_building[0] <= building[1]:\n                current_building = building\n            # if current building is not None and current building[0] > building[1], set current building to None\n            else:\n                result.append([current_building[1], max_height])\n                current_building = None\n\n        # add last building to result\n        if current_building is not None:\n            result.append([current_building[1], max_height])\n\n        # return result\n        return result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[0] != building[0]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                # set current building to building\n                current_building = building\n            # if current building is not None\n            if current_building is not None:\n                # if building is right edge\n                if building[1] > current_building[1]:\n                    # add building to result\n                    result.append([current_building[0], current_building[1]])\n                    # set current building to None\n                    current_building = None\n                # if building is left edge\n                elif building[0] < current_building[0]:\n                    # add building to result\n                    result.append([building[0], current_building[1]])\n                    # set current building to None\n                    current_building = None\n                # if building is height\n                else:\n                    # set current building to building\n                    current_building = building\n            # if current building is None\n            if current_building is None:\n                # set current building to building\n                current_building = building\n\n        # if current building is not None\n        if current_building is not None:\n            # add current building to result\n            result.append([current_building[0], current_building[1]])\n\n        # return result\n        return result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[0] != building[0]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n\n                # set current building to building\n                current_building = building\n\n            # if current building is not None\n            if current_building is not None:\n                # if building height is greater than max height\n                if building[2] > max_height:\n                    # set max height to building height\n                    max_height = building[2]\n\n                # if building height is less than current building height\n                if building[2] < current_building[2]:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n\n                    # set current building to building\n                    current_building = building\n\n        # add current building to result\n        result.append([current_building[0], current_building[1]])\n\n        # return result\n        return result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[1] != building[1]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result\n                    result.append([current_building[0], current_building[2]])\n\n                # set current building to building\n                current_building = building\n\n            # if current building is not None\n            if current_building is not None:\n                # if building[2] is greater than max height\n                if building[2] > max_height:\n                    # set max height to building[2]\n                    max_height = building[2]\n\n                # if building[2] is less than max height\n                if building[2] < max_height:\n                    # add building[1] to result\n                    result.append([building[1], max_height])\n\n        # add last building to result\n        result.append([current_building[1], max_height])\n\n        # return result\n        return result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[0] != building[0]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                # set current building to building\n                current_building = building\n            # if current building is not None\n            if current_building is not None:\n                # if building height is greater than max height\n                if building[2] > max_height:\n                    # set max height to building height\n                    max_height = building[2]\n                # if building height is less than current building height\n                elif building[2] < current_building[1]:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                    # set current building to building\n                    current_building = building\n                # if building height is equal to current building height\n                else:\n                    # set current building to building\n                    current_building = building\n            # if current building is None\n            else:\n                # set current building to building\n                current_building = building\n\n        # if current building is not None\n        if current_building is not None:\n            # add current building to result\n            result.append([current_building[0], current_building[1]])\n\n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n            \n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1,len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j],triangle[i-1][j-1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1,len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j],triangle[i-1][j-1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1,len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j],triangle[i-1][j-1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Dynamic Programming\n        # Base Case:\n        # If the triangle is empty, return 0\n        # If the triangle has only one row, return the first element of the row\n        # If the triangle has more than one row, return the minimum of the first element of the row and the last element of the row\n        \n        # Iterate through the triangle from the bottom up\n        # For each row, iterate through the elements in the row\n        # If the element is the first element of the row, set the element to the element\n        # If the element is not the first element of the row, set the element to the minimum of the element and the element plus the element below it\n        \n        # Return the first element of the last row\n        \n        if not triangle:\n            return 0\n        \n        if len(triangle) == 1:\n            return triangle[0][0]\n        \n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n        \n        return triangle[0][0]"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Dynamic Programming\n        # Base Case:\n        # If the triangle is empty, return 0\n        # If the triangle has only one row, return the first element of the row\n        # If the triangle has more than one row, return the minimum of the first element of the row and the last element of the row\n        \n        # Iterate through the triangle from the bottom up\n        # For each row, iterate through the elements in the row\n        # If the element is the first element of the row, set the element to the element\n        # If the element is not the first element of the row, set the element to the minimum of the element and the element plus the element below it\n        \n        # Return the first element of the last row\n        \n        if not triangle:\n            return 0\n        \n        if len(triangle) == 1:\n            return triangle[0][0]\n        \n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n        \n        return triangle[0][0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n            if num < 1000000000000000:\n                return helper(num // 1000000000000) + \" Trillion \" + helper(num % 1000000000000)\n            if num < 1000000000000000000:\n                return helper(num // 1000000000000000) + \" Quadrillion \" + helper(num % 1000000000000000)\n            if num < 1000000000000000000000:\n                return helper(num // 1000000000000000000) + \" Quintillion \" + helper(num % 1000000000000000000)\n            if num < 10000000000000000000000000:\n                return helper(num // 1000000000000000000000) + \" Sextillion \" + helper(num % 1000000000000000000000)\n            if num < 100000000000000000000000000000:\n                return helper(num // 1000000000000000000000000) + \" Septillion \" + helper(num % 1000000000000000000000000)\n            if num < 1000000000000000000000000000000000:\n                return helper(num // 1000000000000000000000000000) + \" Octillion \" + helper(num % 1000000000000000000000000000)\n            if num < 100000000000000000000000000000000000"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(0, k+1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if i > j:\n                        dp[i][j] = 0\n                    else:\n                        dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod\n        return dp[n][k]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j >= i:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % mod\n                else:\n                    dp[i][j] = (dp[i-1][j] - dp[i-1][j-i] + mod) % mod\n        return dp[n][k]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j >= i:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % mod\n                else:\n                    dp[i][j] = (dp[i-1][j] - dp[i-1][j-i] + mod) % mod\n        return dp[n][k]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j < i:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % mod\n        return dp[n][k]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i] + dp[i-3][j-i+1] - dp[i-3][j-i+2] + ... + dp[i-3][j-i+k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i] + dp[i-3][j-i+1] - dp[i-3][j-i+2] + ... + dp[i-3][j-i+k] + dp[i-3][j-i+k+1] - dp[i-4][j-i+k] + dp[i-4][j-i+k+1] - dp[i-4][j-i+k+2] + ... + dp[i-4][j-i+k+k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i] + dp[i-3][j-i+1] - dp[i-3][j-i+2] + ... + dp[i-3][j-i+k] + dp[i-3][j-i+k+1] - dp[i-4][j-i+k] + dp[i-4][j-i+k+1] - dp[i-4][j-i+k+2] + ... + dp[i-4][j-i+k+k] + dp[i-4][j-i+k+k+1] - dp[i-5][j-i+k+k] + dp[i-5][j-i+k+k+1] - dp[i-5][j-i+k+k+2] + ... + dp[i-5][j-i+k+k+k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return root.val == targetSum\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return root.val == targetSum\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        # 2. Create a pointer to the head of the list\n        # 3. Traverse the list and insert nodes into the dummy nodes\n        # 4. Insert the dummy nodes back into the original list\n        # 5. Return the head of the new list\n        \n        # 1. Create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # 2. Create a pointer to the head of the list\n        curr = head\n        \n        # 3. Traverse the list and insert nodes into the dummy nodes\n        while curr:\n            if curr.val < x:\n                dummy1.next = curr\n                dummy1 = dummy1.next\n            else:\n                dummy2.next = curr\n                dummy2 = dummy2.next\n            curr = curr.next\n        \n        # 4. Insert the dummy nodes back into the original list\n        dummy1.next = dummy2.next\n        dummy2.next = None\n        \n        # 5. Return the head of the new list\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        left = ListNode(0)\n        right = ListNode(0)\n        l = left\n        r = right\n        \n        while head:\n            if head.val < x:\n                l.next = head\n                l = l.next\n            else:\n                r.next = head\n                r = r.next\n            head = head.next\n        \n        l.next = right.next\n        r.next = None\n        \n        return left.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        # 2. Create two pointers\n        # 3. Traverse the list\n        # 4. If the value is less than x, add it to the left list\n        # 5. If the value is greater than or equal to x, add it to the right list\n        # 6. Connect the left list to the right list\n        # 7. Return the left list\n        \n        left = ListNode()\n        right = ListNode()\n        left_tail = left\n        right_tail = right\n        \n        while head:\n            if head.val < x:\n                left_tail.next = head\n                left_tail = left_tail.next\n            else:\n                right_tail.next = head\n                right_tail = right_tail.next\n            head = head.next\n        \n        left_tail.next = right.next\n        right_tail.next = None\n        \n        return left.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        # 2. Create a pointer to the head of the list\n        # 3. Iterate through the list\n        # 4. If the value is less than x, add it to the left list\n        # 5. If the value is greater than or equal to x, add it to the right list\n        # 6. Combine the left and right lists\n        # 7. Return the left list\n        \n        left = ListNode()\n        right = ListNode()\n        left_head = left\n        right_head = right\n        \n        while head:\n            if head.val < x:\n                left.next = head\n                left = left.next\n            else:\n                right.next = head\n                right = right.next\n            head = head.next\n        \n        left.next = right_head.next\n        right.next = None\n        \n        return left_head.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create 2 dummy nodes\n        # 2. Create 2 pointers\n        # 3. Traverse the list\n        # 4. If the node value is less than x, add it to the left list\n        # 5. If the node value is greater than or equal to x, add it to the right list\n        # 6. Connect the left list to the right list\n        # 7. Connect the left list to the right list\n        # 8. Return the left list\n        \n        left = ListNode()\n        right = ListNode()\n        left_tail = left\n        right_tail = right\n        \n        while head:\n            if head.val < x:\n                left_tail.next = head\n                left_tail = left_tail.next\n            else:\n                right_tail.next = head\n                right_tail = right_tail.next\n            head = head.next\n        \n        left_tail.next = right.next\n        right_tail.next = None\n        \n        return left.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        self.backtrack(nums, visited, [], res)\n        return res\n        \n    def backtrack(self, nums, visited, path, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            visited[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, visited, path, res)\n            visited[i] = False\n            path.pop()"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        self.backtrack(nums, visited, [], res)\n        return res\n        \n    def backtrack(self, nums, visited, path, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            visited[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, visited, path, res)\n            visited[i] = False\n            path.pop()"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        for i in range(len(nums)):\n            if nums.count(nums[i]) == 1:\n                return nums[i]\n\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        res = 0\n        for i in nums:\n            res ^= i\n        return res\n\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        res = 0\n        for i in nums:\n            res ^= i\n        return res"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2sum\n        # 2. XOR\n        # 3. set\n        # 4. dict\n        # 5. sort\n        # 6. math\n        # 7. bit manipulation\n        # 8. bit manipulation\n        # 9. bit manipulation\n        # 10. bit manipulation\n        # 11. bit manipulation\n        # 12. bit manipulation\n        # 13. bit manipulation\n        # 14. bit manipulation\n        # 15. bit manipulation\n        # 16. bit manipulation\n        # 17. bit manipulation\n        # 18. bit manipulation\n        # 19. bit manipulation\n        # 20. bit manipulation\n        # 21. bit manipulation\n        # 22. bit manipulation\n        # 23. bit manipulation\n        # 24. bit manipulation\n        # 25. bit manipulation\n        # 26. bit manipulation\n        # 27. bit manipulation\n        # 28. bit manipulation\n        # 29. bit manipulation\n        # 30. bit manipulation\n        # 31. bit manipulation\n        # 32. bit manipulation\n        # 33. bit manipulation\n        # 34. bit manipulation\n        # 35. bit manipulation\n        # 36. bit manipulation\n        # 37. bit manipulation\n        # 38. bit manipulation\n        # 39. bit manipulation\n        # 40. bit manipulation\n        # 41. bit manipulation\n        # 42. bit manipulation\n        # 43. bit manipulation\n        # 44. bit manipulation\n        # 45. bit manipulation\n        # 46. bit manipulation\n        # 47. bit manipulation\n        # 48. bit manipulation\n        # 49. bit manipulation\n        # 50. bit manipulation\n        # 51. bit manipulation\n        # 52. bit manipulation\n        # 53. bit manipulation\n        # 54. bit manipulation\n        # 55. bit manipulation\n        # 56. bit manipulation\n        # 57. bit manipulation\n        # 58. bit manipulation\n        # 59. bit manipulation\n        # 60. bit manipulation\n        # 61. bit manipulation\n        # 62. bit manipulation\n        # 63. bit manipulation\n        # 64. bit manipulation\n        # 65. bit manipulation\n        # 66. bit manipulation\n        # 67. bit manipulation\n        # 68. bit manipulation\n        # 69. bit manipulation\n        # 70. bit manipulation\n        # 71. bit manipulation\n        # 72. bit manipulation\n        # 73. bit manipulation\n        # 74. bit manipulation\n        # 75. bit manipulation\n        # 76. bit manipulation\n        # 77. bit manipulation\n        # 78. bit manipulation\n        # 79. bit manipulation\n        # 80. bit manipulation\n        # 81. bit manipulation\n        # 82. bit manipulation\n        # 83. bit manipulation\n        # 84. bit manipulation\n        # 85. bit manipulation\n        # 86. bit manipulation\n        # 87. bit manipulation\n        # 88. bit manipulation\n        # 89. bit manipulation\n        # 90. bit manipulation\n        # 91. bit manipulation\n        # 92. bit manipulation\n        # 93. bit manipulation\n        # 94. bit manipulation\n        # 95. bit manipulation\n        # 96. bit manipulation\n        # 97. bit manipulation\n        # 98. bit manipulation\n        # 99. bit manipulation\n        # 100. bit manipulation\n        # 101. bit manipulation\n        # 102. bit manipulation\n        # 103. bit manipulation\n        # 104. bit"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR\n        # 2. XOR of a number with itself is 0\n        # 3. XOR of a number with 0 is the number itself\n        # 4. XOR of a number with 0 is the number itself\n        # 5. XOR of a number with itself is 0\n        # 6. XOR of a number with 0 is the number itself\n        # 7. XOR of a number with 0 is the number itself\n        # 8. XOR of a number with itself is 0\n        # 9. XOR of a number with 0 is the number itself\n        # 10. XOR of a number with 0 is the number itself\n        # 11. XOR of a number with itself is 0\n        # 12. XOR of a number with 0 is the number itself\n        # 13. XOR of a number with 0 is the number itself\n        # 14. XOR of a number with itself is 0\n        # 15. XOR of a number with 0 is the number itself\n        # 16. XOR of a number with 0 is the number itself\n        # 17. XOR of a number with 0 is the number itself\n        # 18. XOR of a number with itself is 0\n        # 19. XOR of a number with 0 is the number itself\n        # 20. XOR of a number with 0 is the number itself\n        # 21. XOR of a number with 0 is the number itself\n        # 22. XOR of a number with 0 is the number itself\n        # 23. XOR of a number with 0 is the number itself\n        # 24. XOR of a number with 0 is the number itself\n        # 25. XOR of a number with 0 is the number itself\n        # 26. XOR of a number with 0 is the number itself\n        # 27. XOR of a number with 0 is the number itself\n        # 28. XOR of a number with 0 is the number itself\n        # 29. XOR of a number with 0 is the number itself\n        # 30. XOR of a number with 0 is the number itself\n        # 31. XOR of a number with 0 is the number itself\n        # 32. XOR of a number with 0 is the number itself\n        # 33. XOR of a number with 0 is the number itself\n        # 34. XOR of a number with 0 is the number itself\n        # 35. XOR of a number with 0 is the number itself\n        # 36. XOR of a number with 0 is the number itself\n        # 37. XOR of a number with 0 is the number itself\n        # 38. XOR of a number with 0 is the number itself\n        # 39. XOR of a number with 0 is the number itself\n        # 40. XOR of a number with 0 is the number itself\n        # 41. XOR of a number with 0 is the number itself\n        # 42. XOR of a number with 0 is the number itself\n        # 43. XOR of a number with 0 is the number itself\n        # 44. XOR of a number with 0 is the number itself\n        # 45. XOR of a number with 0 is the number itself\n        # 46. XOR of a number with 0 is the number itself\n        # 47. XOR of a number with 0 is the number itself\n        # 48. XOR of a number with 0 is the number itself\n        # 49. XOR of a number with 0 is the number itself\n        # 50. XOR of a number with 0 is the number itself\n        # 51. XOR of a number with 0 is the number itself\n        # 52. XOR of a number with 0 is the number itself\n        # 53. XOR of a number with 0 is the number itself\n        # 54. XOR of a number with 0 is the number itself\n        # 55. XOR of a number with 0 is the number itself\n        # 56. XOR of a"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR\n        # 2. XOR of a number with itself is 0\n        # 3. XOR of a number with 0 is the number itself\n        # 4. XOR of a number with 0 is the number itself\n        # 5. XOR of a number with itself is 0\n        # 6. XOR of a number with 0 is the number itself\n        # 7. XOR of a number with 0 is the number itself\n        # 8. XOR of a number with itself is 0\n        # 9. XOR of a number with 0 is the number itself\n        # 10. XOR of a number with 0 is the number itself\n        # 11. XOR of a number with itself is 0\n        # 12. XOR of a number with 0 is the number itself\n        # 13. XOR of a number with 0 is the number itself\n        # 14. XOR of a number with itself is 0\n        # 15. XOR of a number with 0 is the number itself\n        # 16. XOR of a number with 0 is the number itself\n        # 17. XOR of a number with itself is 0\n        # 18. XOR of a number with 0 is the number itself\n        # 19. XOR of a number with 0 is the number itself\n        # 20. XOR of a number with 0 is the number itself\n        # 21. XOR of a number with itself is 0\n        # 22. XOR of a number with 0 is the number itself\n        # 23. XOR of a number with 0 is the number itself\n        # 24. XOR of a number with itself is 0\n        # 25. XOR of a number with 0 is the number itself\n        # 26. XOR of a number with 0 is the number itself\n        # 27. XOR of a number with itself is 0\n        # 28. XOR of a number with 0 is the number itself\n        # 29. XOR of a number with 0 is the number itself\n        # 30. XOR of a number with 0 is the number itself\n        # 31. XOR of a number with itself is 0\n        # 32. XOR of a number with 0 is the number itself\n        # 33. XOR of a number with 0 is the number itself\n        # 34. XOR of a number with itself is 0\n        # 35. XOR of a number with 0 is the number itself\n        # 36. XOR of a number with 0 is the number itself\n        # 37. XOR of a number with itself is 0\n        # 38. XOR of a number with 0 is the number itself\n        # 39. XOR of a number with 0 is the number itself\n        # 40. XOR of a number with 0 is the number itself\n        # 41. XOR of a number with itself is 0\n        # 42. XOR of a number with 0 is the number itself\n        # 43. XOR of a number with 0 is the number itself\n        # 44. XOR of a number with itself is 0\n        # 45. XOR of a number with 0 is the number itself\n        # 46. XOR of a number with 0 is the number itself\n        # 47. XOR of a number with itself is 0\n        # 48. XOR of a number with 0 is the number itself\n        # 49. XOR of a number with 0 is the number itself\n        # 50. XOR of a number with 0 is the number itself\n        # 51. XOR of a number with itself is 0\n        # 52. XOR of a number with 0 is the number itself\n        # 53. XOR of a number with 0 is the number itself\n        # 54. XOR of a number with itself is 0\n        # 55. XOR of a number with 0 is the number itself\n        # 56. XOR of a number with 0 is the number itself\n        # 57. XOR of a number with itself"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Use a hashmap to store the frequency of each element in the array\n        ## 2. Iterate through the array and check if the frequency of the element is 1\n        ## 3. If the frequency is 1, return the element\n        ## 4. If the frequency is 0, increment the frequency by 1\n        ## 5. If the frequency is 2, decrement the frequency by 1\n        ## 6. If the frequency is 3, increment the frequency by 1\n        ## 7. If the frequency is 4, decrement the frequency by 1\n        ## 8. If the frequency is 5, increment the frequency by 1\n        ## 9. If the frequency is 6, decrement the frequency by 1\n        ## 10. If the frequency is 7, increment the frequency by 1\n        ## 11. If the frequency is 8, decrement the frequency by 1\n        ## 12. If the frequency is 9, increment the frequency by 1\n        ## 13. If the frequency is 10, decrement the frequency by 1\n        ## 14. If the frequency is 11, increment the frequency by 1\n        ## 15. If the frequency is 12, decrement the frequency by 1\n        ## 16. If the frequency is 13, increment the frequency by 1\n        ## 17. If the frequency is 14, decrement the frequency by 1\n        ## 18. If the frequency is 15, increment the frequency by 1\n        ## 19. If the frequency is 16, decrement the frequency by 1\n        ## 20. If the frequency is 17, increment the frequency by 1\n        ## 21. If the frequency is 18, decrement the frequency by 1\n        ## 22. If the frequency is 19, increment the frequency by 1\n        ## 23. If the frequency is 20, decrement the frequency by 1\n        ## 24. If the frequency is 21, increment the frequency by 1\n        ## 25. If the frequency is 22, decrement the frequency by 1\n        ## 26. If the frequency is 23, increment the frequency by 1\n        ## 27. If the frequency is 24, decrement the frequency by 1\n        ## 28. If the frequency is 25, increment the frequency by 1\n        ## 29. If the frequency is 26, decrement the frequency by 1\n        ## 30. If the frequency is 27, increment the frequency by 1\n        ## 31. If the frequency is 28, decrement the frequency by 1\n        ## 32. If the frequency is 29, increment the frequency by 1\n        ## 33. If the frequency is 30, decrement the frequency by 1\n        ## 34. If the frequency is 31, increment the frequency by 1\n        ## 35. If the frequency is 32, decrement the frequency by 1\n        ## 36. If the frequency is 33, increment the frequency by 1\n        ## 37. If the frequency is 34, decrement the frequency by 1\n        ## 38. If the frequency is 35, increment the frequency by 1\n        ## 39. If the frequency is 36, decrement the frequency by 1\n        ## 40. If the frequency is 37, increment the frequency by 1\n        ## 41. If the frequency is 38, decrement the frequency by 1\n        ## 42. If the frequency is 39, increment the frequency by 1\n        ## 43. If the frequency is 40, decrement the frequency by 1\n        ## 44. If the frequency is 41, increment the frequency by 1\n        ## 45. If the frequency"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + grid[i][j]\n                    if j > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + grid[i][j])\n                    if k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + grid[i][j])\n                    if j > 0 and k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + grid[i][j])\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    res = 0\n                    for dj1, dj2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        new_j1, new_j2 = j1 + dj1, j2 + dj2\n                        if 0 <= new_j1 < n and 0 <= new_j2 < n:\n                            res = max(res, dp[i - 1][new_j1][new_j2])\n                    if grid[i][j1] == -1 or grid[i][j2] == -1:\n                        res = -float('inf')\n                    dp[i][j1][j2] = res + grid[i][j1] + grid[i][j2]\n        return max(dp[-1][-1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + grid[i][j]\n                    if j > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + grid[i][j])\n                    if k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + grid[i][j])\n                    if j > 0 and k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + grid[i][j])\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + grid[i][j]\n                    if j > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + grid[i][j])\n                    if k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + grid[i][j])\n                    if j > 0 and k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + grid[i][j])\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + grid[i][j]\n                    if j > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + grid[i][j])\n                    if k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + grid[i][j])\n                    if j > 0 and k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + grid[i][j])\n        return max(dp[n - 1][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0,0,0],[0,0,0],[0,0,0]]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        dp[0][2] = 1\n        for i in range(1,n+1):\n            dp[0][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % mod\n            dp[0][1] = (dp[0][0] + dp[0][2]) % mod\n            dp[0][2] = dp[0][0] % mod\n            dp[1][0] = (dp[1][0] + dp[1][1] + dp[1][2]) % mod\n            dp[1][1] = (dp[1][0] + dp[1][2]) % mod\n            dp[1][2] = dp[1][0] % mod\n            dp[2][0] = (dp[2][0] + dp[2][1] + dp[2][2]) % mod\n            dp[2][1] = (dp[2][0] + dp[2][2]) % mod\n            dp[2][2] = dp[2][0] % mod\n        return (dp[0][0] + dp[1][0] + dp[2][0]) % mod"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0]*3 for _ in range(2)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        dp[0][2] = 1\n        for i in range(1,n):\n            dp[1][0] = (dp[0][0] + dp[0][1] + dp[0][2])%mod\n            dp[1][1] = (dp[0][0] + dp[0][2])%mod\n            dp[1][2] = dp[0][1]%mod\n            dp[0] = dp[1]\n        return (dp[0][0] + dp[0][1] + dp[0][2])%mod"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0,0,0],[0,0,0]]\n        dp[0][0] = 1\n        dp[1][0] = 1\n        for i in range(1,n+1):\n            dp[0][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % mod\n            dp[0][1] = (dp[0][0] + dp[0][2]) % mod\n            dp[0][2] = dp[0][0] % mod\n            dp[1][0] = (dp[1][0] + dp[1][1] + dp[1][2]) % mod\n            dp[1][1] = (dp[1][0] + dp[1][2]) % mod\n            dp[1][2] = dp[1][0] % mod\n        return (dp[0][0] + dp[1][0]) % mod"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0,0,0],[0,0,0]]\n        dp[0][0] = 1\n        dp[1][0] = 1\n        for i in range(1,n+1):\n            dp[0][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % mod\n            dp[0][1] = (dp[0][0] + dp[0][2]) % mod\n            dp[0][2] = dp[0][0] % mod\n            dp[1][0] = (dp[1][0] + dp[1][1] + dp[1][2]) % mod\n            dp[1][1] = (dp[1][0] + dp[1][2]) % mod\n            dp[1][2] = dp[1][0] % mod\n        return (dp[0][0] + dp[1][0]) % mod"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0]*3 for _ in range(2)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        dp[0][2] = 1\n        for i in range(1, n):\n            dp[1][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % mod\n            dp[1][1] = (dp[0][0] + dp[0][2]) % mod\n            dp[1][2] = dp[0][1] % mod\n            dp[0][0] = dp[1][0] % mod\n            dp[0][1] = dp[1][1] % mod\n            dp[0][2] = dp[1][2] % mod\n        return (dp[0][0] + dp[0][1] + dp[0][2]) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # left = 0\n        # right = len(nums) - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     elif nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left\n\n        # linear search\n        for i in range(len(nums)):\n            if nums[i] >= target:\n                return i\n        return len(nums)"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # left = 0\n        # right = len(nums) - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     elif nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left\n        \n        # linear search\n        for i in range(len(nums)):\n            if nums[i] >= target:\n                return i\n        return len(nums)"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if target is not found, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # 1. find the"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1] + i:\n        #         nums[i] = nums[i - 1] + i\n        #     else:\n        #         nums[i] = nums[i - 1]\n        # return True\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1] + i:\n        #         nums[i] = nums[i - 1] + i\n        #     else:\n        #         nums[i] = nums[i - 1]\n        # return True\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1] + i:\n        #         nums[i] = nums[i - 1] + i\n        #     else:\n        #         nums[i] = nums[i - 1]\n        # return True\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1] + i:\n        #         nums[i] = nums[i - 1] + i\n        #     else:\n        #         nums[i] = nums[i - 1]\n        # return True\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1] + i:\n        #         nums[i] = nums[i - 1] + i\n        #     else:\n        #         nums[i] = nums[i - 1]\n        # return True\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reachable = 0\n        for i, num in enumerate(nums):\n            if i > max_reachable:\n                return False\n            max_reachable = max(max_reachable, i + num)\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0 for i in range(n)] for j in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1,n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n        \n        return grid[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1,n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1,n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211\"\n        \n        if n == 13:\n            return \"13112122212313213211\"\n        \n        if n == 14:\n            return \"11131221123113122211\"\n        \n        if n == 15:\n            return \"3113112221231131122211\"\n        \n        if n == 16:\n            return \"132113111231131122211\"\n        \n        if n == 17:\n            return \"11131221133112132133211\"\n        \n        if n == 18:\n            return \"311311222123213211\"\n        \n        if n == 19:\n            return \"132113111231131122211\"\n        \n        if n == 20:\n            return \"11131221123113122211\"\n        \n        if n == 21:\n            return \"3113112221231131122211\"\n        \n        if n == 22:\n            return \"132113111231131122211\"\n        \n        if n == 23:\n            return \"11131221133112132133211\"\n        \n        if n == 24:\n            return \"311311222123213211\"\n        \n        if n == 25:\n            return \"132113111231131122211\"\n        \n        if n == 26:\n            return \"11131221123113122211\"\n        \n        if n == 27:\n            return \"3113112221231131122211\"\n        \n        if n == 28:\n            return \"132113111231131122211\"\n        \n        if n == 29:\n            return \"11131221133112132133211\"\n        \n        if n == 30:\n            return \"311311222123213211\"\n        \n        if n == 31:\n            return \"132113111231131122211\"\n        \n        if n == 32:\n            return \"11131221123113122211\"\n        \n        if n == 33:\n            return \"3113112221231"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211\"\n        \n        if n == 13:\n            return \"13112122212321322211\"\n        \n        if n == 14:\n            return \"11131221131212312211\"\n        \n        if n == 15:\n            return \"311311222123113112211\"\n        \n        if n == 16:\n            return \"13211311123113112211\"\n        \n        if n == 17:\n            return \"111312211331121321332211\"\n        \n        if n == 18:\n            return \"31131122212321322211\"\n        \n        if n == 19:\n            return \"13211311123113112211\"\n        \n        if n == 20:\n            return \"11131221131212312211\"\n        \n        if n == 21:\n            return \"311311222123113112211\"\n        \n        if n == 22:\n            return \"13211311123113112211\"\n        \n        if n == 23:\n            return \"111312211331121321332211\"\n        \n        if n == 24:\n            return \"31131122212321322211\"\n        \n        if n == 25:\n            return \"13211311123113112211\"\n        \n        if n == 26:\n            return \"111312211331121321332211\"\n        \n        if n == 27:\n            return \"31131122212321322211\"\n        \n        if n == 28:\n            return \"13211311123113112211\"\n        \n        if n == 29:\n            return \"111312211331121321332211\"\n        \n        if n == 30:\n            return \"31131122212321322211\"\n        \n        if n == 31:\n            return \"13211311123113112211\"\n        \n        if n == 32:\n            return \"111312211331121321332211\"\n        \n        if n == 33:\n            return \"311"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211\"\n        \n        if n == 13:\n            return \"13112122212321322211\"\n        \n        if n == 14:\n            return \"11131221131212312211\"\n        \n        if n == 15:\n            return \"3113112221231131122211\"\n        \n        if n == 16:\n            return \"132113111231131122211\"\n        \n        if n == 17:\n            return \"111312211331121321332211\"\n        \n        if n == 18:\n            return \"31131122212321322211\"\n        \n        if n == 19:\n            return \"132113111231131122211\"\n        \n        if n == 20:\n            return \"11131221131212312211\"\n        \n        if n == 21:\n            return \"31131122212321322211\"\n        \n        if n == 22:\n            return \"132113111231131122211\"\n        \n        if n == 23:\n            return \"111312211331121321332211\"\n        \n        if n == 24:\n            return \"31131122212321322211\"\n        \n        if n == 25:\n            return \"132113111231131122211\"\n        \n        if n == 26:\n            return \"111312211331121321332211\"\n        \n        if n == 27:\n            return \"31131122212321322211\"\n        \n        if n == 28:\n            return \"132113111231131122211\"\n        \n        if n == 29:\n            return \"111312211331121321332211\"\n        \n        if n == 30:\n            return \"31131122212321322211\"\n        \n        if n == 31:\n            return \"132113111231131122211\"\n        \n        if n == 32:\n            return \"111312211331121321332211\"\n        \n        if n == 33:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211\"\n        \n        if n == 13:\n            return \"13112122212313213211\"\n        \n        if n == 14:\n            return \"11131221123113122211\"\n        \n        if n == 15:\n            return \"3113112221231131122211\"\n        \n        if n == 16:\n            return \"132113111231131122211\"\n        \n        if n == 17:\n            return \"11131221133112132133211\"\n        \n        if n == 18:\n            return \"311311222123213211\"\n        \n        if n == 19:\n            return \"132113111231131122211\"\n        \n        if n == 20:\n            return \"11131221123113122211\"\n        \n        if n == 21:\n            return \"3113112221231131122211\"\n        \n        if n == 22:\n            return \"132113111231131122211\"\n        \n        if n == 23:\n            return \"11131221133112132133211\"\n        \n        if n == 24:\n            return \"311311222123213211\"\n        \n        if n == 25:\n            return \"132113111231131122211\"\n        \n        if n == 26:\n            return \"11131221123113122211\"\n        \n        if n == 27:\n            return \"3113112221231131122211\"\n        \n        if n == 28:\n            return \"132113111231131122211\"\n        \n        if n == 29:\n            return \"11131221133112132133211\"\n        \n        if n == 30:\n            return \"311311222123213211\"\n        \n        if n == 31:\n            return \"132113111231131122211\"\n        \n        if n == 32:\n            return \"11131221123113122211\"\n        \n        if n == 33:\n            return \"3113112221231"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211\"\n        \n        if n == 13:\n            return \"13112122212313213211\"\n        \n        if n == 14:\n            return \"11131221123113122211\"\n        \n        if n == 15:\n            return \"3113112221231131122211\"\n        \n        if n == 16:\n            return \"132113111231131122211\"\n        \n        if n == 17:\n            return \"11131221133112132133211\"\n        \n        if n == 18:\n            return \"311311222123213211\"\n        \n        if n == 19:\n            return \"132113111231131122211\"\n        \n        if n == 20:\n            return \"11131221123113122211\"\n        \n        if n == 21:\n            return \"3113112221231131122211\"\n        \n        if n == 22:\n            return \"132113111231131122211\"\n        \n        if n == 23:\n            return \"11131221133112132133211\"\n        \n        if n == 24:\n            return \"311311222123213211\"\n        \n        if n == 25:\n            return \"132113111231131122211\"\n        \n        if n == 26:\n            return \"11131221123113122211\"\n        \n        if n == 27:\n            return \"3113112221231131122211\"\n        \n        if n == 28:\n            return \"132113111231131122211\"\n        \n        if n == 29:\n            return \"11131221133112132133211\"\n        \n        if n == 30:\n            return \"311311222123213211\"\n        \n        if n == 31:\n            return \"132113111231131122211\"\n        \n        if n == 32:\n            return \"11131221123113122211\"\n        \n        if n == 33:\n            return \"3113112221231"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isPossible(nums, k, mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > mid:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isPossible(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isPossible(nums, k, mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num <= mid:\n                    currSum += num\n                else:\n                    count += 1\n                    currSum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isPossible(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if nums is empty, return -1\n        if not nums:\n            return -1\n        \n        # if nums has only one element, return the index of target if it is in nums, or -1 if it is not in nums\n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        # if nums has more than one element, binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        \n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        # if nums is empty, return -1\n        # if nums has only one element, return -1\n        \n        # edge cases\n        if len(nums) == 0:\n            return -1\n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        # if nums is empty, return -1\n        # if nums has only one element, return -1\n        # if nums is sorted in ascending order, return -1\n        \n        # edge cases\n        if len(nums) == 0:\n            return -1\n        if len(nums) == 1:\n            return -1\n        if len(nums) == 2:\n            if nums[0] == target:\n                return 0\n            if nums[1] == target:\n                return 1\n            return -1\n        if nums[0] < nums[-1]:\n            return -1\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums)-1\n        while l<=r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid]<nums[r]:\n                if nums[mid]<target<=nums[r]:\n                    l = mid+1\n                else:\n                    r = mid-1\n            else:\n                if nums[l]<=target<nums[mid]:\n                    r = mid-1\n                else:\n                    l = mid+1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map the next available digit\n                for letter in phone[next_digits[0]]:\n                    # append the letter to the combination\n                    # and proceed to the next digits\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits, phone):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], phone)\n        \n        output = []\n        backtrack(\"\", digits, phone)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits):\n            # base case\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits, phone):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], phone)\n        \n        output = []\n        backtrack(\"\", digits, phone)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits, phone):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], phone)\n        \n        output = []\n        backtrack(\"\", digits, phone)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if target - candidates[i] < 0:\n                    break\n                curr.append(candidates[i])\n                backtrack(i, curr, target - candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            if i >= len(candidates) or target < 0:\n                return\n            dfs(i, curr, target - candidates[i])\n            dfs(i + 1, curr + [candidates[i]], target)\n        dfs(0, [], target)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            if i >= len(candidates) or target < 0:\n                return\n            dfs(i, curr, target - candidates[i])\n            curr.append(candidates[i])\n            dfs(i, curr, target)\n            curr.pop()\n            dfs(i + 1, curr, target)\n        dfs(0, [], target)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if target - candidates[i] < 0:\n                    break\n                curr.append(candidates[i])\n                backtrack(i, curr, target - candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(candidates, target, start, path, res):\n            if target == 0:\n                res.append(path[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                path.append(candidates[i])\n                backtrack(candidates, target - candidates[i], i, path, res)\n                path.pop()\n        \n        res = []\n        candidates.sort()\n        backtrack(candidates, target, 0, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert n to int\n        # 2. find the closest palindrome\n        # 3. convert the closest palindrome to str\n        # 4. convert the closest palindrome to int\n        # 5. return the closest palindrome\n        \n        # 1. convert n to int\n        n = int(n)\n        \n        # 2. find the closest palindrome\n        closest = self.findClosestPalindrome(n)\n        \n        # 3. convert the closest palindrome to str\n        closest = str(closest)\n        \n        # 4. convert the closest palindrome to int\n        closest = int(closest)\n        \n        # 5. return the closest palindrome\n        return closest\n        \n    def findClosestPalindrome(self, n):\n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is n, return the closest palindrome\n        # 3. else, return the closest palindrome\n        \n        # 1. find the closest palindrome\n        closest = n\n        \n        # 2. if the closest palindrome is n, return the closest palindrome\n        if closest == n:\n            return closest\n        \n        # 3. else, return the closest palindrome\n        return closest"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert n to int\n        # 2. find the closest palindrome\n        # 3. convert the closest palindrome to str\n        # 4. convert the closest palindrome to int\n        # 5. return the closest palindrome\n        \n        # 1. convert n to int\n        n = int(n)\n        \n        # 2. find the closest palindrome\n        closest = self.findClosestPalindrome(n)\n        \n        # 3. convert the closest palindrome to str\n        closest = str(closest)\n        \n        # 4. convert the closest palindrome to int\n        closest = int(closest)\n        \n        # 5. return the closest palindrome\n        return closest\n        \n    def findClosestPalindrome(self, n):\n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is n, return the closest palindrome\n        # 3. else, return the closest palindrome\n        \n        # 1. find the closest palindrome\n        closest = n\n        \n        # 2. if the closest palindrome is n, return the closest palindrome\n        if closest == n:\n            return closest\n        \n        # 3. else, return the closest palindrome\n        return closest"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert n to int\n        # 2. convert n to list\n        # 3. find the nearest palindrome\n        # 4. convert n to str\n        # 5. return n\n        \n        # 1. convert n to int\n        n = int(n)\n        \n        # 2. convert n to list\n        n_list = list(str(n))\n        \n        # 3. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome(n_list)\n        \n        # 4. convert n to str\n        nearest_palindrome = str(nearest_palindrome)\n        \n        # 5. return n\n        return nearest_palindrome\n        \n    def find_nearest_palindrome(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper_helper(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper_helper_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper_helper_helper(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper_helper_helper_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper_helper_helper_helper(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper_helper_helper_helper_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper_helper_helper_helper_helper(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper_helper_helper_helper_helper_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper_helper_helper_helper_helper_helper(self, n_list):\n        # 1. find the nearest palindrome\n        # 2. return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        nearest_palindrome = self.find_nearest_palindrome_helper_helper_helper_helper_helper_helper_helper(n_list)\n        \n        # 2. return the nearest palindrome\n        return nearest_palindrome\n        \n    def find_nearest_palindrome_helper_helper_helper_helper_helper_helper_helper("}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the number of digits\n        # 2. if the number of digits is 1, return the number minus 1\n        # 3. if the number of digits is 2, return the number minus 1\n        # 4. if the number of digits is 3, return the number minus 2\n        # 5. if the number of digits is 4, return the number minus 2\n        # 6. if the number of digits is 5, return the number minus 2\n        # 7. if the number of digits is 6, return the number minus 2\n        # 8. if the number of digits is 7, return the number minus 2\n        # 9. if the number of digits is 8, return the number minus 2\n        # 10. if the number of digits is 9, return the number minus 2\n        # 11. if the number of digits is 10, return the number minus 2\n        # 12. if the number of digits is 11, return the number minus 2\n        # 13. if the number of digits is 12, return the number minus 2\n        # 14. if the number of digits is 13, return the number minus 2\n        # 15. if the number of digits is 14, return the number minus 2\n        # 16. if the number of digits is 15, return the number minus 2\n        # 17. if the number of digits is 16, return the number minus 2\n        # 18. if the number of digits is 17, return the number minus 2\n        # 19. if the number of digits is 18, return the number minus 2\n        # 20. if the number of digits is 19, return the number minus 2\n        # 21. if the number of digits is 20, return the number minus 2\n        # 22. if the number of digits is 21, return the number minus 2\n        # 23. if the number of digits is 22, return the number minus 2\n        # 24. if the number of digits is 23, return the number minus 2\n        # 25. if the number of digits is 24, return the number minus 2\n        # 26. if the number of digits is 25, return the number minus 2\n        # 27. if the number of digits is 26, return the number minus 2\n        # 28. if the number of digits is 27, return the number minus 2\n        # 29. if the number of digits is 28, return the number minus 2\n        # 30. if the number of digits is 29, return the number minus 2\n        # 31. if the number of digits is 30, return the number minus 2\n        # 32. if the number of digits is 31, return the number minus 2\n        # 33. if the number of digits is 32, return the number minus 2\n        # 34. if the number of digits is 33, return the number minus 2\n        # 35. if the number of digits is 34, return the number minus 2\n        # 36. if the number of digits is 35, return the number minus 2\n        # 37. if the number of digits is 36, return the number minus 2\n        # 38. if the number of digits is 37, return the number minus 2\n        # 39. if the number of digits is 38, return the number minus 2\n        # 40. if the number of digits is 39, return the number minus 2\n        # 41. if the number of digits is 40, return the number minus 2\n        # 42. if the number of digits is 41, return the number minus 2\n        # 43. if the number of digits is 42, return the number minus 2\n        # 44. if the number of digits is 43, return the number minus"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is 0, return 10\n        # 3. If the nearest palindrome is n, return n-1\n        # 4. If the nearest palindrome is n+1, return n+2\n        # 5. If the nearest palindrome is n-1, return n-2\n        # 6. If the nearest palindrome is n+2, return n+1\n        # 7. If the nearest palindrome is n-2, return n-1\n        # 8. If the nearest palindrome is n+3, return n+2\n        # 9. If the nearest palindrome is n-3, return n-2\n        # 10. If the nearest palindrome is n+4, return n+3\n        # 11. If the nearest palindrome is n-4, return n-3\n        # 12. If the nearest palindrome is n+5, return n+4\n        # 13. If the nearest palindrome is n-5, return n-4\n        # 14. If the nearest palindrome is n+6, return n+5\n        # 15. If the nearest palindrome is n-6, return n-5\n        # 16. If the nearest palindrome is n+7, return n+6\n        # 17. If the nearest palindrome is n-7, return n-6\n        # 18. If the nearest palindrome is n+8, return n+7\n        # 19. If the nearest palindrome is n-8, return n-7\n        # 20. If the nearest palindrome is n+9, return n+8\n        # 21. If the nearest palindrome is n-9, return n-8\n        # 22. If the nearest palindrome is n+10, return n+9\n        # 23. If the nearest palindrome is n-10, return n-9\n        # 24. If the nearest palindrome is n+11, return n+10\n        # 25. If the nearest palindrome is n-11, return n-10\n        # 26. If the nearest palindrome is n+12, return n+11\n        # 27. If the nearest palindrome is n-12, return n-11\n        # 28. If the nearest palindrome is n+13, return n+12\n        # 29. If the nearest palindrome is n-13, return n-12\n        # 30. If the nearest palindrome is n+14, return n+13\n        # 31. If the nearest palindrome is n-14, return n-13\n        # 32. If the nearest palindrome is n+15, return n+14\n        # 33. If the nearest palindrome is n-15, return n-14\n        # 34. If the nearest palindrome is n+16, return n+15\n        # 35. If the nearest palindrome is n-16, return n-15\n        # 36. If the nearest palindrome is n+17, return n+16\n        # 37. If the nearest palindrome is n-17, return n-16\n        # 38. If the nearest palindrome is n+18, return n+17\n        # 39. If the nearest palindrome is n-18, return n-17\n        # 40. If the nearest palindrome is n+19, return n+18\n        # 41. If the nearest palindrome is n-19, return n-18\n        # 42. If the nearest palindrome is n+20, return n+19\n        # 43. If the nearest palindrome is n-20, return n-19\n        # 44. If the nearest palindrome is n+21, return n+20\n        # 45. If the nearest palindrome is n-21, return n-20\n        # 46. If the nearest"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        left, right = 0, n-1\n        top, bottom = 0, n-1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        count = 1\n        row_start = 0\n        col_start = 0\n        row_end = n-1\n        col_end = n-1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        count = 1\n        row_start = 0\n        col_start = 0\n        row_end = n-1\n        col_end = n-1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = count\n                count += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = count\n                count += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = count\n                    count += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = count\n                    count += 1\n                col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return rev * sign"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return rev * sign"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return rev * sign"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return rev * sign"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n            \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n            \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n\n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n\n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            temp_max = max_prod\n            max_prod = max(nums[i], max(max_prod * nums[i], min_prod * nums[i]))\n            min_prod = min(nums[i], min(temp_max * nums[i], min_prod * nums[i]))\n            result = max(result, max_prod)\n            \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        stone_set = list(stone_set)\n        stone_set.sort()\n        stone_set = stone_set[1:]\n        stone_set.append(stones[-1])\n        stone_set.append(stones[-1] + 1)\n        stone_set.append(stones[-1] + 2)\n        stone_set.append(stones[-1] + 3)\n        stone_set.append(stones[-1] + 4)\n        stone_set.append(stones[-1] + 5)\n        stone_set.append(stones[-1] + 6)\n        stone_set.append(stones[-1] + 7)\n        stone_set.append(stones[-1] + 8)\n        stone_set.append(stones[-1] + 9)\n        stone_set.append(stones[-1] + 10)\n        stone_set.append(stones[-1] + 11)\n        stone_set.append(stones[-1] + 12)\n        stone_set.append(stones[-1] + 13)\n        stone_set.append(stones[-1] + 14)\n        stone_set.append(stones[-1] + 15)\n        stone_set.append(stones[-1] + 16)\n        stone_set.append(stones[-1] + 17)\n        stone_set.append(stones[-1] + 18)\n        stone_set.append(stones[-1] + 19)\n        stone_set.append(stones[-1] + 20)\n        stone_set.append(stones[-1] + 21)\n        stone_set.append(stones[-1] + 22)\n        stone_set.append(stones[-1] + 23)\n        stone_set.append(stones[-1] + 24)\n        stone_set.append(stones[-1] + 25)\n        stone_set.append(stones[-1] + 26)\n        stone_set.append(stones[-1] + 27)\n        stone_set.append(stones[-1] + 28)\n        stone_set.append(stones[-1] + 29)\n        stone_set.append(stones[-1] + 30)\n        stone_set.append(stones[-1] + 31)\n        stone_set.append(stones[-1] + 32)\n        stone_set.append(stones[-1] + 33)\n        stone_set.append(stones[-1] + 34)\n        stone_set.append(stones[-1] + 35)\n        stone_set.append(stones[-1] + 36)\n        stone_set.append(stones[-1] + 37)\n        stone_set.append(stones[-1] + 38)\n        stone_set.append(stones[-1] + 39)\n        stone_set.append(stones[-1] + 40)\n        stone_set.append(stones[-1] + 41)\n        stone_set.append(stones[-1] + 42)\n        stone_set.append(stones[-1] + 43)\n        stone_set.append(stones[-1] + 44)\n        stone_set.append(stones[-1] + 45)\n        stone_set.append(stones[-1] + 46)\n        stone_set.append(stones[-1] + 47)\n        stone_set.append(stones[-1] + 48)\n        stone_set.append(stones[-1] + 49)\n        stone_set.append(stones[-1] + 50)\n        stone_set.append(stones[-1] + 51)\n        stone_set.append(stones[-1] + 52)\n        stone_set.append(stones[-1] + 53)\n        stone_set.append(stones[-1] + 54)\n        stone_set.append(stones[-1] + 55)\n        stone_set.append(stones[-1] + 56)\n        stone"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        stone_set = list(stone_set)\n        stone_set.sort()\n        stone_set.append(stones[-1]+1)\n        stone_set.append(stones[-1]+2)\n        stone_set.append(stones[-1]+3)\n        stone_set.append(stones[-1]+4)\n        stone_set.append(stones[-1]+5)\n        stone_set.append(stones[-1]+6)\n        stone_set.append(stones[-1]+7)\n        stone_set.append(stones[-1]+8)\n        stone_set.append(stones[-1]+9)\n        stone_set.append(stones[-1]+10)\n        stone_set.append(stones[-1]+11)\n        stone_set.append(stones[-1]+12)\n        stone_set.append(stones[-1]+13)\n        stone_set.append(stones[-1]+14)\n        stone_set.append(stones[-1]+15)\n        stone_set.append(stones[-1]+16)\n        stone_set.append(stones[-1]+17)\n        stone_set.append(stones[-1]+18)\n        stone_set.append(stones[-1]+19)\n        stone_set.append(stones[-1]+20)\n        stone_set.append(stones[-1]+21)\n        stone_set.append(stones[-1]+22)\n        stone_set.append(stones[-1]+23)\n        stone_set.append(stones[-1]+24)\n        stone_set.append(stones[-1]+25)\n        stone_set.append(stones[-1]+26)\n        stone_set.append(stones[-1]+27)\n        stone_set.append(stones[-1]+28)\n        stone_set.append(stones[-1]+29)\n        stone_set.append(stones[-1]+30)\n        stone_set.append(stones[-1]+31)\n        stone_set.append(stones[-1]+32)\n        stone_set.append(stones[-1]+33)\n        stone_set.append(stones[-1]+34)\n        stone_set.append(stones[-1]+35)\n        stone_set.append(stones[-1]+36)\n        stone_set.append(stones[-1]+37)\n        stone_set.append(stones[-1]+38)\n        stone_set.append(stones[-1]+39)\n        stone_set.append(stones[-1]+40)\n        stone_set.append(stones[-1]+41)\n        stone_set.append(stones[-1]+42)\n        stone_set.append(stones[-1]+43)\n        stone_set.append(stones[-1]+44)\n        stone_set.append(stones[-1]+45)\n        stone_set.append(stones[-1]+46)\n        stone_set.append(stones[-1]+47)\n        stone_set.append(stones[-1]+48)\n        stone_set.append(stones[-1]+49)\n        stone_set.append(stones[-1]+50)\n        stone_set.append(stones[-1]+51)\n        stone_set.append(stones[-1]+52)\n        stone_set.append(stones[-1]+53)\n        stone_set.append(stones[-1]+54)\n        stone_set.append(stones[-1]+55)\n        stone_set.append(stones[-1]+56)\n        stone_set.append(stones[-1]+57)\n        stone_set.append(stones[-"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        stone_set = list(stone_set)\n        stone_set.sort()\n        stone_set.append(stones[-1]+1)\n        stone_set.append(stones[-1]+2)\n        stone_set.append(stones[-1]+3)\n        stone_set.append(stones[-1]+4)\n        stone_set.append(stones[-1]+5)\n        stone_set.append(stones[-1]+6)\n        stone_set.append(stones[-1]+7)\n        stone_set.append(stones[-1]+8)\n        stone_set.append(stones[-1]+9)\n        stone_set.append(stones[-1]+10)\n        stone_set.append(stones[-1]+11)\n        stone_set.append(stones[-1]+12)\n        stone_set.append(stones[-1]+13)\n        stone_set.append(stones[-1]+14)\n        stone_set.append(stones[-1]+15)\n        stone_set.append(stones[-1]+16)\n        stone_set.append(stones[-1]+17)\n        stone_set.append(stones[-1]+18)\n        stone_set.append(stones[-1]+19)\n        stone_set.append(stones[-1]+20)\n        stone_set.append(stones[-1]+21)\n        stone_set.append(stones[-1]+22)\n        stone_set.append(stones[-1]+23)\n        stone_set.append(stones[-1]+24)\n        stone_set.append(stones[-1]+25)\n        stone_set.append(stones[-1]+26)\n        stone_set.append(stones[-1]+27)\n        stone_set.append(stones[-1]+28)\n        stone_set.append(stones[-1]+29)\n        stone_set.append(stones[-1]+30)\n        stone_set.append(stones[-1]+31)\n        stone_set.append(stones[-1]+32)\n        stone_set.append(stones[-1]+33)\n        stone_set.append(stones[-1]+34)\n        stone_set.append(stones[-1]+35)\n        stone_set.append(stones[-1]+36)\n        stone_set.append(stones[-1]+37)\n        stone_set.append(stones[-1]+38)\n        stone_set.append(stones[-1]+39)\n        stone_set.append(stones[-1]+40)\n        stone_set.append(stones[-1]+41)\n        stone_set.append(stones[-1]+42)\n        stone_set.append(stones[-1]+43)\n        stone_set.append(stones[-1]+44)\n        stone_set.append(stones[-1]+45)\n        stone_set.append(stones[-1]+46)\n        stone_set.append(stones[-1]+47)\n        stone_set.append(stones[-1]+48)\n        stone_set.append(stones[-1]+49)\n        stone_set.append(stones[-1]+50)\n        stone_set.append(stones[-1]+51)\n        stone_set.append(stones[-1]+52)\n        stone_set.append(stones[-1]+53)\n        stone_set.append(stones[-1]+54)\n        stone_set.append(stones[-1]+55)\n        stone_set.append(stones[-1]+56)\n        stone_set.append(stones[-1]+57)\n        stone_set.append(stones[-"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        stone_set = list(stone_set)\n        stone_set.sort()\n        stone_set.append(stones[-1]+1)\n        stone_set.append(stones[-1]+2)\n        stone_set.append(stones[-1]+3)\n        stone_set.append(stones[-1]+4)\n        stone_set.append(stones[-1]+5)\n        stone_set.append(stones[-1]+6)\n        stone_set.append(stones[-1]+7)\n        stone_set.append(stones[-1]+8)\n        stone_set.append(stones[-1]+9)\n        stone_set.append(stones[-1]+10)\n        stone_set.append(stones[-1]+11)\n        stone_set.append(stones[-1]+12)\n        stone_set.append(stones[-1]+13)\n        stone_set.append(stones[-1]+14)\n        stone_set.append(stones[-1]+15)\n        stone_set.append(stones[-1]+16)\n        stone_set.append(stones[-1]+17)\n        stone_set.append(stones[-1]+18)\n        stone_set.append(stones[-1]+19)\n        stone_set.append(stones[-1]+20)\n        stone_set.append(stones[-1]+21)\n        stone_set.append(stones[-1]+22)\n        stone_set.append(stones[-1]+23)\n        stone_set.append(stones[-1]+24)\n        stone_set.append(stones[-1]+25)\n        stone_set.append(stones[-1]+26)\n        stone_set.append(stones[-1]+27)\n        stone_set.append(stones[-1]+28)\n        stone_set.append(stones[-1]+29)\n        stone_set.append(stones[-1]+30)\n        stone_set.append(stones[-1]+31)\n        stone_set.append(stones[-1]+32)\n        stone_set.append(stones[-1]+33)\n        stone_set.append(stones[-1]+34)\n        stone_set.append(stones[-1]+35)\n        stone_set.append(stones[-1]+36)\n        stone_set.append(stones[-1]+37)\n        stone_set.append(stones[-1]+38)\n        stone_set.append(stones[-1]+39)\n        stone_set.append(stones[-1]+40)\n        stone_set.append(stones[-1]+41)\n        stone_set.append(stones[-1]+42)\n        stone_set.append(stones[-1]+43)\n        stone_set.append(stones[-1]+44)\n        stone_set.append(stones[-1]+45)\n        stone_set.append(stones[-1]+46)\n        stone_set.append(stones[-1]+47)\n        stone_set.append(stones[-1]+48)\n        stone_set.append(stones[-1]+49)\n        stone_set.append(stones[-1]+50)\n        stone_set.append(stones[-1]+51)\n        stone_set.append(stones[-1]+52)\n        stone_set.append(stones[-1]+53)\n        stone_set.append(stones[-1]+54)\n        stone_set.append(stones[-1]+55)\n        stone_set.append(stones[-1]+56)\n        stone_set.append(stones[-1]+57)\n        stone_set.append(stones[-"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        stone_set = list(stone_set)\n        stone_set.sort()\n        stone_set.append(stones[-1]+1)\n        stone_set.append(stones[-1]+2)\n        stone_set.append(stones[-1]+3)\n        stone_set.append(stones[-1]+4)\n        stone_set.append(stones[-1]+5)\n        stone_set.append(stones[-1]+6)\n        stone_set.append(stones[-1]+7)\n        stone_set.append(stones[-1]+8)\n        stone_set.append(stones[-1]+9)\n        stone_set.append(stones[-1]+10)\n        stone_set.append(stones[-1]+11)\n        stone_set.append(stones[-1]+12)\n        stone_set.append(stones[-1]+13)\n        stone_set.append(stones[-1]+14)\n        stone_set.append(stones[-1]+15)\n        stone_set.append(stones[-1]+16)\n        stone_set.append(stones[-1]+17)\n        stone_set.append(stones[-1]+18)\n        stone_set.append(stones[-1]+19)\n        stone_set.append(stones[-1]+20)\n        stone_set.append(stones[-1]+21)\n        stone_set.append(stones[-1]+22)\n        stone_set.append(stones[-1]+23)\n        stone_set.append(stones[-1]+24)\n        stone_set.append(stones[-1]+25)\n        stone_set.append(stones[-1]+26)\n        stone_set.append(stones[-1]+27)\n        stone_set.append(stones[-1]+28)\n        stone_set.append(stones[-1]+29)\n        stone_set.append(stones[-1]+30)\n        stone_set.append(stones[-1]+31)\n        stone_set.append(stones[-1]+32)\n        stone_set.append(stones[-1]+33)\n        stone_set.append(stones[-1]+34)\n        stone_set.append(stones[-1]+35)\n        stone_set.append(stones[-1]+36)\n        stone_set.append(stones[-1]+37)\n        stone_set.append(stones[-1]+38)\n        stone_set.append(stones[-1]+39)\n        stone_set.append(stones[-1]+40)\n        stone_set.append(stones[-1]+41)\n        stone_set.append(stones[-1]+42)\n        stone_set.append(stones[-1]+43)\n        stone_set.append(stones[-1]+44)\n        stone_set.append(stones[-1]+45)\n        stone_set.append(stones[-1]+46)\n        stone_set.append(stones[-1]+47)\n        stone_set.append(stones[-1]+48)\n        stone_set.append(stones[-1]+49)\n        stone_set.append(stones[-1]+50)\n        stone_set.append(stones[-1]+51)\n        stone_set.append(stones[-1]+52)\n        stone_set.append(stones[-1]+53)\n        stone_set.append(stones[-1]+54)\n        stone_set.append(stones[-1]+55)\n        stone_set.append(stones[-1]+56)\n        stone_set.append(stones[-1]+57)\n        stone_set.append(stones[-"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        \n        # assign the rank to each score\n        for i, score in enumerate(score):\n            rank_dict[score] = i + 1\n        \n        # assign the rank to each score\n        for i, score in enumerate(score):\n            if i == 0:\n                score_rank = \"Gold Medal\"\n            elif i == 1:\n                score_rank = \"Silver Medal\"\n            elif i == 2:\n                score_rank = \"Bronze Medal\"\n            else:\n                score_rank = str(i + 1)\n            score_rank = score_rank\n            score_rank = rank_dict[score]\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        rank_map = {score[i]: i+1 for i in range(len(score))}\n        \n        # create a list to store the result\n        result = []\n        \n        # iterate over the score and add the rank to the result\n        for s in score:\n            if rank_map[s] == 1:\n                result.append(\"Gold Medal\")\n            elif rank_map[s] == 2:\n                result.append(\"Silver Medal\")\n            elif rank_map[s] == 3:\n                result.append(\"Bronze Medal\")\n            else:\n                result.append(str(rank_map[s]))\n        \n        return result"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score array in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        \n        # assign the rank to each score\n        for i, score in enumerate(score):\n            rank_dict[score] = i + 1\n        \n        # assign the rank to each score\n        for i, score in enumerate(score):\n            if i == 0:\n                score_rank = \"Gold Medal\"\n            elif i == 1:\n                score_rank = \"Silver Medal\"\n            elif i == 2:\n                score_rank = \"Bronze Medal\"\n            else:\n                score_rank = str(i + 1)\n            score_rank = score_rank\n            score_rank = rank_dict[score]\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank\n            score_rank = score_rank"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        rank_map = {score[i]: i+1 for i in range(len(score))}\n        \n        # create a list to store the result\n        result = []\n        \n        # loop through the score and add the rank to the result\n        for s in score:\n            if rank_map[s] == 1:\n                result.append(\"Gold Medal\")\n            elif rank_map[s] == 2:\n                result.append(\"Silver Medal\")\n            elif rank_map[s] == 3:\n                result.append(\"Bronze Medal\")\n            else:\n                result.append(str(rank_map[s]))\n        \n        return result"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to map the score to the corresponding rank\n        rank_map = {score[i]: i+1 for i in range(len(score))}\n        \n        # create a list to store the relative ranks\n        relative_ranks = []\n        \n        # iterate over the score and add the corresponding rank to the relative ranks\n        for s in score:\n            relative_ranks.append(rank_map[s])\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+1)}\n        \n        # iterate over the relative ranks and add the corresponding rank to the relative ranks\n        for i in range(len(relative_ranks)):\n            relative_ranks[i] = rank_map[relative_ranks[i]]\n        \n        # create a dictionary to map the rank to the corresponding rank\n        rank_map = {rank: rank for rank in range(1, len(score)+"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        start = 0\n        seen = {}\n        for i, c in en\n        if c in seen:\n            start = max(start, seen[c] + 1)\n        seen[c] = i\n        max_len = max(max_len, i - start + 1)\n        return max_len"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        curr_len = 0\n        seen = set()\n        for i in range(len(s)):\n            if s[i] not in seen:\n                curr_len += 1\n                seen.add(s[i])\n            else:\n                max_len = max(max_len, curr_len)\n                curr_len = 0\n                seen = set()\n                seen.add(s[i])\n        return max(max_len, curr_len)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        curr_len = 0\n        seen = {}\n        for i in range(len(s)):\n            if s[i] in seen:\n                curr_len = i - seen[s[i]]\n            else:\n                curr_len += 1\n            max_len = max(max_len, curr_len)\n            seen[s[i]] = i\n        return max_len"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        curr_len = 0\n        start = 0\n        seen = {}\n        for i, c in enumerate(s):\n            if c in seen:\n                start = max(start, seen[c] + 1)\n            seen[c] = i\n            curr_len = i - start + 1\n            max_len = max(max_len, curr_len)\n        return max_len"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        curr_len = 0\n        seen = {}\n        for i in range(len(s)):\n            if s[i] in seen:\n                curr_len = i - seen[s[i]]\n            else:\n                curr_len += 1\n            max_len = max(max_len, curr_len)\n            seen[s[i]] = i\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = max(arr)\n        max_idx = arr.index(max_val)\n        max_val_count = 1\n        for i in range(max_idx):\n            if arr[i] == max_val:\n                max_val_count += 1\n        return max_val_count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        max_num_index = arr.index(max_num)\n        max_num_count = 1\n        for i in range(max_num_index + 1, len(arr)):\n            if arr[i] == max_num:\n                max_num_count += 1\n            else:\n                break\n        return max_num_count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        max_num_index = arr.index(max_num)\n        max_num_count = 1\n        for i in range(max_num_index + 1, len(arr)):\n            if arr[i] == max_num:\n                max_num_count += 1\n            else:\n                break\n        return max_num_count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        max_num_index = arr.index(max_num)\n        max_num_count = 1\n        for i in range(max_num_index + 1, len(arr)):\n            if arr[i] == max_num:\n                max_num_count += 1\n        return max_num_count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        max_num_index = arr.index(max_num)\n        max_num_count = 1\n        for i in range(max_num_index + 1, len(arr)):\n            if arr[i] == max_num:\n                max_num_count += 1\n            else:\n                break\n        return max_num_count"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.val < dummy.next.val:\n                dummy.next = curr\n                curr = curr.next\n                dummy.next.next = None\n            else:\n                prev = dummy\n                while prev.next and prev.next.val < curr.val:\n                    prev = prev.next\n                curr.next = prev.next\n                prev.next = curr\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            for k in range(left, right + 1):\n                if i > mid:\n                    nums[k] = nums[j]\n                    j += 1\n                elif j > right:\n                    nums[k] = nums[i]\n                    i += 1\n                elif nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    nums[k] = nums[j]\n                    j += 1\n                else:\n                    nums[k] = nums[i]\n                    i += 1\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid)\n            count += mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            for k in range(left, right + 1):\n                if i > mid:\n                    nums[k] = nums[j]\n                    j += 1\n                elif j > right:\n                    nums[k] = nums[i]\n                    i += 1\n                elif nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    nums[k] = nums[j]\n                    j += 1\n                else:\n                    nums[k] = nums[i]\n                    i += 1\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    tx %= sx\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    ty %= sy\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    return -1\n            else:\n                if i < len(v2):\n                    return 1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v2) > len(v1):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        min_price = float('inf')\n        max_price = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_price = max(max_price, price)\n            \n        return max_price - min_price"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 20. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 21. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 22. \ucd5c\ub300\uac12 - \ucd5c"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return prev"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return prev"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next_node = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next_node\n        return prev"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return prev"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 1:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 1:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        \n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2sum\n        # 2. 3sum\n        # 3. 4sum\n        # 4. 5sum\n        # 5. 6sum\n        # 6. 7sum\n        # 7. 8sum\n        # 8. 9sum\n        # 9. 10sum\n        # 10. 11sum\n        # 11. 12sum\n        # 12. 13sum\n        # 13. 14sum\n        # 14. 15sum\n        # 15. 16sum\n        # 16. 17sum\n        # 17. 18sum\n        # 18. 19sum\n        # 19. 20sum\n        # 20. 21sum\n        # 21. 22sum\n        # 22. 23sum\n        # 23. 24sum\n        # 24. 25sum\n        # 25. 26sum\n        # 26. 27sum\n        # 27. 28sum\n        # 28. 29sum\n        # 29. 30sum\n        # 30. 31sum\n        # 31. 32sum\n        # 32. 33sum\n        # 33. 34sum\n        # 34. 35sum\n        # 35. 36sum\n        # 36. 37sum\n        # 37. 38sum\n        # 38. 39sum\n        # 39. 40sum\n        # 40. 41sum\n        # 41. 42sum\n        # 42. 43sum\n        # 43. 44sum\n        # 44. 45sum\n        # 45. 46sum\n        # 46. 47sum\n        # 47. 48sum\n        # 48. 49sum\n        # 49. 50sum\n        # 50. 51sum\n        # 51. 52sum\n        # 52. 53sum\n        # 53. 54sum\n        # 54. 55sum\n        # 55. 56sum\n        # 56. 57sum\n        # 57. 58sum\n        # 58. 59sum\n        # 59. 60sum\n        # 60. 61sum\n        # 61. 62sum\n        # 62. 63sum\n        # 63. 64sum\n        # 64. 65sum\n        # 65. 66sum\n        # 66. 67sum\n        # 67. 68sum\n        # 68. 69sum\n        # 69. 70sum\n        # 70. 71sum\n        # 71. 72sum\n        # 72. 73sum\n        # 73. 74sum\n        # 74. 75sum\n        # 75. 76sum\n        # 76. 77sum\n        # 77. 78sum\n        # 78. 79sum\n        # 79. 80sum\n        # 80. 81sum\n        # 81. 82sum\n        # 82. 83sum\n        # 83. 84sum\n        # 84. 85sum\n        # 85. 86sum\n        # 86. 87sum\n        # 87. 88sum\n        # 88. 89sum\n        # 89. 90sum\n        # 90. 91sum\n        # 91. 92sum\n        # 92. 93sum\n        # 93. 94sum\n        # 94. 95sum\n        # 95."}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2sum\n        # 2. 3sum\n        # 3. 4sum\n        # 4. 5sum\n        # 5. 6sum\n        # 6. 7sum\n        # 7. 8sum\n        # 8. 9sum\n        # 9. 10sum\n        # 10. 11sum\n        # 11. 12sum\n        # 12. 13sum\n        # 13. 14sum\n        # 14. 15sum\n        # 15. 16sum\n        # 16. 17sum\n        # 17. 18sum\n        # 18. 19sum\n        # 19. 20sum\n        # 20. 21sum\n        # 21. 22sum\n        # 22. 23sum\n        # 23. 24sum\n        # 24. 25sum\n        # 25. 26sum\n        # 26. 27sum\n        # 27. 28sum\n        # 28. 29sum\n        # 29. 30sum\n        # 30. 31sum\n        # 31. 32sum\n        # 32. 33sum\n        # 33. 34sum\n        # 34. 35sum\n        # 35. 36sum\n        # 36. 37sum\n        # 37. 38sum\n        # 38. 39sum\n        # 39. 40sum\n        # 40. 41sum\n        # 41. 42sum\n        # 42. 43sum\n        # 43. 44sum\n        # 44. 45sum\n        # 45. 46sum\n        # 46. 47sum\n        # 47. 48sum\n        # 48. 49sum\n        # 49. 50sum\n        # 50. 51sum\n        # 51. 52sum\n        # 52. 53sum\n        # 53. 54sum\n        # 54. 55sum\n        # 55. 56sum\n        # 56. 57sum\n        # 57. 58sum\n        # 58. 59sum\n        # 59. 60sum\n        # 60. 61sum\n        # 61. 62sum\n        # 62. 63sum\n        # 63. 64sum\n        # 64. 65sum\n        # 65. 66sum\n        # 66. 67sum\n        # 67. 68sum\n        # 68. 69sum\n        # 69. 70sum\n        # 70. 71sum\n        # 71. 72sum\n        # 72. 73sum\n        # 73. 74sum\n        # 74. 75sum\n        # 75. 76sum\n        # 76. 77sum\n        # 77. 78sum\n        # 78. 79sum\n        # 79. 80sum\n        # 80. 81sum\n        # 81. 82sum\n        # 82. 83sum\n        # 83. 84sum\n        # 84. 85sum\n        # 85. 86sum\n        # 86. 87sum\n        # 87. 88sum\n        # 88. 89sum\n        # 89. 90sum\n        # 90. 91sum\n        # 91. 92sum\n        # 92. 93sum\n        # 93. 94sum\n        # 94. 95sum\n        # 95."}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2sum\n        # 2. 3sum\n        # 3. XOR\n        # 4. 2sum\n        # 5. 3sum\n        # 6. 2sum\n        # 7. 3sum\n        # 8. 2sum\n        # 9. 3sum\n        # 10. 2sum\n        # 11. 3sum\n        # 12. 2sum\n        # 13. 3sum\n        # 14. 2sum\n        # 15. 3sum\n        # 16. 2sum\n        # 17. 3sum\n        # 18. 2sum\n        # 19. 3sum\n        # 20. 2sum\n        # 21. 3sum\n        # 22. 2sum\n        # 23. 3sum\n        # 24. 2sum\n        # 25. 3sum\n        # 26. 2sum\n        # 27. 3sum\n        # 28. 2sum\n        # 29. 3sum\n        # 30. 2sum\n        # 31. 3sum\n        # 32. 2sum\n        # 33. 3sum\n        # 34. 2sum\n        # 35. 3sum\n        # 36. 2sum\n        # 37. 3sum\n        # 38. 2sum\n        # 39. 3sum\n        # 40. 2sum\n        # 41. 3sum\n        # 42. 2sum\n        # 43. 3sum\n        # 44. 2sum\n        # 45. 3sum\n        # 46. 2sum\n        # 47. 3sum\n        # 48. 2sum\n        # 49. 3sum\n        # 50. 2sum\n        # 51. 3sum\n        # 52. 2sum\n        # 53. 3sum\n        # 54. 2sum\n        # 55. 3sum\n        # 56. 2sum\n        # 57. 3sum\n        # 58. 2sum\n        # 59. 3sum\n        # 60. 2sum\n        # 61. 3sum\n        # 62. 2sum\n        # 63. 3sum\n        # 64. 2sum\n        # 65. 3sum\n        # 66. 2sum\n        # 67. 3sum\n        # 68. 2sum\n        # 69. 3sum\n        # 70. 2sum\n        # 71. 3sum\n        # 72. 2sum\n        # 73. 3sum\n        # 74. 2sum\n        # 75. 3sum\n        # 76. 2sum\n        # 77. 3sum\n        # 78. 2sum\n        # 79. 3sum\n        # 80. 2sum\n        # 81. 3sum\n        # 82. 2sum\n        # 83. 3sum\n        # 84. 2sum\n        # 85. 3sum\n        # 86. 2sum\n        # 87. 3sum\n        # 88. 2sum\n        # 89. 3sum\n        # 90. 2sum\n        # 91. 3sum\n        # 92. 2sum\n        # 93. 3sum\n        # 94. 2sum\n        # 95. 3sum\n        # 96. 2sum\n        # 97. 3sum\n        # 98. 2sum\n        # 99. 3sum\n        # 100. 2sum\n        # 101. 3sum\n        # 102. 2sum\n        # 103. 3sum"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2sum\n        # 2. 3sum\n        # 3. XOR\n        # 4. 2sum\n        # 5. 3sum\n        # 6. 2sum\n        # 7. 3sum\n        # 8. 2sum\n        # 9. 3sum\n        # 10. 2sum\n        # 11. 3sum\n        # 12. 2sum\n        # 13. 3sum\n        # 14. 2sum\n        # 15. 3sum\n        # 16. 2sum\n        # 17. 3sum\n        # 18. 2sum\n        # 19. 3sum\n        # 20. 2sum\n        # 21. 3sum\n        # 22. 2sum\n        # 23. 3sum\n        # 24. 2sum\n        # 25. 3sum\n        # 26. 2sum\n        # 27. 3sum\n        # 28. 2sum\n        # 29. 3sum\n        # 30. 2sum\n        # 31. 3sum\n        # 32. 2sum\n        # 33. 3sum\n        # 34. 2sum\n        # 35. 3sum\n        # 36. 2sum\n        # 37. 3sum\n        # 38. 2sum\n        # 39. 3sum\n        # 40. 2sum\n        # 41. 3sum\n        # 42. 2sum\n        # 43. 3sum\n        # 44. 2sum\n        # 45. 3sum\n        # 46. 2sum\n        # 47. 3sum\n        # 48. 2sum\n        # 49. 3sum\n        # 50. 2sum\n        # 51. 3sum\n        # 52. 2sum\n        # 53. 3sum\n        # 54. 2sum\n        # 55. 3sum\n        # 56. 2sum\n        # 57. 3sum\n        # 58. 2sum\n        # 59. 3sum\n        # 60. 2sum\n        # 61. 3sum\n        # 62. 2sum\n        # 63. 3sum\n        # 64. 2sum\n        # 65. 3sum\n        # 66. 2sum\n        # 67. 3sum\n        # 68. 2sum\n        # 69. 3sum\n        # 70. 2sum\n        # 71. 3sum\n        # 72. 2sum\n        # 73. 3sum\n        # 74. 2sum\n        # 75. 3sum\n        # 76. 2sum\n        # 77. 3sum\n        # 78. 2sum\n        # 79. 3sum\n        # 80. 2sum\n        # 81. 3sum\n        # 82. 2sum\n        # 83. 3sum\n        # 84. 2sum\n        # 85. 3sum\n        # 86. 2sum\n        # 87. 3sum\n        # 88. 2sum\n        # 89. 3sum\n        # 90. 2sum\n        # 91. 3sum\n        # 92. 2sum\n        # 93. 3sum\n        # 94. 2sum\n        # 95. 3sum\n        # 96. 2sum\n        # 97. 3sum\n        # 98. 2sum\n        # 99. 3sum\n        # 100. 2sum\n        # 101. 3sum\n        # 102. 2sum\n        # 103. 3sum"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2sum\n        # 2. 3sum\n        # 3. XOR\n        # 4. bit manipulation\n        # 5. hashmap\n        # 6. sorting\n        # 7. binary search\n        # 8. binary search\n        # 9. binary search\n        # 10. binary search\n        # 11. binary search\n        # 12. binary search\n        # 13. binary search\n        # 14. binary search\n        # 15. binary search\n        # 16. binary search\n        # 17. binary search\n        # 18. binary search\n        # 19. binary search\n        # 20. binary search\n        # 21. binary search\n        # 22. binary search\n        # 23. binary search\n        # 24. binary search\n        # 25. binary search\n        # 26. binary search\n        # 27. binary search\n        # 28. binary search\n        # 29. binary search\n        # 30. binary search\n        # 31. binary search\n        # 32. binary search\n        # 33. binary search\n        # 34. binary search\n        # 35. binary search\n        # 36. binary search\n        # 37. binary search\n        # 38. binary search\n        # 39. binary search\n        # 40. binary search\n        # 41. binary search\n        # 42. binary search\n        # 43. binary search\n        # 44. binary search\n        # 45. binary search\n        # 46. binary search\n        # 47. binary search\n        # 48. binary search\n        # 49. binary search\n        # 50. binary search\n        # 51. binary search\n        # 52. binary search\n        # 53. binary search\n        # 54. binary search\n        # 55. binary search\n        # 56. binary search\n        # 57. binary search\n        # 58. binary search\n        # 59. binary search\n        # 60. binary search\n        # 61. binary search\n        # 62. binary search\n        # 63. binary search\n        # 64. binary search\n        # 65. binary search\n        # 66. binary search\n        # 67. binary search\n        # 68. binary search\n        # 69. binary search\n        # 70. binary search\n        # 71. binary search\n        # 72. binary search\n        # 73. binary search\n        # 74. binary search\n        # 75. binary search\n        # 76. binary search\n        # 77. binary search\n        # 78. binary search\n        # 79. binary search\n        # 80. binary search\n        # 81. binary search\n        # 82. binary search\n        # 83. binary search\n        # 84. binary search\n        # 85. binary search\n        # 86. binary search\n        # 87. binary search\n        # 88. binary search\n        # 89. binary search\n        # 90. binary search\n        # 91. binary search\n        # 92. binary search\n        # 93. binary search\n        # 94. binary search\n        # 95. binary search\n        # 96. binary search\n        # 97. binary search\n        # 98. binary search\n        # 99. binary search\n        # 100. binary search\n        # 101. binary search\n        # 102. binary search\n        # 103. binary search\n        # 104. binary search\n        # 105. binary search\n        # 106. binary search\n        # 107. binary search\n        # 108. binary search\n        # 109. binary search\n        # 110. binary search\n        # 111. binary search\n        # 112. binary search\n        # 113. binary search"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if target == \"\":\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if target == \"\":\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to spell out target[0:i]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k and target[j:i] is a substring of stickers[m] for all m < l\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k and target[j:i] is a substring of stickers[m] for all m < l and target[j:i] is a substring of stickers[n] for all n < m\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k and target[j:i] is a substring of stickers[m] for all m < l and target[j:i] is a substring of stickers[n] for all n < m and target[j:i] is a substring of stickers[o] for all o < n\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k and target[j:i] is a substring of stickers[m] for all m < l and target[j:i] is a substring of stickers[n] for all n < m and target[j:i] is a substring of stickers[o] for all o < n and target[j:i] is a substring of stickers[p] for all p < o\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k and target[j:i] is a substring of stickers[m] for all m < l and target[j:i] is a substring of stickers[n] for all n < m and target[j:i] is a substring of stickers[o] for all o < n and target[j:i] is a substring of stickers[p] for all p < o and target[j:i] is a substring of stickers[q] for all q < p\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is a substring of stickers[l] for all l < k and target[j:i] is a substring of stickers[m] for all m < l and target[j"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if target == \"\":\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if target == \"\":\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target)"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid == x:\n                return mid\n            \n            elif mid * mid < x:\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 0\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                result += roman_dict[s[i]]\n                i += 1\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                result += roman_dict[s[i]]\n                i += 1\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        i = 0\n        \n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                total += roman_dict[s[i]]\n                i += 1\n                \n        return total"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        i = 0\n        while i < len(s):\n            if i+1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n            i += 1\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                result += roman_dict[s[i]]\n                i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Approach: Hash Table\n        # 1. Create a hash table\n        # 2. Iterate through the array\n        # 3. If the element is already in the hash table, return True\n        # 4. Otherwise, add the element to the hash table\n        # 5. Return False if the loop completes without finding a duplicate\n        \n        hash_table = {}\n        \n        for num in nums:\n            if num in hash_table:\n                return True\n            else:\n                hash_table[num] = 1\n        \n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # use deque\n        # deque:\n        # 1. append: O(1)\n        # 2. pop: O(1)\n        # 3. max: O(1)\n        # 4. len: O(1)\n        # 5. popleft: O(1)\n        # 6. max: O(1)\n        # 7. len: O(1)\n        # 8. popright: O(1)\n        # 9. max: O(1)\n        # 10. len: O(1)\n        # 11. appendleft: O(1)\n        # 12. max: O(1)\n        # 13. len: O(1)\n        # 14. appendright: O(1)\n        # 15. max: O(1)\n        # 16. len: O(1)\n        # 17. pop: O(1)\n        # 18. max: O(1)\n        # 19. len: O(1)\n        # 20. pop: O(1)\n        # 21. max: O(1)\n        # 22. len: O(1)\n        # 23. pop: O(1)\n        # 24. max: O(1)\n        # 25. len: O(1)\n        # 26. pop: O(1)\n        # 27. max: O(1)\n        # 28. len: O(1)\n        # 29. pop: O(1)\n        # 30. max: O(1)\n        # 31. len: O(1)\n        # 32. pop: O(1)\n        # 33. max: O(1)\n        # 34. len: O(1)\n        # 35. pop: O(1)\n        # 36. max: O(1)\n        # 37. len: O(1)\n        # 38. pop: O(1)\n        # 39. max: O(1)\n        # 40. len: O(1)\n        # 41. pop: O(1)\n        # 42. max: O(1)\n        # 43. len: O(1)\n        # 44. pop: O(1)\n        # 45. max: O(1)\n        # 46. len: O(1)\n        # 47. pop: O(1)\n        # 48. max: O(1)\n        # 49. len: O(1)\n        # 50. pop: O(1)\n        # 51. max: O(1)\n        # 52. len: O(1)\n        # 53. pop: O(1)\n        # 54. max: O(1)\n        # 55. len: O(1)\n        # 56. pop: O(1)\n        # 57. max: O(1)\n        # 58. len: O(1)\n        # 59. pop: O(1)\n        # 60. max: O(1)\n        # 61. len: O(1)\n        # 62. pop: O(1)\n        # 63. max: O(1)\n        # 64. len: O(1)\n        # 65. pop: O(1)\n        # 66. max: O(1)\n        # 67. len: O(1)\n        # 68. pop: O(1)\n        # 69. max: O(1)\n        # 70. len: O(1)\n        # 71. pop: O(1)\n        # 72. max: O(1)\n        # 73. len: O(1)\n        # 74. pop: O(1)\n        # 75. max: O(1)\n        # 76. len: O(1)\n        # 77. pop: O(1)\n        # 78. max: O(1"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums\n        \n        max_list = []\n        max_num = max(nums[:k])\n        max_list.append(max_num)\n        \n        for i in range(k, len(nums)):\n            if nums[i] > max_num:\n                max_num = nums[i]\n            if nums[i-k] == max_num:\n                max_num = max(nums[i-k+1:i+1])\n            max_list.append(max_num)\n        \n        return max_list"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the deque is empty, add the first element to it\n        # 4. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 5. if the element at the front of the deque is greater than the element at the back of the deque, add the element at the back of the deque to the deque\n        # 6. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 7. add the element at the back of the deque to the deque\n        # 8. return the deque\n        \n        # 1. create a deque\n        deque = []\n        # 2. iterate through the array\n        for i in range(len(nums)):\n            # 3. if the deque is empty, add the first element to it\n            if not deque:\n                deque.append(nums[i])\n            # 4. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n            elif deque[0] < nums[i]:\n                deque.pop(0)\n            # 5. if the element at the front of the deque is greater than the element at the back of the deque, add the element at the back of the deque to the deque\n            else:\n                deque.append(nums[i])\n            # 6. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n            if i >= k-1:\n                if deque[0] == nums[i-k+1]:\n                    deque.pop(0)\n                # 7. add the element at the back of the deque to the deque\n                deque.append(nums[i])\n        # 8. return the deque\n        return deque"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums\n        \n        max_nums = []\n        max_nums.append(max(nums[0:k]))\n        \n        for i in range(k, len(nums)):\n            if nums[i] > max_nums[i-k]:\n                max_nums.append(nums[i])\n            else:\n                max_nums.append(max_nums[i-k])\n        \n        return max_nums"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # use deque\n        # deque:\n        # 1. append: O(1)\n        # 2. pop: O(1)\n        # 3. max: O(1)\n        # 4. len: O(1)\n        # 5. popleft: O(1)\n        # 6. max: O(1)\n        # 7. len: O(1)\n        # 8. popright: O(1)\n        # 9. max: O(1)\n        # 10. len: O(1)\n        # 11. appendleft: O(1)\n        # 12. max: O(1)\n        # 13. len: O(1)\n        # 14. appendright: O(1)\n        # 15. max: O(1)\n        # 16. len: O(1)\n        # 17. pop: O(1)\n        # 18. max: O(1)\n        # 19. len: O(1)\n        # 20. pop: O(1)\n        # 21. max: O(1)\n        # 22. len: O(1)\n        # 23. pop: O(1)\n        # 24. max: O(1)\n        # 25. len: O(1)\n        # 26. pop: O(1)\n        # 27. max: O(1)\n        # 28. len: O(1)\n        # 29. pop: O(1)\n        # 30. max: O(1)\n        # 31. len: O(1)\n        # 32. pop: O(1)\n        # 33. max: O(1)\n        # 34. len: O(1)\n        # 35. pop: O(1)\n        # 36. max: O(1)\n        # 37. len: O(1)\n        # 38. pop: O(1)\n        # 39. max: O(1)\n        # 40. len: O(1)\n        # 41. pop: O(1)\n        # 42. max: O(1)\n        # 43. len: O(1)\n        # 44. pop: O(1)\n        # 45. max: O(1)\n        # 46. len: O(1)\n        # 47. pop: O(1)\n        # 48. max: O(1)\n        # 49. len: O(1)\n        # 50. pop: O(1)\n        # 51. max: O(1)\n        # 52. len: O(1)\n        # 53. pop: O(1)\n        # 54. max: O(1)\n        # 55. len: O(1)\n        # 56. pop: O(1)\n        # 57. max: O(1)\n        # 58. len: O(1)\n        # 59. pop: O(1)\n        # 60. max: O(1)\n        # 61. len: O(1)\n        # 62. pop: O(1)\n        # 63. max: O(1)\n        # 64. len: O(1)\n        # 65. pop: O(1)\n        # 66. max: O(1)\n        # 67. len: O(1)\n        # 68. pop: O(1)\n        # 69. max: O(1)\n        # 70. len: O(1)\n        # 71. pop: O(1)\n        # 72. max: O(1)\n        # 73. len: O(1)\n        # 74. pop: O(1)\n        # 75. max: O(1)\n        # 76. len: O(1)\n        # 77. pop: O(1)\n        # 78. max: O(1"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uace0 \uc2dc\uc791\n        # 2. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\uc774 \ub41c\ub2e4.\n        # 3. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\ubcf4\ub2e4 \uc791\ub2e4\uba74 \uc67c\ucabd \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 4. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\ubcf4\ub2e4 \ud06c\ub2e4\uba74 \uc624\ub978\ucabd \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 5. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\uacfc \uac19\ub2e4\uba74 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 6. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\ubcf4\ub2e4 \uc791\ub2e4\uba74 \uc67c\ucabd \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 7. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\ubcf4\ub2e4 \ud06c\ub2e4\uba74 \uc624\ub978\ucabd \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 8. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\uacfc \uac19\ub2e4\uba74 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 9. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\ubcf4\ub2e4 \uc791\ub2e4\uba74 \uc67c\ucabd \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 10. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\ubcf4\ub2e4 \ud06c\ub2e4\uba74 \uc624\ub978\ucabd \ubc30\uc5f4\uc774 \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \ub41c\ub2e4.\n        # 11. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uc911\uac04\uac12\uc774 \ucd5c\uc18c\uac12\uacfc \uac19"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2,rowIndex+1):\n            row = [1] + [row[j]+row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2,rowIndex+1):\n            row.append(1)\n            for j in range(i-1,0,-1):\n                row[j] = row[j] + row[j-1]\n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2,rowIndex+1):\n            row.append(1)\n            for j in range(i-1,0,-1):\n                row[j] = row[j] + row[j-1]\n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            path.append(root.val)\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. 1 <= area <= 10^18\n        # 3. 1 <= area <= 10^15\n        # 4. 1 <= area <= 10^12\n        # 5. 1 <= area <= 10^9\n        # 6. 1 <= area <= 10^6\n        # 7. 1 <= area <= 10^3\n        # 8. 1 <= area <= 10^2\n        # 9. 1 <= area <= 10\n        # 10. 1 <= area <= 1\n        # 11. 1 <= area <= 1000000000\n        # 12. 1 <= area <= 1000000000000\n        # 13. 1 <= area <= 1000000000000000\n        # 14. 1 <= area <= 1000000000000000000\n        # 15. 1 <= area <= 1000000000000000000000\n        # 16. 1 <= area <= 1000000000000000000000000\n        # 17. 1 <= area <= 1000000000000000000000000000\n        # 18. 1 <= area <= 100000000000000000000000000000\n        # 19. 1 <= area <= 10000000000000000000000000000000\n        # 20. 1 <= area <= 1000000000000000000000000000000000\n        # 21. 1 <= area <= 10000000000000000000000000000000000\n        # 22. 1 <= area <= 100000000000000000000000000000000000\n        # 23. 1 <= area <= 1000000000000000000000000000000000000\n        # 24. 1 <= area <= 10000000000000000000000000000000000000\n        # 25. 1 <= area <= 100000000000000000000000000000000000000\n        # 26. 1 <= area <= 1000000000000000000000000000000000000000\n        # 27. 1 <= area <= 10000000000000000000000000000000000000000\n        # 28. 1 <= area <= 100000000000000000000000000000000000000000\n        # 29. 1 <= area <= 1000000000000000000000000000000000000000000\n        # 30. 1 <= area <= 10000000000000000000000000000000000000000000\n        # 31. 1 <= area <="}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. 1 <= area <= 10^18\n        # 3. 1 <= area <= 10^18\n        # 4. 1 <= area <= 10^18\n        # 5. 1 <= area <= 10^18\n        # 6. 1 <= area <= 10^18\n        # 7. 1 <= area <= 10^18\n        # 8. 1 <= area <= 10^18\n        # 9. 1 <= area <= 10^18\n        # 10. 1 <= area <= 10^18\n        # 11. 1 <= area <= 10^18\n        # 12. 1 <= area <= 10^18\n        # 13. 1 <= area <= 10^18\n        # 14. 1 <= area <= 10^18\n        # 15. 1 <= area <= 10^18\n        # 16. 1 <= area <= 10^18\n        # 17. 1 <= area <= 10^18\n        # 18. 1 <= area <= 10^18\n        # 19. 1 <= area <= 10^18\n        # 20. 1 <= area <= 10^18\n        # 21. 1 <= area <= 10^18\n        # 22. 1 <= area <= 10^18\n        # 23. 1 <= area <= 10^18\n        # 24. 1 <= area <= 10^18\n        # 25. 1 <= area <= 10^18\n        # 26. 1 <= area <= 10^18\n        # 27. 1 <= area <= 10^18\n        # 28. 1 <= area <= 10^18\n        # 29. 1 <= area <= 10^18\n        # 30. 1 <= area <= 10^18\n        # 31. 1 <= area <= 10^18\n        # 32. 1 <= area <= 10^18\n        # 33. 1 <= area <= 10^18\n        # 34. 1 <= area <= 10^18\n        # 35. 1 <= area <= 10^18\n        # 36. 1 <= area <= 10^18\n        # 37. 1 <= area <= 10^18\n        # 38. 1 <= area <= 10^18\n        # 39. 1 <= area <= 10^18\n        # 40. 1 <= area <= 10^18\n        # 41. 1 <= area <= 10^18\n        # 42. 1 <= area <= 10^18\n        # 43. 1 <= area <= 10^18\n        # 44. 1 <= area <= 10^18\n        # 45. 1 <= area <= 10^18\n        # 46. 1 <= area <= 10^18\n        # 47. 1 <= area <= 10^18\n        # 48. 1 <= area <= 10^18\n        # 49. 1 <= area <= 10^18\n        # 50. 1 <= area <= 10^18\n        # 51. 1 <= area <= 10^18\n        # 52. 1 <= area <= 10^18\n        # 53. 1 <= area <= 10^18\n        # 54. 1 <= area <= 10^18\n        # 55. 1 <= area <= 10^18\n        # 56. 1 <= area <= 10^18\n        # 57. 1 <= area <= 10^18\n        # 58. 1 <= area <= 10^18\n        # 59. 1 <= area <= 10^18\n        # 60. 1 <= area <= 10^18\n        # 61. 1 <= area <= 10^"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * L = area\n        # 2. L >= W\n        # 3. L - W < W\n        # 4. L - W = area - W\n        # 5. L = area / W\n        # 6. L = area // W\n        # 7. L = area // W + 1\n        # 8. L = area // W + 2\n        # 9. L = area // W + 3\n        # 10. L = area // W + 4\n        # 11. L = area // W + 5\n        # 12. L = area // W + 6\n        # 13. L = area // W + 7\n        # 14. L = area // W + 8\n        # 15. L = area // W + 9\n        # 16. L = area // W + 10\n        # 17. L = area // W + 11\n        # 18. L = area // W + 12\n        # 19. L = area // W + 13\n        # 20. L = area // W + 14\n        # 21. L = area // W + 15\n        # 22. L = area // W + 16\n        # 23. L = area // W + 17\n        # 24. L = area // W + 18\n        # 25. L = area // W + 19\n        # 26. L = area // W + 20\n        # 27. L = area // W + 21\n        # 28. L = area // W + 22\n        # 29. L = area // W + 23\n        # 30. L = area // W + 24\n        # 31. L = area // W + 25\n        # 32. L = area // W + 26\n        # 33. L = area // W + 27\n        # 34. L = area // W + 28\n        # 35. L = area // W + 29\n        # 36. L = area // W + 30\n        # 37. L = area // W + 31\n        # 38. L = area // W + 32\n        # 39. L = area // W + 33\n        # 40. L = area // W + 34\n        # 41. L = area // W + 35\n        # 42. L = area // W + 36\n        # 43. L = area // W + 37\n        # 44. L = area // W + 38\n        # 45. L = area // W + 39\n        # 46. L = area // W + 40\n        # 47. L = area // W + 41\n        # 48. L = area // W + 42\n        # 49. L = area // W + 43\n        # 50. L = area // W + 44\n        # 51. L = area // W + 45\n        # 52. L = area // W + 46\n        # 53. L = area // W + 47\n        # 54. L = area // W + 48\n        # 55. L = area // W + 49\n        # 56. L = area // W + 50\n        # 57. L = area // W + 51\n        # 58. L = area // W + 52\n        # 59. L = area // W + 53\n        # 60. L = area // W + 54\n        # 61. L = area // W + 55\n        # 62. L = area // W + 56\n        # 63. L = area // W + 57\n        # 64. L = area // W + 58\n        # 65. L = area // W + 59\n        # 66. L = area // W + 60\n        # 67. L = area // W + 61\n        # 68. L = area // W + 62\n        # 69. L = area // W + 63\n        # 70. L = area // W + 64\n        # 71. L = area"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. 1 <= area <= 10^18\n        # 3. 1 <= area <= 10^18\n        # 4. 1 <= area <= 10^18\n        # 5. 1 <= area <= 10^18\n        # 6. 1 <= area <= 10^18\n        # 7. 1 <= area <= 10^18\n        # 8. 1 <= area <= 10^18\n        # 9. 1 <= area <= 10^18\n        # 10. 1 <= area <= 10^18\n        # 11. 1 <= area <= 10^18\n        # 12. 1 <= area <= 10^18\n        # 13. 1 <= area <= 10^18\n        # 14. 1 <= area <= 10^18\n        # 15. 1 <= area <= 10^18\n        # 16. 1 <= area <= 10^18\n        # 17. 1 <= area <= 10^18\n        # 18. 1 <= area <= 10^18\n        # 19. 1 <= area <= 10^18\n        # 20. 1 <= area <= 10^18\n        # 21. 1 <= area <= 10^18\n        # 22. 1 <= area <= 10^18\n        # 23. 1 <= area <= 10^18\n        # 24. 1 <= area <= 10^18\n        # 25. 1 <= area <= 10^18\n        # 26. 1 <= area <= 10^18\n        # 27. 1 <= area <= 10^18\n        # 28. 1 <= area <= 10^18\n        # 29. 1 <= area <= 10^18\n        # 30. 1 <= area <= 10^18\n        # 31. 1 <= area <= 10^18\n        # 32. 1 <= area <= 10^18\n        # 33. 1 <= area <= 10^18\n        # 34. 1 <= area <= 10^18\n        # 35. 1 <= area <= 10^18\n        # 36. 1 <= area <= 10^18\n        # 37. 1 <= area <= 10^18\n        # 38. 1 <= area <= 10^18\n        # 39. 1 <= area <= 10^18\n        # 40. 1 <= area <= 10^18\n        # 41. 1 <= area <= 10^18\n        # 42. 1 <= area <= 10^18\n        # 43. 1 <= area <= 10^18\n        # 44. 1 <= area <= 10^18\n        # 45. 1 <= area <= 10^18\n        # 46. 1 <= area <= 10^18\n        # 47. 1 <= area <= 10^18\n        # 48. 1 <= area <= 10^18\n        # 49. 1 <= area <= 10^18\n        # 50. 1 <= area <= 10^18\n        # 51. 1 <= area <= 10^18\n        # 52. 1 <= area <= 10^18\n        # 53. 1 <= area <= 10^18\n        # 54. 1 <= area <= 10^18\n        # 55. 1 <= area <= 10^18\n        # 56. 1 <= area <= 10^18\n        # 57. 1 <= area <= 10^18\n        # 58. 1 <= area <= 10^18\n        # 59. 1 <= area <= 10^18\n        # 60. 1 <= area <= 10^18\n        # 61. 1 <= area <= 10^"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def find_neighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        def find_shortest_path(beginWord, endWord, wordList):\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    return path\n                if word in visited:\n                    continue\n                visited.add(word)\n                neighbors = find_neighbors(word)\n                for neighbor in neighbors:\n                    queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        shortest_path = find_shortest_path(beginWord, endWord, wordList)\n        if not shortest_path:\n            return []\n        result = []\n        for i in range(len(shortest_path)-1):\n            result.append([shortest_path[i], shortest_path[i+1]])\n        return result"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    for j in range(26):\n                        neighbor = curr[:i] + chr(ord(\"a\") + j) + curr[i+1:]\n                        if neighbor in graph:\n                            for neighbor2 in graph[neighbor]:\n                                if neighbor2 == endWord:\n                                    res.append([beginWord, neighbor, neighbor2])\n                                    return res\n                                if neighbor2 not in visited:\n                                    visited.add(neighbor2)\n                                    queue.append(neighbor2)\n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def build_graph(wordList):\n            graph = defaultdict(list)\n            for word in wordList:\n                for i in range(len(word)):\n                    pattern = word[:i] + '*' + word[i+1:]\n                    graph[pattern].append(word)\n            return graph\n        \n        def build_path(graph, beginWord, endWord, path):\n            if beginWord == endWord:\n                return [path]\n            if beginWord not in graph:\n                return []\n            paths = []\n            for neighbor in graph[beginWord]:\n                new_paths = build_path(graph, neighbor, endWord, path + [neighbor])\n                paths.extend(new_paths)\n            return paths\n        \n        graph = build_graph(wordList)\n        paths = build_path(graph, beginWord, endWord, [beginWord])\n        return paths"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def build_graph(wordList):\n            graph = defaultdict(list)\n            for word in wordList:\n                for i in range(len(word)):\n                    pattern = word[:i] + '*' + word[i+1:]\n                    graph[pattern].append(word)\n            return graph\n        \n        def find_path(graph, beginWord, endWord):\n            queue = deque([(beginWord, [beginWord])])\n            visited = set([beginWord])\n            while queue:\n                word, path = queue.popleft()\n                for i in range(len(word)):\n                    pattern = word[:i] + '*' + word[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return path + [neighbor]\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        graph = build_graph(wordList)\n        path = find_path(graph, beginWord, endWord)\n        if path:\n            return [path]\n        else:\n            return []"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    for j in range(26):\n                        neighbor = curr[:i] + chr(ord(\"a\") + j) + curr[i+1:]\n                        if neighbor in graph:\n                            for neighbor2 in graph[neighbor]:\n                                if neighbor2 == endWord:\n                                    res.append([beginWord, neighbor, neighbor2])\n                                    return res\n                                if neighbor2 not in visited:\n                                    visited.add(neighbor2)\n                                    queue.append(neighbor2)\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        if n == 1:\n            return True\n        else:\n            return False"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \ubc18\ubcf5\ud558\uba74\uc11c \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub4e4\uc758 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c \ud6c4, \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 2. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 3. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 4. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 5. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 6. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 7. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 8. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 9. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 10. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 11. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 12. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 13. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 14. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 15. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 16. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 17. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 3. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 4. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 5. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 6. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 7. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 8. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 9. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 10. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 11. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 12. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 13. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 14. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 15. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 16. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min < rectangles[0][0] or x_max > rectangles[-1][2] or y_min < rectangles[0][1] or y_max > rectangles[-1][3]:\n            return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min == x_max and y_min == y_max:\n            return True\n        if x_min == x_max or y_min == y_max:\n            return False\n        if x_min < y_min or x_max > y_max:\n            return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min < rectangles[0][0] or x_max > rectangles[-1][2] or y_min < rectangles[0][1] or y_max > rectangles[-1][3]:\n            return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min == x_max or y_min == y_max:\n            return False\n        if (x_min, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_min) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min < rectangles[0][0] or x_max > rectangles[-1][2] or y_min < rectangles[0][1] or y_max > rectangles[-1][3]:\n            return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            temp = board[i][j]\n            board[i][j] = board[i][j+1]\n            board[i][j+1] = temp\n            return board\n        \n        def isSolved(board):\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] != j+1:\n                        return False\n            return True\n        \n        def getNextStates(board):\n            nextStates = []\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        for k in range(4):\n                            if k != j:\n                                nextBoard = swap(board, i, j)\n                                nextStates.append(nextBoard)\n            return nextStates\n        \n        def bfs(board):\n            queue = [board]\n            visited = set()\n            visited.add(tuple(board[0]))\n            visited.add(tuple(board[1]))\n            level = 0\n            while queue:\n                nextStates = getNextStates(queue.pop(0))\n                for nextState in nextStates:\n                    if isSolved(nextState):\n                        return level+1\n                    if tuple(nextState[0]) not in visited:\n                        visited.add(tuple(nextState[0]))\n                        queue.append(nextState)\n                level += 1\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,2,1\n        # 3,4,5,1,0,2\n        # 4,5,0,1,2,3\n        # 4,5,0,2,1,3\n        # 4,5,1,0,3,2\n        # 5,0,1,2,3,4\n        # 5,0,2,1,3,4\n        # 5,1,0,3,4,2\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,4,0,1,5\n        # 3,4,5,0,1,2\n        # 3,4,5,0,"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1,2,3,5,4,0\n        # 1,2,3,0,4,5\n        # 1,2,3,0,5,4\n        # 1,2,3,4,0,5\n        # 1,2,3,4,5,0\n        # 1,2,3,5,4,0\n        # 1,2,3,5,0,4\n        # 1"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            temp = board[i][j]\n            board[i][j] = board[i][j+1]\n            board[i][j+1] = temp\n            return board\n        \n        def find_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def is_solved(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != i*3+j+1:\n                        return False\n            return True\n        \n        def bfs(board):\n            q = [(board, 0)]\n            visited = set()\n            while q:\n                board, moves = q.pop(0)\n                if is_solved(board):\n                    return moves\n                zero_i, zero_j = find_zero(board)\n                for i, j in [(zero_i-1, zero_j), (zero_i, zero_j-1), (zero_i+1, zero_j), (zero_i, zero_j+1)]:\n                    if i >= 0 and i < 2 and j >= 0 and j < 3:\n                        new_board = swap(board, zero_i, zero_j)\n                        new_board_tuple = tuple(tuple(row) for row in new_board)\n                        if new_board_tuple not in visited:\n                            visited.add(new_board_tuple)\n                            q.append((new_board, moves+1))\n            return -1\n        \n        return bfs(board)"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums is not rotated, return False\n        \n        # if nums is not rotated, binary search\n        # if target is in nums, return True"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if len(nums) == 0:\n            return False\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(inorder_list)):\n            min_diff = min(min_diff, abs(inorder_list[i] - inorder_list[i - 1]))\n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(inorder_list)):\n            min_diff = min(min_diff, abs(inorder_list[i] - inorder_list[i-1]))\n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(inorder_list)):\n            min_diff = min(min_diff, inorder_list[i] - inorder_list[i-1])\n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root is None:\n                return\n            \n            inorder(root.left, min_diff, prev)\n            \n            if prev is not None:\n                min_diff = min(min_diff, root.val - prev)\n            \n            prev = root.val\n            \n            inorder(root.right, min_diff, prev)\n            \n            return min_diff\n        \n        return inorder(root, float('inf'), None)"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(inorder_list)):\n            min_diff = min(min_diff, abs(inorder_list[i] - inorder_list[i-1]))\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if not root:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        max_count = 0\n        max_val = None\n        curr_count = 0\n        prev_val = None\n        for val in inorder_list:\n            if val == prev_val:\n                curr_count += 1\n            else:\n                if curr_count > max_count:\n                    max_count = curr_count\n                    max_val = val\n                curr_count = 1\n            prev_val = val\n        if curr_count > max_count:\n            max_count = curr_count\n            max_val = val\n        return [max_val] if max_count == 1 else [max_val] if max_count == 2 else [max_val, inorder_list[inorder_list.index(max_val) + 1]]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        res = dfs(root)\n        count = {}\n        for i in res:\n            count[i] = count.get(i, 0) + 1\n        max_count = max(count.values())\n        return [k for k, v in count.items() if v == max_count]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        res = dfs(root)\n        count = {}\n        for i in res:\n            count[i] = count.get(i, 0) + 1\n        max_count = max(count.values())\n        return [k for k, v in count.items() if v == max_count]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return [0, float('-inf')]\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] > right[0]:\n                return [left[0] + 1, root.val]\n            elif left[0] < right[0]:\n                return [right[0] + 1, root.val]\n            else:\n                return [left[0] + 1, root.val]\n        \n        return dfs(root)[1:]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        res = dfs(root)\n        count = {}\n        for i in res:\n            count[i] = count.get(i, 0) + 1\n        max_count = max(count.values())\n        return [k for k, v in count.items() if v == max_count]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uae38\uc774 \uccb4\ud06c\n        # 2. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 3. \ucd5c\uc18c 1\uac1c \uc22b\uc790, \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790\n        # 4. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ud654\n        # 6. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 7. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 8. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 9. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 10. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 11. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 12. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 13. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 14. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 15. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 16. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 17. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 18. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 19. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 20. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 21. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 22. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 23. \uc554\ud638 \uac15\ud654 \ud6c4 \ub0a8\uc740 \uae38\uc774 \uccb4\ud06c\n        # 24. \uc554\ud638 \uac15\ud654 \ud6c4 \ufffd"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 7. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 9. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 11. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 13. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 15. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 16. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 17. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ufffd"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 7. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 9. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 11. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 13. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 15. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 16. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 17. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\ufffd"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uae38\uc774 \uccb4\ud06c\n        # 2. \uc22b\uc790, \ub300\ubb38\uc790, \uc18c\ubb38\uc790 \uccb4\ud06c\n        # 3. \uc911\ubcf5 \uccb4\ud06c\n        # 4. \ucd5c\uc18c \ubcc0\uacbd \ud69f\uc218 \uacc4\uc0b0\n        # 5. \ucd5c\uc18c \ubcc0\uacbd \ud69f\uc218 \ubc18\ud658\n        \n        # 1. \uae38\uc774 \uccb4\ud06c\n        if len(password) < 6 or len(password) > 20:\n            return 5\n        \n        # 2. \uc22b\uc790, \ub300\ubb38\uc790, \uc18c\ubb38\uc790 \uccb4\ud06c\n        num_count = 0\n        upper_count = 0\n        lower_count = 0\n        for c in password:\n            if c.isdigit():\n                num_count += 1\n            elif c.isupper():\n                upper_count += 1\n            elif c.islower():\n                lower_count += 1\n        \n        if num_count == 0 or upper_count == 0 or lower_count == 0:\n            return 5\n        \n        # 3. \uc911\ubcf5 \uccb4\ud06c\n        # \uc911\ubcf5 \uccb4\ud06c\ub97c \uc704\ud574 \uccab \ubb38\uc790\ub97c \ub515\uc154\ub108\ub9ac\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \ud0a4\ub294 \ubb38\uc790, \uac12\uc740 \uc911\ubcf5 \ud69f\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\uc0c1\uc774\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud558\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uc774\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud558\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uc774\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud558\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uc774\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud558\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uc774\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud558\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uc774\uba74 \uc911\ubcf5 \uccb4\ud06c\ub97c \ud558\uc9c0 \uc54a\ub294\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\uc758 \uac12\uc774 3\uc774\ud558\uc774\uba74 \ufffd"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638\uac00 \uc88b\ub2e4.\n        # 5. \uc554\ud638\uac00 \uc88b\uc9c0 \uc54a\ub2e4\uba74 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638\uac00 \uc88b\ub2e4.\n        # 7. \uc554\ud638\uac00 \uc88b\uc9c0 \uc54a\ub2e4\uba74 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638\uac00 \uc88b\ub2e4.\n        # 9. \uc554\ud638\uac00 \uc88b\uc9c0 \uc54a\ub2e4\uba74 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638\uac00 \uc88b\ub2e4.\n        # 11. \uc554\ud638\uac00 \uc88b\uc9c0 \uc54a\ub2e4\uba74 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638\uac00 \uc88b\ub2e4.\n        # 13. \uc554\ud638\uac00 \uc88b\uc9c0 \uc54a\ub2e4\uba74 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c, \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638\uac00 \uc88b\ub2e4.\n        # 15. \uc554\ud638\uac00 \uc88b\uc9c0"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n // 5\n            n = n // 5\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n // 5\n            n = n // 5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = -1\n        \n        for c in s:\n            if i == 0 or i == numRows - 1:\n                flag = -flag\n            res[i] += c\n            i += flag\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = True\n        \n        for c in s:\n            res[i] += c\n            if i == 0:\n                flag = True\n            elif i == numRows - 1:\n                flag = False\n            if flag:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = True\n        \n        for c in s:\n            res[i] += c\n            if i == 0:\n                flag = True\n            elif i == numRows - 1:\n                flag = False\n            if flag:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = -1\n        \n        for c in s:\n            if i == 0 or i == numRows - 1:\n                flag = -flag\n            res[i] += c\n            i += flag\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = True\n        \n        for c in s:\n            res[i] += c\n            if i == numRows - 1:\n                flag = False\n            elif i == 0:\n                flag = True\n            if flag:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 3. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 4. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 5. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 6. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 7. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 8. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 9. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 10. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 11. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\uc900\ub2e4.\n        # 12. \uc67c\ucabd\uacfc \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ufffd"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 4. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 5. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 6. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 7. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 8. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 9. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 10. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 11. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 12. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 13. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 14. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 17. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 19. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 20. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ufffd"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # TLE\n        # if len(height) <= 2:\n        #     return 0\n        # water = 0\n        # for i in range(1, len(height)-1):\n        #     left_max = max(height[0:i])\n        #     right_max = max(height[i+1:])\n        #     water += min(left_max, right_max) - height[i]\n        # return water\n\n        # Approach 2: Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Accepted\n        # Use two pointers, left and right, to keep track of the maximum height on the left and right\n        # If the height of the left pointer is less than the height of the right pointer, move the left pointer\n        # If the height of the left pointer is greater than the height of the right pointer, move the right pointer\n        # If the height of the left pointer is equal to the height of the right pointer, move the left pointer\n        # Keep track of the maximum height on the left and right\n        # Calculate the water trapped between the two maximum heights\n        # Repeat the process until the left pointer is less than the right pointer\n        # Return the water trapped\n        if len(height) <= 2:\n            return 0\n        left, right = 0, len(height)-1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                water += right_max - height[right]\n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 17. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 19. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 20. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ufffd"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Use a hashmap to store the frequency of each number in the array\n        ## 2. Iterate through the array and for each number, check if the number is in the hashmap\n        ## 3. If the number is not in the hashmap, add it to the result array\n        ## 4. If the number is in the hashmap, remove it from the hashmap\n        ## 5. Return the result array\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Use a hashmap to store the frequency of each number in the array\n        hashmap = {}\n        for num in nums:\n            if num not in hashmap:\n                hashmap[num] = 1\n            else:\n                hashmap[num] += 1\n        \n        ## 2. Iterate through the array and for each number, check if the number is in the hashmap\n        ## 3. If the number is not in the hashmap, add it to the result array\n        ## 4. If the number is in the hashmap, remove it from the hashmap\n        result = []\n        for i in range(1, len(nums)+1):\n            if i not in hashmap:\n                result.append(i)\n        \n        return result"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. loop through the array and mark the index of the number as negative\n        ## 2. loop through the array again and add the index to the result\n        ## 3. return the result\n        \n        ## Time: O(n)\n        ## Space: O(1)\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        result = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result.append(i+1)\n        \n        return result"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. loop through the array and mark the index as negative\n        ## 2. loop through the array again and add the index to the result\n        ## 3. return the result\n        \n        ## 1. loop through the array and mark the index as negative\n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        ## 2. loop through the array again and add the index to the result\n        result = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result.append(i+1)\n        \n        return result"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can use the array as a hashmap to keep track of the number of times a number appears in the array.\n        ## 2. We can then iterate through the array and add the number to the result array if the number does not appear in the hashmap.\n        ## 3. We can also iterate through the hashmap and add the number to the result array if the number does not appear in the hashmap.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty array.\n        ## 2. If the array has only one element, return an empty array.\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return an empty"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. loop through the array and mark the index as negative\n        ## 2. loop through the array again and add the index to the result\n        ## 3. return the result\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        result = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result.append(i+1)\n        \n        return result"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i = 0\n            j = 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i = 0\n            j = 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            res = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            i = 0\n            j = 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        for interval in intervals:\n            if interval[0] <= res:\n                continue\n            if interval[0] <= res + 1:\n                res += 1\n            else:\n                res += 2\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        for interval in intervals:\n            if interval[0] <= res:\n                continue\n            if interval[1] <= res + 1:\n                res += 1\n            else:\n                res += 2\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        max_num = 0\n        for interval in intervals:\n            if interval[0] > max_num:\n                res += 2\n                max_num = interval[1]\n            elif interval[0] > max_num - 1:\n                res += 1\n                max_num = interval[1]\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        max_num = -1\n        for interval in intervals:\n            if interval[0] > max_num:\n                res += 2\n                max_num = interval[1]\n            elif interval[0] > max_num - 1:\n                res += 1\n                max_num = interval[1]\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        max_num = 0\n        for interval in intervals:\n            if interval[0] > max_num:\n                res += 2\n                max_num = interval[1]\n            elif interval[0] > max_num - 1:\n                res += 1\n                max_num = interval[1]\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            if left.val != right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None:\n                return False\n            if root1.val != root2.val:\n                return False\n            return isMirror(root1.left, root2.right) and isMirror(root1.right, root2.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            if left.val != right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            if left.val != right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                i += 1\n                while stack and stack[-1] != '(':\n                    i = stack.pop()\n                if stack:\n                    stack.pop()\n            else:\n                j = i\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                count = int(formula[i:j]) if i < j else 1\n                i = j\n                if stack:\n                    stack[-1] += count\n                else:\n                    stack.append(count)\n        print(stack)\n        return ''.join([atom + (str(count) if count > 1 else '') for atom, count in sorted(stack)])"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                i += 1\n                while stack and stack[-1] != '(':\n                    i = stack.pop()\n                if stack:\n                    stack.pop()\n            else:\n                j = i\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                count = int(formula[i:j]) if i < j else 1\n                i = j\n                if stack:\n                    stack[-1] += count\n                else:\n                    stack.append(count)\n        res = []\n        while stack:\n            count = stack.pop()\n            if stack:\n                res.append(stack.pop() + str(count))\n            else:\n                res.append(str(count))\n        return ''.join(res[::-1])"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                i = self.count(formula, i, stack)\n            else:\n                i += 1\n        return ''.join(sorted(stack))\n\n    def count(self, formula, i, stack):\n        count = 0\n        while i < len(formula) and formula[i].isdigit():\n            count = count * 10 + int(formula[i])\n            i += 1\n        if stack:\n            i = stack.pop()\n            count = count * (i - stack[-1] - 1)\n        return i"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(open_count, close_count, curr_str, res):\n            if open_count == close_count == n:\n                res.append(curr_str)\n                return\n            if open_count < n:\n                backtrack(open_count + 1, close_count, curr_str + \"(\", res)\n            if close_count < open_count:\n                backtrack(open_count, close_count + 1, curr_str + \")\", res)\n        \n        res = []\n        backtrack(0, 0, \"\", res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(open_count, close_count, curr_str, res):\n            if open_count == close_count == n:\n                res.append(curr_str)\n                return\n            if open_count < n:\n                backtrack(open_count + 1, close_count, curr_str + \"(\", res)\n            if close_count < open_count:\n                backtrack(open_count, close_count + 1, curr_str + \")\", res)\n        \n        res = []\n        backtrack(0, 0, \"\", res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(open_count, close_count, curr_str, res):\n            if open_count == close_count == n:\n                res.append(curr_str)\n                return\n            if open_count < n:\n                backtrack(open_count + 1, close_count, curr_str + \"(\", res)\n            if close_count < open_count:\n                backtrack(open_count, close_count + 1, curr_str + \")\", res)\n        \n        res = []\n        backtrack(0, 0, \"\", res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(open_count, close_count, curr_str, res):\n            if open_count == close_count == n:\n                res.append(curr_str)\n                return\n            if open_count < n:\n                backtrack(open_count + 1, close_count, curr_str + \"(\", res)\n            if close_count < open_count:\n                backtrack(open_count, close_count + 1, curr_str + \")\", res)\n        \n        res = []\n        backtrack(0, 0, \"\", res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left-1, right, s+'(', ans)\n            if right > left:\n                generate(left, right-1, s+')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \ube7c\uc11c \ub2eb\ub294 \uad04\ud638\uc758 \uc704\ufffd"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\uba74\uc11c \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 3. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\uba74\uc11c \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 4. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\uba74\uc11c \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\uba74\uc11c \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 6. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\uba74\uc11c \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\uba74\uc11c \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 8. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ufffd"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 13. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 14. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 15. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 16. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 17. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 18. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 19. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 20. \uc2a4\ud0dd\ufffd"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 4. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 7. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 10. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 13. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\n        # 16. \uc2a4\ufffd"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder = remainder * 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        return sign + str(quotient) + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return sign + str(quotient) + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            denominator = -denominator\n        elif denominator < 0:\n            denominator = -denominator\n            numerator = -numerator\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = []\n        res.append(str(numerator // denominator))\n        numerator = numerator % denominator\n        numerator *= 10\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res.insert(seen[numerator], \"(\")\n                res.append(\")\")\n                break\n            seen[numerator] = len(res)\n            res.append(str(numerator // denominator))\n            numerator = numerator % denominator\n            numerator *= 10\n        \n        return \"\".join(res)"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        return sign + str(quotient) + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return sign + str(quotient) + \".\" + remainder_str"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        print(envelopes)\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        print(envelopes)\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        print(envelopes)\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # print(envelopes)\n        dp = [1] * len(envelopes)\n        max_val = 1\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_val = max(max_val, dp[i])\n        return max_val"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        print(envelopes)\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        row_zero = False\n        col_zero = False\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        row_zero = True\n                    if j == 0:\n                        col_zero = True\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if row_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n        \n        if col_zero:\n            for i in range(rows):\n                matrix[i][0] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        row_zero = False\n        col_zero = False\n        \n        ## check if any row or col has zero\n        for i in range(rows):\n            if matrix[i][0] == 0:\n                row_zero = True\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    col_zero = True\n        \n        ## mark zeroes in rows and cols\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        ## set zeroes in rows and cols\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        ## set zeroes in first row and cols\n        if row_zero:\n            for i in range(rows):\n                matrix[i][0] = 0\n        if col_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n        \n        return matrix"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        # row = [0]*len(matrix)\n        # col = [0]*len(matrix[0])\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if matrix[i][j] == 0:\n        #             row[i] = 1\n        #             col[j] = 1\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if row[i] == 1 or col[j] == 1:\n        #             matrix[i][j] = 0\n        # return matrix\n\n        ## O(1) space\n        row = False\n        col = False\n        for i in range(len(matrix)):\n            if matrix[i][0] == 0:\n                col = True\n            for j in range(1, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(len(matrix)):\n            for j in range(1, len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if col:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n        if row:\n            for j in range(len(matrix[0])):\n                matrix[0][j] = 0\n        return matrix"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        row_zero = False\n        col_zero = False\n\n        # Check if any row or column has zero\n        for i in range(rows):\n            if matrix[i][0] == 0:\n                row_zero = True\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    col_zero = True\n\n        # Set zeroes for rows\n        for i in range(rows):\n            if matrix[i][0] == 0:\n                for j in range(1, cols):\n                    matrix[i][j] = 0\n\n        # Set zeroes for columns\n        for j in range(cols):\n            if matrix[0][j] == 0:\n                for i in range(1, rows):\n                    matrix[i][j] = 0\n\n        # Set zeroes for rows and columns\n        if row_zero:\n            for i in range(rows):\n                matrix[i][0] = 0\n        if col_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n\n        return matrix"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        row_zero = False\n        col_zero = False\n\n        # Check if any row or col has zero\n        for i in range(rows):\n            if matrix[i][0] == 0:\n                row_zero = True\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    col_zero = True\n\n        # Set zeroes for rows\n        for i in range(rows):\n            if matrix[i][0] == 0:\n                for j in range(1, cols):\n                    matrix[i][j] = 0\n\n        # Set zeroes for cols\n        for j in range(cols):\n            if matrix[0][j] == 0:\n                for i in range(1, rows):\n                    matrix[i][j] = 0\n\n        # Set zeroes for rows and cols\n        if row_zero:\n            for i in range(rows):\n                matrix[i][0] = 0\n\n        if col_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n\n        return matrix"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the nth node from the end\n        # 2.1 Find the nth node from the end\n        # 2.2 Remove the nth node from the end\n        # 2.3 Return the head\n        if length == n:\n            return head.next\n        \n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        curr.next = curr.next.next\n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the nth node from the end\n        if length == n:\n            return head.next\n        \n        # 3. Find the nth node from the beginning\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        # 4. Remove the nth node from the end\n        curr.next = curr.next.next\n        \n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the nth node from the end\n        # 2.1 Find the nth node from the end\n        # 2.2 Remove the nth node from the end\n        # 2.3 Return the head\n        if length == n:\n            return head.next\n        \n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        curr.next = curr.next.next\n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if the list is empty\n        if not head:\n            return None\n        \n        # if the list has only one node\n        if not head.next:\n            return None\n        \n        # if the list has two nodes\n        if not head.next.next:\n            head = None\n            return head\n        \n        # if the list has more than two nodes\n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create two pointers\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n nodes ahead\n        for i in range(n):\n            fast = fast.next\n        \n        # move the slow pointer until the fast pointer reaches the end\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the nth node from the end\n        slow.next = slow.next.next\n        \n        # return the modified list\n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if the list is empty\n        if not head:\n            return None\n        \n        # if the list has only one node\n        if not head.next:\n            return None\n        \n        # if the list has two nodes\n        if not head.next.next:\n            head = None\n            return head\n        \n        # if the list has more than two nodes\n        # find the length of the list\n        length = 1\n        temp = head\n        while temp.next:\n            temp = temp.next\n            length += 1\n        \n        # find the node to be removed\n        if length - n == 0:\n            head = head.next\n            return head\n        \n        # find the node to be removed\n        temp = head\n        for i in range(length - n - 1):\n            temp = temp.next\n        \n        temp.next = temp.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return res"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        return list(nums1 & nums2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        return list(nums1 & nums2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return res"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return res"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        res = 0\n        curr = 0\n        for i in range(n):\n            curr += machines[i]\n            res = max(res, abs(curr - avg * (i + 1)))\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u603b\u6570\n        total = sum(machines)\n        # 2. \u5982\u679c\u603b\u6570\u4e0d\u80fd\u88abn\u6574\u9664\uff0c\u5219\u65e0\u6cd5\u5b8c\u6210\n        if total % len(machines) != 0:\n            return -1\n        # 3. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u5e73\u5747\u6570\n        avg = total // len(machines)\n        # 4. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u79fb\u52a8\u6b21\u6570\n        moves = [avg - m if m > avg else -m for m in machines]\n        # 5. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u79fb\u52a8\u6b21\u6570\u7684\u548c\n        return max(moves)"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u603b\u6570\n        total = sum(machines)\n        # 2. \u5982\u679c\u603b\u6570\u4e0d\u80fd\u88abn\u6574\u9664\uff0c\u5219\u65e0\u6cd5\u5b8c\u6210\n        if total % len(machines) != 0:\n            return -1\n        # 3. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u5e73\u5747\u6570\n        avg = total // len(machines)\n        # 4. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u79fb\u52a8\u6b21\u6570\n        moves = [avg - m if m > avg else -m for m in machines]\n        # 5. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u79fb\u52a8\u6b21\u6570\u7684\u548c\n        return max(moves)"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u603b\u6570\n        total = sum(machines)\n        # 2. \u5982\u679c\u603b\u6570\u4e0d\u80fd\u88abn\u6574\u9664\uff0c\u5219\u65e0\u6cd5\u5b8c\u6210\n        if total % len(machines) != 0:\n            return -1\n        # 3. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u5e73\u5747\u6570\n        avg = total // len(machines)\n        # 4. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u79fb\u52a8\u6b21\u6570\n        moves = [avg - m if m > avg else -m for m in machines]\n        # 5. \u8ba1\u7b97\u51fa\u6bcf\u4e2a\u673a\u5668\u7684\u79fb\u52a8\u6b21\u6570\u7684\u548c\n        return max(moves)"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        res = 0\n        cur = 0\n        for i in range(n):\n            cur += machines[i]\n            res = max(res, abs(cur - avg * (i + 1)))\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m+1):\n                c += min(n, x//i)\n            return c\n        \n        l, r = 1, m*n\n        while l < r:\n            mid = (l+r)//2\n            if count(mid) < k:\n                l = mid+1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = (1 if i == 0 else dp[i-1][j]) + 1\n        \n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] == 0:\n                    continue\n                width = dp[i][j]\n                for k in range(i, -1, -1):\n                    width = min(width, dp[k][j])\n                    max_area = max(max_area, width * (i - k + 1))\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = (1 if i == 0 else dp[i-1][j]) + 1\n        \n        max_area = 0\n        for i in range(m):\n            stack = []\n            for j in range(n):\n                if not stack or dp[i][j] >= dp[stack[-1]][j]:\n                    stack.append(j)\n                else:\n                    while stack and dp[i][j] < dp[stack[-1]][j]:\n                        top = stack.pop()\n                        max_area = max(max_area, dp[i][j] * (j - stack[-1] - 1 if stack else j))\n                    stack.append(j)\n            while stack:\n                top = stack.pop()\n                max_area = max(max_area, dp[i][top] * (n - stack[-1] - 1 if stack else n))\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        heights = [0] * cols\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(cols):\n            max_area = max(max_area, self.largestRectangleArea(matrix, i))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        heights = [0] * cols\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(rows):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(rows):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights, heights_copy=None):\n        if not heights_copy:\n            heights_copy = heights[:]\n        \n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            width = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_area = 0\n        heights = [0] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def backtrack(i, curr):\n            if i == len(nums):\n                res.append(curr)\n                return\n            backtrack(i+1, curr)\n            backtrack(i+1, curr + [nums[i]])\n        \n        backtrack(0, [])\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        for i in range(2**len(nums)):\n            temp = []\n            for j in range(len(nums)):\n                if i & (1<<j):\n                    temp.append(nums[j])\n            res.append(temp)\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        for i in range(2**len(nums)):\n            temp = []\n            for j in range(len(nums)):\n                if i & (1<<j):\n                    temp.append(nums[j])\n            res.append(temp)\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def backtrack(i, curr):\n            if i == len(nums):\n                res.append(curr.copy())\n                return\n            backtrack(i+1, curr)\n            curr.append(nums[i])\n            backtrack(i+1, curr)\n            curr.pop()\n        backtrack(0, [])\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def backtrack(i, curr):\n            if i == len(nums):\n                res.append(curr.copy())\n                return\n            backtrack(i+1, curr)\n            curr.append(nums[i])\n            backtrack(i+1, curr)\n            curr.pop()\n        backtrack(0, [])\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \ud6c4 \uc911\uc559\uac12 \ucc3e\uae30\n        # 3. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc744 \ub54c \uc911\uc559\uac12 \ub9ac\ud134\n        # 4. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc9c0 \uc54a\uc744 \ub54c \uc911\uc559\uac12 \ub9ac\ud134\n        # 5. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 6. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc9c0 \uc54a\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 7. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 8. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc9c0 \uc54a\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 9. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 10. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc9c0 \uc54a\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 11. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc744 \ub54c \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12 \ub9ac\ud134\n        # 12. \uc911\uc559\uac12\uc774 \uc67c\ucabd \uc624\ub978\ucabd \ube44\uad50 \uac12\uacfc \uac19\uc9c0 \uc54a\uc744 \ub54c \uc67c\ucabd \uc624\ufffd"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        if s[0] in ['+','-']:\n            s = s[1:]\n        \n        if not s:\n            return False\n        \n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        \n        if not s:\n            return False\n        \n        if s[0] in ['e','E']:\n            s = s[1:]\n        \n        if not s:\n            return False\n        \n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        \n        if not s:\n            return False\n        \n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if s[0] == '':\n                return False\n            if s[1] == '':\n                return False\n            if s[0][0] in ['+','-']:\n                s[0] = s[0][1:]\n            if s[1][0] in ['+','-']:\n                s[1] = s[1][1:]\n            if s[0][0] == 'e':\n                s[0] = s[0][1:]\n            if s[1][0] == 'e':\n                s[1] = s[1][1:]\n            if s[0][0] == 'E':\n                s[0] = s[0][1:]\n            if s[1][0] == 'E':\n                s[1] = s[1][1:]\n            if s[0][0] == '-':\n                s[0] = '-' + s[0][1:]\n            if s[1][0] == '-':\n                s[1] = '-' + s[1][1:]\n            if s[0][0] == '+':\n                s[0] = '+' + s[0][1:]\n            if s[1][0] == '+':\n                s[1] = '+' + s[1][1:]\n            if s[0][0] == '.':\n                s[0] = '.' + s[0][1:]\n            if s[1][0] == '.':\n                s[1] = '.' + s[1][1:]\n            if s[0][0] == '0':\n                s[0] = '0' + s[0][1:]\n            if s[1][0] == '0':\n                s[1] = '0' + s[1][1:]\n            if s[0][0] == '1':\n                s[0] = '1' + s[0][1:]\n            if s[1][0] == '1':\n                s[1] = '1' + s[1][1:]\n            if s[0][0] == '2':\n                s[0] = '2' + s[0][1:]\n            if s[1][0] == '2':\n                s[1] = '2' + s[1][1:]\n            if s[0][0] == '3':\n                s[0] = '3' + s[0][1:]\n            if s[1][0] == '3':\n                s[1] = '3' + s[1][1:]\n            if s[0][0] == '4':\n                s[0] = '4' + s[0][1:]\n            if s[1][0] == '4':\n                s[1] = '4' + s[1][1:]\n            if s[0][0] == '5':\n                s[0] = '5' + s[0][1:]\n            if s[1][0] == '5':\n                s[1] = '5' + s[1][1:]\n            if s[0][0] == '6':\n                s[0] = '6' + s[0][1:]\n            if s[1][0] == '6':\n                s[1] = '6' + s[1][1:]\n            if s[0][0] == '7':\n                s[0] = '7' + s[0][1:]\n            if s[1][0] == '7':"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        if s[0] in ['+','-']:\n            s = s[1:]\n        \n        if not s:\n            return False\n        \n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        \n        if not s:\n            return False\n        \n        if s[0] in ['e','E']:\n            s = s[1:]\n        \n        if not s:\n            return False\n        \n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        \n        if not s:\n            return False\n        \n        if '.' in s:\n            s = s.split('.')\n            if len(s) == 2:\n                if s[0].isdigit() and s[1].isdigit():\n                    return True\n                else:\n                    return False\n            else:\n                return False\n        \n        if s.isdigit():\n            return True\n        \n        return False"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \uc815\uaddc\uc2dd \uc0ac\uc6a9\n        # 2. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568\n        # 3. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 4. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 5. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 6. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 7. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 8. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 9. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 10. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 11. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 12. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 13. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 14. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 15. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 16. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 17. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 18. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c \ubcc0\ud658\n        # 19. \uc815\uaddc\uc2dd \uc0ac\uc6a9 \uc548\ud568 \uc544\ub2c8\uba74 \uc22b\uc790\ub85c"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_map = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in roman_map.keys():\n            while num >= key:\n                roman_num += roman_map[key]\n                num -= key\n                \n        return roman_num"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n                \n        return roman_num"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n                \n        return roman_num"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_map = {\n            1000: \"M\",\n            900: \"CM\",\n            500: \"D\",\n            400: \"CD\",\n            100: \"C\",\n            90: \"XC\",\n            50: \"L\",\n            40: \"XL\",\n            10: \"X\",\n            9: \"IX\",\n            5: \"V\",\n            4: \"IV\",\n            1: \"I\"\n        }\n        \n        roman_num = \"\"\n        \n        for key in roman_map.keys():\n            while num >= key:\n                roman_num += roman_map[key]\n                num -= key\n                \n        return roman_num"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n                \n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 2nd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 3rd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 4th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 5th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 6th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 7th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 8th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 9th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 10th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 11th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 12th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 13th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 14th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 15th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 16th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 17th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 18th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 19th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 20th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 21st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 22nd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 23rd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 24th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 25th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 26th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and decrement the frequency of each character in the hashmap\n        ## 3. Return the character with a frequency of 1\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 2nd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 3rd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 4th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 5th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 6th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 7th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 8th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 9th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 10th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 11th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 12th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 13th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 14th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 15th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 16th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 17th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 18th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 19th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 20th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 21st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 22nd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 23rd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 24th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 25th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 26th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            # find an empty cell\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for val in range(1,10):\n                            if valid(board, i, j, str(val)):\n                                board[i][j] = str(val)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n\n        def valid(board, row, col, val):\n            # check row\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n            # check col\n            for i in range(9):\n                if board[i][col] == val:\n                    return False\n            # check 3x3 box\n            box_row = row // 3\n            box_col = col // 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row*3 + i][box_col*3 + j] == val:\n                        return False\n            return True\n\n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1,10):\n                            if isValid(i,j,str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n            row_start = (row // 3) * 3\n            col_start = (col // 3) * 3\n            for i in range(row_start, row_start + 3):\n                for j in range(col_start, col_start + 3):\n                    if board[i][j] == num:\n                        return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n            row_start = (row // 3) * 3\n            col_start = (col // 3) * 3\n            for i in range(row_start, row_start + 3):\n                for j in range(col_start, col_start + 3):\n                    if board[i][j] == num:\n                        return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            # find an empty space\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for k in range(1,10):\n                            if valid(board, i, j, str(k)):\n                                board[i][j] = str(k)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n\n        def valid(board, row, col, num):\n            # check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # check col\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # check 3x3 box\n            box_row = row // 3\n            box_col = col // 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row * 3 + i][box_col * 3 + j] == num:\n                        return False\n            return True\n\n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half with the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half with the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half with the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        left = 0\n        right = num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        \n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        \n        ans = [0,1,1]\n        i = 2\n        while i <= n:\n            ans.append(ans[i//2] + i%2)\n            i += 1\n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                res.append(res[i//2])\n            else:\n                res.append(res[i//2]+1)\n        return res"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        \n        ans = [0,1,1]\n        i = 3\n        while i <= n:\n            ans.append(ans[i//2] + i%2)\n            i += 1\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return False\n            if board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return False\n            if board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return False\n            if board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n            \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n        \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            elif s_dict[key] != t_dict[key]:\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = 1\n            else:\n                s_dict[s[i]] += 1\n            \n            if t[i] not in t_dict:\n                t_dict[t[i]] = 1\n            else:\n                t_dict[t[i]] += 1\n        \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            else:\n                if s_dict[key] != t_dict[key]:\n                    return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n            \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n        \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            else:\n                if s_dict[key] != t_dict[key]:\n                    return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 cols\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        for i in range(3):\n            for j in range(3):\n                sub_box = []\n                for k in range(3):\n                    for l in range(3):\n                        sub_box.append(board[3*i+k][3*j+l])\n                if len(set(sub_box)) != len(sub_box):\n                    return False\n        \n        # 2. 9 rows\n        for i in range(9):\n            if len(set(board[i])) != len(board[i]):\n                return False\n        \n        # 3. 9 cols\n        for i in range(9):\n            col = []\n            for j in range(9):\n                col.append(board[j][i])\n            if len(set(col)) != len(col):\n                return False\n        \n        # 4. 9 unique numbers\n        for i in range(9):\n            row = []\n            for j in range(9):\n                row.append(board[i][j])\n            if len(set(row)) != len(row):\n                return False\n        \n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        for i in range(3):\n            for j in range(3):\n                sub_box = []\n                for k in range(3):\n                    for l in range(3):\n                        sub_box.append(board[3*i+k][3*j+l])\n                if len(set(sub_box)) != len(sub_box):\n                    return False\n        \n        # 2. 9 rows\n        for i in range(9):\n            if len(set(board[i])) != len(board[i]):\n                return False\n        \n        # 3. 9 columns\n        for i in range(9):\n            col = []\n            for j in range(9):\n                col.append(board[j][i])\n            if len(set(col)) != len(col):\n                return False\n        \n        # 4. 9 unique numbers\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != \".\":\n                    if board[i][j] in col:\n                        return False\n                    col.append(board[i][j])\n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 cols\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        for i in range(3):\n            for j in range(3):\n                sub_box = set()\n                for k in range(3):\n                    for l in range(3):\n                        if board[i*3+k][j*3+l] != '.':\n                            sub_box.add(board[i*3+k][j*3+l])\n                if len(sub_box) != 9:\n                    return False\n        \n        # 2. 9 rows\n        for i in range(9):\n            row = set()\n            for j in range(9):\n                if board[i][j] != '.':\n                    row.add(board[i][j])\n            if len(row) != 9:\n                return False\n        \n        # 3. 9 cols\n        for i in range(9):\n            col = set()\n            for j in range(9):\n                if board[j][i] != '.':\n                    col.add(board[j][i])\n            if len(col) != 9:\n                return False\n        \n        # 4. 9 unique numbers\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.' and board[i][j] in col:\n                    return False\n                col.add(board[i][j])\n        \n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 for loops\n        # 2. 3 sets\n        # 3. 3 for loops\n        # 4. 3 sets\n        # 5. 3 for loops\n        # 6. 3 sets\n        # 7. 3 for loops\n        # 8. 3 sets\n        # 9. 3 for loops\n        # 10. 3 sets\n        # 11. 3 for loops\n        # 12. 3 sets\n        # 13. 3 for loops\n        # 14. 3 sets\n        # 15. 3 for loops\n        # 16. 3 sets\n        # 17. 3 for loops\n        # 18. 3 sets\n        # 19. 3 for loops\n        # 20. 3 sets\n        # 21. 3 for loops\n        # 22. 3 sets\n        # 23. 3 for loops\n        # 24. 3 sets\n        # 25. 3 for loops\n        # 26. 3 sets\n        # 27. 3 for loops\n        # 28. 3 sets\n        # 29. 3 for loops\n        # 30. 3 sets\n        # 31. 3 for loops\n        # 32. 3 sets\n        # 33. 3 for loops\n        # 34. 3 sets\n        # 35. 3 for loops\n        # 36. 3 sets\n        # 37. 3 for loops\n        # 38. 3 sets\n        # 39. 3 for loops\n        # 40. 3 sets\n        # 41. 3 for loops\n        # 42. 3 sets\n        # 43. 3 for loops\n        # 44. 3 sets\n        # 45. 3 for loops\n        # 46. 3 sets\n        # 47. 3 for loops\n        # 48. 3 sets\n        # 49. 3 for loops\n        # 50. 3 sets\n        # 51. 3 for loops\n        # 52. 3 sets\n        # 53. 3 for loops\n        # 54. 3 sets\n        # 55. 3 for loops\n        # 56. 3 sets\n        # 57. 3 for loops\n        # 58. 3 sets\n        # 59. 3 for loops\n        # 60. 3 sets\n        # 61. 3 for loops\n        # 62. 3 sets\n        # 63. 3 for loops\n        # 64. 3 sets\n        # 65. 3 for loops\n        # 66. 3 sets\n        # 67. 3 for loops\n        # 68. 3 sets\n        # 69. 3 for loops\n        # 70. 3 sets\n        # 71. 3 for loops\n        # 72. 3 sets\n        # 73. 3 for loops\n        # 74. 3 sets\n        # 75. 3 for loops\n        # 76. 3 sets\n        # 77. 3 for loops\n        # 78. 3 sets\n        # 79. 3 for loops\n        # 80. 3 sets\n        # 81. 3 for loops\n        # 82. 3 sets\n        # 83. 3 for loops\n        # 84. 3 sets\n        # 85. 3 for loops\n        # 86. 3 sets\n        # 87. 3 for loops\n        # 88. 3 sets\n        # 89. 3 for loops\n        # 90. 3 sets\n        # 91. 3 for loops\n        # 92. 3 sets\n        # 93. 3 for loops\n        # 94. 3 sets\n        # 95. 3 for loops\n        # 96. 3 sets\n        # 97. 3 for loops\n        # 98. 3 sets\n        # 9"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        \n        # 1. 3x3 sub-box"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        s = s.split()\n        s.reverse()\n        return ' '.join(s)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res += (ord(columnTitle[i]) - 64) * (26 ** (len(columnTitle) - i - 1))\n        return res"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res += (ord(columnTitle[i]) - 64) * (26 ** (len(columnTitle) - i - 1))\n        return res"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 144000\n        # 26^5 = 7372800\n        # 26^6 = 393216000\n        # 26^7 = 21843200000\n        # 26^8 = 1152921504000\n        # 26^9 = 57646075200000\n        # 26^10 = 3174153504000000\n        # 26^11 = 171798691840000000\n        # 26^12 = 1000000000000000000\n        # 26^13 = 439804651103232000000\n        # 26^14 = 23432902008176640000000\n        # 26^15 = 12899242505813734400000000\n        # 26^16 = 74467353879807520000000000\n        # 26^17 = 4226137453693640000000000000\n        # 26^18 = 211337657692690400000000000000\n        # 26^19 = 1056743089485560000000000000000\n        # 26^20 = 5283715447423600000000000000000\n        # 26^21 = 26418023232136000000000000000000\n        # 26^22 = 132092166569200000000000000000000\n        # 26^23 = 660410343736000000000000000000000\n        # 26^24 = 3302051718640000000000000000000000\n        # 26^25 = 16510258064000000000000000000000000\n        # 26^26 = 82551240320000000000000000000000000\n        # 26^27 = 412756200160000000000000000000000000\n        # 26^28 = 2063781000800000000000000000000000000\n        # 26^29 = 10318905004000000000000000000000000000\n        # 26^30 = 51594525024000000000000000000000000000\n        # 26^31 = 258472625008000000000000"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 26^0 * 1 + 26^1 * 2 + 26^2 * 3 + ... + 26^(n-1) * (n-1) + (n)\n        # 2. 26^(n-1) * (n-1) + (n)\n        # 3. 26^(n-1) * (n-1) + (n) = (26^n - 1)\n        # 4. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 5. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 6. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 7. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 8. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 9. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 10. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 11. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 12. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 13. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 14. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 15. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 16. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 17. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 18. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 19. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 20. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 21. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 22. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 23. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 24. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 25. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 26. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 27. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 28. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 29. 26^n - 1 = (26^n - 1) / (26^(n-1))\n        # 30. 26"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 26^0 * 1 + 26^1 * 2 + 26^2 * 3 + ... + 26^n * nth_digit\n        # 2. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 3. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 4. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 5. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 6. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 7. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 8. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 9. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 10. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 11. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 12. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 13. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 14. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 15. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 16. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 17. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 18. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 19. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 * 26^2 + ... + 26^n * 26^n\n        # 20. 26^0 * 26^0 + 26^1 * 26^1 + 26^2 *"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first = head\n        second = prev\n        while second.next:\n            temp = first.next\n            first.next = second\n            first = temp\n            \n            temp = second.next\n            second.next = first\n            second = temp\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Merge the first and second halves\n        first = head\n        second = prev\n        while second.next:\n            temp = first.next\n            first.next = second\n            first = temp\n            \n            temp = second.next\n            second.next = first\n            second = temp\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        \n        second = self.reverse(second)\n        \n        first = head\n        \n        while first and second:\n            temp = first.next\n            first.next = second\n            first = temp\n            \n            temp = second.next\n            second.next = first\n            second = temp\n        \n        return head\n    \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between pattern and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern and word are not in the mapping, add them\n            if pattern[i] not in mapping:\n                if words[i] not in mapping.values():\n                    mapping[pattern[i]] = words[i]\n                else:\n                    return False\n            # if the pattern and word are in the mapping, check if they match\n            else:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the words are mapped, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping of pattern to words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the mapping, add it\n            if pattern[i] not in mapping:\n                mapping[pattern[i]] = words[i]\n            # if the pattern is in the mapping, check if the word is the same as the mapping\n            else:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the words are mapped, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the number of words is not equal to the number of letters in the pattern, return False\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the mapping, check if the word matches the corresponding word in the mapping\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the mapping, add it to the mapping\n            else:\n                if word in mapping.values():\n                    return False\n                mapping[letter] = word\n        \n        # if all the letters are mapped correctly, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between pattern and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern and word are not in the mapping, add them\n            if pattern[i] not in mapping:\n                if words[i] not in mapping.values():\n                    mapping[pattern[i]] = words[i]\n                else:\n                    return False\n            # if the pattern and word are in the mapping, check if they match\n            else:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the words are mapped, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the number of words is not equal to the number of letters in the pattern, return False\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the mapping, check if the word matches the corresponding word in the mapping\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the mapping, add it to the mapping\n            else:\n                if word in mapping.values():\n                    return False\n                mapping[letter] = word\n        \n        # if all the letters are mapped correctly, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        # 2. binary search in that row\n        # 3. return true if target is in that row\n        # 4. return false otherwise\n        \n        # 1. find the row\n        #"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new list node\n        # 2. Create a new list node\n        # 3. Create a new list node\n        # 4. Create a new list node\n        # 5. Create a new list node\n        # 6. Create a new list node\n        # 7. Create a new list node\n        # 8. Create a new list node\n        # 9. Create a new list node\n        # 10. Create a new list node\n        # 11. Create a new list node\n        # 12. Create a new list node\n        # 13. Create a new list node\n        # 14. Create a new list node\n        # 15. Create a new list node\n        # 16. Create a new list node\n        # 17. Create a new list node\n        # 18. Create a new list node\n        # 19. Create a new list node\n        # 20. Create a new list node\n        # 21. Create a new list node\n        # 22. Create a new list node\n        # 23. Create a new list node\n        # 24. Create a new list node\n        # 25. Create a new list node\n        # 26. Create a new list node\n        # 27. Create a new list node\n        # 28. Create a new list node\n        # 29. Create a new list node\n        # 30. Create a new list node\n        # 31. Create a new list node\n        # 32. Create a new list node\n        # 33. Create a new list node\n        # 34. Create a new list node\n        # 35. Create a new list node\n        # 36. Create a new list node\n        # 37. Create a new list node\n        # 38. Create a new list node\n        # 39. Create a new list node\n        # 40. Create a new list node\n        # 41. Create a new list node\n        # 42. Create a new list node\n        # 43. Create a new list node\n        # 44. Create a new list node\n        # 45. Create a new list node\n        # 46. Create a new list node\n        # 47. Create a new list node\n        # 48. Create a new list node\n        # 49. Create a new list node\n        # 50. Create a new list node\n        # 51. Create a new list node\n        # 52. Create a new list node\n        # 53. Create a new list node\n        # 54. Create a new list node\n        # 55. Create a new list node\n        # 56. Create a new list node\n        # 57. Create a new list node\n        # 58. Create a new list node\n        # 59. Create a new list node\n        # 60. Create a new list node\n        # 61. Create a new list node\n        # 62. Create a new list node\n        # 63. Create a new list node\n        # 64. Create a new list node\n        # 65. Create a new list node\n        # 66. Create a new list node\n        # 67. Create a new list node\n        # 68. Create a new list node\n        # 69. Create a new list node\n        # 70. Create a new list node\n        # 71. Create a new list node\n        # 72. Create a new list node\n        # 73. Create a new list node\n        # 74. Create a new list node\n        # 75. Create a new list node\n        # 76. Create a new list node\n        # 77. Create a new list node\n        # 78. Create a new list node\n        # 79. Create a new list node\n        # 80. Create a new list node\n        # 81. Create a new list node\n        # 82. Create a new list node\n        # 83. Create a new list node\n        # 84. Create a new list node\n        # 85. Create a new list node\n        # 86. Create a new list node"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new list node\n        # 2. Create a new list node\n        # 3. Create a new list node\n        # 4. Create a new list node\n        # 5. Create a new list node\n        # 6. Create a new list node\n        # 7. Create a new list node\n        # 8. Create a new list node\n        # 9. Create a new list node\n        # 10. Create a new list node\n        # 11. Create a new list node\n        # 12. Create a new list node\n        # 13. Create a new list node\n        # 14. Create a new list node\n        # 15. Create a new list node\n        # 16. Create a new list node\n        # 17. Create a new list node\n        # 18. Create a new list node\n        # 19. Create a new list node\n        # 20. Create a new list node\n        # 21. Create a new list node\n        # 22. Create a new list node\n        # 23. Create a new list node\n        # 24. Create a new list node\n        # 25. Create a new list node\n        # 26. Create a new list node\n        # 27. Create a new list node\n        # 28. Create a new list node\n        # 29. Create a new list node\n        # 30. Create a new list node\n        # 31. Create a new list node\n        # 32. Create a new list node\n        # 33. Create a new list node\n        # 34. Create a new list node\n        # 35. Create a new list node\n        # 36. Create a new list node\n        # 37. Create a new list node\n        # 38. Create a new list node\n        # 39. Create a new list node\n        # 40. Create a new list node\n        # 41. Create a new list node\n        # 42. Create a new list node\n        # 43. Create a new list node\n        # 44. Create a new list node\n        # 45. Create a new list node\n        # 46. Create a new list node\n        # 47. Create a new list node\n        # 48. Create a new list node\n        # 49. Create a new list node\n        # 50. Create a new list node\n        # 51. Create a new list node\n        # 52. Create a new list node\n        # 53. Create a new list node\n        # 54. Create a new list node\n        # 55. Create a new list node\n        # 56. Create a new list node\n        # 57. Create a new list node\n        # 58. Create a new list node\n        # 59. Create a new list node\n        # 60. Create a new list node\n        # 61. Create a new list node\n        # 62. Create a new list node\n        # 63. Create a new list node\n        # 64. Create a new list node\n        # 65. Create a new list node\n        # 66. Create a new list node\n        # 67. Create a new list node\n        # 68. Create a new list node\n        # 69. Create a new list node\n        # 70. Create a new list node\n        # 71. Create a new list node\n        # 72. Create a new list node\n        # 73. Create a new list node\n        # 74. Create a new list node\n        # 75. Create a new list node\n        # 76. Create a new list node\n        # 77. Create a new list node\n        # 78. Create a new list node\n        # 79. Create a new list node\n        # 80. Create a new list node\n        # 81. Create a new list node\n        # 82. Create a new list node\n        # 83. Create a new list node\n        # 84. Create a new list node\n        # 85. Create a new list node\n        # 86. Create a new list node"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new linked list\n        # 2. Create a new node\n        # 3. Add the values of the linked lists\n        # 4. Add the values of the linked lists\n        # 5. Return the new linked list\n        \n        # 1. Create a new linked list\n        new_list = ListNode()\n        \n        # 2. Create a new node\n        new_node = new_list\n        \n        # 3. Add the values of the linked lists\n        while l1 or l2:\n            if l1:\n                new_node.val += l1.val\n                l1 = l1.next\n            if l2:\n                new_node.val += l2.val\n                l2 = l2.next\n            if new_node.val >= 10:\n                new_node.next = ListNode(new_node.val // 10)\n                new_node.val = new_node.val % 10\n            else:\n                new_node.next = None\n            if l1 or l2:\n                new_node = new_node.next\n                if l1:\n                    new_node.next = ListNode()\n                if l2:\n                    new_node.next = ListNode()\n            new_node = new_node.next\n        \n        # 4. Return the new linked list\n        return new_list"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new linked list\n        # 2. Add the values of the two linked lists\n        # 3. Return the new linked list\n        \n        # 1. Create a new linked list\n        new_list = ListNode()\n        \n        # 2. Add the values of the two linked lists\n        # 2.1. Create a pointer to the new linked list\n        new_list_ptr = new_list\n        \n        # 2.2. Create a pointer to the first node of the first linked list\n        l1_ptr = l1\n        \n        # 2.3. Create a pointer to the first node of the second linked list\n        l2_ptr = l2\n        \n        # 2.4. Create a variable to store the sum of the two numbers\n        sum = 0\n        \n        # 2.5. Create a variable to store the carry over\n        carry_over = 0\n        \n        # 2.6. Loop through the two linked lists\n        while l1_ptr is not None or l2_ptr is not None:\n            \n            # 2.7. If the first linked list is not None, add the value of the first node to the sum\n            if l1_ptr is not None:\n                sum += l1_ptr.val\n                \n            # 2.8. If the second linked list is not None, add the value of the second node to the sum\n            if l2_ptr is not None:\n                sum += l2_ptr.val\n                \n            # 2.9. If the sum is greater than 9, add the carry over to the sum\n            if sum > 9:\n                sum = sum % 10\n                carry_over = 1\n            else:\n                carry_over = 0\n                \n            # 2.10. Create a new node with the sum as its value\n            new_list_ptr.next = ListNode(sum)\n            \n            # 2.11. Move the pointer to the next node\n            new_list_ptr = new_list_ptr.next\n            \n            # 2.12. If the first linked list is not None, move the pointer to the next node\n            if l1_ptr is not None:\n                l1_ptr = l1_ptr.next\n                \n            # 2.13. If the second linked list is not None, move the pointer to the next node\n            if l2_ptr is not None:\n                l2_ptr = l2_ptr.next\n                \n            # 2.14. Reset the sum to 0\n            sum = 0\n            \n        # 2.15. If the carry over is 1, add a new node with the carry over as its value\n        if carry_over == 1:\n            new_list_ptr.next = ListNode(carry_over)\n            \n        # 2.16. Return the new linked list\n        return new_list.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a new list node\n        # 2. create a new list node\n        # 3. create a new list node\n        # 4. create a new list node\n        # 5. create a new list node\n        # 6. create a new list node\n        # 7. create a new list node\n        # 8. create a new list node\n        # 9. create a new list node\n        # 10. create a new list node\n        # 11. create a new list node\n        # 12. create a new list node\n        # 13. create a new list node\n        # 14. create a new list node\n        # 15. create a new list node\n        # 16. create a new list node\n        # 17. create a new list node\n        # 18. create a new list node\n        # 19. create a new list node\n        # 20. create a new list node\n        # 21. create a new list node\n        # 22. create a new list node\n        # 23. create a new list node\n        # 24. create a new list node\n        # 25. create a new list node\n        # 26. create a new list node\n        # 27. create a new list node\n        # 28. create a new list node\n        # 29. create a new list node\n        # 30. create a new list node\n        # 31. create a new list node\n        # 32. create a new list node\n        # 33. create a new list node\n        # 34. create a new list node\n        # 35. create a new list node\n        # 36. create a new list node\n        # 37. create a new list node\n        # 38. create a new list node\n        # 39. create a new list node\n        # 40. create a new list node\n        # 41. create a new list node\n        # 42. create a new list node\n        # 43. create a new list node\n        # 44. create a new list node\n        # 45. create a new list node\n        # 46. create a new list node\n        # 47. create a new list node\n        # 48. create a new list node\n        # 49. create a new list node\n        # 50. create a new list node\n        # 51. create a new list node\n        # 52. create a new list node\n        # 53. create a new list node\n        # 54. create a new list node\n        # 55. create a new list node\n        # 56. create a new list node\n        # 57. create a new list node\n        # 58. create a new list node\n        # 59. create a new list node\n        # 60. create a new list node\n        # 61. create a new list node\n        # 62. create a new list node\n        # 63. create a new list node\n        # 64. create a new list node\n        # 65. create a new list node\n        # 66. create a new list node\n        # 67. create a new list node\n        # 68. create a new list node\n        # 69. create a new list node\n        # 70. create a new list node\n        # 71. create a new list node\n        # 72. create a new list node\n        # 73. create a new list node\n        # 74. create a new list node\n        # 75. create a new list node\n        # 76. create a new list node\n        # 77. create a new list node\n        # 78. create a new list node\n        # 79. create a new list node\n        # 80. create a new list node\n        # 81. create a new list node\n        # 82. create a new list node\n        # 83. create a new list node\n        # 84. create a new list node\n        # 85. create a new list node\n        # 86. create a new list node"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums) - 2:\n            if nums[i+2] - nums[i] == nums[i+1] - nums[i]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums)-2:\n            if nums[i+2] - nums[i] == nums[i+1] - nums[i]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums) - 2:\n            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums)-2:\n            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums) - 2:\n            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        curr_len = 0\n        curr_words = []\n        for word in words:\n            if curr_len + len(word) + len(curr_words) > maxWidth:\n                res.append(self.justify(curr_words, maxWidth, curr_len))\n                curr_words = [word]\n                curr_len = len(word)\n            else:\n                curr_words.append(word)\n                curr_len += len(word)\n        res.append(self.justify(curr_words, maxWidth, curr_len))\n        return res\n\n    def justify(self, words, maxWidth, curr_len):\n        if len(words) == 1:\n            return words[0] + ' ' * (maxWidth - len(words[0]))\n        num_spaces = maxWidth - curr_len\n        num_spaces_per_word = num_spaces // (len(words) - 1)\n        num_extra_spaces = num_spaces % (len(words) - 1)\n        res = ''\n        for i in range(len(words) - 1):\n            res += words[i] + ' ' * num_spaces_per_word\n            if i < num_extra_spaces:\n                res += ' '\n        res += words[-1]\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            curr_len = len(words[i])\n            j = i + 1\n            while j < len(words) and curr_len + len(words[j]) + 1 <= maxWidth:\n                curr_len += len(words[j]) + 1\n                j += 1\n            if j == len(words):\n                res.append(' '.join(words[i:j]) + ' ' * (maxWidth - curr_len))\n            else:\n                num_spaces = maxWidth - curr_len\n                num_words = j - i\n                if num_words == 1:\n                    res.append(words[i] + ' ' * num_spaces)\n                else:\n                    avg_spaces = num_spaces // (num_words - 1)\n                    extra_spaces = num_spaces % (num_words - 1)\n                    res.append(words[i] + ' ' * avg_spaces + ' '.join(words[i+1:j] + [' '] * extra_spaces))\n                i = j\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            line = []\n            line_len = 0\n            while i < len(words) and line_len + len(words[i]) + len(line) <= maxWidth:\n                line.append(words[i])\n                line_len += len(words[i])\n                i += 1\n            if i == len(words):\n                res.append(' '.join(line) + ' ' * (maxWidth - len(line) - len(line) + 1))\n            else:\n                if len(line) == 1:\n                    res.append(line[0] + ' ' * (maxWidth - len(line[0])))\n                else:\n                    num_spaces = maxWidth - len(line) - len(line) + 1\n                    num_spaces_per_word = num_spaces // (len(line) - 1)\n                    num_extra_spaces = num_spaces % (len(line) - 1)\n                    res.append(' '.join(line[0:num_extra_spaces + 1] + [' ' * num_spaces_per_word] * (len(line) - 1)))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur_len = 0\n        cur_words = []\n        for word in words:\n            if cur_len + len(word) + len(cur_words) > maxWidth:\n                res.append(self.justify(cur_words, maxWidth, cur_len))\n                cur_words = []\n                cur_len = 0\n            cur_len += len(word)\n            cur_words.append(word)\n        if cur_words:\n            res.append(self.justify(cur_words, maxWidth, cur_len))\n        return res\n\n    def justify(self, words, maxWidth, cur_len):\n        if len(words) == 1:\n            return words[0] + ' ' * (maxWidth - len(words[0]))\n        num_spaces = maxWidth - cur_len\n        if len(words) == 2:\n            return words[0] + ' ' * num_spaces + words[1]\n        num_spaces_per_word = num_spaces // (len(words) - 1)\n        num_extra_spaces = num_spaces % (len(words) - 1)\n        res = ''\n        for i in range(len(words) - 1):\n            res += words[i] + ' ' * num_spaces_per_word\n            if num_extra_spaces:\n                res += ' '\n                num_extra_spaces -= 1\n        res += words[-1]\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            curr_len = len(words[i])\n            j = i + 1\n            while j < len(words) and curr_len + len(words[j]) + 1 <= maxWidth:\n                curr_len += len(words[j]) + 1\n                j += 1\n            if j == len(words):\n                res.append(' '.join(words[i:j]) + ' ' * (maxWidth - curr_len))\n            else:\n                num_spaces = maxWidth - curr_len\n                num_words = j - i\n                if num_words == 1:\n                    res.append(words[i] + ' ' * num_spaces)\n                else:\n                    avg_spaces = num_spaces // (num_words - 1)\n                    extra_spaces = num_spaces % (num_words - 1)\n                    res.append(words[i] + ' ' * avg_spaces + ' '.join(words[i+1:j] + [' '] * extra_spaces))\n                i = j\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area ="}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        words.sort(key=len)\n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word):\n            if word in memo:\n                return memo[word]\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in memo and right in memo:\n                    memo[word] = True\n                    return True\n                if left in memo and is_concatenated(right):\n                    memo[word] = True\n                    return True\n            memo[word] = False\n            return False\n        \n        memo = {}\n        res = []\n        for word in words:\n            if is_concatenated(word):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        words.sort(key=len)\n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        words.sort(key=len)\n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col, board):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row, board):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(row, col, board):\n                    board[row][col] = 1\n                    count += backtrack(row + 1, board)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0 for _ in range(n)] for _ in range(n)]\n        return backtrack(0, board)"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col, board):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row, board):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(row, col, board):\n                    board[row][col] = 1\n                    count += backtrack(row + 1, board)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0 for _ in range(n)] for _ in range(n)]\n        return backtrack(0, board)"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                self.count += 1\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        self.count = 0\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return self.count"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                self.count += 1\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        self.count = 0\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return self.count"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col, board):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row, board):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(row, col, board):\n                    board[row][col] = 1\n                    count += backtrack(row + 1, board)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0 for _ in range(n)] for _ in range(n)]\n        return backtrack(0, board)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n\n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n\n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n\n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}