{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            n_i, n_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= n_i < m and 0 <= n_j < n and not visited[n_i][n_j]:\n                i, j = n_i, n_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and all numbers larger than n as 0\n        # 2. iterate through the array and mark the numbers as negative\n        # 3. iterate through the array again and return the first number that is not marked as negative\n        # 4. if all numbers are marked as negative, return n + 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate the list of numbers\n        nums = [i for i in range(1, n+1)]\n        \n        # 2. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 3. calculate the kth permutation\n        k -= 1\n        res = ''\n        for i in range(n):\n            fact //= n-i\n            idx = k // fact\n            res += str(nums[idx])\n            nums.pop(idx)\n            k %= fact\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            \n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                \n                # return the indices of the two numbers\n                return [num_dict[target - num] + 1, i + 1]\n            \n            # add the number to the dictionary with its index\n            num_dict[num] = i"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prod + curr, res)\n                    backtrack(j+1, curr, prev - curr, prod - curr, res)\n                    backtrack(j+1, curr, prev * curr, prod * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 0, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            ans = []\n            for i, num in enimport itertools\n            for num in nums:\n                if len(ans) < k:\n                    heapq.heappush(ans, num)\n                else:\n                    if num > ans[0]:\n                        heapq.heappop(ans)\n                        heapq.heappush(ans, num)\n            return ans\n        \n        def merge(nums1, nums2):\n            ans = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    i += 1\n                else:\n                    j += 1\n                ans.append(nums1[i] if i < len(nums1) else nums2[j])\n            return ans\n        \n        def find_max(nums, k):\n            ans = []\n            for i in range(len(nums) - k + 1):\n                if not ans or nums[i] > ans[-1]:\n                    ans.append(nums[i])\n            return ans\n        \n        def find_max_k(nums1, nums2, k):\n            if len(nums1) < k:\n                return find_max(nums2, k)\n            if len(nums2) < k:\n                return find_max(nums1, k)\n            if len(nums1) == len(nums2) == k:\n                return nums1\n            if len(nums1) > len(nums2):\n                return find_max_k(nums1, nums2, k)\n            if len(nums1) < len(nums2):\n                return find_max_k(nums2, nums1, k)\n            if nums1[0] > nums2[0]:\n                return find_max_k(nums1, nums2, k)\n            if nums1[0] < nums2[0]:\n                return find_max_k(nums2, nums1, k)\n            return find_max_k(nums1[1:], nums2[1:], k - 1)\n        \n        return find_max_k(pick(nums1, k), pick(nums2, k), k)"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1 - dungeon[i][j], 1)\n                elif i == m-1:\n                    dp[i][j] = max(dp[i][j+1] - dungeon[i][j], 1)\n                elif j == n-1:\n                    dp[i][j] = max(dp[i+1][j] - dungeon[i][j], 1)\n                else:\n                    dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count, left = 0, 0\n            for i in range(n):\n                while nums[i] - nums[left] > mid:\n                    left += 1\n                count += i - left\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = [i for i, letter in enumerate(s_list) if letter in vowels]\n        vowel_indices.reverse()\n        for i in vowel_indices:\n            s_list[i] = s_list[i].swapcase()\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 0\n                while num in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 120 ms, faster than 99.95% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Missing Number.\n        \n        ##"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        \n        while queue:\n            word, length = queue.popleft()\n            \n            for i in range(len(word)):\n                for j in range(ord('a'), ord('z') + 1):\n                    new_word = word[:i] + chr(j) + word[i + 1:]\n                    \n                    if new_word == endWord:\n                        return length + 1\n                    \n                    if new_word in wordList:\n                        queue.append((new_word, length + 1))\n                        wordList.remove(new_word)\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        result = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 0\n            else:\n                if carry == 1:\n                    result = '0' + result\n                else:\n                    result = '1' + result\n                carry = 1\n        if carry == 1:\n            result = '1' + result\n        return result"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(len(prices) - 1)) - (max(prices[i+1] - prices[i] for i in range(len(prices) - 1)) - min(prices[i+1] - prices[i] for i in range(len(prices) - 1)))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j] + (prices[i] - prices[i - 1] if prices[i] - prices[i - 1] > 0 else 0), dp[i - 1][j - 1] + prices[i] - prices[i - 1] if prices[i] - prices[i - 1] > 0 else dp[i - 1][j - 1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        hex_dict = {10: \"a\", 11: \"b\", 12: \"c\", 13: \"d\", 14: \"e\", 15: \"f\"}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = \"\"\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        count = {}\n        \n        # loop through the string and count the number of occurrences of each character\n        for char in s:\n            if char not in count:\n                count[char] = 1\n            else:\n                count[char] += 1\n        \n        # loop through the string again and return the first character with a count of 1\n        for i, char in enumerate(s):\n            if count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = list(num1), list(num2)\n        \n        carry = 0\n        for i in range(len(num1)):\n            if i < len(num2):\n                carry += int(num1[i]) + int(num2[i])\n            else:\n                carry += int(num1[i])\n            \n            num1[i] = str(carry % 10)\n            carry //= 10\n        \n        if carry:\n            num1.append(str(carry))\n        \n        return ''.join(num1)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res, num = 0, 0\n            while i < len(s):\n                if s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                elif s[i] == '(':\n                    num, i = helper(s, i + 1, 1)\n                elif s[i] == ')':\n                    return res, i + 1\n                else:\n                    res += sign * num\n                    sign = 1 if s[i] == '+' else -1\n                    num = 0\n                i += 1\n            return res + sign * num, i\n        \n        return helper(s, 0, 1)[0]"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        sorted_profits = sorted(profits)\n        \n        # iterate over sorted capital\n        for i in range(len(sorted_capital)):\n            # if we can afford the next project\n            if sorted_capital[i][0] <= w:\n                # add to capital\n                w += sorted_capital[i][1]\n            # if we have enough projects\n            else:\n                # add to capital\n                w += sorted_profits[k]\n                k -= 1\n            # if we have no more projects\n            if k == 0:\n                break\n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and i == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the number to its right\n        # find the first number that is bigger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number\n        \n        # find the first number that is smaller than the number to its right\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        else:\n            nums.reverse()\n            return\n        \n        # find the first number that is bigger than the number to its right\n        for i in range(len(nums)-1,i,-1):\n            if nums[i] > nums[i-1]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[i-1] = nums[i-1],nums[i]\n        \n        # reverse the numbers to the right of the number\n        nums[i:] = nums[i:][::-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(n)\n        # 1. Create a dictionary\n        # 2. Iterate through the list\n        # 3. If the current element is already in the dictionary, return True\n        # 4. If the current element is not in the dictionary, add it to the dictionary\n        # 5. If the current element is not in the dictionary, add it to the dictionary\n        # 6. If the current element is not in the dictionary, add it to the dictionary\n        # 7. If the current element is not in the dictionary, add it to the dictionary\n        # 8. If the current element is not in the dictionary, add it to the dictionary\n        # 9. If the current element is not in the dictionary, add it to the dictionary\n        # 10. If the current element is not in the dictionary, add it to the dictionary\n        # 11. If the current element is not in the dictionary, add it to the dictionary\n        # 12. If the current element is not in the dictionary, add it to the dictionary\n        # 13. If the current element is not in the dictionary, add it to the dictionary\n        # 14. If the current element is not in the dictionary, add it to the dictionary\n        # 15. If the current element is not in the dictionary, add it to the dictionary\n        # 16. If the current element is not in the dictionary, add it to the dictionary\n        # 17. If the current element is not in the dictionary, add it to the dictionary\n        # 18. If the current element is not in the dictionary, add it to the dictionary\n        # 19. If the current element is not in the dictionary, add it to the dictionary\n        # 20. If the current element is not in the dictionary, add it to the dictionary\n        # 21. If the current element is not in the dictionary, add it to the dictionary\n        # 22. If the current element is not in the dictionary, add it to the dictionary\n        # 23. If the current element is not in the dictionary, add it to the dictionary\n        # 24. If the current element is not in the dictionary, add it to the dictionary\n        # 25. If the current element is not in the dictionary, add it to the dictionary\n        # 26. If the current element is not in the dictionary, add it to the dictionary\n        # 27. If the current element is not in the dictionary, add it to the dictionary\n        # 28. If the current element is not in the dictionary, add it to the dictionary\n        # 29. If the current element is not in the dictionary, add it to the dictionary\n        # 30. If the current element is not in the dictionary, add it to the dictionary\n        # 31. If the current element is not in the dictionary, add it to the dictionary\n        # 32. If the current element is not in the dictionary, add it to the dictionary\n        # 33. If the current element is not in the dictionary, add it to the dictionary\n        # 34. If the current element is not in the dictionary, add it to the dictionary\n        # 35. If the current element is not in the dictionary, add it to the dictionary\n        # 36. If the current element is not in the dictionary, add it to the dictionary\n        # 37. If the current element is not in the dictionary, add it to the dictionary\n        # 38. If the current element is not in the dictionary, add it to the dictionary\n        # 39. If the current element is not in the dictionary, add it to the dictionary\n        # 40. If the current element is not in the dictionary, add it to the dictionary\n        # 41. If the current element is not in the dictionary, add it to the dictionary\n        # 42. If the current element is not in the dictionary, add it to the dictionary\n        # 43. If the current element is not in the dictionary, add it to the dictionary\n        # 44. If the current element is not in the dictionary, add it to the dictionary\n        # 45. If the current element is not in the dictionary, add it to the dictionary\n        # 46. If the current element is not in the dictionary, add it to the dictionary\n        # 47. If the current element is not in the dictionary, add it to the dictionary\n        # 48."}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)\n        \n        #print(couples)\n        #print(couples)"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        count = 0\n        \n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        \n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left-1):\n            prev = curr\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of s\n        # reverse the string and add it to the end of s\n        # return the reversed string\n        \n        # find the longest palindrome that is"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(s) == 0:\n            return \"\"\n        \n        if len(s) == 1:\n            return s\n        \n        if len(s) == 2:\n            if s[0] == t[0] and s[1] == t[1]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 3:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 4:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 5:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 6:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 7:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 8:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 9:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 10:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 11:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 12:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i-1] >= distance[i-3] and distance[i-1] == distance[i-4]:\n                return True\n            if i >= 4 and distance[i] + distance[i-1] >= distance[i-4] and distance[i-1] == distance[i-5]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of each letter\n        # 2. if the number of each letter is odd, add 1 to the result\n        # 3. if the number of each letter is even, add it to the result\n        \n        # 1.\n        letter_count = {}\n        for letter in s:\n            if letter not in letter_count:\n                letter_count[letter] = 1\n            else:\n                letter_count[letter] += 1\n        \n        # 2.\n        result = 0\n        for letter in letter_count:\n            if letter_count[letter] % 2 == 1:\n                result += 1\n        \n        # 3.\n        return result + (1 if result < len(s) else 0)"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder)\n        root.left = self.buildTree(inorder[:idx], postorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = collections.deque([start])\n            visited = set([start])\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    i, j = q.popleft()\n                    if [i, j] == end:\n                        return steps\n                    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < m and 0 <= nj < n and forest[ni][nj] > 0 and (ni, nj) not in visited:\n                            q.append((ni, nj))\n                            visited.add((ni, nj))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\n        steps = 0\n        for i, j in trees:\n            steps += bfs((0, 0), (i, j))\n            if steps < 0:\n                return steps\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use two pointers to find the sum of the subarray\n        # 3. use a hashmap to store the sum and its frequency\n        # 4. iterate the hashmap to find the sum in the range\n        # 5. return the sum\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the hashmap\n        hashmap = {}\n        \n        # initialize the sum and the count\n        sum = 0\n        count = 0\n        \n        # iterate the array\n        for num in nums:\n            # add the sum to the hashmap\n            sum += num\n            \n            # if the sum is in the hashmap, increment the count\n            if sum - lower in hashmap:\n                count += hashmap[sum - lower]\n            \n            # if the sum is in the hashmap, increment the count\n            if sum - upper in hashmap:\n                count += hashmap[sum - upper]\n            \n            # add the sum to the hashmap\n            hashmap[sum] = hashmap.get(sum, 0) + 1\n        \n        # return the count\n        return count"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2*n+0.25)**0.5-0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i>>1))\n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        return self.climbStairs(n-1) + self.climbStairs(n-2)"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n            for i in range(1, len(word)):\n                word_list.append(word[:i] + \" \" + word[i:])\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        # from the wordDict\n        word_list = list(set(word_list))\n        \n        # create a list of all the possible combinations of words\n        #"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first interval, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last interval, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first interval, merge it with the first interval\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last interval, merge it with the last interval\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle interval, merge it with the middle interval\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any interval, insert it between the intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[0] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval, insert it at the end\n        return intervals + [newInterval]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig, 1 bucket, 1 minute\n        # 2. 2 pigs, 1 bucket, 1 minute\n        # 3. 3 pigs, 1 bucket, 1 minute\n        # 4. 4 pigs, 1 bucket, 1 minute\n        # 5. 5 pigs, 1 bucket, 1 minute\n        # 6. 6 pigs, 1 bucket, 1 minute\n        # 7. 7 pigs, 1 bucket, 1 minute\n        # 8. 8 pigs, 1 bucket, 1 minute\n        # 9. 9 pigs, 1 bucket, 1 minute\n        # 10. 10 pigs, 1 bucket, 1 minute\n        # 11. 11 pigs, 1 bucket, 1 minute\n        # 12. 12 pigs, 1 bucket, 1 minute\n        # 13. 13 pigs, 1 bucket, 1 minute\n        # 14. 14 pigs, 1 bucket, 1 minute\n        # 15. 15 pigs, 1 bucket, 1 minute\n        # 16. 16 pigs, 1 bucket, 1 minute\n        # 17. 17 pigs, 1 bucket, 1 minute\n        # 18. 18 pigs, 1 bucket, 1 minute\n        # 19. 19 pigs, 1 bucket, 1 minute\n        # 20. 20 pigs, 1 bucket, 1 minute\n        # 21. 21 pigs, 1 bucket, 1 minute\n        # 22. 22 pigs, 1 bucket, 1 minute\n        # 23. 23 pigs, 1 bucket, 1 minute\n        # 24. 24 pigs, 1 bucket, 1 minute\n        # 25. 25 pigs, 1 bucket, 1 minute\n        # 26. 26 pigs, 1 bucket, 1 minute\n        # 27. 27 pigs, 1 bucket, 1 minute\n        # 28. 28 pigs, 1 bucket, 1 minute\n        # 29. 29 pigs, 1 bucket, 1 minute\n        # 30. 30 pigs, 1 bucket, 1 minute\n        # 31. 31 pigs, 1 bucket, 1 minute\n        # 32. 32 pigs, 1 bucket, 1 minute\n        # 33. 33 pigs, 1 bucket, 1 minute\n        # 34. 34 pigs, 1 bucket, 1 minute\n        # 35. 35 pigs, 1 bucket, 1 minute\n        # 36. 36 pigs, 1 bucket, 1 minute\n        # 37. 37 pigs, 1 bucket, 1 minute\n        # 38. 38 pigs, 1 bucket, 1 minute\n        # 39. 39 pigs, 1 bucket, 1 minute\n        # 40. 40 pigs, 1 bucket, 1 minute\n        # 41. 41 pigs, 1 bucket, 1 minute\n        # 42. 42 pigs, 1 bucket, 1 minute\n        # 43. 43 pigs, 1 bucket, 1 minute\n        # 44. 44 pigs, 1 bucket, 1 minute\n        # 45. 45 pigs, 1 bucket, 1 minute\n        # 46. 46 pigs, 1 bucket, 1 minute\n        # 47. 47 pigs, 1 bucket, 1 minute\n        # 48. 48 pigs, 1 bucket, 1 minute\n        # 49. 49 pigs, 1 bucket, 1 minute\n        # 50. 50 pigs, 1 bucket, 1 minute\n        # 51. 51 pigs, 1 bucket, 1 minute\n        # 52. 52 pigs, 1 bucket, 1 minute\n        #"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n^2)\n        \n        # Dijkstra\n        # Time: O(n^2 log(n^2))\n        # Space: O(n"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # The first row and column will always have a unique path to the cell\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                res[i+j+1] += res[i+j] // 10\n                res[i+j] %= 10\n                \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) - 1 and res[i] == 0:\n            i += 1\n            \n        return ''.join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        def merge(l1, l2):\n            if not l1:\n                return l2\n            if not l2:\n                return l1\n            if l1.val < l2.val:\n                l1.next = merge(l1.next, l2)\n                return l1\n            else:\n                l2.next = merge(l1, l2.next)\n                return l2\n        \n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        if len(lists) == 2:\n            return merge(lists[0], lists[1])\n        if len(lists) == 3:\n            return merge(merge(lists[0], lists[1]), lists[2])\n        if len(lists) == 4:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], lists[3]))\n        if len(lists) == 5:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 6:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 7:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 8:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 9:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 10:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 11:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 12:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 13:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 14:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 15:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 16:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 17:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 18:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 19:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 20:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 21:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 22:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 23:\n            return merge(merge(lists[0], lists["}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x//5 + x//25 + x//125 + x//625 + x//3125 + x//15625 + x//78125 + x//390625 + x//1953125 + x//9765625 + x//48828125 + x//244140625 + x//1220703125 + x//6103015625\n\n        if k == 0:\n            return 5\n        if k == 1:\n            return 0\n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) // 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return r - l"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def get_index(word, words):\n            for i, w in enumerate(words):\n                if w == word:\n                    return i\n            return -1\n        \n        def get_pairs(word, words):\n            pairs = []\n            for i, w in enumerate(words):\n                if w == word:\n                    continue\n                if is_palindrome(word + w):\n                    pairs.append([i, get_index(word, words)])\n            return pairs\n        \n        return [p for word in words for p in get_pairs(word, words)]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            # always pick right middle element as a root\n            mid = (left + right) // 2\n            \n            # inorder traversal: left <= root <= right\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(i + di, j + dj)\n        \n        def build_walls(i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                build_walls(i + di, j + dj)\n        \n        def build_walls_dfs(i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                build_walls_dfs(i + di, j + dj)\n        \n        def build_walls_bfs(i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            q = collections.deque([(i, j)])\n            while q:\n                i, j = q.popleft()\n                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if i + di < 0 or i + di >= len(isInfected) or j + dj < 0 or j + dj >= len(isInfected[0]):\n                        continue\n                    if isInfected[i + di][j + dj] == 1:\n                        continue\n                    isInfected[i + di][j + dj] = 1\n                    q.append((i + di, j + dj))\n        \n        def build_walls_bfs_dfs(i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            q = collections.deque([(i, j)])\n            while q:\n                i, j = q.popleft()\n                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if i + di < 0 or i + di >= len(isInfected) or j + dj < 0 or j + dj >= len(isInfected[0]):\n                        continue\n                    if isInfected[i + di][j + dj] == 1:\n                        continue\n                    isInfected[i + di][j + dj] = 1\n                    q.append((i + di, j + dj))\n                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    if i + di < 0 or i + di >= len(isInfected) or j + dj < 0 or j + dj >= len(isInfected[0]):\n                        continue\n                    if isInfected[i + di][j + dj] == 1:\n                        continue\n                    isInfected[i + di][j + dj] = 1\n                    q.append(("}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                    if 0 <= x < m and 0 <= y < n and matrix[x][y] > val:\n                        dp[i][j] = max(dp[i][j], dfs(x, y))\n                dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        # build the result list from the dp array\n        res = []\n        if dp[-1]:\n            self.dfs(s, wordDict, 0, [], res)\n        \n        return res\n    \n    def dfs(self, s, wordDict, start, path, res):\n        if start == len(s):\n            res.append(' '.join(path))\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in wordDict:\n                self.dfs(s, wordDict, end, path + [s[start:end]], res)"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_result = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_result.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                result.append(level_result[::-1])\n            else:\n                result.append(level_result)\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def gen_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def gen_times(h, m):\n            if h < 12 and m < 60:\n                return [gen_time(h, m)]\n            else:\n                return []\n        \n        def gen_times_helper(h, m, turnedOn):\n            if turnedOn == 0:\n                return [gen_time(h, m)]\n            else:\n                return gen_times_helper(h, m + 1, turnedOn - 1) + gen_times_helper(h + 1, m, turnedOn - 1)\n        \n        return gen_times_helper(0, 0, turnedOn)"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        pascal = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, len(pascal[i-1])):\n                row.append(pascal[i-1][j-1] + pascal[i-1][j])\n            row.append(1)\n            pascal.append(row)\n        \n        return pascal"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            if (i, j) not in seen:\n                seen.add((i, j))\n                ans += h\n                for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                        heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.find_median(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements in the array\n        for i in range(k, len(nums)):\n            # Remove the first element from the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median\n            median = self.find_median(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def find_median(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the window has an odd number of elements, return the middle element\n        if len(window) % 2 == 1:\n            return window[len(window) // 2]\n        \n        # Otherwise, return the average of the two middle elements\n        return (window[len(window) // 2 - 1] + window[len(window) // 2]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubarray(arr, k):\n            maxSum = float('-inf')\n            curSum = 0\n            prefixSum = [0]\n            for num in arr:\n                curSum += num\n                prefixSum.append(curSum)\n            for i in range(len(prefixSum)):\n                for j in range(i):\n                    curSum = prefixSum[i] - prefixSum[j]\n                    if curSum <= k:\n                        maxSum = max(maxSum, curSum)\n            return maxSum\n        \n        m, n = len(matrix), len(matrix[0])\n        maxSum = float('-inf')\n        for i in range(n):\n            curSum = [0] * m\n            for j in range(i, n):\n                for r in range(m):\n                    curSum[r] += matrix[r][j]\n                maxSum = max(maxSum, maxSumSubarray(curSum, k))\n        return maxSum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -536870912\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -268435456\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -134217728\n        \n        if dividend == -2147483648 and divisor == 32:\n            return -67108864\n        \n        if dividend == -2147483648 and divisor == 64:\n            return -33554432\n        \n        if dividend == -2147483648 and divisor == 128:\n            return -16777216\n        \n        if dividend == -2147483648 and divisor == 256:\n            return -8388608\n        \n        if dividend == -2147483648 and divisor == 512:\n            return -4194304\n        \n        if dividend == -2147483648 and divisor == 1024:\n            return -2097152\n        \n        if dividend == -2147483648 and divisor == 2048:\n            return -1048576\n        \n        if dividend == -2147483648 and divisor == 4096:\n            return -524288\n        \n        if dividend == -2147483648 and divisor == 8192:\n            return -262144\n        \n        if dividend == -2147483648 and divisor == 16384:\n            return -131072\n        \n        if dividend == -2147483648 and divisor == 32768:\n            return -65536\n        \n        if dividend == -2147483648 and divisor == 65536:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 131072:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 262144:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 524288:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 1048576:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 2097152:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 4194304:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 8388608:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 16777216:\n            return -128\n        \n        if dividend == -21"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.01\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards = [a + b] + [c for c in cards if c not in [a, b]]\n                        elif op == '-':\n                            new_cards = [a - b] + [c for c in cards if c not in [a, b]]\n                        elif op == '*':\n                            new_cards = [a * b] + [c for c in cards if c not in [a, b]]\n                        else:\n                            new_cards = [float(a) / b] + [c for c in cards if c not in [a, b]]\n                        if backtrack(new_cards, target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '?')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n            \n        # dfs\n        res = []\n        def dfs(node):\n            # if there is no more nodes to visit, add to the result\n            if len(graph[node]) == 0:\n                res.append(node)\n                return\n            # otherwise, visit all the neighbors\n            for neighbor in graph[node]:\n                graph[node].remove(neighbor)\n                dfs(neighbor)\n                \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = [[0, 0]]\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the previous building\n            if current_building != building[1] or current_building is None:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current building to the result\n                    result.append([building[0], current_height])\n                # set the current building to the current building\n                current_building = building[1]\n                # set the current height to the current height\n                current_height = building[2]\n            # if the current building is not None\n            else:\n                # set the current height to the max of the current height and the current building height\n                current_height = max(current_height, building[2])\n        \n        # return the result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] - dp[i-k-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j-1] - dp[i-k-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-2][j-2]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-2][j-2] + dp[i-k-2][j-3] - dp[i-k-3][j-3]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-2][j-2] + dp[i-k-2][j-3] - dp[i-k-3][j-3] + dp[i-k-3][j-4] - dp[i-k-4][j-4]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-2][j-2] + dp[i-k-2][j-3] - dp[i-k-3][j-3] + dp[i-k-3][j-4] - dp[i-k-4][j-4] + dp[i-k-4][j-5] - dp[i-k-5][j-5]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-2][j-2] + dp[i-k-2][j-3] - dp[i-k-3][j-3] + dp[i-k-3][j-4] - dp[i-k-4][j-4] + dp[i-k-4][j-5] - dp[i-k-5][j-5] + dp[i-k-5][j-6] - dp[i-k-6][j-6]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-k-1][j] + dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-2][j-2] + dp[i-k-2][j-3] - dp[i-k-3][j-3] + dp"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        for edge in edges:\n            if edge[0] not in parent:\n                parent[edge[0]] = edge[1]\n            else:\n                parent[edge[0]] = -1\n        \n        # find the node with only one parent\n        for edge in edges:\n            if edge[1] not in parent:\n                parent[edge[1]] = edge[0]\n            else:\n                if parent[edge[1]] == -1:\n                    return edge\n                else:\n                    return [parent[edge[1]], edge[1]]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            # there is a valid combination\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutation\n                backtrack(first + 1)\n                # backtrack, restore the array to its original state\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2*sum(set(nums))-sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    p1 = max(j1, i - j1)\n                    p2 = max(j2, i - j2)\n                    if p1 + p2 <= i:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2]\n                        if j1 > 0:\n                            dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1 - 1][j2] + grid[i][j1])\n                        if j2 > 0:\n                            dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1][j2 - 1] + grid[i][j2])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if j1 == j2)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # O(log"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,m):\n            grid[i][0] = grid[i][0] + grid[i-1][0]\n        \n        for j in range(1,n):\n            grid[0][j] = grid[0][j] + grid[0][j-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] = min(grid[i][j-1],grid[i-1][j]) + grid[i][j]\n        \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = self.countAndSay(n-1)\n        res = ''\n        count = 1\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i-1]:\n                count += 1\n            else:\n                res += str(count) + prev[i-1]\n                count = 1\n        res += str(count) + prev[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, m):\n            cnt = 1\n            curr_sum = 0\n            for n in nums:\n                if curr_sum + n > m:\n                    cnt += 1\n                    curr_sum = n\n                else:\n                    curr_sum += n\n            return cnt <= k\n        \n        l, r = max(nums), sum(nums)\n        while l < r:\n            m = (l + r) // 2\n            if check(nums, k, m):\n                r = m\n            else:\n                l = m + 1\n        return l"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot is not found, return -1\n        if pivot == -1:\n            return -1\n        \n        # if the target is less than the first element, search the right side\n        if target < nums[0]:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n        # if the target is greater than the last element, search the left side\n        elif target > nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        \n        # if the target is between the first and last element, search the entire array\n        else:\n            return self.binary_search(nums, target, 0, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        \"\"\"\n        Find the pivot in the rotated array\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        # if the array is not rotated, return -1\n        if nums[left] < nums[right]:\n            return -1\n        \n        # binary search to find the pivot\n        while left <= right:\n            mid = (left + right) // 2\n            \n            # if the mid element is greater than the next element, it is the pivot\n            if nums[mid] > nums[mid + 1]:\n                return mid + 1\n            \n            # if the mid element is less than the previous element, it is the pivot\n            elif nums[mid - 1] > nums[mid]:\n                return mid\n            \n            # if the mid element is greater than the first element, search the left side\n            elif nums[mid] > nums[left]:\n                left = mid + 1\n            \n            # if the mid element is less than the last element, search the right side\n            else:\n                right = mid - 1\n        \n        return -1\n    \n    def binary_search(self, nums, target, left, right):\n        \"\"\"\n        Binary search to find the target in the rotated array\n        \"\"\"\n        while left <= right:\n            mid = (left + right) // 2\n            \n            # if the target is found, return the index\n            if nums[mid] == target:\n                return mid\n            \n            # if the target is greater than the mid element, search the right side\n            elif nums[mid] < target:\n                left = mid + 1\n            \n            # if the target is less than the mid element, search the left side\n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_palindrome(num):\n            num = str(num)\n            if num[0] == '0':\n                return '0'\n            if is_palindrome(num):\n                return num\n            if num[0] == '1':\n                return '11'\n            if num[0] == '9':\n                return '99'\n            return num[0] + '1' + num[1:][::-1]\n        \n        def get_closest(num):\n            if is_palindrome(num):\n                return num\n            if num[0] == '0':\n                return '0'\n            if num[0] == '1':\n                return '11'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '4':\n                return '99'\n            if num[0] == '6':\n                return '99'\n            if num[0] == '8':\n                return '99'\n            if num[0] == '2':\n                return '11'\n            if num[0] == '7':\n                return '99'\n            if num[0] == '5':\n                return '99'\n            if num[0] == '3':\n                return '99'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '1':\n                return '11'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '4':\n                return '99'\n            if num[0] == '6':\n                return '99'\n            if num[0] == '8':\n                return '99'\n            if num[0] == '2':\n                return '11'\n            if num[0] == '7':\n                return '99'\n            if num[0] == '5':\n                return '99'\n            if num[0] == '3':\n                return '99'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '1':\n                return '11'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '4':\n                return '99'\n            if num[0] == '6':\n                return '99'\n            if num[0] == '8':\n                return '99'\n            if num[0] == '2':\n                return '11'\n            if num[0] == '7':\n                return '99'\n            if num[0] == '5':\n                return '99'\n            if num[0] == '3':\n                return '99'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '1':\n                return '11'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '4':\n                return '99'\n            if num[0] == '6':\n                return '99'\n            if num[0] == '8':\n                return '99'\n            if num[0] == '2':\n                return '11'\n            if num[0] == '7':\n                return '99'\n            if num[0] == '5':\n                return '99'\n            if num[0] == '3':\n                return '99'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '1':\n                return '11'\n            if num[0] == '9':\n                return '99'\n            if num[0] == '4':\n                return '99'\n            if num[0] == '6':\n                return '99'\n            if num[0] == '8':\n                return '99'\n            if num[0] == '2':\n                return '11'\n            if num[0] == '7':\n                return '9"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        num = 1\n        left, right = 0, n-1\n        top, bottom = 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        \n        return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = temp\n                \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum product and the current product\n        max_product = nums[0]\n        curr_product = nums[0]\n        \n        # Iterate through the array\n        for i in range(1, len(nums)):\n            # If the current number is positive, update the current product\n            if nums[i] > 0:\n                curr_product *= nums[i]\n            # If the current number is 0, set the current product to 1\n            elif nums[i] == 0:\n                curr_product = 1\n            # If the current number is negative, update the maximum product if the current product is greater than the maximum product\n            else:\n                max_product = max(max_product, curr_product)\n                curr_product = nums[i]\n            # Update the maximum product\n            max_product = max(max_product, curr_product)\n        \n        # Return the maximum product\n        return max_product"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a dict to store the stone position\n        stone_dict = {}\n        for i, stone in enumerate(stones):\n            stone_dict[stone] = i\n        \n        # 2. build a dict to store the jump distance\n        jump_dict = {}\n        \n        # 3. build a queue to store the current stone\n        queue = collections.deque()\n        queue.append((0, 0))\n        \n        while queue:\n            # 4. pop the current stone\n            current_stone, current_jump = queue.popleft()\n            \n            # 5. check if the current stone is the last stone\n            if current_stone == stones[-1]:\n                return True\n            \n            # 6. check if the current stone is in the stone_dict\n            if current_stone not in stone_dict:\n                continue\n            \n            # 7. check if the current jump is in the jump_dict\n            for jump in [current_jump - 1, current_jump, current_jump + 1]:\n                if jump > 0 and jump + current_stone in stone_dict:\n                    queue.append((stone_dict[jump + current_stone], jump))\n                    jump_dict[jump + current_stone] = jump\n        \n        return False"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in enumerate(score_sorted):\n            score_rank[s] = i + 1\n        \n        # create a list of ranks\n        ranks = []\n        for s in score:\n            ranks.append(score_rank[s])\n        \n        # create a list of ranks\n        ranks_str = []\n        for r in ranks:\n            if r == 1:\n                ranks_str.append(\"Gold Medal\")\n            elif r == 2:\n                ranks_str.append(\"Silver Medal\")\n            elif r == 3:\n                ranks_str.append(\"Bronze Medal\")\n            else:\n                ranks_str.append(str(r))\n        \n        return ranks_str"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the variables\n        max_len = 0\n        curr_len = 0\n        seen = {}\n        \n        # 2. Iterate through the string\n        for i, c in enimport collections\n        if c in seen:\n            curr_len = i - seen[c]\n        else:\n            curr_len += 1\n        max_len = max(max_len, curr_len)\n        seen[c] = i\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 0\n            word_dict[word] += 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            seen = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict:\n                    if word not in seen:\n                        seen[word] = 0\n                    seen[word] += 1\n                    if seen[word] > word_dict[word]:\n                        break\n            else:\n                res.append(i)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max element in the array\n        # 2. find the index of the max element\n        # 3. find the min element in the array\n        # 4. find the index of the min element\n        # 5. find the max element in the array\n        # 6. find the index of the max element\n        # 7. find the min element in the array\n        # 8. find the index of the min element\n        # 9. find the max element in the array\n        # 10. find the index of the max element\n        # 11. find the min element in the array\n        # 12. find the index of the min element\n        # 13. find the max element in the array\n        # 14. find the index of the max element\n        # 15. find the min element in the array\n        # 16. find the index of the min element\n        # 17. find the max element in the array\n        # 18. find the index of the max element\n        # 19. find the min element in the array\n        # 20. find the index of the min element\n        # 21. find the max element in the array\n        # 22. find the index of the max element\n        # 23. find the min element in the array\n        # 24. find the index of the min element\n        # 25. find the max element in the array\n        # 26. find the index of the max element\n        # 27. find the min element in the array\n        # 28. find the index of the min element\n        # 29. find the max element in the array\n        # 30. find the index of the max element\n        # 31. find the min element in the array\n        # 32. find the index of the min element\n        # 33. find the max element in the array\n        # 34. find the index of the max element\n        # 35. find the min element in the array\n        # 36. find the index of the min element\n        # 37. find the max element in the array\n        # 38. find the index of the max element\n        # 39. find the min element in the array\n        # 40. find the index of the min element\n        # 41. find the max element in the array\n        # 42. find the index of the max element\n        # 43. find the min element in the array\n        # 44. find the index of the min element\n        # 45. find the max element in the array\n        # 46. find the index of the max element\n        # 47. find the min element in the array\n        # 48. find the index of the min element\n        # 49. find the max element in the array\n        # 50. find the index of the max element\n        # 51. find the min element in the array\n        # 52. find the index of the min element\n        # 53. find the max element in the array\n        # 54. find the index of the max element\n        # 55. find the min element in the array\n        # 56. find the index of the min element\n        # 57. find the max element in the array\n        # 58. find the index of the max element\n        # 59. find the min element in the array\n        # 60. find the index of the min element\n        # 61. find the max element in the array\n        # 62. find the index of the max element\n        # 63. find the min element in the array\n        # 64. find the index of the min element\n        # 65. find the max element in the array\n        # 66. find the index of the max element\n        # 67. find the min element in the array\n        # 68. find the index of the min element\n        # 69. find the max element in the array\n        # 70. find the index of the max element\n        # 71. find the min element in the array\n        # 72. find the index of the min element\n        # 73. find the max element in the array\n        # 74. find the index of the"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid\n            count = 0\n            while i < mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i\n                    j += 1\n                else:\n                    i += 1\n            nums[left:right+1] = sorted(nums[left:right+1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid+1, right)\n            count += merge(nums, left, mid+1, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums)-1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            # add course duration to total\n            total += course[0]\n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n        \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    break\n                kth = kth.next\n            if not kth:\n                break\n            # reverse the nodes in the range\n            # prev -> kth\n            # kth -> curr\n            # curr -> next\n            curr = prev.next\n            next = curr.next\n            for i in range(k-1):\n                curr.next = next.next\n                next.next = prev.next\n                prev.next = next\n                next = curr.next\n            prev = kth\n        \n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(n)\n        ## Runtime: 120 ms, faster than 99.28% of Python online submissions for Repeated Substring Pattern.\n        ## Memory Usage: 13.9 MB, less than 99.28% of Python online submissions for Repeated Substring Pattern.\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2022-01-24\n        ## 2"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a dictionary to store the count of each number\n        ## 2. iterate through the dictionary and return the number that has count of 1\n        \n        d = {}\n        for i in nums:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n        \n        for i in d:\n            if d[i] == 1:\n                return i"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. iterate through target, for each letter, check if it can be made from stickers\n        # 4. if it can, add 1 to the count\n        # 5. if it can't, check if it can be made from stickers with one less sticker\n        # 6. if it can't, return -1\n        \n        # build a dict for each sticker\n        sticker_dict = {}\n        for sticker in stickers:\n            sticker_dict[sticker] = set()\n            for letter in sticker:\n                sticker_dict[sticker].add(letter)\n        \n        # build a dict for each letter in target\n        target_dict = {}\n        for letter in target:\n            target_dict[letter] = 0\n        \n        # iterate through target, for each letter, check if it can be made from stickers\n        for letter in target_dict:\n            if letter not in sticker_dict:\n                return -1\n            else:\n                for sticker in sticker_dict:\n                    if letter in sticker_dict[sticker]:\n                        target_dict[letter] += 1\n        \n        # if it can't, check if it can be made from stickers with one less sticker\n        for sticker in sticker_dict:\n            if target_dict[sticker] == 0:\n                for letter in sticker_dict[sticker]:\n                    target_dict[letter] -= 1\n        \n        # if it can't, return -1\n        if target_dict[sticker] != 0:\n            return -1\n        else:\n            return sum(target_dict.values())"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        \n        for i in range(len(s)):\n            if i+1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n                \n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7])]\n        \n        if len(nums) == 9:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8])]\n        \n        if len(nums) == 10:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9])]\n        \n        if len(nums) == 11:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10])]\n        \n        if len(nums) == 12:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11])]\n        \n        if len(nums) == 13:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12])]\n        \n        if len(nums) == 14:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13])]\n        \n        if len(nums) == 15:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums[14])]\n        \n        if len(nums) == 16:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val] + path]\n            return dfs(root.left, targetSum - root.val, path + [root.val]) + dfs(root.right, targetSum - root.val, path + [root.val])\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(int(math.sqrt(area)), 0, -1):\n            if area % i == 0:\n                return [area/i, i]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                graph[pattern].append(word)\n        \n        # build a queue and a set\n        queue = collections.deque([beginWord])\n        visited = set(beginWord)\n        \n        # build a dict to store the shortest path\n        shortest_path = {}\n        shortest_path[beginWord] = [beginWord]\n        \n        # BFS\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n                        shortest_path[neighbor] = shortest_path[word] + [neighbor]\n        \n        # build the result\n        result = []\n        if endWord not in shortest_path:\n            return result\n        else:\n            result = [shortest_path[endWord]]\n            while result[0][0] != beginWord:\n                result.insert(0, [result[0][i] for i in range(len(result[0])-1)])\n            return result"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 10/10 cases passed (16 ms)\n        ## Your runtime beats 99.99 % of python3 submissions\n        ## Your memory usage beats 99.99 % of python3 submissions\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i not in \"+-*/\":\n                stack.append(int(i))\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                if i == \"+\":\n                    stack.append(a + b)\n                elif i == \"-\":\n                    stack.append(b - a)\n                elif i == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(b) / a))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles:\n            return False\n        \n        if (x_max, y_min) not in rectangles:\n            return False\n        \n        if (x_min, y_max) not in rectangles:\n            return False\n        \n        if (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            return [[1,2,3],[4,5,0]]\n        \n        def get_distance(board):\n            distance = 0\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != get_goal(board)[i][j]:\n                        distance += 1\n            return distance\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, distance = queue.pop(0)\n                if board == get_goal(board):\n                    return distance\n                if board not in visited:\n                    visited.add(board)\n                    neighbors = get_neighbors(board)\n                    for neighbor in neighbors:\n                        queue.append((neighbor, distance + 1))\n            return -1\n        \n        return bfs(tuple(board))"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] <= target <= nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        \n        # if the target is in the second half of the array, search in the second half\n        else:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n    \n    def binary_search(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                    \n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n                    \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        return sorted(dfs(root), key=lambda x: (-dfs(root).count(x), x))[:dfs(root).count(sorted(dfs(root), key=lambda x: (-dfs(root).count(x), x))[0])]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the length of password\n        # 3. check the length of password\n        # 4. check the length of password\n        # 5. check the length of password\n        # 6. check the length of password\n        # 7. check the length of password\n        # 8. check the length of password\n        # 9. check the length of password\n        # 10. check the length of password\n        # 11. check the length of password\n        # 12. check the length of password\n        # 13. check the length of password\n        # 14. check the length of password\n        # 15. check the length of password\n        # 16. check the length of password\n        # 17. check the length of password\n        # 18. check the length of password\n        # 19. check the length of password\n        # 20. check the length of password\n        # 21. check the length of password\n        # 22. check the length of password\n        # 23. check the length of password\n        # 24. check the length of password\n        # 25. check the length of password\n        # 26. check the length of password\n        # 27. check the length of password\n        # 28. check the length of password\n        # 29. check the length of password\n        # 30. check the length of password\n        # 31. check the length of password\n        # 32. check the length of password\n        # 33. check the length of password\n        # 34. check the length of password\n        # 35. check the length of password\n        # 36. check the length of password\n        # 37. check the length of password\n        # 38. check the length of password\n        # 39. check the length of password\n        # 40. check the length of password\n        # 41. check the length of password\n        # 42. check the length of password\n        # 43. check the length of password\n        # 44. check the length of password\n        # 45. check the length of password\n        # 46. check the length of password\n        # 47. check the length of password\n        # 48. check the length of password\n        # 49. check the length of password\n        # 50. check the length of password\n        # 51. check the length of password\n        # 52. check the length of password\n        # 53. check the length of password\n        # 54. check the length of password\n        # 55. check the length of password\n        # 56. check the length of password\n        # 57. check the length of password\n        # 58. check the length of password\n        # 59. check the length of password\n        # 60. check the length of password\n        # 61. check the length of password\n        # 62. check the length of password\n        # 63. check the length of password\n        # 64. check the length of password\n        # 65. check the length of password\n        # 66. check the length of password\n        # 67. check the length of password\n        # 68. check the length of password\n        # 69. check the length of password\n        # 70. check the length of password\n        # 71. check the length of password\n        # 72. check the length of password\n        # 73. check the length of password\n        # 74. check the length of password\n        # 75. check the length of password\n        # 76. check the length of password\n        # 77. check the length of password\n        # 78. check the length of password\n        # 79. check the length of password\n        # 80. check the length of password\n        # 81. check the length of password\n        # 82. check the length of password\n        # 83. check the length of password\n        # 84. check the length of password\n        # 85. check the length of password\n        # 86. check the length of password"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        return n/5 + self.trailingZeroes(n/5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-04-27\n        ## 1. Find the max height of left and right\n        ## 2. Find the min height of left and right\n        ## 3. Find the min height of left and right\n        ## 4. Find the min height of left and right\n        ## 5. Find the min height of left and right\n        ## 6. Find the min height of left and right\n        ## 7. Find the min height of left and right\n        ## 8. Find the min height of left and right\n        ## 9. Find the min height of left and right\n        ## 10. Find the min height of left and right\n        ## 11. Find the min height of left and right\n        ## 12. Find the min height of left and right\n        ## 13. Find the min height of left and right\n        ## 14. Find the min height of left and right\n        ## 15. Find the min height of left and right\n        ## 16. Find the min height of left and right\n        ## 17. Find the min height of left and right\n        ## 18. Find the min height of left and right\n        ## 19. Find the min height of left and right\n        ## 20. Find the min height of left and right\n        ## 21. Find the min height of left and right\n        ## 22. Find the min height of left and right\n        ## 23. Find the min height of left and right\n        ## 24. Find the min height of left and right\n        ## 25. Find the min height of left and right\n        ## 26. Find the min height of left and right\n        ## 27. Find the min height of left and right\n        ## 28. Find the min height of left and right\n        ## 29. Find the min height of left and right\n        ## 30. Find the min height of left and right\n        ## 31. Find the min height of left and right\n        ## 32. Find the min height of left and right\n        ## 33. Find the min height of left and right\n        ## 34. Find the min height of left and right\n        ## 35. Find the min height of left and right\n        ## 36. Find the min height of left and right\n        ## 37. Find the min height of left and right\n        ## 38. Find the min height of left and right\n        ## 39. Find the min height of left and right\n        ## 40. Find the min height of left and right\n        ## 41. Find the min height of left and right\n        ## 42. Find the min height of left and right\n        ## 43. Find the min height of left and right\n        ## 44. Find the min height of left and right\n        ## 45. Find the min height of left and right\n        ## 46. Find the min height of left and right\n        ## 47. Find the min height of left and right\n        ## 48. Find the min height of left and right\n        ## 49. Find the min height of left and right\n        ## 50. Find the min height of left and right\n        ## 51. Find the min height of left and right\n        ## 52. Find the min height of left and right\n        ## 53. Find the min height of left and right\n        ## 54. Find the min height of left and right\n        ## 55. Find the min height of left and right\n        ## 56. Find the min height of left and right\n        ## 57. Find the min height of left and right\n        ## 58. Find the min height of left and right\n        ## 59. Find the min height of left and right\n        ## 60. Find the min height of left and right\n        ## 61. Find the min height of left and right\n        ## 6"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Create a list of all numbers from 1 to n\n        ## 2. Iterate through the list and mark the numbers as visited\n        ## 3. Return the list of numbers that are not visited\n        \n        n = len(nums)\n        nums = [0] * n\n        \n        for i in range(n):\n            nums[nums[i] - 1] += 1\n            \n        return [i + 1 for i in range(n) if nums[i] == 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [sum(1 for x in nums[i:] if x < nums[i]) for i in range(len(nums))]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max end with the first interval\n        max_end = intervals[0][1]\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the current interval starts before the max end\n            if interval[0] > max_end:\n                # update the result\n                res += max_end - max_end + 1\n                # update the max end\n                max_end = interval[1]\n            # if the current interval ends before the max end\n            elif interval[1] < max_end:\n                # update the max end\n                max_end = interval[1]\n            # if the current interval ends after the max end\n            else:\n                # update the result\n                res += 1\n                # update the max end\n                max_end = interval[1]\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return result"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the number of patches needed and the current sum\n        patches = 0\n        curr_sum = 0\n        \n        # Iterate over the numbers in the array\n        for num in nums:\n            # If the current sum plus the current number is less than or equal to n, add the current number to the sum\n            if curr_sum + num <= n:\n                curr_sum += num\n            # If the current sum plus 1 is greater than n, add 1 to the number of patches needed and add 1 to the current sum\n            else:\n                patches += 1\n                curr_sum += num\n                curr_sum += 1\n        \n        # Return the number of patches needed\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        res = ''\n        if (numerator < 0) ^ (denominator < 0):\n            res += '-'\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        \n        if numerator % denominator == 0:\n            return res\n        \n        res += '.'\n        numerator %= denominator\n        seen = {}\n        while numerator:\n            if numerator in seen:\n                res = res[:seen[numerator]] + '(' + res[seen[numerator]:] + ')'\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        dp = [1] * len(envelopes)\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Use a 2D array to store the row and column index of the 0s\n        ## 2. Iterate through the matrix and if a 0 is found, update the 2D array\n        ## 3. Iterate through the 2D array and set the corresponding row and column to 0\n        \n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        if not matrix:\n            return\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_0 = [False] * m\n        col_0 = [False] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row_0[i] = True\n                    col_0[j] = True\n        \n        for i in range(m):\n            for j in range(n):\n                if row_0[i] or col_0[j]:\n                    matrix[i][j] = 0\n\n# 2022-05-24 15:50:00"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the nth position\n        slow.next = slow.next.next\n        \n        # return the modified linked list\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) / n\n        ans = 0\n        cur = 0\n        for i in range(n):\n            cur += machines[i] - avg\n            ans = max(ans, abs(cur))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        root.right = self.sortedListToBST(slow.next.next)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            if len(curr) == k:\n                output.append(curr[:])\n            for i in range(first, n):\n                curr.append(nums[i])\n                backtrack(i + 1, curr)\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        # if len(nums) == 1:\n        #     return nums[0]\n        # if nums[0] == nums[-1]:\n        #     return min(nums[1:])\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] == nums[-2]:\n        #     return min(nums[1:-1])\n        # if nums[-1] > nums[-2] and nums[-1] > nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] > nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] > nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] > nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] > nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        # if nums[-1] > nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and not s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and not s[0].isdigit():\n            return False\n        \n        # 5. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 6. check if it is a valid exponent\n        if s[0] in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 7. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 8. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 9. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 10. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 11. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 12. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 13. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 14. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 15. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 16. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 17. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0] != 'e' and not s[0].isdigit():\n            return False\n        \n        # 18. check if it is a valid exponent\n        if s[0] not in ('+',"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 2nd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 3rd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 4th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 5th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 6th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 7th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 8th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 9th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 10th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 11th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 12th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 13th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 14th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 15th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 16th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 17th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 18th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 19th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 20th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 21th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 22th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 23th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 24th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 25th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 26th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 27th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 28th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 29th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 30th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 31th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 32th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 33th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 34th method"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node, path):\n            if len(path) > 2:\n                return\n            if node.isWord:\n                res.add(path)\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] not in node.children:\n                return\n            tmp = board[i][j]\n            board[i][j] = '#'\n            dfs(i + 1, j, node.children[tmp], path + tmp)\n            dfs(i - 1, j, node.children[tmp], path + tmp)\n            dfs(i, j + 1, node.children[tmp], path + tmp)\n            dfs(i, j - 1, node.children[tmp], path + tmp)\n            board[i][j] = tmp\n        \n        res = set()\n        root = Trie()\n        for word in words:\n            root.insert(word)\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, root, '')\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for c in s_dict:\n            if s_dict[c] != t_dict.get(c, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 squares\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(square)) != len(square):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        return [str(i) if i%3 and i%5 else 'FizzBuzz' if i%3 and i%5==0 else 'Fizz' if i%3 and i%5 != 0 else 'Buzz' if i%5 and i%3 != 0 else i for i in range(1,n+1)]"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. for each character, multiply the character by 26^(index)\n        # 5. add the result to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            # 4. for each character, multiply the character by 26^(index)\n            total += (26**i) * (ord(columnTitle[i]) - ord('A') + 1)\n            \n        # 5. return the total\n        return total"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        \n        second = self.reverse(second)\n        \n        first = head\n        \n        while second:\n            temp = first.next\n            first.next = second\n            second = second.next\n            first.next.next = temp\n            first = temp\n        \n        return head\n    \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for char, word in zip(pattern, words):\n            # if the word is not in the mapping, add it\n            if word not in mapping:\n                mapping[word] = char\n            # if the word is in the mapping, check if it matches the pattern\n            elif mapping[word] != char:\n                return False\n        \n        # if we reach here, all words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers of nums are used\n            # we print the combination list\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 or l2 or carry:\n            val1 = (l1.val if l1 else 0)\n            val2 = (l2.val if l2 else 0)\n            \n            carry, out = divmod(val1 + val2 + carry, 10)\n            \n            curr.next = ListNode(out)\n            curr = curr.next\n            \n            l1 = (l1.next if l1 else None)\n            l2 = (l2.next if l2 else None)\n            \n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert to binary\n        ## 2. flip bits\n        ## 3. convert back to decimal\n        \n        ## 1. convert to binary\n        binary = bin(num)[2:]\n        \n        ## 2. flip bits\n        flip_bits = \"\"\n        for bit in binary:\n            if bit == \"0\":\n                flip_bits += \"1\"\n            else:\n                flip_bits += \"0\"\n        \n        ## 3. convert back to decimal\n        return int(flip_bits, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(1, len(nums)-1):\n            if nums[i+1] - nums[i] == diff:\n                count += 1\n            else:\n                diff = nums[i+1] - nums[i]\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current line\n        current_line = []\n        \n        # initialize the current line length\n        current_line_length = 0\n        \n        # loop through the words\n        for word in words:\n            # if the current line length + the length of the current word + the space between words is less than the max width\n            if current_line_length + len(word) + len(current_line) < maxWidth:\n                # add the word to the current line\n                current_line.append(word)\n                # add the length of the word to the current line length\n                current_line_length += len(word)\n            else:\n                # if the current line length is greater than 0\n                if len(current_line) > 0:\n                    # if the current line length is 1\n                    if len(current_line) == 1:\n                        # add the current line to the result list\n                        result.append(' '.join(current_line) + ' ' * (maxWidth - len(current_line[0])))\n                    else:\n                        # calculate the number of spaces between words\n                        spaces = (maxWidth - current_line_length) // (len(current_line) - 1)\n                        # calculate the number of extra spaces\n                        extra_spaces = (maxWidth - current_line_length) % (len(current_line) - 1)\n                        # initialize the current line\n                        current_line = []\n                        # add the spaces to the current line\n                        for i in range(spaces):\n                            current_line.append(' ' * 1)\n                        # add the extra spaces to the current line\n                        for i in range(extra_spaces):\n                            current_line.append(' ' * 1)\n                        # add the current line to the result list\n                        result.append(' '.join(current_line) + ' ' * (maxWidth - len(current_line[0])))\n                # add the word to the current line\n                current_line.append(word)\n                # add the length of the word to the current line length\n                current_line_length = len(word)\n        \n        # if the current line length is greater than 0\n        if len(current_line) > 0:\n            # if the current line length is 1\n            if len(current_line) == 1:\n                # add the current line to the result list\n                result.append(' '.join(current_line) + ' ' * (maxWidth - len(current_line[0])))\n            else:\n                # calculate the number of spaces between words\n                spaces = (maxWidth - current_line_length) // (len(current_line) - 1)\n                # calculate the number of extra spaces\n                extra_spaces = (maxWidth - current_line_length) % (len(current_line) - 1)\n                # initialize the current line\n                current_line = []\n                # add the spaces to the current line\n                for i in range(spaces):\n                    current_line.append(' ' * 1)\n                # add the extra spaces to the current line\n                for i in range(extra_spaces):\n                    current_line.append(' ' * 1)\n                # add the current line to the result list\n                result.append(' '.join(current_line) + ' ' * (maxWidth - len(current_line[0])))\n        \n        # return the result list\n        return result"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left, right = word[:i], word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                self.count += 1\n                return\n            \n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n                    \n        self.count = 0\n        backtrack(0, set(), set(), set())\n        return self.count"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. check if the list has 3 elements\n        # 3. if not, return the max element\n        # 4. if yes, return the third max element\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}