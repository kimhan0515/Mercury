{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert all negative numbers to positive numbers\n        ## 2. mark all numbers in the range [1, len(nums)] as visited\n        ## 3. iterate through the array and mark the numbers as visited\n        ## 4. iterate through the array again and return the first number that is not visited\n        \n        ## 1. convert all negative numbers to positive numbers\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = float('inf')\n        \n        ## 2. mark all numbers in the range [1, len(nums)] as visited\n        for i in range(len(nums)):\n            num = abs(nums[i])\n            if num <= len(nums):\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        ## 3. iterate through the array and mark the numbers as visited\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        \n        ## 4. iterate through the array again and return the first number that is not visited\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate the list of numbers from 1 to n\n        nums = [i for i in range(1, n+1)]\n        \n        # 2. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 3. calculate the kth permutation\n        k -= 1\n        res = \"\"\n        for i in range(n-1, -1, -1):\n            # 3.1 calculate the index of the ith digit\n            idx = k // fact\n            # 3.2 calculate the digit\n            res += str(nums[idx])\n            # 3.3 remove the digit from the list\n            nums.pop(idx)\n            # 3.4 update k\n            k %= fact\n            # 3.5 update the factorial\n            fact //= i\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if op == None:\n                    backtrack(j+1, curr_num, curr_num, res, num[i])\n                else:\n                    backtrack(j+1, curr + curr_num, curr_num, res, op + '+' + num[i])\n                    backtrack(j+1, curr - curr_num, -curr_num, res, op + '-' + num[i])\n                    backtrack(j+1, curr - prev + prev * curr_num, prev * curr_num, res, op + '*' + num[i])\n        \n        res = []\n        backtrack(0, 0, 0, res, None)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        n = len(s)\n        if n <= k:\n            return s\n        if n % k == 0:\n            return s[:k] + '-' + self.licenseKeyFormatting(s[k:], k)\n        else:\n            return s[:n % k] + '-' + self.licenseKeyFormatting(s[n % k:], k)"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we can't, return -1\n        \n        ## 1. check if we can complete the circuit\n        ## 2. if we can, return the starting station\n        ## 3. if we"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if out and out[-1] < nums[i]:\n                        out.pop()\n                    out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while nums1 or nums2:\n                if not nums1:\n                    return out + nums2\n                if not nums2:\n                    return out + nums1\n                if nums1[0] > nums2[0]:\n                    out.append(nums1.pop(0))\n                else:\n                    out.append(nums2.pop(0))\n            return out\n        \n        def find_max(nums1, nums2, k):\n            out = []\n            for i in range(k):\n                if len(nums1) > len(nums2):\n                    out.append(nums1.pop(0))\n                elif len(nums1) < len(nums2):\n                    out.append(nums2.pop(0))\n                else:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1.pop(0))\n                    else:\n                        out.append(nums2.pop(0))\n            return out\n        \n        def find_max_k(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) > len(nums2):\n                return nums1[:-k]\n            if len(nums1) < len(nums2):\n                return nums2[:-k]\n            if nums1[-1] > nums2[-1]:\n                return nums1[:-k]\n            if nums1[-1] < nums2[-1]:\n                return nums2[:-k]\n            return nums1[:-k]\n        \n        if len(nums1) + len(nums2) < k:\n            return []\n        if len(nums1) == 0:\n            return nums2[:k]\n        if len(nums2) == 0:\n            return nums1[:k]\n        if k == 1:\n            return max(nums1, nums2)\n        if k == 2:\n            return merge(nums1, nums2)\n        if k == len(nums1) + len(nums2):\n            return find_max(nums1, nums2, k)\n        if k == len(nums1):\n            return find_max(nums1, nums2, k)\n        if k == len(nums2):\n            return find_max(nums1, nums2, k)\n        if k == len(nums1) + 1:\n            return find_max_k(nums1, nums2, k)\n        if k == len(nums2) + 1:\n            return find_max_k(nums1, nums2, k)\n        if k == 3:\n            return merge(pick(nums1, 2), pick(nums2, 2))\n        if k == 4:\n            return merge(pick(nums1, 3), pick(nums2, 2))\n        if k == 5:\n            return merge(pick(nums1, 3), pick(nums2, 3))\n        if k == 6:\n            return merge(pick(nums1, 4), pick(nums2, 3))\n        if k == 7:\n            return merge(pick(nums1, 4), pick(nums2, 4))\n        if k == 8:\n            return merge(pick(nums1, 5), pick(nums2, 4))\n        if k == 9:\n            return merge(pick(nums1, 5), pick(nums2, 5))\n        if k == 10:\n            return merge(pick(nums1, 6), pick(nums2, 5))\n        if k == 11:\n            return merge(pick(num"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            m = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= m:\n                    j += 1\n                cnt += j - i - 1\n            if cnt < k:\n                l = m + 1\n            else:\n                r = m\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_length = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                current_num = num\n                current_length = 1\n                \n                while current_num + 1 in nums_set:\n                    current_num += 1\n                    current_length += 1\n                    \n                max_length = max(max_length, current_length)\n                \n        return max_length"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Subtract the sum of all the numbers in the range [0, n] from the sum of all the numbers in the array\n        ## 4. Return the result\n        \n        ## Initialization\n        n = len(nums)\n        sum_all = sum(nums)\n        sum_range = (n * (n + 1)) // 2\n        \n        ## Return the result\n        return sum_range - sum_all"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        result = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if b[i] == '1':\n                carry += 1\n            if carry % 2 == 1:\n                result = '1' + result\n            else:\n                result = '0' + result\n            carry //= 2\n        if carry == 1:\n            result = '1' + result\n        return result"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if target < nums[mid]:\n                    right = mid - 1\n                elif target > nums[mid]:\n                    left = mid + 1\n                else:\n                    index = mid\n                    if find_left_index:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return 0\n        \n        if nums[0] == 0:\n            return -1\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(len(nums)):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices):\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for i in range(len(prices)-1))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1, k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0], dp[j-1][1] + prices[i])\n                dp[j][1] = max(dp[j][1], dp[j-1][0] - prices[i])\n        \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 2 ** 32 + num\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        return ''.join(hex_list[::-1])"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary with key as character and value as index\n        # create a list to store the index of the first occurence of each character\n        # iterate through the string and check if the character is already in the dictionary\n        # if it is, then remove it from the dictionary and add the index to the list\n        # if it is not, then add the character to the dictionary and add the index to the list\n        # return the first element in the list\n        \n        d = {}\n        l = []\n        for i in range(len(s)):\n            if s[i] in d:\n                l.remove(d[s[i]])\n            else:\n                d[s[i]] = i\n                l.append(i)\n        if len(l) == 0:\n            return -1\n        else:\n            return l[0]"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        if indexDiff < 0 or valueDiff < 0:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n                    return True\n        \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return 1 + left + right"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            sum = int(num1[i]) + int(num2[i]) + carry\n            carry = sum // 10\n            res.append(str(sum % 10))\n        \n        for i in range(len(num1), len(num2)):\n            sum = int(num2[i]) + carry\n            carry = sum // 10\n            res.append(str(sum % 10))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                    continue\n                if s[i] == '(':\n                    res, i = helper(s, i + 1, 1)\n                elif s[i] == ')':\n                    return res, i + 1\n                else:\n                    num = 0\n                    while i < len(s) and s[i].isdigit():\n                        num = num * 10 + int(s[i])\n                        i += 1\n                    res += sign * num\n                    if i < len(s) and s[i] == '+':\n                        sign = 1\n                        i += 1\n                    elif i < len(s) and s[i] == '-':\n                        sign = -1\n                        i += 1\n            return res, i\n        \n        return helper(s, 0, 1)[0]"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the profits and capital by capital\n        # sort the"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and i == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the point\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is not greater than k, return False\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        # print(couples)\n        \n        # print(couples[0][0])\n        # print(couples[0][1])\n        \n        # print(couples[1][0])\n        # print(couples[1][1])\n        \n        # print(couples[2][0])\n        # print(couples[2][1])\n        \n        # print(couples[3][0])\n        # print(couples[3][1])\n        \n        # print(couples[4][0])\n        # print(couples[4][1])\n        \n        # print(couples[5][0])\n        # print(couples[5][1])\n        \n        # print(couples[6][0])\n        # print(couples[6][1])\n        \n        # print(couples[7][0])\n        # print(couples[7][1])\n        \n        # print(couples[8][0])\n        # print(couples[8][1])\n        \n        # print(couples[9][0])\n        # print(couples[9][1])\n        \n        # print(couples[10][0])\n        # print(couples[10][1])\n        \n        # print(couples[11][0])\n        # print(couples[11][1])\n        \n        # print(couples[12][0])\n        # print(couples[12][1])\n        \n        # print(couples[13][0])\n        # print(couples[13][1])\n        \n        # print(couples[14][0])\n        # print(couples[14][1])\n        \n        # print(couples[15][0])\n        # print(couples[15][1])\n        \n        # print(couples[16][0])\n        # print(couples[16][1])\n        \n        # print(couples[17][0])\n        # print(couples[17][1])\n        \n        # print(couples[18][0])\n        # print(couples[18][1])\n        \n        # print(couples[19][0])\n        # print(couples[19][1])\n        \n        # print(couples[20][0])\n        # print(couples[20][1])\n        \n        # print(couples[21][0])\n        # print(couples[21][1])\n        \n        # print(couples[22][0])\n        # print(couples[22][1])\n        \n        # print(couples[23][0])\n        # print(couples[23][1])\n        \n        # print(couples[24][0])\n        # print(couples[24][1])\n        \n        # print(couples[25][0])\n        # print(couples[25][1])\n        \n        # print(couples[26][0])\n        # print(couples[26][1])\n        \n        # print(couples[27][0])\n        # print(couples[27][1])\n        \n        # print(couples[28][0])\n        # print(couples[28][1])\n        \n        # print(couples[29][0])\n        # print(couples[29][1])\n        \n        # print(couples[30][0])\n        # print(couples[30][1])\n        \n        # print(couples[31][0])\n        # print(couples[31][1])\n        \n        # print(couples[32][0])\n        # print(couples[32][1])\n        \n        # print(couples[33][0])\n        # print(couples[33][1])\n        \n        # print(couples[34][0])\n        # print(couples[34"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1:\n                ans.append(word)\n            elif set(word.lower()) <= row2:\n                ans.append(word)\n            elif set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(s) == 0:\n            return \"\"\n        \n        if len(s) == 1:\n            return s\n        \n        if len(s) == 2:\n            if s[0] == t[0] and s[1] == t[1]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 3:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 4:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 5:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 6:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 7:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 8:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 9:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 10:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 11:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 12:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character\n        # 2. iterate through the hashmap and add the max of odd and even values to the result\n        # 3. if the hashmap has a value of 1, add 1 to the result\n        # 4. return the result\n        \n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        result = 0\n        for key in hashmap:\n            if hashmap[key] % 2 == 0:\n                result += hashmap[key]\n            else:\n                result += hashmap[key] - 1\n        \n        if len(hashmap) == 1:\n            return result + 1\n        else:\n            return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0]+1, cur[1]), (cur[0]-1, cur[1]), (cur[0], cur[1]+1), (cur[0], cur[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        steps = bfs(start, (len(forest)-1, len(forest[0])-1))\n        if steps == -1:\n            return -1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use two pointers to find the range sum\n        # 3. use a hashmap to store the range sum and its count\n        # 4. use a prefix sum to store the range sum\n        # 5. use a hashmap to store the range sum and its count\n        # 6. use a prefix sum to store the range sum\n        # 7. use a hashmap to store the range sum and its count\n        # 8. use a prefix sum to store the range sum\n        # 9. use a hashmap to store the range sum and its count\n        # 10. use a prefix sum to store the range sum\n        # 11. use a hashmap to store the range sum and its count\n        # 12. use a prefix sum to store the range sum\n        # 13. use a hashmap to store the range sum and its count\n        # 14. use a prefix sum to store the range sum\n        # 15. use a hashmap to store the range sum and its count\n        # 16. use a prefix sum to store the range sum\n        # 17. use a hashmap to store the range sum and its count\n        # 18. use a prefix sum to store the range sum\n        # 19. use a hashmap to store the range sum and its count\n        # 20. use a prefix sum to store the range sum\n        # 21. use a hashmap to store the range sum and its count\n        # 22. use a prefix sum to store the range sum\n        # 23. use a hashmap to store the range sum and its count\n        # 24. use a prefix sum to store the range sum\n        # 25. use a hashmap to store the range sum and its count\n        # 26. use a prefix sum to store the range sum\n        # 27. use a hashmap to store the range sum and its count\n        # 28. use a prefix sum to store the range sum\n        # 29. use a hashmap to store the range sum and its count\n        # 30. use a prefix sum to store the range sum\n        # 31. use a hashmap to store the range sum and its count\n        # 32. use a prefix sum to store the range sum\n        # 33. use a hashmap to store the range sum and its count\n        # 34. use a prefix sum to store the range sum\n        # 35. use a hashmap to store the range sum and its count\n        # 36. use a prefix sum to store the range sum\n        # 37. use a hashmap to store the range sum and its count\n        # 38. use a prefix sum to store the range sum\n        # 39. use a hashmap to store the range sum and its count\n        # 40. use a prefix sum to store the range sum\n        # 41. use a hashmap to store the range sum and its count\n        # 42. use a prefix sum to store the range sum\n        # 43. use a hashmap to store the range sum and its count\n        # 44. use a prefix sum to store the range sum\n        # 45. use a hashmap to store the range sum and its count\n        # 46. use a prefix sum to store the range sum\n        # 47. use a hashmap to store the range sum and its count\n        # 48. use a prefix sum to store the range sum\n        # 49. use a hashmap to store the range sum and its count\n        # 50. use a prefix sum to store the range sum\n        # 51. use a hashmap to store the range sum and its count\n        # 52. use a prefix sum to store the range sum\n        # 53. use a hashmap to store the range sum and its count\n        # 54. use a prefix sum to store the range sum\n        # 55. use a hashmap to store the range sum and its count\n        # 56. use a prefix sum to store the range sum\n        # 57. use a hashmap to store the range sum and its count\n        # 58. use a prefix sum to store the range sum\n        # 59. use a hashmap to store the range sum and its count\n        # 60. use"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the middle row\n        # 4. Find the number of coins in the first row\n        # 5. Find the number of coins in the second row\n        # 6. Find the number of coins in the third row\n        # 7. Find the number of coins in the fourth row\n        # 8. Find the number of coins in the fifth row\n        # 9. Find the number of coins in the sixth row\n        # 10. Find the number of coins in the seventh row\n        # 11. Find the number of coins in the eighth row\n        # 12. Find the number of coins in the ninth row\n        # 13. Find the number of coins in the tenth row\n        # 14. Find the number of coins in the eleventh row\n        # 15. Find the number of coins in the twelfth row\n        # 16. Find the number of coins in the thirteenth row\n        # 17. Find the number of coins in the fourteenth row\n        # 18. Find the number of coins in the fifteenth row\n        # 19. Find the number of coins in the sixteenth row\n        # 20. Find the number of coins in the seventeenth row\n        # 21. Find the number of coins in the eighteenth row\n        # 22. Find the number of coins in the nineteenth row\n        # 23. Find the number of coins in the twentieth row\n        # 24. Find the number of coins in the twenty-first row\n        # 25. Find the number of coins in the twenty-second row\n        # 26. Find the number of coins in the twenty-third row\n        # 27. Find the number of coins in the twenty-fourth row\n        # 28. Find the number of coins in the twenty-fifth row\n        # 29. Find the number of coins in the twenty-sixth row\n        # 30. Find the number of coins in the twenty-seventh row\n        # 31. Find the number of coins in the twenty-eighth row\n        # 32. Find the number of coins in the twenty-ninth row\n        # 33. Find the number of coins in the thirty-first row\n        # 34. Find the number of coins in the thirty-second row\n        # 35. Find the number of coins in the thirty-third row\n        # 36. Find the number of coins in the thirty-fourth row\n        # 37. Find the number of coins in the thirty-fifth row\n        # 38. Find the number of coins in the thirty-sixth row\n        # 39. Find the number of coins in the thirty-seventh row\n        # 40. Find the number of coins in the thirty-eighth row\n        # 41. Find the number of coins in the thirty-ninth row\n        # 42. Find the number of coins in the forty-first row\n        # 43. Find the number of coins in the forty-second row\n        # 44. Find the number of coins in the forty-third row\n        # 45. Find the number of coins in the forty-fourth row\n        # 46. Find the number of coins in the forty-fifth row\n        # 47. Find the number of coins in the forty-sixth row\n        # 48. Find the number of coins in the forty-seventh row\n        # 49. Find the number of coins in the forty-eighth row\n        # 50. Find the number of coins in the forty-ninth row\n        # 51. Find the number of coins in the fifty-first row\n        # 52. Find the number of coins in the fifty-second row\n        # 53. Find the number of coins in the fifty-third row\n        # 54. Find the number of coins in the fifty-fourth row\n        # 55. Find the number of coins in the fifty-fifth row\n        # 56. Find the number of coins in the fifty"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            for j in range(len(res)-1,-1,-1):\n                res.append(res[j]+2**i)\n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = []\n        for word in s.split():\n            word_list_s.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_list_"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (not left or left.val < node.val) and (not right or right.val > node.val):\n                return valid(node.left, left, node) and valid(node.right, node, right)\n            else:\n                return False\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last interval in the list, add it to the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first interval in the list, add it to the beginning\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first interval in the list, merge the intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = [intervals[0][0], intervals[0][1]]\n            return intervals\n        \n        # if the new interval overlaps with the last interval in the list, merge the intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = [intervals[-1][0], intervals[-1][1]]\n            return intervals\n        \n        # if the new interval overlaps with the middle interval in the list, merge the intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = [intervals[i][0], intervals[i][1]]\n                return intervals\n        \n        # if the new interval does not overlap with any interval in the list, insert the new interval\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any interval in the list, append the new interval\n        intervals.append(newInterval)\n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. create a min heap with the min of each list\n        # 3. create a max heap with the max of each list\n        # 4. while the min heap has more than 1 element, pop the min element from the min heap and add the max element from the max heap to the min heap\n        # 5. return the range\n        \n        min_heap = []\n        max_heap = []\n        for i in range(len(nums)):\n            heapq.heappush(min_heap, (nums[i][0], i, 0))\n            heapq.heappush(max_heap, (-nums[i][0], i, 0))\n        \n        min_val = min_heap[0][0]\n        max_val = -max_heap[0][0]\n        range_min = min_val\n        range_max = max_val\n        \n        while len(min_heap) == len(max_heap):\n            min_val, i, j = heapq.heappop(min_heap)\n            max_val = -heapq.heappop(max_heap)[0]\n            if max_val - min_val < range_max - range_min:\n                range_min = min_val\n                range_max = max_val\n            if j + 1 < len(nums[i]):\n                heapq.heappush(min_heap, (nums[i][j + 1], i, j + 1))\n                heapq.heappush(max_heap, (-nums[i][j + 1], i, j + 1))\n        \n        return [range_min, range_max]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        heap = [(grid[0][0], 0, 0)]\n        while heap:\n            time, i, j = heapq.heappop(heap)\n            if (i, j) == (n - 1, n - 1):\n                return time\n            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    heapq.heappush(heap, (max(time, grid[ni][nj]), ni, nj))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m x n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # set the first row to 1\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # set the first column to 1\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # iterate through the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == \"0\":\n            res.pop()\n            \n        return \"\".join(res)"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper():\n            return False\n        else:\n            return True"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did the code run on Leetcode: Yes\n        \n        ## Approach:\n        ## 1. Iterate through the array\n        ## 2. For each element, find the max profit\n        ## 3. Return the max profit\n        \n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                if prices[j] > prices[i]:\n                    max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n                \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        queue = collections.deque([s])\n        seen = set([s])\n        while queue:\n            s = queue.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    queue.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i+1] if i+1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x//5\n        \n        lo, hi = 0, 10**10\n        while lo < hi:\n            mid = (lo + hi)//2\n            if f(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(word):\n            return word == word[::-1]\n        \n        def get_pairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if is_palindrome(word[i:]):\n                    pairs.append(i)\n                if i and is_palindrome(word[:i]):\n                    pairs.append(i + len(word) - 1)\n            return pairs\n        \n        pairs = []\n        for i in range(len(words)):\n            for j in get_pairs(words[i]):\n                if i != j:\n                    pairs.append([i, j])\n        return pairs"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, r, c):\n            q = deque([(r, c)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for r in range(len(isInfected)):\n                    for c in range(len(isInfected[0])):\n                        if isInfected[r][c] == 1:\n                            infected.add((r, c))\n                if not infected:\n                    break\n                q = deque(infected)\n                while q:\n                    r, c = q.popleft()\n                    for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                        if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                            isInfected[nr][nc] = 2\n                            q.append((nr, nc))\n                walls += 1\n            return walls\n        \n        walls = build_walls(isInfected)\n        for r in range(len(isInfected)):\n            for c in range(len(isInfected[0])):\n                if isInfected[r][c] == 1:\n                    spread(isInfected, r, c)\n        return walls"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_len = 1\n        \n        for d in dirs:\n            x, y = i + d[0], j + d[1]\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = s.split(\" \")\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_list_s_in_dict_11.append(word)"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_length = len(queue)\n            level_result = []\n            \n            for i in range(level_length):\n                node = queue.pop(0)\n                level_result.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 1:\n                level_result.reverse()\n                \n            result.append(level_result)\n            level += 1\n            \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + ':' + str(m).zfill(2)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.extend(get_times(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = curr_i + di, curr_j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters into lowercase letters\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(len(nums) - k):\n            # Remove the leftmost element from the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i + k])\n            \n            # Find the median\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the average of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.left.val + root.right.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    q = collections.deque()\n                    q.append(0)\n                    for i in range(m + 1):\n                        while q and q[-1] < i:\n                            q.pop()\n                        if q:\n                            res = max(res, sums[i] - sums[q[0]])\n                        q.append(i)\n            return res\n\n        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums = [max(sums[i] - k, 0) for i in range(m)]\n                sums = [0] + sums\n                q = collections.deque()\n                q.append(0)\n                for i in range(m + 1):\n                    while q and q[-1] < i:\n                        q.pop()\n                    if q:\n                        res = max(res, sums[i] - sums[q[0]])\n                    q.append(i)\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i*j == 0 or i == len(board)-1 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, 24):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        if p[0] != '*':\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '?'):\n            if self.isMatch(s, p[1:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JBK0JJK68YQ\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n            \n        # dfs\n        res = []\n        def dfs(node):\n            # terminator\n            if len(res) == 0:\n                res.append(node)\n            if node not in graph:\n                return\n            # process\n            for neighbor in graph[node]:\n                dfs(neighbor)\n            # revert\n            res.append(node)\n            \n        dfs(\"JFK\")\n        return res"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        curr_height = 0\n        \n        # initialize the current building\n        curr_building = None\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the current building is None, set it to the current building\n            if curr_building is None:\n                curr_building = building\n            # if the current building is not None and the current building is not the same as the current building, add the current building to the result list\n            elif curr_building[0] != building[0]:\n                result.append([curr_building[0], curr_height])\n                curr_building = building\n            # if the current building is not None and the current building is the same as the current building, update the current height\n            else:\n                curr_height = max(curr_height, building[2])\n        \n        # add the last building to the result list\n        result.append([curr_building[0], curr_height])\n        \n        # return the result list\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1,len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j],triangle[i-1][j-1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the edge that has the node with two parents\n        # 3. find the node that has the edge that has the node with two parents\n        # 4. return the edge that has the node with two parents\n        \n        # 1. find the node with two parents\n        parent_dict = {}\n        for edge in edges:\n            if edge[0] not in parent_dict:\n                parent_dict[edge[0]] = []\n            parent_dict[edge[0]].append(edge[1])\n        \n        # 2. find the edge that has the node with two parents\n        for edge in edges:\n            if edge[1] in parent_dict and edge[0] in parent_dict[edge[1]]:\n                return edge\n        \n        # 3. find the node that has the edge that has the node with two parents\n        for edge in edges:\n            if edge[1] not in parent_dict:\n                parent_dict[edge[1]] = []\n            parent_dict[edge[1]].append(edge[0])\n        \n        # 4. return the edge that has the node with two parents\n        for edge in edges:\n            if edge[0] in parent_dict and edge[1] in parent_dict[edge[0]]:\n                return edge\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            # add permutation to the list of permutations\n            if first == n:   permutations.append(nums[:])\n\n            # consider all remaining integers\n            for i in range(first, n):\n\n                # skip duplicates\n                if i != first and nums[i] == nums[first]:\n                    continue\n\n                # place i-th integer first\n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n\n                # use next integer to complete the permutation\n                backtrack(first + 1)\n\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n\n        n = len(nums)\n        permutations = []\n        backtrack()\n        return permutations"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 1 = 0\n        ## 1 ^ 0 = 1\n        ## 2 ^ 2 = 0\n        ## 2 ^ 1 = 3\n        ## 3 ^ 1 = 2\n        ## 3 ^ 0 = 3\n        ## 4 ^ 4 = 0\n        ## 4 ^ 5 = 5\n        ## 5 ^ 5 = 0\n        ## 5 ^ 6 = 7\n        ## 6 ^ 6 = 0\n        ## 6 ^ 7 = 9\n        ## 7 ^ 7 = 0\n        ## 8 ^ 8 = 0\n        ## 8 ^ 9 = 10\n        ## 9 ^ 9 = 0\n        ## 10 ^ 10 = 0\n        ## 11 ^ 11 = 0\n        ## 12 ^ 12 = 0\n        ## 13 ^ 13 = 0\n        ## 14 ^ 14 = 0\n        ## 15 ^ 15 = 0\n        ## 16 ^ 16 = 0\n        ## 17 ^ 17 = 0\n        ## 18 ^ 18 = 0\n        ## 19 ^ 19 = 0\n        ## 20 ^ 20 = 0\n        ## 21 ^ 21 = 0\n        ## 22 ^ 22 = 0\n        ## 23 ^ 23 = 0\n        ## 24 ^ 24 = 0\n        ## 25 ^ 25 = 0\n        ## 26 ^ 26 = 0\n        ## 27 ^ 27 = 0\n        ## 28 ^ 28 = 0\n        ## 29 ^ 29 = 0\n        ## 30 ^ 30 = 0\n        ## 31 ^ 31 = 0\n        ## 32 ^ 32 = 0\n        ## 33 ^ 33 = 0\n        ## 34 ^ 34 = 0\n        ## 35 ^ 35 = 0\n        ## 36 ^ 36 = 0\n        ## 37 ^ 37 = 0\n        ## 38 ^ 38 = 0\n        ## 39 ^ 39 = 0\n        ## 40 ^ 40 = 0\n        ## 41 ^ 41 = 0\n        ## 42 ^ 42 = 0\n        ## 43 ^ 43 = 0\n        ## 44 ^ 44 = 0\n        ## 45 ^ 45 = 0\n        ## 46 ^ 46 = 0\n        ## 47 ^ 47 = 0\n        ## 48 ^ 48 = 0\n        ## 49 ^ 49 = 0\n        ## 50 ^ 50 = 0\n        ## 51 ^ 51 = 0\n        ## 52 ^ 52 = 0\n        ## 53 ^ 53 = 0\n        ## 54 ^ 54 = 0\n        ## 55 ^ 55 = 0\n        ## 56 ^ 56 = 0\n        ## 57 ^ 57 = 0\n        ## 58 ^ 58 = 0\n        ## 59 ^ 59 = 0\n        ## 60 ^ 60 = 0\n        ## 61 ^ 61 = 0\n        ## 62 ^ 62 = 0\n        ## 63 ^ 63 = 0\n        ## 64 ^ 64 = 0\n        ## 65 ^ 65 = 0\n        ## 66 ^ 66 = 0\n        ## 67 ^ 67 = 0\n        ## 68 ^ 68 = 0\n        ## 69 ^ 69 = 0\n        ## 70 ^ 70 = 0\n        ## 71 ^ 71 ="}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into a list of words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    p1 = max(j1 - 1, 0)\n                    p2 = min(j1 + 1, n - 1)\n                    p3 = max(j2 - 1, 0)\n                    p4 = min(j2 + 1, n - 1)\n                    for p in [p1, p2, p3, p4]:\n                        if grid[i][p] != -1:\n                            dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][p1][p2] + (grid[i][j1] if j1 == p else 0) + (grid[i][j2] if j2 == p else 0))\n        return dp[n - 1][n - 1][n - 1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 1:\n            return True\n        \n        max_reach = 0\n        \n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n            \n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132132221\"\n        \n        if n == 12:\n            return \"311311222123213221131112311312211\"\n        \n        if n == 13:\n            return \"132113111231131122112131221131122211\"\n        \n        if n == 14:\n            return \"1113122113311213213222123132113123113122112132221132122212313211312311312211\"\n        \n        if n == 15:\n            return \"311311222123213221131112311312211213222113212221231321131231131221121322211321222123132113123113122112132221132122212313211312311312211\"\n        \n        if n == 16:\n            return \"1321131112311311221121312211311222112132221132122212313211312311312211213222113212221231321131231131221121322211321222123132113123113122112132221132122212313211312311312211\"\n        \n        if n == 17:\n            return \"1113122113311213213222123132113123113122112132221132122212313211312311312211213222113212221231321131231131221121322211321222123132113123113122112132221132122212313211312311312211\"\n        \n        if n == 18:\n            return \"31131122212321322113111231131221121322211"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(maxSum):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > maxSum:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] <= target <= nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        # if the target is in the second half of the array, search in the second half\n        else:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return mid + 1\n            elif nums[mid] < nums[mid - 1]:\n                return mid\n            elif nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n    def binary_search(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res, start):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates, target - candidates[i], path + [candidates[i]], res, i)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res, 0)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the string\n        length = len(n)\n        \n        # 2. get the number of digits in the string\n        digits = length // 2\n        \n        # 3. get the left and right halves of the string\n        left = n[:digits]\n        right = n[digits:]\n        \n        # 4. get the possible palindromes\n        possible = [int(left + right), int(left + \"0\" + right[::-1]), int(left + \"1\" + right[1:]), int(left + \"9\" + right[1:])]\n        \n        # 5. get the closest palindrome\n        closest = min(possible, key=lambda x: abs(x - int(n)))\n        \n        # 6. return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        top = 0\n        bottom = n - 1\n        left = 0\n        right = n - 1\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        \n        rev = 0\n        \n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            temp_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_max = temp_max\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        stone_set = set(stones)\n        \n        # dp[i] = True if there exists a way to jump to the ith stone\n        dp = [False] * (len(stones) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(stones)):\n            for j in range(i):\n                if stones[j] + j in stone_set:\n                    dp[stones[j] + j] = True\n        \n        return dp[-1]"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the list\n        score.sort()\n        \n        # create a dictionary\n        score_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_list = ['Gold Medal', 'Silver Medal', 'Bronze Medal']\n        \n        # create a list of the medals\n        medal_"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        start = 0\n        end = 0\n        char_map = {}\n        \n        while end < len(s):\n            if s[end] in char_map:\n                start = max(start, char_map[s[end]] + 1)\n            curr_len = end - start + 1\n            max_len = max(max_len, curr_len)\n            char_map[s[end]] = end\n            end += 1\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_dict = {}\n        for word in word_dict:\n            word_dict_len_count_dict[word] = 0\n        \n        word_dict_len_count_dict[words[0]] += 1\n        \n        word_dict_len_count_dict_len = len(word_dict_len_count_dict)\n        \n        word_dict_len_count_dict_len_count = {}\n        for word in word_dict_len_count_dict:\n            word_dict_len_count_dict_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len = len(word_dict_len_count_dict_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count:\n            word_dict_len_count_dict_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count_len_count:\n            word_dict_len_count_dict_len_count_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count_len_count_len_count:\n            word_dict_len_count_dict_len_count_len_count_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count_len_count_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count_len_count_len_count_len_count:\n            word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count)\n        \n        word_dict_len_count_"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max element in the array\n        # 3. find the index of the max element\n        # 4. find the max element in the array from the index of the max element to the end\n        # 5. find the max element in the array from the index of the max element to the end\n        # 6. find the max element in the array from the index of the max element to the end\n        # 7. find the max element in the array from the index of the max element to the end\n        # 8. find the max element in the array from the index of the max element to the end\n        # 9. find the max element in the array from the index of the max element to the end\n        # 10. find the max element in the array from the index of the max element to the end\n        # 11. find the max element in the array from the index of the max element to the end\n        # 12. find the max element in the array from the index of the max element to the end\n        # 13. find the max element in the array from the index of the max element to the end\n        # 14. find the max element in the array from the index of the max element to the end\n        # 15. find the max element in the array from the index of the max element to the end\n        # 16. find the max element in the array from the index of the max element to the end\n        # 17. find the max element in the array from the index of the max element to the end\n        # 18. find the max element in the array from the index of the max element to the end\n        # 19. find the max element in the array from the index of the max element to the end\n        # 20. find the max element in the array from the index of the max element to the end\n        # 21. find the max element in the array from the index of the max element to the end\n        # 22. find the max element in the array from the index of the max element to the end\n        # 23. find the max element in the array from the index of the max element to the end\n        # 24. find the max element in the array from the index of the max element to the end\n        # 25. find the max element in the array from the index of the max element to the end\n        # 26. find the max element in the array from the index of the max element to the end\n        # 27. find the max element in the array from the index of the max element to the end\n        # 28. find the max element in the array from the index of the max element to the end\n        # 29. find the max element in the array from the index of the max element to the end\n        # 30. find the max element in the array from the index of the max element to the end\n        # 31. find the max element in the array from the index of the max element to the end\n        # 32. find the max element in the array from the index of the max element to the end\n        # 33. find the max element in the array from the index of the max element to the end\n        # 34. find the max element in the array from the index of the max element to the end\n        # 35. find the max element in the array from the index of the max element to the end\n        # 36. find the max element in the array from the index of the max element to the end\n        # 37. find the max element in the array from the index of the max element to the end\n        # 38. find the max element in the array from the index of the max element to the end\n        # 39. find the max element in the array from the index of the max element to the end\n        # 40. find the max element in the array from the index of the max element to the end\n        # 41. find the max element in the array from the index of the max element to the end\n        # 42. find the max element in the array from the index of the max element to the end\n        # 43. find the max element in the array from the index of the max element to the end\n        # 44. find the max element in the array from the index of the max element to the end\n        # 45. find the max element in"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i >= len(v1):\n                v1.append('0')\n            if i >= len(v2):\n                v2.append('0')\n            \n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n        \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            kth = self.getKth(prev, k)\n            if not kth:\n                break\n            curr = kth.next\n            nxt = curr.next\n            while curr != kth:\n                curr.next = nxt.next\n                nxt.next = kth.next\n                kth.next = nxt\n                nxt = curr.next\n            prev = kth\n        return dummy.next\n    \n    def getKth(self, head, k):\n        while head and k > 0:\n            head = head.next\n            k -= 1\n        return head"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(s[0]) != 0:\n        #     return False\n        # for i in range(len(s)//len(s[0])):\n        #     if s[i*len(s[0]):] == s[:len(s[0])]:\n        #         return True\n        # return False\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## for i in nums:\n        ##     if nums.count(i) == 1:\n        ##         return i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## hashmap = {}\n        ## for i in nums:\n        ##     if i not in hashmap:\n        ##         hashmap[i] = 1\n        ##     else:\n        ##         hashmap[i] += 1\n        ## for i in hashmap:\n        ##     if hashmap[i] == 1:\n        ##         return i\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.45% of Python3 online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python3 online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if not s:\n                    continue\n                if target.startswith(s):\n                    res = min(res, 1 + dfs(target[len(s):]))\n            memo[target] = res if res != float('inf') else -1\n            return memo[target]\n        \n        memo = {}\n        return dfs(target)"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1] + 1\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k][j])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize the result variable with the value of the last roman numeral\n        result = roman_dict[s[-1]]\n        \n        # loop through the string in reverse order\n        for i in range(len(s) - 2, -1, -1):\n            # if the current roman numeral is less than the next roman numeral, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add the current roman numeral to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if k == 1:\n            return nums\n        \n        max_list = []\n        max_num = max(nums[0:k])\n        max_list.append(max_num)\n        \n        for i in range(k, len(nums)):\n            if max_num == nums[i-k]:\n                max_num = max(nums[i-k+1:i+1])\n            elif max_num < nums[i]:\n                max_num = nums[i]\n            max_list.append(max_num)\n        \n        return max_list"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[mid + 1]:\n        #         return nums[mid + 1]\n        #     if nums[mid - 1] > nums[mid]:\n        #         return nums[mid]\n        #     if nums[mid] < nums[right]:\n        #         right = mid - 1\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            if nums[mid] < nums[right]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc \uad6c\ud558\uae30\n        # 2. \uc81c\uacf1\uadfc\uae4c\uc9c0 \ubc18\ubcf5\ud558\uae30\n        # 3. \uc81c\uacf1\uadfc\uae4c\uc9c0 \ubc18\ubcf5\ud558\uba74\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\uc11c \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf5\ubb38 \uc548\uc5d0\ufffd"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"_\" + word[i+1:]].append(word)\n        \n        # build a queue and a set to store the shortest path\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        shortest_path = {}\n        \n        # BFS\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if neighbor in graph:\n                        for node in graph[neighbor]:\n                            if node not in visited:\n                                visited.add(node)\n                                queue.append(node)\n                                shortest_path[node] = [word, neighbor]\n        \n        # build the shortest path\n        res = []\n        if endWord not in shortest_path:\n            return res\n        \n        while endWord in shortest_path:\n            res.append([endWord])\n            endWord = shortest_path[endWord][0]\n        \n        res.reverse()\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n            else:\n                res += [r + [nums[i]] for r in res if r + [nums[i]] not in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 13. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        \n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles:\n            return False\n        \n        if (x_max, y_min) not in rectangles:\n            return False\n        \n        if (x_min, y_max) not in rectangles:\n            return False\n        \n        if (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 17576\n        # 26^4 = 4294967296\n        # 26^5 = 1099511627776\n        # 26^6 = 343597383688000\n        # 26^7 = 10737418240000000\n        # 26^8 = 377980456121600000\n        # 26^9 = 12582912258026800000\n        # 26^10 = 439804651110323200000\n        # 26^11 = 14717325050063616000000\n        # 26^12 = 467772960000000000000000\n        # 26^13 = 15559436504160612000000000\n        # 26^14 = 4882813630944136960000000000\n        # 26^15 = 1677721607593745612000000000000\n        # 26^16 = 503316483525242961600000000000000\n        # 26^17 = 1617132888241610321600000000000000000\n        # 26^18 = 503316483525242961600000000000000000000\n        # 26^19 = 161713288824161032160000000000000000000000\n        # 26^20 = 5033164835252429616000000000000000000000000\n        # 26^21 = 161713288824161032160000000000000000000000000\n        # 26^22 = 5033164835252429616000000000000000000000000000\n        # 26^23 = 161713288824161032160000000000000000000000000000\n        # 26^24 = 5033164835252429616000000000000000000000000000000\n        # 26^25 = 16171328882416103216000000000000000000000000000000\n        # 26^26 = 50331648352524296160000000000000000000000000000000\n        # 26^27 = 1617132888241610"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a string\n        board_str = \"\"\n        for row in board:\n            for num in row:\n                board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            \n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            \n            return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum > target:\n                    right -= 1\n                else:\n                    left += 1\n                    \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root is None:\n                return\n            \n            inorder(root.left, min_diff, prev)\n            \n            if prev is not None:\n                min_diff = min(min_diff, root.val - prev)\n            \n            prev = root.val\n            \n            inorder(root.right, min_diff, prev)\n            \n            return min_diff\n        \n        return inorder(root, float('inf'), None)"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        return sorted(Counter(dfs(root)).most_common(1)[0][0] if Counter(dfs(root)).most_common(1)[0][1] > 1 else [Counter(dfs(root)).most_common(1)[0][0]]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force approach\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        \n        ## Approach 1: Two pointer approach\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## Approach 2: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 3: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 4: Two pointer approach\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## Approach 5: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 6: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 7: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 8: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 9: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 10: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 11: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 12: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 13: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 14: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 15: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 16: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 17: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 18: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 19: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 20: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 21: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 22: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 23: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 24: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 25: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 26: Stack\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 27: Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        \n        ## Approach 28: Stack\n        ## Time complexity: O(n)\n        #"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ##"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in en\n        enumerate(nums)])]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max end\n        max_end = -1\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the current interval has a start\n            if interval[0] > max_end:\n                # update the result\n                res += 2\n                # update the max end\n                max_end = interval[1]\n            # if the current interval has a end\n            elif interval[1] > max_end:\n                # update the result\n                res += 1\n                # update the max end\n                max_end = interval[1]\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n += nums[i]\n                i += 1\n            else:\n                patches += 1\n                n += n\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uad04\ud638\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc704\uce58\ub97c \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uad04\ud638\uc758 \uac1c\uc218\uc640 \uc624\ub978\ucabd \uad04\ud638\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 3. \uc67c\ucabd \uad04\ud638\uc758 \uac1c\uc218\uc640 \uc624\ub978\ucabd \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud558\uc5ec \ucd5c\ub300 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        \n        stack = [-1]\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_part = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                decimal_part = \"(\" + decimal_part\n                decimal_part += \")\" * (remainder_dict[remainder] - len(decimal_part))\n                break\n            else:\n                remainder_dict[remainder] = len(remainder_dict)\n                decimal_part += str(quotient)\n        \n        if sign == -1:\n            decimal_part = \"-\" + decimal_part\n        \n        return decimal_part"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        max_len = 1\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_len = max(max_len, dp[i])\n        \n        return max_len"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    if i == 0:\n                        row_zero = True\n                    else:\n                        matrix[i][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\n                    matrix[i][j] = 0\n        \n        if matrix[0][0] == 0:\n            for i in range(m):\n                matrix[i][0] = 0\n        \n        if row_zero:\n            for i in range(m):\n                matrix[i][0] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if sum(machines) == 0:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        if avg == 0:\n            return 0\n        if avg < 0:\n            return -1\n        if avg > 0:\n            ans = 0\n            for i in range(n):\n                ans += abs(machines[i] - avg)\n            return ans\n        else:\n            ans = 0\n            for i in range(n):\n                ans += abs(machines[i] - avg)\n            return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            if len(curr) == k:\n                output.append(curr[:])\n            for i in range(first, len(nums)):\n                curr.append(nums[i])\n                backtrack(i + 1, curr)\n                curr.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[right]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789'):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n        \n        # 4. check if it is a valid decimal\n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        # 5. check if it is a valid float\n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        # 6. check if it is a valid integer\n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.55% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.9 MB, less than 100."}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Inorder traversal\n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node\n        # 2. Find the first node where the value is larger than the previous node\n        # 3. Swap the values of the two nodes\n        \n        # 1. Find the first node where the value is smaller than the previous node"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        if num < 4:\n            return False\n        \n        left = 2\n        right = num // 2\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node, path):\n            if len(path) > 2:\n                return\n            if node not in node.children:\n                return\n            if len(node.children[node]) == 0:\n                return\n            if len(path) == 2:\n                return\n            if len(path) == 1:\n                if len(node.children[node]) == 0:\n                    return\n                if len(node.children[node]) == 1:\n                    return\n                if len(node.children[node]) == 2:\n                    return\n            if len(node.children[node]) == 1:\n                if len(node.children[node]) == 1:\n                    return\n                if len(node.children[node]) == 2:\n                    return\n            if len(node.children[node]) == 2:\n                return\n            if len(node.children[node]) == 3:\n                return\n            if len(node.children[node]) == 4:\n                return\n            if len(node.children[node]) == 5:\n                return\n            if len(node.children[node]) == 6:\n                return\n            if len(node.children[node]) == 7:\n                return\n            if len(node.children[node]) == 8:\n                return\n            if len(node.children[node]) == 9:\n                return\n            if len(node.children[node]) == 10:\n                return\n            if len(node.children[node]) == 11:\n                return\n            if len(node.children[node]) == 12:\n                return\n            if len(node.children[node]) == 13:\n                return\n            if len(node.children[node]) == 14:\n                return\n            if len(node.children[node]) == 15:\n                return\n            if len(node.children[node]) == 16:\n                return\n            if len(node.children[node]) == 17:\n                return\n            if len(node.children[node]) == 18:\n                return\n            if len(node.children[node]) == 19:\n                return\n            if len(node.children[node]) == 20:\n                return\n            if len(node.children[node]) == 21:\n                return\n            if len(node.children[node]) == 22:\n                return\n            if len(node.children[node]) == 23:\n                return\n            if len(node.children[node]) == 24:\n                return\n            if len(node.children[node]) == 25:\n                return\n            if len(node.children[node]) == 26:\n                return\n            if len(node.children[node]) == 27:\n                return\n            if len(node.children[node]) == 28:\n                return\n            if len(node.children[node]) == 29:\n                return\n            if len(node.children[node]) == 30:\n                return\n            if len(node.children[node]) == 31:\n                return\n            if len(node.children[node]) == 32:\n                return\n            if len(node.children[node]) == 33:\n                return\n            if len(node.children[node]) == 34:\n                return\n            if len(node.children[node]) == 35:\n                return\n            if len(node.children[node]) == 36:\n                return\n            if len(node.children[node]) == 37:\n                return\n            if len(node.children[node]) == 38:\n                return\n            if len(node.children[node]) == 39:\n                return\n            if len(node.children[node]) == 40:\n                return\n            if len(node.children[node]) == 41:\n                return\n            if len(node.children[node]) == 42:\n                return\n            if len(node.children[node]) == 43:\n                return\n            if len(node.children[node]) == 44:\n                return\n            if len(node.children[node]) == 45:\n                return\n            if len(node.children[node]) == 46:\n                return\n            if len(node.children[node]) == 47:\n                return\n            if len(node.children[node]) == 48:\n                return\n            if len(node.children"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. convert each character to its corresponding number\n        # 4. add the numbers together\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. convert each character to its corresponding number\n        # 3.1. create a dictionary to map each character to its corresponding number\n        char_to_num = {\n            'A': 1,\n            'B': 2,\n            'C': 3,\n            'D': 4,\n            'E': 5,\n            'F': 6,\n            'G': 7,\n            'H': 8,\n            'I': 9,\n            'J': 10,\n            'K': 11,\n            'L': 12,\n            'M': 13,\n            'N': 14,\n            'O': 15,\n            'P': 16,\n            'Q': 17,\n            'R': 18,\n            'S': 19,\n            'T': 20,\n            'U': 21,\n            'V': 22,\n            'W': 23,\n            'X': 24,\n            'Y': 25,\n            'Z': 26\n        }\n        \n        # 3.2. create a variable to store the sum of the numbers\n        sum_of_nums = 0\n        \n        # 3.3. iterate over the list of characters\n        for i, char in en.umerate(columnTitle):\n            # 3.3.1. get the corresponding number for the character\n            num = char_to_num[char]\n            # 3.3.2. raise the number to the power of the index\n            num = num ** (i + 1)\n            # 3.3.3. add the number to the sum\n            sum_of_nums += num\n            \n        # 4. return the sum\n        return sum_of_nums"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, first.next, second = second, first.next, second.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # check if the pattern and word are already in the dictionary\n            if pattern[i] in mapping:\n                # check if the pattern and word are mapped to the same word\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            # if the pattern and word are not in the dictionary\n            else:\n                # add the pattern and word to the dictionary\n                mapping[pattern[i]] = words[i]\n        \n        # return True if the pattern and words are mapped\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            # we've a valid combination\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n                    elif target > matrix[i][j]:\n                        continue\n                    else:\n                        return False\n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a dummy node\n        dummy = ListNode()\n        # Initialize a pointer to the dummy node\n        curr = dummy\n        # Initialize a variable to store the carry\n        carry = 0\n        \n        # Loop until both lists are empty\n        while l1 or l2 or carry:\n            # If both lists are not empty, add the values of the nodes\n            if l1:\n                val1 = l1.val\n            else:\n                val1 = 0\n            if l2:\n                val2 = l2.val\n            else:\n                val2 = 0\n            # Calculate the sum of the current node and the carry\n            sum_val = val1 + val2 + carry\n            # Calculate the carry for the next iteration\n            carry = sum_val // 10\n            # Calculate the value for the current node\n            curr.next = ListNode(sum_val % 10)\n            # Move to the next node\n            curr = curr.next\n            # Move to the next node in each list\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        # Return the dummy node's next node\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        \n        ## convert to complement\n        complement = \"\"\n        for i in binary:\n            if i == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        ## convert to decimal\n        return int(complement, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Two Pointer Approach\n        ## Time Complexity: O(n)\n        ##"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols + [col], diag1 + [row + col], diag2 + [row - col])\n            return count\n        \n        return backtrack(0, [], [], [])"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            nums.sort()\n            return nums[-3]"}]}