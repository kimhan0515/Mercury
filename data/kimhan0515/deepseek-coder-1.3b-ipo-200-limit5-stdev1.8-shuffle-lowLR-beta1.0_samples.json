{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        \n        m, n = len(s), len(t)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = 1\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i][j-1]\n        return dp[m][n]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers as 0\n        # 2. mark all numbers in the range [1, len(nums)] as 1\n        # 3. iterate through the array and mark the corresponding indices as -1\n        # 4. iterate through the array again and return the first index with a value of 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        nums = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            fact //= i\n            idx = k // fact\n            k %= fact\n            ans += str(nums[idx])\n            nums.pop(idx)\n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if op:\n                    backtrack(j + 1, curr, curr, res, op + '+' + num[j])\n                    backtrack(j + 1, -curr, curr, res, op + '-' + num[j])\n                    backtrack(j + 1, curr * prev, curr, res, op + '*' + num[j])\n                else:\n                    backtrack(j + 1, curr, curr, res, num[j])\n                    backtrack(j + 1, -curr, -curr, res, '-' + num[j])\n                    backtrack(j + 1, curr * prev, curr, res, num[j])\n        \n        res = []\n        backtrack(0, 0, 1, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left_sum = dfs(root.left, curr_sum * 10 + root.val)\n            right_sum = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left_sum + right_sum\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        if n % k == 0:\n            return s[:k] + '-' + self.licenseKeyFormatting(s[k:], k)\n        else:\n            return s[:n % k] + '-' + self.licenseKeyFormatting(s[n % k:], k)"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n                \n        return [1] + digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return false if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if p[0] is '*'\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (s and (p[0] == s[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if p[0] is '*'\n        else:\n            return s and (p[0] == s[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in en.umerate(nums):\n                while out and k > 0 and out[-1] < n:\n                    out.pop()\n                    k -= 1\n                out.append(n)\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def find_max(nums, k):\n            out = []\n            for i in range(len(nums) - k + 1):\n                if out and out[-1] < nums[i]:\n                    out.pop()\n                out.append(nums[i])\n            return out\n        \n        m, n = len(nums1), len(nums2)\n        if m + n < k:\n            return []\n        if m < k:\n            return nums2[:k]\n        if n < k:\n            return nums1[:k]\n        if m == n == k:\n            return nums1\n        if m < n:\n            return merge(find_max(nums1, k), find_max(nums2, k - m))\n        else:\n            return merge(find_max(nums2, k), find_max(nums1, k - n))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1 - dungeon[i][j], 1)\n                elif i == m - 1:\n                    dp[i][j] = max(dp[i][j + 1] - dungeon[i][j], 1)\n                elif j == n - 1:\n                    dp[i][j] = max(dp[i + 1][j] - dungeon[i][j], 1)\n                else:\n                    dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = [i for i, c in enumerate(s_list) if c in vowels]\n        vowel_indices.reverse()\n        for i in vowel_indices:\n            s_list[i] = s_list[i][::-1]\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.44% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Missing Number.\n        \n        ##"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time:"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        res = []\n        for i in range(len(a)-1, -1, -1):\n            if i < len(b):\n                carry += int(a[i]) + int(b[i])\n            else:\n                carry += int(a[i])\n            res.append(str(carry % 2))\n            carry //= 2\n        if carry:\n            res.append(str(carry))\n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if target < nums[mid]:\n                    right = mid - 1\n                elif target > nums[mid]:\n                    left = mid + 1\n                else:\n                    index = mid\n                    if find_left_index:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) // 2) for i in range(0, len(prices) - 1))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j] + max(prices[i] - prices[i - 1], 0), dp[i - 1][j - 1] + prices[i] - prices[i - 1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        hex_dict = {10: \"a\", 11: \"b\", 12: \"c\", 13: \"d\", 14: \"e\", 15: \"f\"}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = \"\"\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # iterate through the string and update the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate through the string again and return the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for num in nums:\n            if num == 1:\n                curr_count += 1\n            else:\n                max_count = max(max_count, curr_count)\n                curr_count = 0\n        \n        return max(max_count, curr_count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = list(num1), list(num2)\n        \n        carry = 0\n        for i in range(len(num1)):\n            if i < len(num2):\n                carry += int(num1[i]) + int(num2[i])\n            else:\n                carry += int(num1[i])\n            \n            num1[i] = str(carry % 10)\n            carry //= 10\n        \n        if carry:\n            num1.append(str(carry))\n        \n        return ''.join(num1)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def calculate(s):\n            stack = []\n            sign = '+'\n            num = 0\n            for i in range(len(s)):\n                if s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                if s[i] in '+-' or i == len(s) - 1:\n                    if sign == '+':\n                        stack.append(num)\n                    elif sign == '-':\n                        stack.append(-num)\n                    elif sign == '*':\n                        stack.append(stack.pop() * num)\n                    elif sign == '/':\n                        stack.append(int(stack.pop() / num))\n                    sign = s[i]\n                    num = 0\n            return sum(stack)\n        \n        return calculate(s.replace(' ', ''))"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif i == '}':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n            elif i == ']':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # find the number that is larger than the first number\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the second half of the array\n        left, right = 0, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # Use a set to store the last seen index of each element\n        # If the element is already in the set, check if the difference between the current index and the last seen index is less than or equal to k\n        # If the element is not in the set, add it to the set\n        # If the element is in the set, check if the difference between the current index and the last seen index is less than or equal to k\n        # If the element is not in the set, add it to the set\n        # If the element is in the set, return True\n        \n        seen = set()\n        \n        for i, num in enumerate(nums):\n            if num in seen:\n                if i - seen[num] <= k:\n                    return True\n            seen[num] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, len(couples), 2):\n            if couples[i][1] != couples[i+1][0]:\n                couples[i+1] = couples[i]\n                swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1:\n                ans.append(word)\n            elif set(word.lower()) <= row2:\n                ans.append(word)\n            elif set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # for example, if the string is \"abcd\", the longest palindrome that can be centered at the beginning is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is 2\n        # the longest palindrome that can be centered at the beginning of the string is \"dcb\"\n        # the length of the longest palindrome is"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # if t is empty, return empty string\n        if not t:\n            return \"\"\n        \n        # create a dictionary to store the frequency of each character in t\n        t_dict = {}\n        for char in t:\n            if char not in t_dict:\n                t_dict[char] = 1\n            else:\n                t_dict[char] += 1\n        \n        # create a dictionary to store the frequency of characters in s\n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        match_dict = {}\n        for char in t_dict:\n            if char in s_dict:\n                match_dict[char] = min(t_dict"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] == distance[i+4] - distance[i+2]:\n                return True\n            if i >= 4 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+2] + distance[i+3] >= distance[i+4] and distance[i+1] == distance[i+5] - distance[i+4]:\n                return True\n            if i >= 5 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+2] + distance[i+3] >= distance[i+4] and distance[i+3] + distance[i+4] >= distance[i+5] and distance[i+1] == distance[i+6] - distance[i+5]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of each letter\n        # 2. if the number of letter is odd, add 1 to the result\n        # 3. if the number of letter is even, add it to the result\n        # 4. return the result\n        \n        # 1.\n        letter_dict = {}\n        for letter in s:\n            if letter not in letter_dict:\n                letter_dict[letter] = 1\n            else:\n                letter_dict[letter] += 1\n        \n        # 2.\n        result = 0\n        for letter in letter_dict:\n            if letter_dict[letter] % 2 == 1:\n                result += 1\n        \n        # 3.\n        if result == 0:\n            result = 1\n        \n        # 4.\n        return result * 2"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                if q:\n                    steps += 1\n                for x, y in q:\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(x, y) for x in range(m) for y in range(n) if forest[x][y] > 1]\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        steps = 0\n        for i, (x, y) in en\n            if (x, y) == (0, 0):\n                return steps\n            steps += bfs((x, y), (0, 0))\n            if steps < 0:\n                return -1\n            steps += bfs((0, 0), (x, y))\n            if steps < 0:\n                return -1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number we can generate\n        # 2. 2^n - 1 is the max number we can generate\n        # 3. 2^n - 1 is the max number we can generate\n        # 4. 2^n - 1 is the max number we can generate\n        # 5. 2^n - 1 is the max number we can generate\n        # 6. 2^n - 1 is the max number we can generate\n        # 7. 2^n - 1 is the max number we can generate\n        # 8. 2^n - 1 is the max number we can generate\n        # 9. 2^n - 1 is the max number we can generate\n        # 10. 2^n - 1 is the max number we can generate\n        # 11. 2^n - 1 is the max number we can generate\n        # 12. 2^n - 1 is the max number we can generate\n        # 13. 2^n - 1 is the max number we can generate\n        # 14. 2^n - 1 is the max number we can generate\n        # 15. 2^n - 1 is the max number we can generate\n        # 16. 2^n - 1 is the max number we can generate\n        # 17. 2^n - 1 is the max number we can generate\n        # 18. 2^n - 1 is the max number we can generate\n        # 19. 2^n - 1 is the max number we can generate\n        # 20. 2^n - 1 is the max number we can generate\n        # 21. 2^n - 1 is the max number we can generate\n        # 22. 2^n - 1 is the max number we can generate\n        # 23. 2^n - 1 is the max number we can generate\n        # 24. 2^n - 1 is the max number we can generate\n        # 25. 2^n - 1 is the max number we can generate\n        # 26. 2^n - 1 is the max number we can generate\n        # 27. 2^n - 1 is the max number we can generate\n        # 28. 2^n - 1 is the max number we can generate\n        # 29. 2^n - 1 is the max number we can generate\n        # 30. 2^n - 1 is the max number we can generate\n        # 31. 2^n - 1 is the max number we can generate\n        # 32. 2^n - 1 is the max number we can generate\n        # 33. 2^n - 1 is the max number we can generate\n        # 34. 2^n - 1 is the max number we can generate\n        # 35. 2^n - 1 is the max number we can generate\n        # 36. 2^n - 1 is the max number we can generate\n        # 37. 2^n - 1 is the max number we can generate\n        # 38. 2^n - 1 is the max number we can generate\n        # 39. 2^n - 1 is the max number we can generate\n        # 40. 2^n - 1 is the max number we can generate\n        # 41. 2^n - 1 is the max number we can generate\n        # 42. 2^n - 1 is the max number we can generate\n        # 43. 2^n - 1 is the max number we can generate\n        # 44. 2^n - 1 is the max number we can generate\n        # 45. 2^n - 1 is the max number we can generate\n        # 46. 2^n - 1 is the max number we can generate\n        # 47. 2^n - 1 is the max number we can generate\n        # 48. 2^n - 1 is the max number we can generate\n        # 49. 2^n - 1 is the max number we can generate\n        # 5"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordD"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # initialize the result list\n        result = []\n        \n        # loop through the intervals\n        for interval in intervals:\n            # if the current interval is after the new interval, add it to the result list\n            if interval[1] < newInterval[0]:\n                result.append(interval)\n            # if the current interval is before the new interval, add the new interval to the result list\n            elif interval[0] > newInterval[1]:\n                result.append(newInterval)\n                newInterval = interval\n            # if the current interval overlaps with the new interval, merge the intervals\n            else:\n                newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\n        \n        # add the final interval to the result list\n        result.append(newInterval)\n        \n        return result"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of all the numbers in the first list\n        # 2. iterate through the rest of the lists, and for each number,\n        #    check if it is in the range of the min and max\n        # 3. if it is, update the min and max\n        # 4. if the max is larger than the range, update the range\n        \n        # 1. find the min and max of all the numbers in the first list\n        min_num = float('inf')\n        max_num = float('-inf')\n        for nums_list in nums:\n            for num in nums_list:\n                min_num = min(min_num, num)\n                max_num = max(max_num, num)\n        \n        # 2. iterate through the rest of the lists, and for each number,\n        #    check if it is in the range of the min and max\n        # 3. if it is, update the min and max\n        # 4. if the max is larger than the range, update the range\n        range_min = min_num\n        range_max = max_num\n        for nums_list in nums[1:]:\n            for num in nums_list:\n                if num > range_max:\n                    range_max = num\n                if num < range_min:\n                    range_min = num\n        \n        return [range_min, range_max]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set()\n        seen.add((0, 0))\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = '0'\n        for i in range(len(num2)):\n            carry = 0\n            for j in range(len(num1)):\n                digit1 = int(num1[len(num1) - j - 1])\n                digit2 = int(num2[len(num2) - i - 1])\n                product = digit1 * digit2 + carry\n                carry = product // 10\n                product = product % 10\n                product = str(product) + res\n                if len(product) > i + j + 1:\n                    res = product[0:i + j + 2]\n                else:\n                    res = product + res[0:i + j + 1]\n        return res"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max profit from left to right\n        # 2. find the max profit from right to left\n        # 3. return the max of the two\n        \n        # 1. find the max profit from left to right\n        max_profit = 0\n        min_price = prices[0]\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        left, right = 0, len(s)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(s[:mid]):\n                right = mid\n            else:\n                left = mid + 1\n        return [s[:left], s[left:]]"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(1)\n        \n        # Merge k sorted lists\n        # Use a min heap to store the head of each list\n        # Iterate through the heap and merge the lists\n        # Return the head of the merged list\n        \n        # Initialize the heap\n        heap = []\n        \n        # Iterate through the lists\n        for i in range(len(lists)):\n            # If the list is not empty, add its head to the heap\n            if lists[i]:\n                heapq.heappush(heap, (lists[i].val, i))\n                lists[i] = lists[i].next\n        \n        # Initialize the head of the merged list\n        head = ListNode()\n        curr = head\n        \n        # Iterate through the heap\n        while heap:\n            # Get the smallest element from the heap\n            val, i = heapq.heappop(heap)\n            \n            # Add the element to the merged list\n            curr.next = ListNode(val)\n            curr = curr.next\n            \n            # If the next element is not None, add it to the heap\n            if lists[i]:\n                heapq.heappush(heap, (lists[i].val, i))\n                lists[i] = lists[i].next\n        \n        # Return the head of the merged list\n        return head.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x//5 + (x%5 > 0)\n        \n        lo, hi = 0, 10**18\n        while lo < hi:\n            mid = (lo + hi)//2\n            if f(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a hashmap for words\n        word_map = {word: i for i, word in enumerate(words)}\n        \n        # build a hashmap for reversed words\n        reverse_map = {}\n        for i, word in enumerate(words):\n            reverse_map[word[::-1]] = i\n        \n        # build a list for result\n        result = []\n        \n        # iterate over words\n        for i, word in enumerate(words):\n            # if word is a palindrome\n            if word in reverse_map:\n                # add to result\n                result.append([i, reverse_map[word]])\n            \n            # reverse word\n            rev_word = word[::-1]\n            \n            # if rev_word is a palindrome\n            if rev_word in word_map:\n                # add to result\n                result.append([reverse_map[rev_word], i])\n        \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, row, col):\n            q = deque([(row, col)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for r in range(len(isInfected)):\n                    for c in range(len(isInfected[0])):\n                        if isInfected[r][c] == 1:\n                            infected.add((r, c))\n                if not infected:\n                    break\n                q = deque(infected)\n                while q:\n                    r, c = q.popleft()\n                    for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                        if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                            isInfected[nr][nc] = 2\n                            q.append((nr, nc))\n                walls += 1\n            return walls\n        \n        walls = build_walls(isInfected)\n        for r in range(len(isInfected)):\n            for c in range(len(isInfected[0])):\n                if isInfected[r][c] == 1:\n                    spread(isInfected, r, c)\n        return walls + build_walls(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        if not dp[-1]:\n            return []\n        \n        # Backtrack to construct the list of sentences.\n        res = []\n        self.backtrack(s, wordDict, 0, [], res)\n        return res\n    \n    def backtrack(self, s, wordDict, start, path, res):\n        if start == len(s):\n            res.append(' '.join(path))\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in wordDict:\n                self.backtrack(s, wordDict, end, path + [s[start:end]], res)"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                level_nodes.reverse()\n            result.append(level_nodes)\n            level += 1\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(n):\n            if n == 0:\n                return [0]\n            if n == 1:\n                return [1,2,4,8]\n            if n == 2:\n                return [3,5,6,9,10]\n            if n == 3:\n                return [7,11,12]\n            if n == 4:\n                return [15,20,24,30]\n            if n == 5:\n                return [31,40,48,56,60]\n            if n == 6:\n                return [72,80,90,100,120,144,200,240,300,360]\n            if n == 7:\n                return [168,256,345,432,520,600,720,840,960,1080]\n            if n == 8:\n                return [192,288,384,480,576,672,768,872,976,1080]\n            if n == 9:\n                return [2048,3072,4096,5120,6144,7168,8192,9216,10240,11264]\n            if n == 10:\n                return [12288,14336,16384,18432,20480,22528,24576,26624,28672,30720]\n            if n == 11:\n                return [32768,43520,54272,65024,75776,86528,97280,108032,118784,129536,140288]\n            if n == 12:\n                return [161024,181440,201856,222272,242688,263104,283520,303936,324352,344768,365184]\n            if n == 13:\n                return [368960,480000,591040,702080,813120,924160,1035200,1146240,1257280,1368320,1479360]\n            if n == 14:\n                return [1610240,1814400,2018560,2222720,2426880,2631040,2835200,3039360,3243520,3447680,3651840]\n            if n == 15:\n                return [3689600,4800000,5910400,7020800,8131200,9241600,10352000,11462400,12572800,13683200,14793600]\n            if n == 16:\n                return [16102400,18144000,20185600,22227200,24268800,26310400,28352000,30393600,32435200,34476800,36518400]\n            if n == 17:\n                return [36896000,48000"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(res[i-1][j-1] + res[i-1][j])\n            row.append(1)\n            res.append(row)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set()\n        for i in range(m+n-1):\n            if i < m:\n                seen.add((i, 0))\n            else:\n                seen.add((m+n-2, i-m))\n            while heap:\n                h, i, j = heapq.heappop(heap)\n                for ni, nj in [(i, j+1), (i, j-1), (i+1, j), (i-1, j)]:\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                        seen.add((ni, nj))\n                        heapq.heappush(heap, (max(heightMap[ni][nj], h), ni, nj))\n        return sum(max(heightMap[i][j], h) - heightMap[i][j] for i, j in seen)"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the window\n        window = nums[:k]\n        \n        # 3. Calculate the median\n        median = self.calculateMedian(window)\n        \n        # 4. Append the median to the result list\n        result.append(median)\n        \n        # 5. Iterate over the remaining elements\n        for i in range(k, len(nums)):\n            # 6. Remove the leftmost element from the window\n            window.remove(nums[i - k])\n            \n            # 7. Add the new element to the window\n            window.add(nums[i])\n            \n            # 8. Calculate the median\n            median = self.calculateMedian(window)\n            \n            # 9. Append the median to the result list\n            result.append(median)\n        \n        # 10. Return the result list\n        return result\n    \n    def calculateMedian(self, window):\n        # 1. Calculate the median\n        if len(window) % 2 == 0:\n            median = (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0\n        else:\n            median = window[len(window) // 2]\n        \n        # 2. Return the median\n        return median"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for _ in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                res = max(res, self.maxSubArray(sums, k))\n                if res == k:\n                    return k\n        return res\n    \n    def maxSubArray(self, sums, k):\n        s = 0\n        res = float('-inf')\n        d = {0: -1}\n        for i, v in enumerate(sums):\n            s += v\n            if s - k in d:\n                res = max(res, s - k)\n            if s not in d:\n                d[s] = i\n            res = max(res, s - d[s - k])\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483647:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483647:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483646:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483649:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483650:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483651:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483652:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483653:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483654:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483655:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483656:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483657:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483658:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483659:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483660:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483661:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483662:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483663:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483664:\n            return 1\n        \n        if dividend == 21474836"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board) - 1 or j == 0 or j == len(board[0]) - 1:\n                    dfs(i, j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the indices of the numbers\n        num_dict = {}\n        \n        # iterate through the list of numbers\n        for i, num in enumerate(nums):\n            \n            # check if the complement of the current number is in the dictionary\n            if target - num in num_dict:\n                \n                # return the indices of the complement and the current number\n                return [num_dict[target - num], i]\n            \n            # add the current number to the dictionary with its index\n            num_dict[num] = i\n            \n        # if no complement is found, return an empty list\n        return []"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.01\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards = [a + b, a - b, a * b, float(a) / b]\n                        elif op == '-':\n                            new_cards = [a - b, b - a, a * b, float(b) / a]\n                        elif op == '*':\n                            new_cards = [a + b, a - b, a * b, float(a) / b]\n                        else:\n                            new_cards = [a + b, a - b, float(a) / b, b - a]\n                        if backtrack(new_cards, target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if first character matches\n        if not s or not p[0] == '*':\n            return False\n        \n        # if p is not empty, check if first character is '*'\n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or self.isMatch(s[1:], p)\n        \n        # if p is not empty, check if first character is '?'\n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, check if first character matches\n        return s[0] == p[0] and self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/10098"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in tickets:\n            graph[from_city].append(to_city)\n        \n        # sort the graph by alphabetical order\n        for city in graph:\n            graph[city].sort(reverse=True)\n        \n        # dfs\n        res = []\n        def dfs(city):\n            # if there is no more city to visit, add the current city to the result\n            if len(graph[city]) == 0:\n                res.append(city)\n                return\n            # visit all the next cities\n            for next_city in graph[city]:\n                graph[city].remove(next_city)\n                dfs(next_city)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. sort the buildings by left edge\n        # 2. use a priority queue to store the heights of the buildings\n        # 3. use a list to store the heights of the skyline\n        # 4. iterate through the buildings\n        # 5. if the current building is taller than the top of the priority queue, add it to the priority queue\n        # 6. if the current building is shorter than the top of the priority queue, remove it from the priority queue\n        # 7. if the priority queue is empty, add 0 to the list\n        # 8. if the priority queue is not empty, add the top of the priority queue to the list\n        # 9. return the list\n        \n        # 1. sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # 2. use a priority queue to store the heights of the buildings\n        pq = []\n        \n        # 3. use a list to store the heights of the skyline\n        skyline = []\n        \n        # 4. iterate through the buildings\n        for building in buildings:\n            \n            # 5. if the current building is taller than the top of the priority queue, add it to the priority queue\n            if building[2] > 0:\n                heapq.heappush(pq, (-building[2], building[1]))\n                \n            # 6. if the current building is shorter than the top of the priority queue, remove it from the priority queue\n            else:\n                while pq and pq[0][1] <= building[0]:\n                    heapq.heappop(pq)\n                \n            # 7. if the priority queue is empty, add 0 to the list\n            if not pq:\n                skyline.append([building[0], 0])\n                \n            # 8. if the priority queue is not empty, add the top of the priority queue to the list\n            else:\n                skyline.append([building[0], -pq[0][0]])\n                \n        # 9. return the list\n        return skyline"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # reverse the string\n        for i in range(len(s) // 2):\n            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # O(n) space\n        dp = [0] * (len(triangle) + 1)\n        \n        for row in triangle[::-1]:\n            for i, num in en\n            dp[i] = min(dp[i], dp[i + 1]) + num\n        \n        return dp[0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if j >= i:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % MOD\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with only one parent\n        # 3. find the edge that connects the two nodes\n        # 4. find the edge that connects the node with only one parent\n        # 5. return the edge that connects the two nodes\n        \n        # 1. find the node with two parents\n        parent_map = {}\n        for edge in edges:\n            if edge[0] in parent_map:\n                parent_map[edge[0]].append(edge[1])\n            else:\n                parent_map[edge[0]] = [edge[1]]\n        \n        # 2. find the node with only one parent\n        for edge in edges:\n            if edge[1] not in parent_map:\n                parent_map[edge[1]] = [edge[0]]\n            else:\n                parent_map[edge[1]].append(edge[0])\n        \n        # 3. find the edge that connects the two nodes\n        for edge in edges:\n            if edge[1] not in parent_map[edge[0]]:\n                return edge\n        \n        # 4. find the edge that connects the node with only one parent\n        for edge in edges:\n            if len(parent_map[edge[1]]) == 1:\n                return edge\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 2 ^ 2 = 0\n        ## 2 ^ 1 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + grid[i][j2]\n                    if j1 > 0:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1 - 1][j2] + grid[i][j1] + grid[i][j2])\n                    if j2 > 0:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1][j2 - 1] + grid[i][j1] + grid[i][j2])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if grid[n - 1][j1] == -1 or grid[n - 1][j2] == -1)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        #"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        \n        for j in range(1, n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211211131221'\n        \n        if n == 13:\n            return '1321132132111231131221123113112221'\n        \n        if n == 14:\n            return '111312211312132112311312211211131221'\n        \n        if n == 15:\n            return '31131122213213211231131221123113112221'\n        \n        if n == 16:\n            return '13211321321123113122112311312211211131221'\n        \n        if n == 17:\n            return '11131221131213211231131221123113112221'\n        \n        if n == 18:\n            return '3113112221321321123113122112311312211211131221'\n        \n        if n == 19:\n            return '13211321321123113122112311312211211131221'\n        \n        if n == 20:\n            return '1113122113121321123113122112311312211211131221'\n        \n        if n == 21:\n            return '3113112221321321123113122112311312211211131221'\n        \n        if n == 22:\n            return '13211321321123113122112311312211211131221'\n        \n        if n == 23:\n            return '1113122113121321123113122112311312211211131221'\n        \n        if n == 24:\n            return '3113112221321321123113122112311312211211131221'\n        \n        if n == 25:\n            return '1321132132112311312211231131221121113"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        pivot = l\n        \n        # find the target\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[(m + pivot) % len(nums)] < target:\n                l = m + 1\n            elif nums[(m + pivot) % len(nums)] > target:\n                r = m - 1\n            else:\n                return (m + pivot) % len(nums)\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        res = ['']\n        \n        for digit in digits:\n            tmp = []\n            for letter in phone[digit]:\n                for item in res:\n                    tmp.append(item + letter)\n            res = tmp\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        current = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the current index\n        current_index = 0\n        \n        # initialize the current target\n        current_target = target\n        \n        # loop through the candidates\n        while current_index < len(candidates):\n            # if the current sum is less than the target\n            if current_sum < current_target:\n                # add the current candidate to the current combination\n                current.append(candidates[current_index])\n                # update the current sum\n                current_sum += candidates[current_index]\n                # update the current index\n                current_index += 1\n            # if the current sum is equal to the target\n            elif current_sum == current_target:\n                # add the current combination to the result\n                result.append(current[:])\n                # update the current sum\n                current_sum -= candidates[current_index - 1]\n                # update the current index\n                current_index -= 1\n            # if the current sum is greater than the target\n            else:\n                # update the current sum\n                current_sum -= candidates[current_index - 1]\n                # update the current index\n                current_index -= 1\n                # update the current combination\n                current.pop()\n        \n        # return the result\n        return result"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of n\n        length = len(n)\n        \n        # 2. get the left and right part of n\n        left = n[:length//2]\n        right = n[length//2:]\n        \n        # 3. get the list of all possible palindromes\n        palindromes = [int(left + right[::-1]), int(left + '0' + right[1:]), int(left + '9' + right[1:])]\n        \n        # 4. get the closest palindrome\n        closest = min(palindromes, key=lambda x: abs(x - int(n)))\n        \n        # 5. return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        # transpose\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a hashmap\n        score_hashmap = {}\n        \n        # create a hashmap\n        for i, s in enumerate(score_sorted):\n            score_hashmap[s] = i + 1\n        \n        # create a list of the result\n        result = []\n        \n        # iterate through the score\n        for s in score:\n            # if the score is in the hashmap\n            if s in score_hashmap:\n                # add the rank to the result\n                result.append(str(score_hashmap[s]))\n            # if the score is not in the hashmap\n            else:\n                # add the score to the hashmap\n                score_hashmap[s] = \"Gold Medal\"\n                # add the rank to the result\n                result.append(score_hashmap[s])\n        \n        # return the result\n        return result"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # 1. left pointer\n        # 2. right pointer\n        # 3. hashmap\n        # 4. max_len\n        \n        # 1. left pointer\n        left = 0\n        \n        # 2. right pointer\n        right = 0\n        \n        # 3. hashmap\n        hashmap = {}\n        \n        # 4. max_len\n        max_len = 0\n        \n        while right < len(s):\n            if s[right] not in hashmap:\n                hashmap[s[right]] = 1\n                right += 1\n                max_len = max(max_len, right - left)\n            else:\n                del hashmap[s[left]]\n                left += 1\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            right = i\n            word_count_dict = collections.Counter()\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                right += word_len\n                if word in word_dict:\n                    word_count_dict[word] += 1\n                    while word_count_dict[word] > word_dict[word]:\n                        word_count_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                if right - left == len(words) * word_len:\n                    res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max element in the array\n        # 2. find the index of the max element\n        # 3. find the max element in the array from the index of the max element to the end\n        # 4. find the max element in the array from the index of the max element to the end\n        # 5. find the max element in the array from the index of the max element to the end\n        # 6. find the max element in the array from the index of the max element to the end\n        # 7. find the max element in the array from the index of the max element to the end\n        # 8. find the max element in the array from the index of the max element to the end\n        # 9. find the max element in the array from the index of the max element to the end\n        # 10. find the max element in the array from the index of the max element to the end\n        # 11. find the max element in the array from the index of the max element to the end\n        # 12. find the max element in the array from the index of the max element to the end\n        # 13. find the max element in the array from the index of the max element to the end\n        # 14. find the max element in the array from the index of the max element to the end\n        # 15. find the max element in the array from the index of the max element to the end\n        # 16. find the max element in the array from the index of the max element to the end\n        # 17. find the max element in the array from the index of the max element to the end\n        # 18. find the max element in the array from the index of the max element to the end\n        # 19. find the max element in the array from the index of the max element to the end\n        # 20. find the max element in the array from the index of the max element to the end\n        # 21. find the max element in the array from the index of the max element to the end\n        # 22. find the max element in the array from the index of the max element to the end\n        # 23. find the max element in the array from the index of the max element to the end\n        # 24. find the max element in the array from the index of the max element to the end\n        # 25. find the max element in the array from the index of the max element to the end\n        # 26. find the max element in the array from the index of the max element to the end\n        # 27. find the max element in the array from the index of the max element to the end\n        # 28. find the max element in the array from the index of the max element to the end\n        # 29. find the max element in the array from the index of the max element to the end\n        # 30. find the max element in the array from the index of the max element to the end\n        # 31. find the max element in the array from the index of the max element to the end\n        # 32. find the max element in the array from the index of the max element to the end\n        # 33. find the max element in the array from the index of the max element to the end\n        # 34. find the max element in the array from the index of the max element to the end\n        # 35. find the max element in the array from the index of the max element to the end\n        # 36. find the max element in the array from the index of the max element to the end\n        # 37. find the max element in the array from the index of the max element to the end\n        # 38. find the max element in the array from the index of the max element to the end\n        # 39. find the max element in the array from the index of the max element to the end\n        # 40. find the max element in the array from the index of the max element to the end\n        # 41. find the max element in the array from the index of the max element to the end\n        # 42. find the max element in the array from the index of the max element to the end\n        # 43. find the max element in the array from the index of the max element to the end\n        # 44. find the max element in the array from the index of the max element to"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, cur.next.next, prev.next = cur.next.next, cur, prev.next\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the matrix with the lengths of the two strings\n        m, n = len(word1), len(word2)\n        \n        # Initialize the matrix with zeros\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Fill the matrix with the lengths of the two strings\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # Return the difference between the lengths of the two strings\n        return m + n - 2 * dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left_paths + right_paths]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid:\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n                i += 1\n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    return 1\n            else:\n                if i < len(v2):\n                    return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # greedy\n        # max heap\n        heap = []\n        \n        # sum of durations\n        total = 0\n        \n        for duration, end in courses:\n            # add to heap\n            heapq.heappush(heap, duration)\n            # add duration to total\n            total += duration\n            # if total exceeds end date, remove from heap\n            if total > end:\n                total -= heapq.heappop(heap)\n        \n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            for i in range(k):\n                if curr:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            next = curr\n            prev.next, curr = self.reverse(prev.next, curr)\n            prev = curr\n            curr = next\n        return dummy.next\n    \n    def reverse(self, start, end):\n        prev = None\n        curr = start\n        while curr != end:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev, end"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(s[0]) != 0:\n        #     return False\n        \n        # return s in (s + s)[1:-1]\n        \n        return s in (s * 2)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4) + dp[i-6] * 2 * (2*i - 11) / (i-5)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4) + dp[i-6] * 2 * (2*i - 11) / (i-5) + dp[i-7] * 2 * (2*i - 13) / (i-6)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4) + dp[i-6] * 2 * (2*i - 11) / (i-5) + dp[i-7] * 2 * (2*i - 13) / (i-6) + dp[i-8] * 2 * (2*i - 15) / (i-7)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) /"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the list and check if the count is 1\n        # 3. if it is, return the number\n        # 4. if it is not, add 1 to the count\n        # 5. if the count is 3, remove the number from the dictionary\n        # 6. if the count is 2, add the number to the dictionary\n        # 7. if the count is 1, add the number to the dictionary\n        \n        # 1. create a dictionary to store the count of each number\n        count = {}\n        \n        # 2. iterate through the list and check if the count is 1\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n        \n        # 3. if it is, return the number\n        for num in count:\n            if count[num] == 1:\n                return num\n        \n        # 4. if it is not, add 1 to the count\n        # 5. if the count is 3, remove the number from the dictionary\n        # 6. if the count is 2, add the number to the dictionary\n        # 7. if the count is 1, add the number to the dictionary\n        \n        # 1. create a dictionary to store the count of each number\n        count = {}\n        \n        # 2. iterate through the list and check if the count is 1\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n        \n        # 3. if it is, return the number\n        for num in count:\n            if count[num] == 1:\n                return num\n        \n        # 4. if it is not, add 1 to the count\n        # 5. if the count is 3, remove the number from the dictionary\n        # 6. if the count is 2, add the number to the dictionary\n        # 7. if the count is 1, add the number to the dictionary\n        \n        # 1. create a dictionary to store the count of each number\n        count = {}\n        \n        # 2. iterate through the list and check if the count is 1\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n        \n        # 3. if it is, return the number\n        for num in count:\n            if count[num] == 1:\n                return num\n        \n        # 4. if it is not, add 1 to the count\n        # 5. if the count is 3, remove the number from the dictionary\n        # 6. if the count is 2, add the number to the dictionary\n        # 7. if the count is 1, add the number to the dictionary\n        \n        # 1. create a dictionary to store the count of each number\n        count = {}\n        \n        # 2. iterate through the list and check if the count is 1\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n        \n        # 3. if it is, return the number\n        for num in count:\n            if count[num] == 1:\n                return num\n        \n        # 4. if it is not, add 1 to the count\n        # 5. if the count is 3, remove the number from the dictionary\n        # 6. if the count is 2, add the number to the dictionary\n        # 7. if the count is 1, add the number to the dictionary\n        \n        # 1. create a dictionary to store the count of each number\n        count = {}\n        \n        # 2. iterate through the list and check if the count is 1\n        for num in nums:\n            if num not in count:\n                count[num] = 1\n            else:\n                count[num] += 1\n        \n        # 3. if it is, return the number\n        for num in count:\n            if count[num] == 1:\n                return num\n        \n        # 4. if it is not, add 1 to the count"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to form target[0:i]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize the result to 0\n        result = 0\n        \n        # loop through the string in reverse order\n        for i in range(len(s) - 1, -1, -1):\n            # if the current character is less than the next character, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i + 1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if k == 1:\n            return nums\n        \n        max_list = []\n        max_num = max(nums[0:k])\n        max_list.append(max_num)\n        \n        for i in range(k, len(nums)):\n            if nums[i] > max_num:\n                max_num = nums[i]\n            if i >= k:\n                if nums[i-k] == max_num:\n                    max_num = max(nums[i-k+1:i+1])\n                else:\n                    max_num = max(max_num, nums[i-k+1])\n            max_list.append(max_num)\n        \n        return max_list"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge nums1 and nums2 into nums\n        nums = nums1 + nums2\n        nums.sort()\n        \n        # find median\n        if len(nums) % 2 == 1:\n            return nums[len(nums) // 2]\n        else:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # l, r = 0, len(nums) - 1\n        # while l < r:\n        #     mid = (l + r) // 2\n        #     if nums[mid] > nums[r]:\n        #         l = mid + 1\n        #     else:\n        #         r = mid\n        # return nums[l]\n        \n        # linear search\n        return min(nums)"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. 1 <= area <= 10^18\n        # 3. 1 <= area <= 10^19\n        # 4. 1 <= area <= 10^20\n        # 5. 1 <= area <= 10^21\n        # 6. 1 <= area <= 10^22\n        # 7. 1 <= area <= 10^23\n        # 8. 1 <= area <= 10^24\n        # 9. 1 <= area <= 10^25\n        # 10. 1 <= area <= 10^26\n        # 11. 1 <= area <= 10^27\n        # 12. 1 <= area <= 10^28\n        # 13. 1 <= area <= 10^29\n        # 14. 1 <= area <= 10^30\n        # 15. 1 <= area <= 10^31\n        # 16. 1 <= area <= 10^32\n        # 17. 1 <= area <= 10^33\n        # 18. 1 <= area <= 10^34\n        # 19. 1 <= area <= 10^35\n        # 20. 1 <= area <= 10^36\n        # 21. 1 <= area <= 10^37\n        # 22. 1 <= area <= 10^38\n        # 23. 1 <= area <= 10^39\n        # 24. 1 <= area <= 10^40\n        # 25. 1 <= area <= 10^41\n        # 26. 1 <= area <= 10^42\n        # 27. 1 <= area <= 10^43\n        # 28. 1 <= area <= 10^44\n        # 29. 1 <= area <= 10^45\n        # 30. 1 <= area <= 10^46\n        # 31. 1 <= area <= 10^47\n        # 32. 1 <= area <= 10^48\n        # 33. 1 <= area <= 10^49\n        # 34. 1 <= area <= 10^50\n        # 35. 1 <= area <= 10^51\n        # 36. 1 <= area <= 10^52\n        # 37. 1 <= area <= 10^53\n        # 38. 1 <= area <= 10^54\n        # 39. 1 <= area <= 10^55\n        # 40. 1 <= area <= 10^56\n        # 41. 1 <= area <= 10^57\n        # 42. 1 <= area <= 10^58\n        # 43. 1 <= area <= 10^59\n        # 44. 1 <= area <= 10^60\n        # 45. 1 <= area <= 10^61\n        # 46. 1 <= area <= 10^62\n        # 47. 1 <= area <= 10^63\n        # 48. 1 <= area <= 10^64\n        # 49. 1 <= area <= 10^65\n        # 50. 1 <= area <= 10^66\n        # 51. 1 <= area <= 10^67\n        # 52. 1 <= area <= 10^68\n        # 53. 1 <= area <= 10^69\n        # 54. 1 <= area <= 10^70\n        # 55. 1 <= area <= 10^71\n        # 56. 1 <= area <= 10^72\n        # 57. 1 <= area <= 10^73\n        # 58. 1 <= area <= 10^74\n        # 59. 1 <= area <= 10^75\n        # 60. 1 <= area <= 10^76\n        # 61. 1 <= area <= 10^"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build queue and visited\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        \n        # build result\n        result = []\n        while queue:\n            # get current level\n            level = []\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    path = [endWord]\n                    while path[0] != beginWord:\n                        path.insert(0, visited[path[0]])\n                    result.append(path)\n                else:\n                    for i in range(len(word)):\n                        for neighbor in graph[word[:i] + \"*\" + word[i+1:]]:\n                            if neighbor not in visited:\n                                visited[neighbor] = word\n                                queue.append(neighbor)\n                                level.append(neighbor)\n            if not level:\n                return result\n            # remove visited nodes\n            for word in level:\n                del visited[word]\n        \n        return result"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]]\n            else:\n                res += [nums[i]]\n                for j in range(len(res)-1, -1, -1):\n                    if j == len(res)-1 or nums[i] != nums[i-1]:\n                        res += [res[j] + [nums[i]]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26\u8fdb\u5236\u8f6c\u6362\n        # 1. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 2. \u4ece1\u5f00\u59cb\n        # 3. \u4ece10\u8fdb\u4f4d\n        # 4. \u4ece10\u8fdb\u4f4d\n        # 5. \u4ece10\u8fdb\u4f4d\n        # 6. \u4ece10\u8fdb\u4f4d\n        # 7. \u4ece10\u8fdb\u4f4d\n        # 8. \u4ece10\u8fdb\u4f4d\n        # 9. \u4ece10\u8fdb\u4f4d\n        # 10. \u4ece10\u8fdb\u4f4d\n        # 11. \u4ece10\u8fdb\u4f4d\n        # 12. \u4ece10\u8fdb\u4f4d\n        # 13. \u4ece10\u8fdb\u4f4d\n        # 14. \u4ece10\u8fdb\u4f4d\n        # 15. \u4ece10\u8fdb\u4f4d\n        # 16. \u4ece10\u8fdb\u4f4d\n        # 17. \u4ece10\u8fdb\u4f4d\n        # 18. \u4ece10\u8fdb\u4f4d\n        # 19. \u4ece10\u8fdb\u4f4d\n        # 20. \u4ece10\u8fdb\u4f4d\n        # 21. \u4ece10\u8fdb\u4f4d\n        # 22. \u4ece10\u8fdb\u4f4d\n        # 23. \u4ece10\u8fdb\u4f4d\n        # 24. \u4ece10\u8fdb\u4f4d\n        # 25. \u4ece10\u8fdb\u4f4d\n        # 26. \u4ece10\u8fdb\u4f4d\n        # 27. \u4ece10\u8fdb\u4f4d\n        # 28. \u4ece10\u8fdb\u4f4d\n        # 29. \u4ece10\u8fdb\u4f4d\n        # 30. \u4ece10\u8fdb\u4f4d\n        # 31. \u4ece10\u8fdb\u4f4d\n        # 32. \u4ece10\u8fdb\u4f4d\n        # 33. \u4ece10\u8fdb\u4f4d\n        # 34. \u4ece10\u8fdb\u4f4d\n        # 35. \u4ece10\u8fdb\u4f4d\n        # 36. \u4ece10\u8fdb\u4f4d\n        # 37. \u4ece10\u8fdb\u4f4d\n        # 38. \u4ece10\u8fdb\u4f4d\n        # 39. \u4ece10\u8fdb\u4f4d\n        # 40. \u4ece10\u8fdb\u4f4d\n        # 41. \u4ece10\u8fdb\u4f4d\n        # 42. \u4ece10\u8fdb\u4f4d\n        # 43. \u4ece10\u8fdb\u4f4d\n        # 44. \u4ece10\u8fdb\u4f4d\n        # 45. \u4ece10\u8fdb\u4f4d\n        # 46. \u4ece10\u8fdb\u4f4d\n        # 47. \u4ece10\u8fdb\u4f4d\n        # 48. \u4ece10\u8fdb\u4f4d\n        # 49. \u4ece10\u8fdb\u4f4d\n        # 50. \u4ece10\u8fdb\u4f4d\n        # 51. \u4ece10\u8fdb\u4f4d\n        # 52. \u4ece10\u8fdb\u4f4d\n        # 53. \u4ece10\u8fdb\u4f4d\n        # 54. \u4ece10\u8fdb\u4f4d\n        # 55. \u4ece10\u8fdb\u4f4d\n        # 56. \u4ece10\u8fdb\u4f4d\n        # 57. \u4ece10\u8fdb\u4f4d\n        # 58. \u4ece10\u8fdb\u4f4d\n        # 59. \u4ece10\u8fdb\u4f4d\n        # 60. \u4ece10\u8fdb\u4f4d\n        # 61. \u4ece10\u8fdb\u4f4d\n        # 62. \u4ece10\u8fdb\u4f4d\n        # 63. \u4ece10\u8fdb\u4f4d\n        # 64. \u4ece10\u8fdb\u4f4d\n        # 65. \u4ece10\u8fdb\u4f4d\n        # 66. \u4ece10\u8fdb\u4f4d\n        # 67. \u4ece10\u8fdb\u4f4d\n        # 68. \u4ece10\u8fdb\u4f4d\n        # 69. \u4ece10\u8fdb\u4f4d\n        # 70. \u4ece10\u8fdb\u4f4d\n        # 71. \u4ece10\u8fdb\u4f4d\n        # 72. \u4ece10\u8fdb\u4f4d\n        # 73. \u4ece10\u8fdb\u4f4d\n        # 74. \u4ece10\u8fdb\u4f4d\n        # 75. \u4ece10\u8fdb\u4f4d\n        # 76. \u4ece10\u8fdb\u4f4d\n        # 77. \u4ece10\u8fdb\u4f4d\n        # 78. \u4ece10\u8fdb\u4f4d\n        # 79. \u4ece10"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        \n        for num in nums:\n            if cur_sum < 0:\n                cur_sum = num\n            else:\n                cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n            else:\n                if t[i] in t_to_s:\n                    return False\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        pivot = l\n        \n        # find the target\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[(m + pivot) % len(nums)] == target:\n                return True\n            elif nums[(m + pivot) % len(nums)] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[-1][-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                    \n                if sum > target:\n                    right -= 1\n                else:\n                    left += 1\n                    \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = float('-inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return [0, float('-inf')]\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] > right[0]:\n                return [left[0] + 1, root.val]\n            elif left[0] == right[0]:\n                return [left[0] + 1, root.val]\n            else:\n                return [right[0] + 1, root.val]\n        \n        return dfs(root)[1:]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check length\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        if len(password) > 20:\n            return max(20 - len(password), 3)\n        \n        # 2. check for repeating characters\n        # 2.1 check for 3 repeating characters in a row\n        # 2.2 check for 2 repeating characters in a row\n        # 2.3 check for 1 repeating character in a row\n        # 2.4 check for 0 repeating characters in a row\n        # 2.5 check for 0 repeating characters in a row\n        # 2.6 check for 0 repeating characters in a row\n        # 2.7 check for 0 repeating characters in a row\n        # 2.8 check for 0 repeating characters in a row\n        # 2.9 check for 0 repeating characters in a row\n        # 2.10 check for 0 repeating characters in a row\n        # 2.11 check for 0 repeating characters in a row\n        # 2.12 check for 0 repeating characters in a row\n        # 2.13 check for 0 repeating characters in a row\n        # 2.14 check for 0 repeating characters in a row\n        # 2.15 check for 0 repeating characters in a row\n        # 2.16 check for 0 repeating characters in a row\n        # 2.17 check for 0 repeating characters in a row\n        # 2.18 check for 0 repeating characters in a row\n        # 2.19 check for 0 repeating characters in a row\n        # 2.20 check for 0 repeating characters in a row\n        # 2.21 check for 0 repeating characters in a row\n        # 2.22 check for 0 repeating characters in a row\n        # 2.23 check for 0 repeating characters in a row\n        # 2.24 check for 0 repeating characters in a row\n        # 2.25 check for 0 repeating characters in a row\n        # 2.26 check for 0 repeating characters in a row\n        # 2.27 check for 0 repeating characters in a row\n        # 2.28 check for 0 repeating characters in a row\n        # 2.29 check for 0 repeating characters in a row\n        # 2.30 check for 0 repeating characters in a row\n        # 2.31 check for 0 repeating characters in a row\n        # 2.32 check for 0 repeating characters in a row\n        # 2.33 check for 0 repeating characters in a row\n        # 2.34 check for 0 repeating characters in a row\n        # 2.35 check for 0 repeating characters in a row\n        # 2.36 check for 0 repeating characters in a row\n        # 2.37 check for 0 repeating characters in a row\n        # 2.38 check for 0 repeating characters in a row\n        # 2.39 check for 0 repeating characters in a row\n        # 2.40 check for 0 repeating characters in a row\n        # 2.41 check for 0 repeating characters in a row\n        # 2.42 check for 0 repeating characters in a row\n        # 2.43 check for 0 repeating characters in a row\n        # 2.44 check for 0 repeating characters in a row\n        # 2.45 check for 0 repeating characters in a row\n        # 2.46 check for 0 repeating characters in a row\n        # 2.47 check for 0 repeating characters in a row\n        # 2.48 check for 0 repeating characters in a row\n        # 2.49 check for 0 repeating characters in a row\n        # 2.50 check for 0 repeating characters in a row\n        # 2.51 check for 0 repeating characters in a row\n        # 2.52 check for 0 repeating characters in a row\n        # 2.53 check for 0 repeating characters in a row\n        # 2.54 check for 0 repeating characters in a row\n        # 2.55 check for 0 repeating characters in a row\n        # 2.56 check for 0 repeating characters in a row\n        # 2.57 check for 0"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2^n = n^2 * 2\n        # 2. 2^n = n^2 * 2\n        # 3. 2^n = n^2 * 2\n        # 4. 2^n = n^2 * 2\n        # 5. 2^n = n^2 * 2\n        # 6. 2^n = n^2 * 2\n        # 7. 2^n = n^2 * 2\n        # 8. 2^n = n^2 * 2\n        # 9. 2^n = n^2 * 2\n        # 10. 2^n = n^2 * 2\n        # 11. 2^n = n^2 * 2\n        # 12. 2^n = n^2 * 2\n        # 13. 2^n = n^2 * 2\n        # 14. 2^n = n^2 * 2\n        # 15. 2^n = n^2 * 2\n        # 16. 2^n = n^2 * 2\n        # 17. 2^n = n^2 * 2\n        # 18. 2^n = n^2 * 2\n        # 19. 2^n = n^2 * 2\n        # 20. 2^n = n^2 * 2\n        # 21. 2^n = n^2 * 2\n        # 22. 2^n = n^2 * 2\n        # 23. 2^n = n^2 * 2\n        # 24. 2^n = n^2 * 2\n        # 25. 2^n = n^2 * 2\n        # 26. 2^n = n^2 * 2\n        # 27. 2^n = n^2 * 2\n        # 28. 2^n = n^2 * 2\n        # 29. 2^n = n^2 * 2\n        # 30. 2^n = n^2 * 2\n        # 31. 2^n = n^2 * 2\n        # 32. 2^n = n^2 * 2\n        # 33. 2^n = n^2 * 2\n        # 34. 2^n = n^2 * 2\n        # 35. 2^n = n^2 * 2\n        # 36. 2^n = n^2 * 2\n        # 37. 2^n = n^2 * 2\n        # 38. 2^n = n^2 * 2\n        # 39. 2^n = n^2 * 2\n        # 40. 2^n = n^2 * 2\n        # 41. 2^n = n^2 * 2\n        # 42. 2^n = n^2 * 2\n        # 43. 2^n = n^2 * 2\n        # 44. 2^n = n^2 * 2\n        # 45. 2^n = n^2 * 2\n        # 46. 2^n = n^2 * 2\n        # 47. 2^n = n^2 * 2\n        # 48. 2^n = n^2 * 2\n        # 49. 2^n = n^2 * 2\n        # 50. 2^n = n^2 * 2\n        # 51. 2^n = n^2 * 2\n        # 52. 2^n = n^2 * 2\n        # 53. 2^n = n^2 * 2\n        # 54. 2^n = n^2 * 2\n        # 55. 2^n = n^2 * 2\n        # 56. 2^n = n^2 * 2\n        # 57. 2^n = n^2 * 2\n        # 58."}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5."}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the number as negative\n        ## 3. iterate through the list again and return the numbers that are positive\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use binary search to find the index of the number in the sorted array\n        # 3. use binary search to find the number of numbers smaller than the number\n        # 4. use binary search to find the number of numbers smaller than the number\n        # 5. use binary search to find the number of numbers smaller than the number\n        # 6. use binary search to find the number of numbers smaller than the number\n        # 7. use binary search to find the number of numbers smaller than the number\n        # 8. use binary search to find the number of numbers smaller than the number\n        # 9. use binary search to find the number of numbers smaller than the number\n        # 10. use binary search to find the number of numbers smaller than the number\n        # 11. use binary search to find the number of numbers smaller than the number\n        # 12. use binary search to find the number of numbers smaller than the number\n        # 13. use binary search to find the number of numbers smaller than the number\n        # 14. use binary search to find the number of numbers smaller than the number\n        # 15. use binary search to find the number of numbers smaller than the number\n        # 16. use binary search to find the number of numbers smaller than the number\n        # 17. use binary search to find the number of numbers smaller than the number\n        # 18. use binary search to find the number of numbers smaller than the number\n        # 19. use binary search to find the number of numbers smaller than the number\n        # 20. use binary search to find the number of numbers smaller than the number\n        # 21. use binary search to find the number of numbers smaller than the number\n        # 22. use binary search to find the number of numbers smaller than the number\n        # 23. use binary search to find the number of numbers smaller than the number\n        # 24. use binary search to find the number of numbers smaller than the number\n        # 25. use binary search to find the number of numbers smaller than the number\n        # 26. use binary search to find the number of numbers smaller than the number\n        # 27. use binary search to find the number of numbers smaller than the number\n        # 28. use binary search to find the number of numbers smaller than the number\n        # 29. use binary search to find the number of numbers smaller than the number\n        # 30. use binary search to find the number of numbers smaller than the number\n        # 31. use binary search to find the number of numbers smaller than the number\n        # 32. use binary search to find the number of numbers smaller than the number\n        # 33. use binary search to find the number of numbers smaller than the number\n        # 34. use binary search to find the number of numbers smaller than the number\n        # 35. use binary search to find the number of numbers smaller than the number\n        # 36. use binary search to find the number of numbers smaller than the number\n        # 37. use binary search to find the number of numbers smaller than the number\n        # 38. use binary search to find the number of numbers smaller than the number\n        # 39. use binary search to find the number of numbers smaller than the number\n        # 40. use binary search to find the number of numbers smaller than the number\n        # 41. use binary search to find the number of numbers smaller than the number\n        # 42. use binary search to find the number of numbers smaller than the number\n        # 43. use binary search to find the number of numbers smaller than the number\n        # 44. use binary search to find the number of numbers smaller than the number\n        # 45. use binary search to find the number of numbers smaller than the number\n        # 46. use binary search to find the number of numbers smaller than the number\n        # 47. use binary search to find the number of numbers smaller than the number\n        # 48. use binary search to find the number of numbers smaller than the number\n        # 49. use binary search to find the number of numbers smaller than the number\n        # 50. use binary search to find the number of numbers smaller than the number\n        # 51. use binary search to find the number of numbers smaller than the number\n        # 52. use binary search to find the number of numbers smaller than the number\n        #"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = curr = 0\n        for i in intervals:\n            if i[0] > curr:\n                curr = i[1] - 1\n                ans += 2\n            elif i[0] > curr:\n                curr = i[1] - 1\n                ans += 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        if not root:\n            return True\n        return isMirror(root.left, root.right)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                if node.right:\n                    stack.append(node.right)\n                if node.left:\n                    stack.append(node.left)\n                res.append(node.val)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n - i - 1)\n            for l in left:\n                for r in right:\n                    res.append('({}){}'.format(l, r))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        num_sum = 0\n        \n        # iterate\n        while num_sum < n:\n            if i < len(nums) and nums[i] <= num_sum + 1:\n                num_sum += nums[i]\n                i += 1\n            else:\n                num_sum += num_sum + 1\n                patches += 1\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. stack\n        # 6. dynamic programming\n        # 7. greedy\n        # 8. stack\n        # 9. dynamic programming\n        # 10. greedy\n        # 11. stack\n        # 12. dynamic programming\n        # 13. greedy\n        # 14. stack\n        # 15. dynamic programming\n        # 16. greedy\n        # 17. stack\n        # 18. dynamic programming\n        # 19. greedy\n        # 20. stack\n        # 21. dynamic programming\n        # 22. greedy\n        # 23. stack\n        # 24. dynamic programming\n        # 25. greedy\n        # 26. stack\n        # 27. dynamic programming\n        # 28. greedy\n        # 29. stack\n        # 30. dynamic programming\n        # 31. greedy\n        # 32. stack\n        # 33. dynamic programming\n        # 34. greedy\n        # 35. stack\n        # 36. dynamic programming\n        # 37. greedy\n        # 38. stack\n        # 39. dynamic programming\n        # 40. greedy\n        # 41. stack\n        # 42. dynamic programming\n        # 43. greedy\n        # 44. stack\n        # 45. dynamic programming\n        # 46. greedy\n        # 47. stack\n        # 48. dynamic programming\n        # 49. greedy\n        # 50. stack\n        # 51. dynamic programming\n        # 52. greedy\n        # 53. stack\n        # 54. dynamic programming\n        # 55. greedy\n        # 56. stack\n        # 57. dynamic programming\n        # 58. greedy\n        # 59. stack\n        # 60. dynamic programming\n        # 61. greedy\n        # 62. stack\n        # 63. dynamic programming\n        # 64. greedy\n        # 65. stack\n        # 66. dynamic programming\n        # 67. greedy\n        # 68. stack\n        # 69. dynamic programming\n        # 70. greedy\n        # 71. stack\n        # 72. dynamic programming\n        # 73. greedy\n        # 74. stack\n        # 75. dynamic programming\n        # 76. greedy\n        # 77. stack\n        # 78. dynamic programming\n        # 79. greedy\n        # 80. stack\n        # 81. dynamic programming\n        # 82. greedy\n        # 83. stack\n        # 84. dynamic programming\n        # 85. greedy\n        # 86. stack\n        # 87. dynamic programming\n        # 88. greedy\n        # 89. stack\n        # 90. dynamic programming\n        # 91. greedy\n        # 92. stack\n        # 93. dynamic programming\n        # 94. greedy\n        # 95. stack\n        # 96. dynamic programming\n        # 97. greedy\n        # 98. stack\n        # 99. dynamic programming\n        # 100. greedy\n        # 101. stack\n        # 102. dynamic programming\n        # 103. greedy\n        # 104. stack\n        # 105. dynamic programming\n        # 106. greedy\n        # 107. stack\n        # 108. dynamic programming\n        # 109. greedy\n        # 110. stack\n        # 111. dynamic programming\n        # 112. greedy\n        # 113. stack\n        # 114. dynamic programming\n        # 115. greedy\n        # 116. stack\n        # 117. dynamic"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_part = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            decimal_part += str(quotient)\n            \n            if remainder in remainder_dict:\n                decimal_part = decimal_part[:remainder_dict[remainder]] + \"(\" + decimal_part[remainder_dict[remainder]:] + \")\"\n                break\n            remainder_dict[remainder] = len(decimal_part)\n        \n        return str(sign * quotient) + \".\" + decimal_part"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width, then height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find longest increasing subsequence\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O("}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create two pointers\n        left = dummy\n        right = dummy\n        \n        # move right pointer n steps\n        for i in range(n + 1):\n            right = right.next\n        \n        # move both pointers at the same time\n        while right:\n            left = left.next\n            right = right.next\n        \n        # delete the node\n        left.next = left.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 13.9 MB, less than 99.44% of Python online submissions for Intersection of Two Arrays.\n        ## Use set to store the elements in nums1\n        ## Then, iterate through nums2 and check if the element is in the set\n        ## If it is, add it to the result\n        ## Return the result\n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i] - avg\n            ans = max(ans, abs(curr))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(n, x // i)\n            return cnt\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(subset[:])\n            else:\n                # include nums[first] in subset\n                subset.append(nums[first])\n                backtrack(first + 1)\n                # not include nums[first] in subset\n                subset.pop()\n                backtrack(first + 1)\n        \n        output = []\n        n = len(nums)\n        for i in range(2 ** n):\n            subset = []\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 5. check if it is a valid exponent\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 6. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 7. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 8. check if it is a valid exponent\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 9. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 10. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 11. check if it is a valid exponent\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 12. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 13. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 14. check if it is a valid exponent\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 15. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 2. I, II, III, IV, V, VI, VII, VIII, IX, X\n        # 3. XL, XC, CD, CM, D, DC, DD, DCC, DCCC, CM\n        # 4. LX, LXX, LXXX, LXXXV, LXXXIX, XC\n        # 5. CX, CXX, CXXX, CXXXV, CXXXIX, XL\n        # 6. XCV, XCVV, XCVVV, XCVVVV, XCVVVVV, XCVVVVVV\n        # 7. IV, IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 8. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 9. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 10. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 11. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 12. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 13. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 14. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 15. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 16. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 17. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 18. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 19. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 20. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 21. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 22. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 23. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 24. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 25. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 26. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 27. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 28. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 29. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 30. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 31. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 32. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 33. IX, XL, XC, CD, CM, DD, DDC, DDC, DDC\n        # 34."}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 1. XOR all the characters in s and t\n        ## 2. XOR the result with 0\n        ## 3. Return the result\n        \n        result = 0\n        for c in s:\n            result ^= ord(c)\n        for c in t:\n            result ^= ord(c)\n        return chr(result)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_space(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        return (i, j)\n            return None\n        \n        def is_valid(board, num, pos):\n            # check row\n            for i in range(9):\n                if board[pos[0]][i] == num and pos[1] != i:\n                    return False\n            \n            # check column\n            for i in range(9):\n                if board[i][pos[1]] == num and pos[0] != i:\n                    return False\n            \n            # check box\n            box_x = pos[0] // 3\n            box_y = pos[1] // 3\n            \n            for i in range(box_x * 3, box_x * 3 + 3):\n                for j in range(box_y * 3, box_y * 3 + 3):\n                    if board[i][j] == num and (i, j) != pos:\n                        return False\n            \n            return True\n        \n        def solve(board):\n            empty = find_empty_space(board)\n            if empty is None:\n                return True\n            \n            for i in range(1, 10):\n                if is_valid(board, str(i), empty):\n                    board[empty[0]][empty[1]] = str(i)\n                    \n                    if solve(board):\n                        return True\n                    \n                    board[empty[0]][empty[1]] = '.'\n            \n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left, right = 0, num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0, 1]\n        \n        ans = [0, 1]\n        for i in range(2, n + 1):\n            if i % 2 == 0:\n                ans.append(ans[i // 2])\n            else:\n                ans.append(ans[i // 2] + 1)\n        \n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node, path):\n            if len(path) > 2:\n                return\n            if node.isWord:\n                res.add(path)\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] not in node.children:\n                return\n            tmp = board[i][j]\n            board[i][j] = '#'\n            dfs(i + 1, j, node.children[tmp], path + tmp)\n            dfs(i - 1, j, node.children[tmp], path + tmp)\n            dfs(i, j + 1, node.children[tmp], path + tmp)\n            dfs(i, j - 1, node.children[tmp], path + tmp)\n            board[i][j] = tmp\n        \n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.isWord = False\n        \n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n            node.isWord = True\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, root, '')\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if not self.isValid(box):\n                    return False\n        \n        return True\n    \n    def isValid(self, box):\n        counts = collections.Counter(filter(lambda x: x != \".\", box))\n        return len(counts) == len(set(counts.values()))"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 1440000\n        # 26^5 = 73720000\n        # 26^6 = 3486784000\n        # 26^7 = 167961600000\n        # 26^8 = 7836416000000\n        # 26^9 = 394560000000000\n        # 26^10 = 19767520000000000\n        # 26^11 = 987904000000000000\n        # 26^12 = 49680000000000000000\n        # 26^13 = 2488320000000000000000\n        # 26^14 = 12544000000000000000000\n        # 26^15 = 627200000000000000000000\n        # 26^16 = 3136000000000000000000000\n        # 26^17 = 15544000000000000000000000\n        # 26^18 = 777200000000000000000000000\n        # 26^19 = 3886400000000000000000000000\n        # 26^20 = 19536000000000000000000000000\n        # 26^21 = 97680000000000000000000000000\n        # 26^22 = 488320000000000000000000000000\n        # 26^23 = 2441600000000000000000000000000\n        # 26^24 = 12252000000000000000000000000000\n        # 26^25 = 61264000000000000000000000000000\n        # 26^26 = 306432000000000000000000000000000\n        # 26^27 = 1505840000000000000000000000000000\n        # 26^28 = 7529600000000000000000000000000000\n        # 26^29 = 37648000000000000000000000000000000\n        # 26^30 = 188240000000000000000000000000000000\n        # 26^31 = 941200000000000000000000000000000000\n        # 26^32 = 47064000"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for letter, word in zip(pattern, words):\n            # check if the letter is already in the mapping\n            if letter in mapping:\n                # check if the word is already mapped to the letter\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the mapping, add it with the word\n            else:\n                mapping[letter] = word\n        \n        # if all the letters are mapped to words, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a dummy node\n        dummy = ListNode()\n        \n        # Initialize a pointer to the dummy node\n        curr = dummy\n        \n        # Initialize a variable to store the carry over\n        carry = 0\n        \n        # Iterate over the two linked lists\n        while l1 or l2 or carry:\n            # Calculate the sum of the current nodes\n            if l1:\n                sum1 = l1.val\n            else:\n                sum1 = 0\n            if l2:\n                sum2 = l2.val\n            else:\n                sum2 = 0\n            # Calculate the sum of the current nodes\n            sum = sum1 + sum2 + carry\n            # Calculate the carry over\n            carry = sum // 10\n            # Calculate the value of the current node\n            curr.next = ListNode(sum % 10)\n            # Move the pointers to the next node\n            curr = curr.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        # Return the dummy node's next node\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        flip_binary = \"\"\n        for bit in binary:\n            if bit == \"0\":\n                flip_binary += \"1\"\n            else:\n                flip_binary += \"0\"\n        \n        # 3. convert back to decimal\n        return int(flip_binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n        \n        return sum(dp)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time: O(N^2)\n        # Space: O(N)\n        \n        # 1. build a set of words\n        # 2. iterate through each word\n        # 3. if word is in set, then check if it can be built from other words in set\n        # 4. if it can, then add it to the result\n        # 5. if it cannot, then add it to the set\n        \n        word_set = set(words)\n        result = []\n        \n        for word in words:\n            if self.can_be_built(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        \n        return result\n    \n    def can_be_built(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and suffix in word_set:\n                return True\n            if prefix in word_set and self.can_be_built(suffix, word_set):\n                return True\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = ''\n        \n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return sign * res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row + col}, diag2 | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return [['.' * col + 'Q' + '.' * (n - col - 1) for col in cols]]\n            \n            ans = []\n            for col in range(n):\n                if cols & (1 << col) == 0 and diag1 & (1 << (row + col)) == 0 and diag2 & (1 << (row - col + n - 1)) == 0:\n                    cols |= (1 << col)\n                    diag1 |= (1 << (row + col))\n                    diag2 |= (1 << (row - col + n - 1))\n                    ans.extend(backtrack(row + 1, cols, diag1, diag2))\n                    cols ^= (1 << col)\n                    diag1 ^= (1 << (row + col))\n                    diag2 ^= (1 << (row - col + n - 1))\n            return ans\n        \n        return backtrack(0, 0, 0, 0)"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. if the list has 3 elements, return the third element\n        # 4. if the list has more than 3 elements, return the third element\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}