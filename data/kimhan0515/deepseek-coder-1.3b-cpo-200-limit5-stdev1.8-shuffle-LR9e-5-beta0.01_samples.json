{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        # 3. If the current number is positive and less than the length of the array, swap the current number with the index of the current number - 1\n        # 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        # 5. If the current number is positive and less than the length of the array, return the index + 1\n        # 6. If the current number is positive and greater than the length of the array, return the length of the array + 1\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                # 3. If the current number is positive and less than the length of the array, swap the current number with the index of the current number - 1\n                if nums[i] != nums[nums[i] - 1]:\n                    nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]\n                else:\n                    i += 1\n        \n        # 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 5. If the current number is positive and less than the length of the array, return the index + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # 1. set left and right pointers\n        # 2. if sum of left and right is greater than target, move right pointer to the left\n        # 3. if sum of left and right is less than target, move left pointer to the right\n        # 4. if sum of left and right is equal to target, return [left+1, right+1]\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] > target:\n                right -= 1\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                return [left+1, right+1]\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(''.join(path))\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if i == 0:\n                    backtrack(j+1, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, res)\n                    backtrack(j+1, curr, curr, res)\n                    backtrack(j+1, -curr, prev - curr, res)\n                    backtrack(j+1, -curr, curr - prev, res)\n                    backtrack(j+1, curr * prev, curr, res)\n                    backtrack(j+1, curr * prev, -curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr * 10 + root.val\n            return dfs(root.left, curr * 10 + root.val) + dfs(root.right, curr * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        res = \"\"\n        for i in range(0, len(s), k):\n            res += s[i:i+k]\n            res += '-'\n        res = res[:-1]\n        return res[::-1]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        if total_gas < total_cost:\n            return -1\n        \n        start = 0\n        curr_gas = 0\n        for i in range(n):\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                start = i + 1\n                curr_gas = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return s and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if s and (s[0] == p[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n        else:\n            while s and (s[0] == p[0] or p[0] == '.'):\n                if self.isMatch(s, p[2:]):\n                    return True\n                s = s[1:]\n            return self.isMatch(s, p[2:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def max_k_nums(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        if len(nums1) < k:\n            return nums2[:k]\n        if len(nums2) < k:\n            return nums1[:k]\n        \n        nums1 = pick(nums1, k)\n        nums2 = pick(nums2, k)\n        \n        if len(nums1) == len(nums2):\n            return merge(nums1, nums2)\n        \n        if len(nums1) > len(nums2):\n            return max_k_nums(nums1, k)\n        else:\n            return max_k_nums(nums2, k)"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(dp[i+1][n-1] - dungeon[i][n-1], 1)\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(dp[m-1][j+1] - dungeon[m-1][j], 1)\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5\n        ## 0 ^ 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 2 ^ 3 ^ 3 ^ 3\n        ## 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 2 ^ 2 ^ 2\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 2\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0\n        ## 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1\n        ## 1\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1\n        ## 1\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1\n        ## 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(N * M)\n        # Space Complexity: O(N * M)\n        # where N is the number of words in wordList and M is the length of the longest word in wordList\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        \n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    return level\n                for i in range(len(curr)):\n                    neighbor = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n            level += 1\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        res = \"\"\n        carry = 0\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        \n        if carry == 1:\n            res += \"1\"\n        \n        return res[::-1]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, is_left):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (is_left and nums[mid] == target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_index = binary_search(nums, target, True)\n        if left_index == len(nums) or nums[left_index] != target:\n            return [-1, -1]\n        right_index = binary_search(nums, target, False) - 1\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(len(prices) - 1))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(len(prices) - 2, -1, -1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i + 1][j] - prices[i], dp[i + 1][j - 1])\n                dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + prices[i])\n        \n        return dp[0][k]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a hashmap to store the frequency of each character in the string\n        # 2. Iterate through the string and check if the character is already in the hashmap\n        # 3. If the character is already in the hashmap, increment the frequency by 1\n        # 4. If the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # 5. Iterate through the string again and return the index of the first character with a frequency of 1\n        # 6. If there is no character with a frequency of 1, return -1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        hashmap = {}\n        for char in s:\n            if char in hashmap:\n                hashmap[char] += 1\n            else:\n                hashmap[char] = 1\n        \n        for i in range(len(s)):\n            if hashmap[s[i]] == 1:\n                return i\n        \n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n\n        # if len(nums) <= 1:\n        #     return False\n\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] -"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n            if s[i] == '(':\n                stack.append('(')\n            if s[i] == ')':\n                num = self.calculate(stack)\n                stack.pop()\n                stack.append(num)\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits = [profits[i] for i in range(len(profits))]\n        # capital = [capital[i] for i in range(len(capital))]\n        # profits.sort()\n        # capital.sort()\n        # print(profits)\n        # print(capital)\n        # print(profits[::-1])\n        # print(capital[::-1])\n        # print(profits[::-1][:k])\n        # print(capital[::-1][:k])\n        # print(profits[::-1][:k][::-1])\n        # print(capital[::-1][:k][::-1])\n        # print(profits[::-1][:k][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(capital[::-1][:k][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1])\n        # print(profits[::-1][:k][::-1][::-1][::-1][::-1][::"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the index of the first number that is smaller than the next number\n        # find the index of the first number that is larger than the number at the index\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the result\n        \n        # find the index of the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        else:\n            nums.reverse()\n            return\n        \n        # find the index of the first number that is larger than the number at the index\n        for i in range(len(nums)-1,i,-1):\n            if nums[i] > nums[i-1]:\n                break\n        else:\n            nums[i-1],nums[i] = nums[i],nums[i-1]\n            return\n        \n        # swap the two numbers\n        nums[i],nums[i-1] = nums[i-1],nums[i]\n        \n        # reverse the numbers after the index\n        nums[i:] = nums[i:][::-1]\n        \n        return"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Approach: Using a hashmap to store the values and their indices\n        # If the value is already in the hashmap, then check if the difference between the indices is less than or equal to k\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hashmap, then add it to the hashmap\n        # If the value is in the hashmap, then return True\n        # If the value is not in the hash"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = \"qwertyuiop\"\n        row2 = \"asdfghjkl\"\n        row3 = \"zxcvbnm\"\n        res = []\n        for word in words:\n            if word[0] in row1:\n                r = row1\n            elif word[0] in row2:\n                r = row2\n            else:\n                r = row3\n            for c in word:\n                if c not in r:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        while count <= right:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        head = prev\n        \n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the concatenated string is a palindrome, return the concatenated string\n        # 5. Otherwise, return the reversed string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_map = {}\n        for c in t:\n            t_map[c] = t_map.get(c, 0) + 1\n        \n        left = 0\n        right = 0\n        min_window = \"\"\n        min_window_len = float(\"inf\")\n        window_map = {}\n        for c in s:\n            window_map[c] = window_map.get(c, 0) + 1\n            if c in t_map and window_map[c] <= t_map[c]:\n                right += 1\n            \n            while left <= right and right < len(s):\n                if right - left + 1 < min_window_len:\n                    min_window = s[left:right+1]\n                    min_window_len = right - left + 1\n                window_map[s[left]] -= 1\n                left += 1\n        \n        return min_window"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] >= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i+4] >= distance[i+2] and distance[i+3] >= distance[i+1]:\n                return True\n            if i >= 4 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] == distance[i+1]:\n                return True\n            if i >= 5 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1]:\n                return True\n            if i >= 6 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+6] + distance[i+8] >= distance[i+7]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ube7c\uc900\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ube7c\uc900\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 3\uc744 \ube7c\uc900\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 3\uc744 \ube7c\uc900\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 4\ub97c \ube7c\uc900\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 4\ub97c \ube7c\uc900\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 5\ub97c \ube7c\uc900\ub2e4.\n        # 11. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 5\ub97c \ube7c\uc900\ub2e4.\n        # 12. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 6\uc744 \ube7c\uc900\ub2e4.\n        # 13. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= len(forest) or j < 0 or j >= len(forest[0]):\n                return float('inf')\n            if forest[i][j] == 0:\n                return float('inf')\n            if i == len(forest) - 1 and j == len(forest[0]) - 1:\n                return 0\n            if i == len(forest) - 1:\n                return dfs(i, j + 1) + 1\n            if j == len(forest[0]) - 1:\n                return dfs(i + 1, j) + 1\n            return min(dfs(i, j + 1), dfs(i + 1, j), dfs(i, j + 1)) + 1\n        \n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i, j))\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        res = 0\n        for i, j in trees:\n            res += dfs(i, j)\n            if res == float('inf'):\n                return -1\n        return res"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8elower\u7684\u4e0b\u6807i\n        # 3. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8eupper\u7684\u4e0b\u6807j\n        # 4. \u8fd4\u56dej-i\n        # 5. \u65f6\u95f4\u590d\u6742\u5ea6O(nlogn)\n        # 6. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 7. \u901a\u8fc7\n        # 8. 2022-08-25 15:44:55\n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Since the number of coins is always positive, we can use the formula:\n        # coins = (sqrt(8 * n + 1) - 1) / 2\n        # where n is the number of coins.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of complete rows of the staircase.\n        # The formula is used to find the number of"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0]\n        for i in range(1,n):\n            res += [2**i + x for x in res[::-1]]\n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i]) for all 0 <= j < i\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i])\n        #"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (node.val <= left or node.val >= right):\n                return False\n            \n            return valid(node.left, left, node.val) and valid(node.right, node.val, right)\n        \n        return valid(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty, return intervals\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not overlapping with any interval in intervals, return newInterval\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        if newInterval[0] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if newInterval is overlapping with the first interval in intervals, update newInterval\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            newInterval = intervals[0]\n        \n        # if newInterval is overlapping with the last interval in intervals, update newInterval\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            newInterval = intervals[-1]\n        \n        # if newInterval is overlapping with any interval in intervals, merge newInterval with the interval\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                newInterval = intervals[i]\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                newInterval = intervals[i]\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n        \n        # remove the interval from intervals that is overlapping with newInterval\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.pop(i)\n                break\n        \n        # insert newInterval into intervals\n        intervals.insert(0, newInterval)\n        \n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    path.append(s[start:i+1])\n                    backtrack(s, i+1, path, res)\n                    path.pop()\n        \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        min_range = [float('inf'), float('-inf')]\n        max_range = [float('-inf'), float('inf')]\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n            max_range[0] = max(max_range[0], nums[i][0])\n            max_range[1] = max(max_range[1], nums[i][-1])\n        while heap:\n            curr_min, curr_index, curr_num = heapq.heappop(heap)\n            if max_range[1] - max_range[0] < max_range[1] - min_range[0]:\n                min_range[0] = curr_min\n                min_range[1] = max_range[1]\n            if curr_num + 1 < len(nums[curr_index]):\n                heapq.heappush(heap, (nums[curr_index][curr_num + 1], curr_index, curr_num + 1))\n                max_range[1] = max(max_range[1], nums[curr_index][curr_num + 1])\n        return min_range"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000 buckets, 15 minutes, 15 minutes\n        # 2. 1000 buckets, 15 minutes, 30 minutes\n        # 3. 1000 buckets, 15 minutes, 60 minutes\n        # 4. 1000 buckets, 15 minutes, 120 minutes\n        # 5. 1000 buckets, 15 minutes, 240 minutes\n        # 6. 1000 buckets, 15 minutes, 480 minutes\n        # 7. 1000 buckets, 15 minutes, 960 minutes\n        # 8. 1000 buckets, 15 minutes, 1920 minutes\n        # 9. 1000 buckets, 15 minutes, 3840 minutes\n        # 10. 1000 buckets, 15 minutes, 7680 minutes\n        # 11. 1000 buckets, 15 minutes, 15360 minutes\n        # 12. 1000 buckets, 15 minutes, 30720 minutes\n        # 13. 1000 buckets, 15 minutes, 61440 minutes\n        # 14. 1000 buckets, 15 minutes, 122880 minutes\n        # 15. 1000 buckets, 15 minutes, 245760 minutes\n        # 16. 1000 buckets, 15 minutes, 491520 minutes\n        # 17. 1000 buckets, 15 minutes, 983040 minutes\n        # 18. 1000 buckets, 15 minutes, 1966080 minutes\n        # 19. 1000 buckets, 15 minutes, 3932160 minutes\n        # 20. 1000 buckets, 15 minutes, 7864320 minutes\n        # 21. 1000 buckets, 15 minutes, 15728640 minutes\n        # 22. 1000 buckets, 15 minutes, 31457280 minutes\n        # 23. 1000 buckets, 15 minutes, 62914560 minutes\n        # 24. 1000 buckets, 15 minutes, 125829120 minutes\n        # 25. 1000 buckets, 15 minutes, 251658240 minutes\n        # 26. 1000 buckets, 15 minutes, 503316480 minutes\n        # 27. 1000 buckets, 15 minutes, 1006632960 minutes\n        # 28. 1000 buckets, 15 minutes, 2013265920 minutes\n        # 29. 1000 buckets, 15 minutes, 4026531840 minutes\n        # 30. 1000 buckets, 15 minutes, 8053063680 minutes\n        # 31. 1000 buckets, 15 minutes, 16106127360 minutes\n        # 32. 1000 buckets, 15 minutes, 32212254720 minutes\n        # 33. 1000 buckets, 15 minutes, 64424509440 minutes\n        # 34. 1000 buckets, 15 minutes, 128849018880 minutes\n        # 35. 1000 buckets, 15 minutes, 257698037760 minutes\n        # 36. 1000 buckets, 15 minutes, 51539"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # BFS\n        q = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        while q:\n            curr, i, j = q.pop(0)\n            res = max(res, curr)\n            if i == n - 1 and j == n - 1:\n                return res\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    q.append((grid[ni][nj], ni, nj))\n                    visited.add((ni, nj))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             dp[i][j] = 1\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             dp[i][j] = 1\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             dp[i][j] = 1\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             dp[i][j] = 1\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             dp[i][j] = 1\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             dp"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n        \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n        \n        res = res[::-1]\n        while res[0] == 0:\n            res = res[1:]\n        \n        return \"\".join(map(str, res))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:index+1], inorder[:index])\n        root.right = self.buildTree(preorder[index+1:], inorder[index+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, res):\n            if left == 0 and right == 0:\n                if isValid(s):\n                    res.append(s)\n                return\n            for i in range(left + right):\n                if i < left:\n                    dfs(s[:i] + s[i+1:], left - 1, right, res)\n                if i >= left and i < right:\n                    dfs(s[:i] + s[i+1:], left, right - 1, res)\n        \n        res = []\n        dfs(s, s.count('('), s.count(')'), res)\n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = lists[:mid]\n        right = lists[mid:]\n        \n        left = self.mergeKLists(left)\n        right = self.mergeKLists(right)\n        \n        return self.mergeTwoLists(left, right)\n        \n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] +"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 1\n            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)\n        \n        m, n = len(isInfected), len(isInfected[0])\n        res = 0\n        while True:\n            infected = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                break\n            res += 1\n            for i, j in infected:\n                isInfected[i][j] = 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        dfs(i, j)\n        return res"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        max_len = 1\n        \n        for direction in directions:\n            x = i + direction[0]\n            y = j + direction[1]\n            \n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            quotient = n // i\n            remainder = n % i\n            count += quotient * i\n            if remainder == 0:\n                count += remainder\n            elif remainder == 1:\n                count += remainder + quotient + 1\n            else:\n                count += remainder + i\n            i *= 10\n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level += 1\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                result.append(level_nodes[::-1])\n            else:\n                result.append(level_nodes)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(hour):\n            if hour == 0:\n                return []\n            elif hour == 1:\n                return ['0:01','0:02','0:04','0:08','0:16','0:32','0:64','1:00','2:00','4:00','8:00']\n            else:\n                return ['0:01','0:02','0:04','0:08','0:16','0:32','0:64','1:00','2:00','4:00','8:00'] + get_hour(hour-1)\n        \n        if turnedOn == 0:\n            return []\n        elif turnedOn == 1:\n            return ['0:01','0:02','0:04','0:08','0:16','0:32','0:64','1:00','2:00','4:00','8:00']\n        else:\n            return get_hour(turnedOn)"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 3 == 0:\n            return self.isPowerOfThree(n/3)\n        return False"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.max_sum = max(self.max_sum, left + root.val + right)\n            return max(left, right) + root.val\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and not visited[new_i][new_j]:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    visited[new_i][new_j] = True\n                    heapq.heappush(heap, (heightMap[new_i][new_j], new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 2-1. \uc9dd\uc218\uc77c \uacbd\uc6b0\n        if len(nums) % 2 == 0:\n            return [(nums[k//2-1] + nums[k//2]) / 2]\n        # 2-2. \ud640\uc218\uc77c \uacbd\uc6b0\n        else:\n            return [nums[k//2]]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        curr.next = head\n        \n        k = k % length\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 14. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 15. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 16. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 17. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 18. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 19. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 20. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 21. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 22. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 23. \uc815\ub82c\ud55c \ub4a4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        if dividend == -2**31 and divisor == 1:\n            return -2**31\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend / divisor)\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend) / abs(divisor))\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend) / abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend) / abs(divisor))\n        \n        return 0"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]\n\n        return [-1,-1]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    for op in ['+', '-', '*', '/']:\n                        new_cards = [cards[k] for k in range(len(cards)) if k != i and k != j]\n                        new_cards.append(eval(str(cards[i]) + op + str(cards[j])))\n                        if dfs(new_cards):\n                            return True\n            return False\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[0] != building[0]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                # set current building to building\n                current_building = building\n            # if current building is not None\n            if current_building is not None:\n                # if building height is greater than max height\n                if building[2] > max_height:\n                    # set max height to building height\n                    max_height = building[2]\n                # if building height is less than current building height\n                if building[2] < current_building[2]:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                    # set current building to building\n                    current_building = building\n                # if building height is greater than current building height\n                if building[2] > current_building[2]:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                    # set current building to building\n                    current_building = building\n\n        # add last building to result\n        result.append([current_building[0], current_building[1]])\n\n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n            return \"\"\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if i > j:\n                        dp[i][j] = 0\n                    else:\n                        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        # 2. Create a pointer to the head of the first list\n        # 3. Create a pointer to the head of the second list\n        # 4. Iterate through the linked list\n        # 5. If the value of the current node is less than x, add it to the first list\n        # 6. If the value of the current node is greater than or equal to x, add it to the second list\n        # 7. Set the next pointer of the first list to the second list\n        # 8. Set the next pointer of the second list to the next node\n        # 9. Return the first list\n        \n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        curr = head\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while curr:\n            if curr.val < x:\n                curr1.next = curr\n                curr1 = curr1.next\n            else:\n                curr2.next = curr\n                curr2 = curr2.next\n            curr = curr.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        self.backtrack(nums, visited, [], res)\n        return res\n        \n    def backtrack(self, nums, visited, path, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            visited[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, visited, path, res)\n            visited[i] = False\n            path.pop()"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR\n        # 2. XOR of a number with itself is 0\n        # 3. XOR of a number with 0 is the number\n        # 4. XOR of two numbers is the XOR of the two numbers\n        # 5. XOR of a number with 0 is the number\n        # 6. XOR of a number with itself is 0\n        # 7. XOR of a number with 0 is the number\n        # 8. XOR of two numbers is the XOR of the two numbers\n        # 9. XOR of a number with 0 is the number\n        # 10. XOR of a number with itself is 0\n        # 11. XOR of a number with 0 is the number\n        # 12. XOR of two numbers is the XOR of the two numbers\n        # 13. XOR of a number with 0 is the number\n        # 14. XOR of a number with itself is 0\n        # 15. XOR of a number with 0 is the number\n        # 16. XOR of two numbers is the XOR of the two numbers\n        # 17. XOR of a number with 0 is the number\n        # 18. XOR of a number with itself is 0\n        # 19. XOR of a number with 0 is the number\n        # 20. XOR of two numbers is the XOR of the two numbers\n        # 21. XOR of a number with 0 is the number\n        # 22. XOR of a number with itself is 0\n        # 23. XOR of a number with 0 is the number\n        # 24. XOR of two numbers is the XOR of the two numbers\n        # 25. XOR of a number with 0 is the number\n        # 26. XOR of a number with itself is 0\n        # 27. XOR of a number with 0 is the number\n        # 28. XOR of two numbers is the XOR of the two numbers\n        # 29. XOR of a number with 0 is the number\n        # 30. XOR of a number with itself is 0\n        # 31. XOR of a number with 0 is the number\n        # 32. XOR of two numbers is the XOR of the two numbers\n        # 33. XOR of a number with 0 is the number\n        # 34. XOR of a number with itself is 0\n        # 35. XOR of a number with 0 is the number\n        # 36. XOR of two numbers is the XOR of the two numbers\n        # 37. XOR of a number with 0 is the number\n        # 38. XOR of a number with itself is 0\n        # 39. XOR of a number with 0 is the number\n        # 40. XOR of two numbers is the XOR of the two numbers\n        # 41. XOR of a number with 0 is the number\n        # 42. XOR of a number with itself is 0\n        # 43. XOR of a number with 0 is the number\n        # 44. XOR of two numbers is the XOR of the two numbers\n        # 45. XOR of a number with 0 is the number\n        # 46. XOR of a number with itself is 0\n        # 47. XOR of a number with 0 is the number\n        # 48. XOR of two numbers is the XOR of the two numbers\n        # 49. XOR of a number with 0 is the number\n        # 50. XOR of a number with itself is 0\n        # 51. XOR of a number with 0 is the number\n        # 52. XOR of two numbers is the XOR of the two numbers\n        # 53. XOR of a number with 0 is the number\n        # 54. XOR of a number with itself is 0\n        # 55. XOR of a number with 0 is the number\n        # 56. XOR of two numbers is the XOR of the two numbers\n        # 57. XOR of a number with 0 is the number\n        #"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    res = 0\n                    for dj1, dj2 in [(1, 1), (-1, -1)]:\n                        new_j1, new_j2 = j1 + dj1, j2 + dj2\n                        if 0 <= new_j1 < n and 0 <= new_j2 < n:\n                            res = max(res, dp[i - 1][new_j1][new_j2])\n                    if grid[i][j1] == -1 or grid[i][j2] == -1:\n                        res = -float('inf')\n                    dp[i][j1][j2] = res + grid[i][j1] + grid[i][j2]\n        return max(dp[n - 1][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0]*3 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2]\n            dp[i][1] = dp[i-1][0]\n            dp[i][2] = dp[i-1][1]\n            dp[i][0] %= mod\n            dp[i][1] %= mod\n            dp[i][2] %= mod\n        return (dp[n][0] + dp[n][1] + dp[n][2]) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return False\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return False\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return False\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return False\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return False\n\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i >= nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return False\n\n        # if len(nums) == 1"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1,n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211211131221\"\n        \n        if n == 13:\n            return \"132113213211231131221131211131221\"\n        \n        if n == 14:\n            return \"111312211312111312212321231131221131211\"\n        \n        if n == 15:\n            return \"31131122213213211231131221231131221131211\"\n        \n        if n == 16:\n            return \"1321132132112311312212321231131221231131221131211\"\n        \n        if n == 17:\n            return \"1113122113121113122123212311312212321231131221231131221\"\n        \n        if n == 18:\n            return \"3113112221321321123113122123212311312212321231131221231131221\"\n        \n        if n == 19:\n            return \"132113213211231131221232123113122123212311312212321231131221231131221\"\n        \n        if n == 20:\n            return \"111312211312111312212321231131221232123113122123212311312212321231131221\"\n        \n        if n == 21:\n            return \"31131122213213211231131221232123113122123212311312212321231131221231131221\"\n        \n        if n == 22:\n            return \"1321132132112311312212321231131221232123113122123212311312212321231131221\"\n        \n        if n == 23:\n            return \"111"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isPossible(nums, k, mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > mid:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isPossible(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map the next available digit\n                for letter in phone[next_digits[0]]:\n                    # append the letter to the combination\n                    # and proceed to the next digits\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, target, path):\n            if target == 0:\n                res.append(path)\n                return\n            if i >= len(candidates) or target < 0:\n                return\n            dfs(i, target - candidates[i], path + [candidates[i]])\n            dfs(i + 1, target, path)\n        dfs(0, target, [])\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the closest palindrome\n        # 2. If the closest palindrome is the same as n, return the smallest palindrome\n        # 3. If the closest palindrome is 0, return 0\n        # 4. If the closest palindrome is n, return n\n        # 5. If the closest palindrome is n+1, return n+1\n        # 6. If the closest palindrome is n-1, return n-1\n\n        # 1. Find the closest palindrome\n        closest_palindrome = self.find_closest_palindrome(n)\n\n        # 2. If the closest palindrome is the same as n, return the smallest palindrome\n        if closest_palindrome == n:\n            return self.find_smallest_palindrome(n)\n\n        # 3. If the closest palindrome is 0, return 0\n        if closest_palindrome == \"0\":\n            return \"0\"\n\n        # 4. If the closest palindrome is n, return n\n        if closest_palindrome == n:\n            return n\n\n        # 5. If the closest palindrome is n+1, return n+1\n        if closest_palindrome == n+1:\n            return n+1\n\n        # 6. If the closest palindrome is n-1, return n-1\n        if closest_palindrome == n-1:\n            return n-1\n\n    def find_closest_palindrome(self, n):\n        # Find the closest palindrome\n        closest_palindrome = None\n        closest_diff = float('inf')\n\n        # Find the closest palindrome\n        for i in range(10**(len(n)-1), 10**(len(n))):\n            if i == int(n):\n                continue\n            if i == int(n)+1:\n                if closest_diff > abs(int(n)-1):\n                    closest_diff = abs(int(n)-1)\n                    closest_palindrome = i\n                continue\n            if i == int(n)-1:\n                if closest_diff > abs(int(n)+1):\n                    closest_diff = abs(int(n)+1)\n                    closest_palindrome = i\n                continue\n            if i == int(n)+2:\n                if closest_diff > abs(int(n)+2):\n                    closest_diff = abs(int(n)+2)\n                    closest_palindrome = i\n                continue\n            if i == int(n)-2:\n                if closest_diff > abs(int(n)-2):\n                    closest_diff = abs(int(n)-2)\n                    closest_palindrome = i\n                continue\n            if i == int(n)+3:\n                if closest_diff > abs(int(n)+3):\n                    closest_diff = abs(int(n)+3)\n                    closest_palindrome = i\n                continue\n            if i == int(n)-3:\n                if closest_diff > abs(int(n)-3):\n                    closest_diff = abs(int(n)-3)\n                    closest_palindrome = i\n                continue\n            if i == int(n)+4:\n                if closest_diff > abs(int(n)+4):\n                    closest_diff = abs(int(n)+4)\n                    closest_palindrome = i\n                continue\n            if i == int(n)-4:\n                if closest_diff > abs(int(n)-4):\n                    closest_diff = abs(int(n)-4)\n                    closest_palindrome = i\n                continue\n            if i == int(n)+5:\n                if closest_diff > abs(int(n)+5):\n                    closest_diff = abs(int(n)+5)\n                    closest_palindrome = i\n                continue\n            if i == int(n)-5:\n                if closest_diff > abs(int(n)-5):\n                    closest_diff = abs(int(n)-5)\n                    closest_palindrome = i\n                continue\n            if i == int(n)+6:\n                if closest_diff > abs(int(n)+6):\n                    closest_diff = abs(int(n)+6)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            for i in range(col_end, col_start - 1, -1):\n                matrix[row_end][i] = num\n                num += 1\n            row_end -= 1\n            \n            for i in range(row_end, row_start - 1, -1):\n                matrix[i][col_start] = num\n                num += 1\n            col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n\n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(stones[-1])\n        stone_set.add(stones[-1] + 1)\n        stone_set.add(stones[-1] + 2)\n        stone_set.add(stones[-1] + 3)\n        stone_set.add(stones[-1] + 4)\n        stone_set.add(stones[-1] + 5)\n        stone_set.add(stones[-1] + 6)\n        stone_set.add(stones[-1] + 7)\n        stone_set.add(stones[-1] + 8)\n        stone_set.add(stones[-1] + 9)\n        stone_set.add(stones[-1] + 10)\n        stone_set.add(stones[-1] + 11)\n        stone_set.add(stones[-1] + 12)\n        stone_set.add(stones[-1] + 13)\n        stone_set.add(stones[-1] + 14)\n        stone_set.add(stones[-1] + 15)\n        stone_set.add(stones[-1] + 16)\n        stone_set.add(stones[-1] + 17)\n        stone_set.add(stones[-1] + 18)\n        stone_set.add(stones[-1] + 19)\n        stone_set.add(stones[-1] + 20)\n        stone_set.add(stones[-1] + 21)\n        stone_set.add(stones[-1] + 22)\n        stone_set.add(stones[-1] + 23)\n        stone_set.add(stones[-1] + 24)\n        stone_set.add(stones[-1] + 25)\n        stone_set.add(stones[-1] + 26)\n        stone_set.add(stones[-1] + 27)\n        stone_set.add(stones[-1] + 28)\n        stone_set.add(stones[-1] + 29)\n        stone_set.add(stones[-1] + 30)\n        stone_set.add(stones[-1] + 31)\n        stone_set.add(stones[-1] + 32)\n        stone_set.add(stones[-1] + 33)\n        stone_set.add(stones[-1] + 34)\n        stone_set.add(stones[-1] + 35)\n        stone_set.add(stones[-1] + 36)\n        stone_set.add(stones[-1] + 37)\n        stone_set.add(stones[-1] + 38)\n        stone_set.add(stones[-1] + 39)\n        stone_set.add(stones[-1] + 40)\n        stone_set.add(stones[-1] + 41)\n        stone_set.add(stones[-1] + 42)\n        stone_set.add(stones[-1] + 43)\n        stone_set.add(stones[-1] + 44)\n        stone_set.add(stones[-1] + 45)\n        stone_set.add(stones[-1] + 46)\n        stone_set.add(stones[-1] + 47)\n        stone_set.add(stones[-1] + 48)\n        stone_set.add(stones[-1] + 49)\n        stone_set.add(stones[-1] + 50)\n        stone_set.add(stones[-1] + 51)\n        stone_set.add(stones[-1] + 52)\n        stone_set.add(stones[-1] + 53)\n        stone_set.add(stones[-1] + 54)\n        stone_set.add(stones[-1] + 55)\n        stone_set.add(stones[-1] + 56)\n        stone_set.add(stones[-1] + 57)\n        stone_set.add(stones[-1] + 58)\n        stone_set.add(stones[-1] + 59)\n        stone_set.add"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        rank_map = {score[i]: i+1 for i in range(len(score))}\n        \n        # create a list to store the result\n        result = []\n        \n        # loop through the score and add the rank to the result\n        for s in score:\n            if rank_map[s] == 1:\n                result.append(\"Gold Medal\")\n            elif rank_map[s] == 2:\n                result.append(\"Silver Medal\")\n            elif rank_map[s] == 3:\n                result.append(\"Bronze Medal\")\n            else:\n                result.append(str(rank_map[s]))\n        \n        return result"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        start = 0\n        seen = {}\n        for i, c in enumerate(s):\n            if c in seen:\n                start = max(start, seen[c] + 1)\n            seen[c] = i\n            max_len = max(max_len, i - start + 1)\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        chunks = 0\n        for i in range(len(arr)):\n            if arr[i] == max_num:\n                chunks += 1\n                max_num = max(arr[i+1:])\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            nums[left:right + 1] = temp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid)\n            count += mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v2) > len(v1):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) == 1:\n        #     return 0\n        # max_profit = 0\n        # for i in range(len(prices)-1):\n        #     for j in range(i+1, len(prices)):\n        #         if prices[j] - prices[i] > max_profit:\n        #             max_profit = prices[j] - prices[i]\n        # return max_profit\n        \n        # if len(prices) == 1:\n        #     return 0\n        # max_profit = 0\n        # min_price = prices[0]\n        # for i in range(1, len(prices)):\n        #     if prices[i] < min_price:\n        #         min_price = prices[i]\n        #     elif prices[i] - min_price > max_profit:\n        #         max_profit = prices[i] - min_price\n        # return max_profit\n        \n        if len(prices) == 1:\n            return 0\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            elif prices[i] - min_price > max_profit:\n                max_profit = prices[i] - min_price\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2*a + b = a + a + b\n        # 2. 2*a + 2*b = a + b + a + b\n        # 3. 2*a + 2*b + 2*c = a + b + c + a + b + c\n        # 4. 2*a + 2*b + 2*c + 2*d = a + b + c + d + a + b + c + d\n        # 5. 2*a + 2*b + 2*c + 2*d + 2*e = a + b + c + d + e + a + b + c + d + e\n        # 6. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f = a + b + c + d + e + f + a + b + c + d + e + f\n        # 7. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g = a + b + c + d + e + f + g + a + b + c + d + e + f + g\n        # 8. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h = a + b + c + d + e + f + g + h + a + b + c + d + e + f + g + h\n        # 9. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i = a + b + c + d + e + f + g + h + i + a + b + c + d + e + f + g + h + i\n        # 10. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i + 2*j = a + b + c + d + e + f + g + h + i + j + a + b + c + d + e + f + g + h + i + j\n        # 11. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i + 2*j + 2*k = a + b + c + d + e + f + g + h + i + j + k + a + b + c + d + e + f + g + h + i + j + k\n        # 12. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i + 2*j + 2*k + 2*l = a + b + c + d + e + f + g + h + i + j + k + l + a + b + c + d + e + f + g + h + i + j + k + l\n        # 13. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i + 2*j + 2*k + 2*l + 2*m = a + b + c + d + e + f + g + h + i + j + k + l + m + a + b + c + d + e + f + g + h + i + j + k + l + m\n        # 14. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i + 2*j + 2*k + 2*l + 2*m + 2*n = a + b + c + d + e + f + g + h + i + j + k + l + m + n + a + b + c + d + e + f + g + h + i + j + k + l + m + n\n        # 15. 2*a + 2*b + 2*c + 2*d + 2*e + 2*f + 2*g + 2*h + 2*i + 2*j + 2*k + 2*l + 2*m + 2*n + 2*o = a + b + c + d + e + f + g + h + i + j + k + l +"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if target == \"\":\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target)"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                result += roman_dict[s[i]]\n                i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums\n        \n        max_nums = []\n        max_nums.append(max(nums[0:k]))\n        \n        for i in range(k, len(nums)):\n            if nums[i] > max_nums[-1]:\n                max_nums.append(nums[i])\n            else:\n                max_nums.append(max_nums[-1])\n        \n        return max_nums"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(int(area**0.5), 0, -1):\n            if area % i == 0:\n                return [area//i, i]\n        \n        return [area, 1]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def find_neighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        queue = [beginWord]\n        visited = {beginWord}\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            new_queue = []\n            for word in queue:\n                if word == endWord:\n                    res.append(list(visited))\n                else:\n                    neighbors = find_neighbors(word)\n                    for neighbor in neighbors:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            new_queue.append(neighbor)\n            queue = new_queue\n        \n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        if n == 1:\n            return True\n        else:\n            return False"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            if path not in res:\n                res.append(path)\n            for i in range(start, len(nums)):\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 3. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 4. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 5. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 6. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 7. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 8. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 9. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 10. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 11. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 12. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 13. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 14. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 15. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\uace0 \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 16. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min == x_max and y_min == y_max:\n            return True\n        if x_min == x_max or y_min == y_max:\n            return False\n        if x_min < y_min or x_max > y_max:\n            return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,0,4,5,1\n        # 3,4,5,0,1,2\n        # 3,4,0,5,1,2\n        # 3,0,4,5,1,2\n        # 4,5,0,1,2,3\n        # 4,0,5,1,2,3\n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,0,4,5,1\n        # 3,4,5,0,1,2\n        # 3,4,0,5,1,2\n        # 3,0,4,5,1,2\n        # 4,5,0,1,2,3\n        # 4,0,5,1,2,3\n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,0,4,5,1\n        # 3,4,5,0,1,2\n        # 3,4,0,5,1,2\n        # 3,0,4,5,1,2\n        # 4,5,0,1,2,3\n        # 4,0,5,1,2,3\n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,0,4,5,1\n        # 3,4,5,0,1,2\n        # 3,4,0,5,1,2\n        # 3,0,4,5,1,2\n        # 4,5,0,1,2,3\n        # 4,0,5,1,2,3\n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,0,4,5,1\n        # 3,4,5,0,1,2\n        # 3,4,0,5,1,2\n        # 3,0,4,5,1,2\n        # 4,5,0,1,2,3\n        # 4,0,5,1,2,3\n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1,2,3,4,0,5\n        # 2,3,4,5,0,1\n        # 2,3,4,0,5,1\n        # 2,3,0,4,5,1\n        # 3,4,5,0,1,2\n        # 3,4,0,5,1,2\n        # 3,0,4,5,1,2\n        # 4,5,0,1,2,3\n        # 4,0,5,1,2,3\n        # 0,1,2,3,4,5\n        # 1,2,3,4,5,0\n        # 1"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l = 0\n        r = len(nums)-1\n        while l<=r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < nums[r]:\n                if nums[mid] < target and target <= nums[r]:\n                    l = mid+1\n                else:\n                    r = mid-1\n            else:\n                if nums[l] <= target and target < nums[mid]:\n                    r = mid-1\n                else:\n                    l = mid+1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n        return dp[-1][-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            if s[0] == '1' or (s[0] == '2' and s[1] in '0123456'):\n                return 2\n            else:\n                return 1\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[-1] % (10**9 + 7)"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.min_diff = min(self.min_diff, root.val - self.prev)\n            self.prev = root.val\n            inorder(root.right)\n        \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        res = dfs(root)\n        max_count = max(res.count(x) for x in set(res))\n        return [x for x in set(res) if res.count(x) == max_count]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 7. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 9. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 11. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 13. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 15. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 16. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1 \uc99d\uac00\n        # 17. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \ufffd"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n // 5\n            n = n // 5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = True\n        \n        for c in s:\n            res[i] += c\n            if i == numRows - 1:\n                flag = False\n            elif i == 0:\n                flag = True\n            if flag:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ufffd"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. loop through the array and mark the index of the number as negative\n        ## 2. loop through the array again and add the index to the result\n        ## 3. return the result\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        \n        result = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result.append(i + 1)\n        \n        return result"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        for interval in intervals:\n            if interval[0] <= res:\n                continue\n            if interval[0] <= res + 1:\n                res += 1\n            else:\n                res += 2\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None:\n                return False\n            if root1.val != root2.val:\n                return False\n            return isMirror(root1.left, root2.right) and isMirror(root1.right, root2.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \u5148\u628a\u6240\u6709\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u90fd\u7b97\u51fa\u6765\n        # 2. \u518d\u628a\u6240\u6709\u975e\u62ec\u53f7\u5143\u7d20\u7b97\u51fa\u6765\n        # 3. \u6700\u540e\u628a\u6240\u6709\u5143\u7d20\u90fd\u7b97\u51fa\u6765\n        # 4. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 5. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 6. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 7. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 8. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 9. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 10. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 11. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 12. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 13. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 14. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 15. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 16. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 17. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 18. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 19. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 20. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 21. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 22. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 23. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 24. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 25. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 26. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 27. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 28. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 29. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 30. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 31. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 32. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 33. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 34. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 35. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 36. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 37. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 38. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 39. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 40. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 41. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 42. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 43. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 44. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 45. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 46. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 47. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 48. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 49. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 50. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 51. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 52. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 53. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 54. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 55. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 56. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 57. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167\u51fa\u73b0\u7684\u6b21\u6570\u6392\u5e8f\n        # 58. \u628a\u6240\u6709\u5143\u7d20\u6309\u7167"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, res):\n            if left == 0 and right == 0:\n                res.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', res)\n            if right > left:\n                generate(left, right - 1, s + ')', res)\n        \n        res = []\n        generate(n, n, '', res)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\ub97c \ub2eb\ub294 \uad04\ud638\ub85c \ubc14\uafbc\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \uc13c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uc640 \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uac00 \ub354 \ub9ce\uc740 \uacbd\uc6b0, \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uac00 \ub354 \uc801\uc740 \uacbd\uc6b0, \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uac00 \ub354 \ub9ce\uc740 \uacbd\uc6b0, \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uac00 \ub354 \uc801\uc740 \uacbd\uc6b0, \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uac00 \ub354 \ub9ce\uc740 \uacbd\uc6b0, \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\uac00 \ub354 \uc801\uc740 \uacbd\uc6b0, \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ud638\uc758 \uac1c\uc218\ub97c \ube44\uad50\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc313\uc778 \uc5ec\ub294 \uad04\ufffd"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            denominator = -denominator\n        elif denominator < 0:\n            denominator = -denominator\n            numerator = -numerator\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = []\n        res.append(str(numerator // denominator))\n        numerator = numerator % denominator\n        numerator *= 10\n        seen = {}\n        while numerator:\n            if numerator in seen:\n                res.insert(seen[numerator], \"(\")\n                res.append(\")\")\n                break\n            seen[numerator] = len(res)\n            res.append(str(numerator // denominator))\n            numerator = numerator % denominator\n            numerator *= 10\n        \n        return \"\".join(res)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # slow is the middle\n        # reverse the second half\n        # merge the two halves\n        \n        # reverse the second half\n        prev = None\n        curr = slow\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # merge the two halves\n        left = head\n        right = prev\n        while right.next:\n            temp = left.next\n            left.next = right\n            left = temp\n            temp = right.next\n            right.next = left\n            right = temp\n        \n        return prev"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [envelopes[0][1]]\n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = envelopes[i][1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        # row = [False] * len(matrix)\n        # col = [False] * len(matrix[0])\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if matrix[i][j] == 0:\n        #             row[i] = True\n        #             col[j] = True\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if row[i] or col[j]:\n        #             matrix[i][j] = 0\n        \n        ## O(1) space\n        # row = [False] * len(matrix)\n        # col = [False] * len(matrix[0])\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if matrix[i][j] == 0:\n        #             row[i] = True\n        #             col[j] = True\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if row[i] or col[j]:\n        #             matrix[i][j] = 0\n        #             ## if matrix[i][j] == 0:\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ## else:\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0] = 0\n        #             ##     matrix[0][j] = 0\n        #             ##     matrix[i][j] = 0\n        #             ##     matrix[i][0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the nth node from the end\n        if length == n:\n            return head.next\n        \n        # 3. Find the nth node from the beginning\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        # 4. Remove the nth node from the end\n        curr.next = curr.next.next\n        \n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return res"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        res = 0\n        cur = 0\n        for i in range(n):\n            cur += machines[i]\n            res = max(res, abs(cur - avg * (i + 1)))\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        heights = [0] * cols\n        \n        for row in range(rows):\n            for col in range(cols):\n                if matrix[row][col] == '1':\n                    heights[col] += 1\n                else:\n                    heights[col] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i, height in enumerate(heights):\n            while stack and height <= heights[stack[-1]]:\n                top = stack.pop()\n                if not stack:\n                    left = -1\n                else:\n                    left = stack[-1]\n                max_area = max(max_area, (i - left - 1) * heights[top])\n            stack.append(i)\n        \n        while stack:\n            top = stack.pop()\n            if not stack:\n                left = -1\n            else:\n                left = stack[-1]\n            max_area = max(max_area, (len(heights) - left - 1) * heights[top])\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        for i in range(2**len(nums)):\n            temp = []\n            for j in range(len(nums)):\n                if i & (1<<j):\n                    temp.append(nums[j])\n            res.append(temp)\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_map = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_str = ''\n        \n        for key in roman_map.keys():\n            while num >= key:\n                roman_str += roman_map[key]\n                num -= key\n                \n        return roman_str"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return t[0]\n        # if len(t) == 0:\n        #     return s[0]\n        # if len(s) == 1 and len(t) == 1:\n        #     return t[0]\n        # if len(s) == 1 and len(t) == 2:\n        #     return t[1]\n        # if len(s) == 2 and len(t) == 1:\n        #     return t[0]\n        # if len(s) == 2 and len(t) == 2:\n        #     return t[1]\n        # if len(s) == 3 and len(t) == 3:\n        #     return t[2]\n        # if len(s) == 4 and len(t) == 4:\n        #     return t[3]\n        # if len(s) == 5 and len(t) == 5:\n        #     return t[4]\n        # if len(s) == 6 and len(t) == 6:\n        #     return t[5]\n        # if len(s) == 7 and len(t) == 7:\n        #     return t[6]\n        # if len(s) == 8 and len(t) == 8:\n        #     return t[7]\n        # if len(s) == 9 and len(t) == 9:\n        #     return t[8]\n        # if len(s) == 10 and len(t) == 10:\n        #     return t[9]\n        # if len(s) == 11 and len(t) == 11:\n        #     return t[10]\n        # if len(s) == 12 and len(t) == 12:\n        #     return t[11]\n        # if len(s) == 13 and len(t) == 13:\n        #     return t[12]\n        # if len(s) == 14 and len(t) == 14:\n        #     return t[13]\n        # if len(s) == 15 and len(t) == 15:\n        #     return t[14]\n        # if len(s) == 16 and len(t) == 16:\n        #     return t[15]\n        # if len(s) == 17 and len(t) == 17:\n        #     return t[16]\n        # if len(s) == 18 and len(t) == 18:\n        #     return t[17]\n        # if len(s) == 19 and len(t) == 19:\n        #     return t[18]\n        # if len(s) == 20 and len(t) == 20:\n        #     return t[19]\n        # if len(s) == 21 and len(t) == 21:\n        #     return t[20]\n        # if len(s) == 22 and len(t) == 22:\n        #     return t[21]\n        # if len(s) == 23 and len(t) == 23:\n        #     return t[22]\n        # if len(s) == 24 and len(t) == 24:\n        #     return t[23]\n        # if len(s) == 25 and len(t) == 25:\n        #     return t[24]\n        # if len(s) == 26 and len(t) == 26:\n        #     return t[25]\n        # if len(s) == 27 and len(t) == 27:\n        #     return t[26]\n        # if len(s) == 28 and len(t) == 28:\n        #     return t[27]\n        # if len(s) == 29 and len(t) == 29:\n        #     return t[28]\n        # if len(s) == 30 and len(t) == 30:\n        #     return t[29]\n        # if len(s) == 31 and len(t) == 31:\n        #     return t[30]\n        # if len(s) == 32 and len(t) == 32:\n        #     return t[31"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for k in range(1, 10):\n                            if isValid(board, i, j, str(k)):\n                                board[i][j] = str(k)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n\n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                    return False\n            return True\n\n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes\n        # inorder traversal again\n        # find the two nodes that are swapped\n        # swap the two nodes"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        if sorted(s1) != sorted(s2):\n            return False\n        if len(s1) == 1:\n            return True\n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, word, visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0] or (i, j) in visited:\n                return False\n            visited.add((i, j))\n            res = dfs(i + 1, j, word[1:], visited) or dfs(i - 1, j, word[1:], visited) or dfs(i, j + 1, word[1:], visited) or dfs(i, j - 1, word[1:], visited)\n            visited.remove((i, j))\n            return res\n        \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i, j, word, set()):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 for loops\n        # 2. 3 for loops\n        # 3. 3 for loops\n        # 4. 3 for loops\n        # 5. 3 for loops\n        # 6. 3 for loops\n        # 7. 3 for loops\n        # 8. 3 for loops\n        # 9. 3 for loops\n        # 10. 3 for loops\n        # 11. 3 for loops\n        # 12. 3 for loops\n        # 13. 3 for loops\n        # 14. 3 for loops\n        # 15. 3 for loops\n        # 16. 3 for loops\n        # 17. 3 for loops\n        # 18. 3 for loops\n        # 19. 3 for loops\n        # 20. 3 for loops\n        # 21. 3 for loops\n        # 22. 3 for loops\n        # 23. 3 for loops\n        # 24. 3 for loops\n        # 25. 3 for loops\n        # 26. 3 for loops\n        # 27. 3 for loops\n        # 28. 3 for loops\n        # 29. 3 for loops\n        # 30. 3 for loops\n        # 31. 3 for loops\n        # 32. 3 for loops\n        # 33. 3 for loops\n        # 34. 3 for loops\n        # 35. 3 for loops\n        # 36. 3 for loops\n        # 37. 3 for loops\n        # 38. 3 for loops\n        # 39. 3 for loops\n        # 40. 3 for loops\n        # 41. 3 for loops\n        # 42. 3 for loops\n        # 43. 3 for loops\n        # 44. 3 for loops\n        # 45. 3 for loops\n        # 46. 3 for loops\n        # 47. 3 for loops\n        # 48. 3 for loops\n        # 49. 3 for loops\n        # 50. 3 for loops\n        # 51. 3 for loops\n        # 52. 3 for loops\n        # 53. 3 for loops\n        # 54. 3 for loops\n        # 55. 3 for loops\n        # 56. 3 for loops\n        # 57. 3 for loops\n        # 58. 3 for loops\n        # 59. 3 for loops\n        # 60. 3 for loops\n        # 61. 3 for loops\n        # 62. 3 for loops\n        # 63. 3 for loops\n        # 64. 3 for loops\n        # 65. 3 for loops\n        # 66. 3 for loops\n        # 67. 3 for loops\n        # 68. 3 for loops\n        # 69. 3 for loops\n        # 70. 3 for loops\n        # 71. 3 for loops\n        # 72. 3 for loops\n        # 73. 3 for loops\n        # 74. 3 for loops\n        # 75. 3 for loops\n        # 76. 3 for loops\n        # 77. 3 for loops\n        # 78. 3 for loops\n        # 79. 3 for loops\n        # 80. 3 for loops\n        # 81. 3 for loops\n        # 82. 3 for loops\n        # 83. 3 for loops\n        # 84. 3 for loops\n        # 85. 3 for loops\n        # 86. 3 for loops\n        # 87. 3 for loops\n        # 88. 3 for loops\n        # 89. 3 for loops\n        # 90. 3 for loops\n        # 91. 3 for loops\n        # 92. 3 for loops\n        # 93. 3 for loops\n        # 94. 3 for loops"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 144000\n        # 26^5 = 7372800\n        # 26^6 = 393216000\n        # 26^7 = 21843200000\n        # 26^8 = 1152921504000\n        # 26^9 = 57646075200000\n        # 26^10 = 3174153504000000\n        # 26^11 = 172976189040000000\n        # 26^12 = 1000000000000000000\n        # 26^13 = 439804651103232000000\n        # 26^14 = 23432902008176640000000\n        # 26^15 = 1289924250573516800000000\n        # 26^16 = 74467353878309440000000000\n        # 26^17 = 4226137453693632000000000000\n        # 26^18 = 2488314611713058560000000000000\n        # 26^19 = 155616734462673024000000000000000\n        # 26^20 = 9783871721333664000000000000000000\n        # 26^21 = 589146410971132000000000000000000000\n        # 26^22 = 36457320548506400000000000000000000000\n        # 26^23 = 2231811461577360000000000000000000000000\n        # 26^24 = 137653673486112000000000000000000000000000\n        # 26^25 = 7892289174336000000000000000000000000000000\n        # 26^26 = 444114458717360000000000000000000000000000000\n        # 26^27 = 2657789299111200000000000000000000000000000000\n        # 26^28 = 16238949445520000000000000000000000000000000000\n        # 26^29 = 96194742228000000000000000000000000000000000000\n        # 26"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        curr = slow\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # merge the first and second halves\n        first = head\n        second = prev\n        while second.next:\n            temp = first.next\n            first.next = second\n            first = temp\n            \n            temp = second.next\n            second.next = first\n            second = temp\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] in d:\n                if d[pattern[i]] != s[i]:\n                    return False\n            else:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        low = 0\n        high = m*n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new list node\n        # 2. Create a new list node\n        # 3. Create a new list node\n        # 4. Create a new list node\n        # 5. Create a new list node\n        # 6. Create a new list node\n        # 7. Create a new list node\n        # 8. Create a new list node\n        # 9. Create a new list node\n        # 10. Create a new list node\n        # 11. Create a new list node\n        # 12. Create a new list node\n        # 13. Create a new list node\n        # 14. Create a new list node\n        # 15. Create a new list node\n        # 16. Create a new list node\n        # 17. Create a new list node\n        # 18. Create a new list node\n        # 19. Create a new list node\n        # 20. Create a new list node\n        # 21. Create a new list node\n        # 22. Create a new list node\n        # 23. Create a new list node\n        # 24. Create a new list node\n        # 25. Create a new list node\n        # 26. Create a new list node\n        # 27. Create a new list node\n        # 28. Create a new list node\n        # 29. Create a new list node\n        # 30. Create a new list node\n        # 31. Create a new list node\n        # 32. Create a new list node\n        # 33. Create a new list node\n        # 34. Create a new list node\n        # 35. Create a new list node\n        # 36. Create a new list node\n        # 37. Create a new list node\n        # 38. Create a new list node\n        # 39. Create a new list node\n        # 40. Create a new list node\n        # 41. Create a new list node\n        # 42. Create a new list node\n        # 43. Create a new list node\n        # 44. Create a new list node\n        # 45. Create a new list node\n        # 46. Create a new list node\n        # 47. Create a new list node\n        # 48. Create a new list node\n        # 49. Create a new list node\n        # 50. Create a new list node\n        # 51. Create a new list node\n        # 52. Create a new list node\n        # 53. Create a new list node\n        # 54. Create a new list node\n        # 55. Create a new list node\n        # 56. Create a new list node\n        # 57. Create a new list node\n        # 58. Create a new list node\n        # 59. Create a new list node\n        # 60. Create a new list node\n        # 61. Create a new list node\n        # 62. Create a new list node\n        # 63. Create a new list node\n        # 64. Create a new list node\n        # 65. Create a new list node\n        # 66. Create a new list node\n        # 67. Create a new list node\n        # 68. Create a new list node\n        # 69. Create a new list node\n        # 70. Create a new list node\n        # 71. Create a new list node\n        # 72. Create a new list node\n        # 73. Create a new list node\n        # 74. Create a new list node\n        # 75. Create a new list node\n        # 76. Create a new list node\n        # 77. Create a new list node\n        # 78. Create a new list node\n        # 79. Create a new list node\n        # 80. Create a new list node\n        # 81. Create a new list node\n        # 82. Create a new list node\n        # 83. Create a new list node\n        # 84. Create a new list node\n        # 85. Create a new list node\n        # 86. Create a new list node"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Convert the decimal to binary\n        # 5. Convert the binary to decimal\n        # 6. Convert the decimal to binary\n        # 7. Convert the binary to decimal\n        # 8. Convert the decimal to binary\n        # 9. Convert the binary to decimal\n        # 10. Convert the decimal to binary\n        # 11. Convert the binary to decimal\n        # 12. Convert the decimal to binary\n        # 13. Convert the binary to decimal\n        # 14. Convert the decimal to binary\n        # 15. Convert the binary to decimal\n        # 16. Convert the decimal to binary\n        # 17. Convert the binary to decimal\n        # 18. Convert the decimal to binary\n        # 19. Convert the binary to decimal\n        # 20. Convert the decimal to binary\n        # 21. Convert the binary to decimal\n        # 22. Convert the decimal to binary\n        # 23. Convert the binary to decimal\n        # 24. Convert the decimal to binary\n        # 25. Convert the binary to decimal\n        # 26. Convert the decimal to binary\n        # 27. Convert the binary to decimal\n        # 28. Convert the decimal to binary\n        # 29. Convert the binary to decimal\n        # 30. Convert the decimal to binary\n        # 31. Convert the binary to decimal\n        # 32. Convert the decimal to binary\n        # 33. Convert the binary to decimal\n        # 34. Convert the decimal to binary\n        # 35. Convert the binary to decimal\n        # 36. Convert the decimal to binary\n        # 37. Convert the binary to decimal\n        # 38. Convert the decimal to binary\n        # 39. Convert the binary to decimal\n        # 40. Convert the decimal to binary\n        # 41. Convert the binary to decimal\n        # 42. Convert the decimal to binary\n        # 43. Convert the binary to decimal\n        # 44. Convert the decimal to binary\n        # 45. Convert the binary to decimal\n        # 46. Convert the decimal to binary\n        # 47. Convert the binary to decimal\n        # 48. Convert the decimal to binary\n        # 49. Convert the binary to decimal\n        # 50. Convert the decimal to binary\n        # 51. Convert the binary to decimal\n        # 52. Convert the decimal to binary\n        # 53. Convert the binary to decimal\n        # 54. Convert the decimal to binary\n        # 55. Convert the binary to decimal\n        # 56. Convert the decimal to binary\n        # 57. Convert the binary to decimal\n        # 58. Convert the decimal to binary\n        # 59. Convert the binary to decimal\n        # 60. Convert the decimal to binary\n        # 61. Convert the binary to decimal\n        # 62. Convert the decimal to binary\n        # 63. Convert the binary to decimal\n        # 64. Convert the decimal to binary\n        # 65. Convert the binary to decimal\n        # 66. Convert the decimal to binary\n        # 67. Convert the binary to decimal\n        # 68. Convert the decimal to binary\n        # 69. Convert the binary to decimal\n        # 70. Convert the decimal to binary\n        # 71. Convert the binary to decimal\n        # 72. Convert the decimal to binary\n        # 73. Convert the binary to decimal\n        # 74. Convert the decimal to binary\n        # 75. Convert the binary to decimal\n        # 76. Convert the decimal to binary\n        # 77. Convert the binary to decimal\n        # 78. Convert the decimal to binary\n        # 79. Convert the binary to decimal\n        # 80. Convert the decimal to binary\n        # 81. Convert the binary to decimal\n        # 82. Convert the decimal to binary\n        # 83. Convert the binary to decimal\n        # 84. Convert the decimal to binary\n        # 85. Convert the binary to decimal\n        # 86. Convert the decimal to binary"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                count += self.numberOfArithmeticSlices(nums[i+2:])\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            curr_len = len(words[i])\n            j = i + 1\n            while j < len(words) and curr_len + len(words[j]) + 1 <= maxWidth:\n                curr_len += len(words[j]) + 1\n                j += 1\n            if j == len(words):\n                res.append(' '.join(words[i:j]) + ' ' * (maxWidth - curr_len))\n            else:\n                num_spaces = maxWidth - curr_len\n                num_words = j - i\n                if num_words == 1:\n                    res.append(words[i] + ' ' * num_spaces)\n                else:\n                    num_spaces_per_word = num_spaces // (num_words - 1)\n                    num_extra_spaces = num_spaces % (num_words - 1)\n                    res.append(' '.join(words[i:j] + [words[i] + ' ' * num_spaces_per_word] * num_extra_spaces))\n            i = j\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def isConcatenated(word):\n            if word in self.memo:\n                return self.memo[word]\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in self.memo and right in self.memo:\n                    self.memo[word] = True\n                    return True\n                if left in self.memo and isConcatenated(right):\n                    self.memo[word] = True\n                    return True\n            self.memo[word] = False\n            return False\n        \n        self.memo = {}\n        res = []\n        for word in words:\n            if isConcatenated(word):\n                res.append(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = -num\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row - col not in diag1 and row + col not in diag2:\n                    cols.add(col)\n                    diag1.add(row - col)\n                    diag2.add(row + col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row - col)\n                    diag2.remove(row + col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(row, col, board):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row, board, res):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(row, col, board):\n                    board[row][col] = 'Q'\n                    backtrack(row + 1, board, res)\n                    board[row][col] = '.'\n            return\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        res = []\n        backtrack(0, board, res)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n\n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}