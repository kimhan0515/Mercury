{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            \n            # go right\n            for col in range(left, right+1):\n                res.append(matrix[top][col])\n            \n            # go down\n            for row in range(top+1, bottom+1):\n                res.append(matrix[row][right])\n            \n            # if we have only one row or one column left, we are done\n            if left == right or top == bottom:\n                break\n            \n            # go left\n            for col in reversed(range(left, right)):\n                res.append(matrix[bottom][col])\n            \n            # go up\n            for row in reversed(range(top, bottom)):\n                res.append(matrix[row][left])\n            \n            left, right, top, bottom = left+1, right-1, top+1, bottom-1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            elif nums[i] != end:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n            if i == len(nums) - 1:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character in t\n        # initialize the dictionary with 0\n        d = {}\n        for char in t:\n            d[char] = 0\n        \n        # initialize the count to 1 since we know that the first character of t will always be in s\n        count = 1\n        \n        # iterate through the characters in s\n        for char in s:\n            # if the character is in the dictionary, increment the count\n            if char in d:\n                count += d[char]\n            # update the count of the character in the dictionary\n            d[char] = count\n        \n        # initialize the count to 0\n        res = 0\n        \n        # iterate through the characters in t\n        for char in t:\n            # if the character is in the dictionary, add the count to the count\n            if char in d:\n                res += d[char]\n        \n        # return the count\n        return res"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and all numbers greater than n as 0\n        # 2. mark the numbers that appear as indices as negative\n        # 3. iterate through the array and look for the first positive number\n        # 4. if no positive number is found, return n\n        \n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] < 0:\n                nums[i] = 0\n                \n        for i in range(n):\n            if nums[nums[i] % n] > 0:\n                nums[nums[i] % n] = nums[nums[i] % n] * -1\n                \n        for i in range(1, n):\n            if nums[i] > 0:\n                return i\n            \n        if not nums[0]:\n            return 1\n        \n        return n"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # initialize the result as a string\n        result = ''\n        \n        # initialize the factorial list\n        factorial = [1]\n        \n        # calculate the factorial\n        for i in range(1, n):\n            factorial.append(factorial[-1] * i)\n        \n        # initialize the nums list\n        nums = list(range(1, n+1))\n        \n        # iterate through the k\n        k -= 1\n        \n        # iterate through the factorial list\n        for i in range(n-1, -1, -1):\n            # get the index of the current digit\n            current_digit = k // factorial[i]\n            # add the current digit to the result\n            result += str(nums[current_digit])\n            # remove the current digit from the nums list\n            nums.pop(current_digit)\n            # decrement k\n            k -= current_digit * factorial[i]\n        \n        # add the remaining digits to the result\n        result += ''.join(map(str, nums))\n        \n        # return the result\n        return result"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left = 0\n        right = len(numbers)-1\n        \n        while left < right:\n            if numbers[left] + numbers[right] > target:\n                right -= 1\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                return [left+1, right+1]\n        return [-1,-1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if not num or len(num) < 2:\n            return []\n        \n        res = []\n        n = len(num)\n        last, curr = 0, int(num[0])\n        res.append(['', curr, curr])\n        \n        for i in range(1, n):\n            curr = curr * 10 + int(num[i])\n            if i == 1:\n                res.append(['+', curr, curr])\n            else:\n                prev = res[-1][1]\n                res.append(['+', curr, prev + curr])\n                \n        # 2nd part\n        for i, (op, curr, prev) in enumerate(res):\n            if op == '+':\n                curr += prev\n                res[i] = ['', curr, curr]\n            elif op == '-':\n                curr -= prev\n                res[i] = ['', curr, -prev]\n            else:\n                curr *= prev\n                res[i] = ['', curr, curr]\n                \n        # 3rd part\n        res = res[::-1]\n        for i, (op, curr, prev) in enumerate(res):\n            if op == '+':\n                curr += prev\n                res[i] = ['', curr, curr]\n            elif op == '-':\n                curr -= prev\n                res[i] = ['', curr, -prev]\n            else:\n                curr *= prev\n                res[i] = ['', curr, curr]\n                \n        # 4th part\n        res = res[::-1]\n        for i, (op, curr, prev) in enumerate(res):\n            if i == 0:\n                if curr == target:\n                    res[i] = ['', curr, prev]\n            elif op == '+':\n                curr += prev\n                res[i] = ['', curr, prev]\n            elif op == '-':\n                curr -= prev\n                res[i] = ['', curr, prev]\n            else:\n                curr *= prev\n                res[i] = ['', curr, prev]\n                \n        # 5th part\n        for i, (op, curr, prev) in enumerate(res):\n            if i == 0:\n                if curr == target:\n                    res[i] = ['', curr, prev]\n            elif op == '+':\n                res[i] = ['+', curr, prev]\n            elif op == '-':\n                res[i] = ['-', curr, prev]\n            else:\n                res[i] = ['', curr, prev]\n                \n        # 6th part\n        res = []\n        if res[-1][0] == '+':\n            res.append(target)\n        elif res[-1][0] == '-':\n            res.append(-target)\n        else:\n            res.append(target)\n            \n        for op, curr, prev in res:\n            if op == '+':\n                curr += prev\n            elif op == '-':\n                curr -= prev\n            else:\n                curr *= prev\n                \n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1: Recursive\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(h)\n        ## where n is the number of nodes in the tree and h is the height of the tree.\n        \n        ## Intuition:\n        ## We can use a recursive DFS to traverse the tree in post-order.\n        ## For each node, we can add the current node's value to the running sum.\n        ## Then, we can prepend the running sum with the sum of the node's left and right children.\n        ## Finally, we can return the running sum at the end of the recursion.\n        \n        ## Algorithm:\n        ## Initialize a running sum of 0.\n        ## Initialize a variable to store the sum of the root-to-leaf path.\n        ## Recursively traverse the tree in post-order.\n        ## For each node, we can add the current node's value to the running sum.\n        ## Then, we can prepend the running sum with the sum of the node's left and right children.\n        ## Finally, we can return the running sum at the end of the recursion.\n        \n        ## Code:\n        self.total = 0\n        self.dfs(root, 0)\n        return self.total\n        \n    def dfs(self, root, runningSum):\n        # base case\n        if not root:\n            return 0\n        \n        # recursive case\n        # prepend running sum with the sum of the node's left and right children\n        runningSum = runningSum * 10 + root.val\n        \n        # if we are at a leaf node, we can add the running sum to the total\n        if not root.left and not root.right:\n            self.total += runningSum\n            \n        # recursively traverse the left and right subtrees\n        self.dfs(root.left, runningSum)\n        self.dfs(root.right, runningSum)\n        \n        # return the running sum at the end of the recursion\n        return runningSum"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.upper()\n        s = s.replace('-','')\n        n = len(s)\n        if n <= k:\n            return s\n        if n % k == 0:\n            return s[:k] + '-' + self.licenseKeyFormatting(s[k:],k)\n        else:\n            return s[:n-n%k] + '-' + self.licenseKeyFormatting(s[n-n%k:],k)"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total_gas, total_cost, curr_gas = 0, 0, 0\n        \n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            curr_gas += gas[i]\n            curr_gas -= cost[i]\n            \n            if curr_gas < 0:\n                curr_gas = 0\n                \n        if total_gas < total_cost:\n            return -1\n        \n        return 0"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # add 1 to the beginning and end of nums\n        nums = [1] + nums + [1]\n        \n        # sort nums in ascending order\n        nums.sort()\n        \n        # initialize the dp array\n        n = len(nums)\n        dp = [0] * n\n        \n        # iterate over nums from right to left\n        for i in range(n-2, -1, -1):\n            # iterate over nums from left to right\n            left, right = 0, i\n            # keep track of the maximum coins we can get\n            maxCoins = 0\n            # iterate over nums from left to right\n            while left < n and nums[left] <= nums[right]:\n                # update the maximum coins we can get\n                maxCoins = max(maxCoins, dp[left])\n                # update the maximum coins we can get\n                maxCoins += (right - left) * nums[right]\n                # move left pointer to the right\n                left += 1\n            # update the dp array\n            dp[i] = maxCoins\n        \n        # initialize the maximum coins we can get\n        maxCoins = 0\n        # iterate over nums from left to right\n        left, right = 0, n-1\n        # iterate over nums from left to right\n        while left < n and nums[left] <= nums[right]:\n            # update the maximum coins we can get\n            maxCoins = max(maxCoins, dp[left])\n            # update the maximum coins we can get\n            maxCoins += (right - left) * nums[right]\n            # move left pointer to the right\n            left += 1\n        # update the maximum coins we can get\n        maxCoins = max(maxCoins, dp[left])\n        \n        # return the maximum coins we can get\n        return maxCoins"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # if the last digit is 9, then we need to add 1 to the rest of the digits\n        # if the last digit is not 9, then we just need to add 1 to the last digit\n        # if the last digit is 9, then we need to add 1 to the rest of the digits and then add 1 to the last digit\n        \n        # if the last digit is 9, then we need to add 1 to the rest of the digits\n        if digits[-1] == 9:\n            digits[-1] = 0\n            for i in range(len(digits)-2,-1,-1):\n                if digits[i] == 9:\n                    digits[i] = 0\n                else:\n                    digits[i] += 1\n                    return digits\n            digits.insert(0,1)\n        else:\n            digits[-1] += 1\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the pattern is empty, the only way to match the string is to be empty\n        if not p:\n            return not s\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and len(p) == 1:\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] == '*' and len(p) == 1:\n            return True\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[1] != '*' and len(p) == 2:\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[1] == '*' and len(p) == 2:\n            return True\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] == '*' and p[1] == '*':\n            return True\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] == '*' and p[1] != '*':\n            return True\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] == '*':\n            return True\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern has a '*', the only way to match the string is to be empty\n        if p[0] != '*' and p[1] != '*':\n            return False\n        \n        # if the pattern"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        m, n = len(nums1), len(nums2)\n        ans = []\n        \n        for i in range(k):\n            j = k - i\n            \n            if j > n:\n                continue\n            \n            # find the index of the first number to be placed in the first k slots\n            # of nums2.\n            # if nums1[i] > nums2[j-1] then nums1[i] will never be at the right place\n            # in k slots of nums2\n            # so we can safely remove k-j elements from nums2\n            # otherwise we would be removing k-j-1 elements from nums2\n            # since we are looking for the kth largest number in nums2\n            # if nums1[i] < nums2[j] then nums1[i] will be at the right place in k slots of nums2\n            # so we can remove k slots from nums2 and add nums1[i] to the right place\n            # otherwise we would be removing (k-j) slots from nums2 and nums1[i] to the left\n            # since we are looking for the kth largest number in nums1\n            # if nums1[i] > nums2[j] then nums1[i] will be at the right place in k slots of nums2\n            # so we can remove k slots from nums2 and add nums1[i] to the right place\n            # otherwise we would be removing (k-j) slots from nums2 and nums1[i] to the left\n            # since we are looking for the kth largest number in nums1\n            # if nums2[j-1] > nums1[i] then nums2[j-1] will never be at the right place\n            # in k slots of nums1\n            # so we can safely remove k-j elements from nums1\n            # otherwise we would be removing k-j-1 elements from nums1\n            # since we are looking for the kth largest number in nums2\n            # if nums2[j-1] < nums1[i] then nums2[j-1] will be at the right place in k slots of nums1\n            # so we can remove k slots from nums1 and add nums2[j-1] to the right place\n            # otherwise we would be removing (k-j) slots from nums1 and nums2[j-1] to the left\n            # since we are looking for the kth largest number in nums2\n            # if nums1[i] > nums2[j] then nums1[i] will be at the right place in k slots of nums2\n            # so we can remove k slots from nums2 and add nums1[i] to the right place\n            # otherwise we would be removing (k-j) slots from nums2 and nums1[i] to the left\n            # since we are looking for the kth largest number in nums1\n            # if nums2[j-1] < nums1[i] then nums2[j-1] will be at the right place in k slots of nums1\n            # so we can remove k slots from nums1 and add nums2[j-1] to the right place\n            # otherwise we would be removing (k-j) slots from nums1 and nums2[j-1] to the left\n            # since we are looking for the kth largest number in nums2\n            # if nums1[0] > nums2[0] or i == 0:\n            #     ans = nums1\n            # else:\n            #     ans = nums2\n            # if nums1[0] > nums2[j] or j == 0:\n            #     ans = nums1\n            # else:\n            #     ans = nums2\n            # if nums1[0] > nums2[j] or j == 0:\n            #     ans = nums1\n            # else:\n            #     ans = nums2\n            # if nums1[0] > nums2[j] or j == 0:\n            #     ans = nums1\n            # else:\n            #     ans = nums2\n            # if nums1[0] > nums2"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum_divisors = 1\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                if i**2 != num:\n                    sum_divisors += i + num//i\n                else:\n                    sum_divisors += i\n        \n        return sum_divisors == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 2:\n            return n\n        \n        a, b = 0, 1\n        \n        for i in range(n-1):\n            a, b = b, a + b\n            \n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all negative, then the minimum health needed is 1\n        # if the last column is all negative, then the minimum health needed is 1\n        # if the last cell is positive, then the minimum health needed is 1\n        # if the last cell is negative, then the minimum health needed is -1\n        \n        # if the last row is all positive, then the minimum health needed is 1\n        # if the last column is all positive, then the minimum health needed is"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # binary search for the kth smallest distance\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            # count the number of pairs with distance <= mid\n            count = mid\n            # move left pointer to the right\n            left_ptr = left\n            # for each num in nums, if nums[right] - nums[left_ptr] <= mid,\n            # then we can add 1 to count\n            for num in nums:\n                if nums[right] - num >= mid:\n                    count += right - left_ptr\n                else:\n                    # otherwise, move left_ptr to the right\n                    left_ptr += 1\n            # if count is less than k, then we need to move right pointer\n            # to the right\n            if count < k:\n                left = mid + 1\n            # otherwise, we need to move left pointer to the right\n            else:\n                right = mid\n        # return the count\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split()) if s else 0"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        # reverse = s[::-1]\n        # ans = []\n        # for i in reverse:\n        #     if i in vowels:\n        #         ans.append(i)\n        # ans = ans[::-1]\n        # for i in range(len(s)):\n        #     if s[i] in vowels:\n        #         ans.append(ans.pop())\n        # return ''.join(ans)\n        \n        # two pointers\n        left, right = 0, len(s) - 1\n        s = list(s)\n        while left < right:\n            if s[left] in vowels and s[right] in vowels:\n                s[left], s[right] = s[right], s[left]\n                left, right = left + 1, right - 1\n            elif s[left] not in vowels:\n                left += 1\n            elif s[right] not in vowels:\n                right -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        longest = 0\n        \n        for num in nums_set:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_streak = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_streak += 1\n                    \n                longest = max(longest, curr_streak)\n                \n        return longest"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1: Using XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## XOR all the numbers from 0 to n, and all the numbers in nums\n        ## Then XOR all the numbers from 0 to n+1, and the missing number\n        \n        n = len(nums)\n        xor_nums = 0\n        xor_missing = 0\n        \n        for i in range(n):\n            xor_nums ^= nums[i]\n            xor_missing ^= i\n        \n        return xor_nums ^ xor_missing\n        \n        \n        ## Solution 2: Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Create a set and add all the numbers in nums\n        ## Then iterate through the set and check if the number is in the set\n        ## If the number is not in the set, return the number\n        \n        num_set = set()\n        \n        for num in nums:\n            num_set.add(num)\n        \n        for i in range(len(nums) + 1):\n            if i not in num_set:\n                return i\n        \n        \n        ## Solution 3: Using Sorting\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        \n        ## Sort the array nums\n        ## Then iterate through the sorted array and check if the number is in the sorted array\n        ## If the number is not in the sorted array, return the number\n        \n        nums.sort()\n        \n        if nums[0] != 0:\n            return 0\n        \n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1]:\n                return nums[i]\n        \n        return len(nums)"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # create a set to store the words\n        wordSet = set(wordList)\n        \n        # if endWord is not in the set, return 0\n        if endWord not in wordSet:\n            return 0\n        \n        # create a dictionary to store the words and their neighbors\n        wordNeighbors = collections.defaultdict(set)\n        \n        # iterate through the words in the set\n        for word in wordSet:\n            # iterate through the characters in the word\n            for i in range(len(word)):\n                # create a key for each word and add its neighbor to the dictionary\n                key = word[:i] + '_' + word[i+1:]\n                wordNeighbors[key].add(word)\n        \n        # create a queue and add the beginWord to it\n        queue = collections.deque([beginWord])\n        \n        # create a set to store the visited words\n        visited = set()\n        \n        # create a variable to store the number of transformations needed\n        numTrans = 0\n        \n        # while the queue is not empty\n        while queue:\n            # increment the number of transformations\n            numTrans += 1\n            \n            # iterate through the number of transformations\n            for _ in range(len(queue)):\n                # pop the first word from the queue\n                currWord = queue.popleft()\n                \n                # if the current word is the endWord, return the number of transformations\n                if currWord == endWord:\n                    return numTrans\n                \n                # if the current word is not in the set of visited words, add it to the set\n                if currWord not in visited:\n                    visited.add(currWord)\n                    \n                # iterate through the characters in the current word\n                for i in range(len(currWord)):\n                    # create a key for each word and add its neighbor to the dictionary\n                    key = currWord[:i] + '_' + currWord[i+1:]\n                    \n                    # if the key is in the dictionary, iterate through the neighbors of the key\n                    for neighbor in wordNeighbors[key]:\n                        # if the neighbor has not been visited, add it to the queue and mark it as visited\n                        if neighbor not in visited:\n                            queue.append(neighbor)\n                            visited.add(neighbor)\n        \n        # if the endWord is not in the set of visited words, return 0\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize the result and the carry\n        result = ''\n        carry = 0\n        \n        # Iterate through both a and b, starting from the end\n        for i, j in zip(a[::-1], b[::-1]):\n            # Calculate the sum of the current bits in a and b, \n            # and the carry\n            sum_ = int(i) + int(j) + carry\n            # Calculate the carry for the next iteration\n            carry = sum_ // 2\n            # Calculate the result, which is the sum modulo 2\n            result += str(sum_ % 2)\n        \n        # If there's still a carry from the previous iteration, \n        # append it to the result\n        if carry:\n            result += '1'\n        \n        # Reverse the result to get the final answer\n        return result[::-1]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search to find the first instance of target\n        left_idx = bisect.bisect_left(nums, target)\n        \n        # if the target is not present in the array, return [-1, -1]\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        \n        # binary search to find the last instance of target\n        right_idx = bisect.bisect_right(nums, target)\n        \n        # return the indices\n        return [left_idx, right_idx - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        k = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] != nums[k-1]:\n                nums[k] = nums[i]\n                k += 1\n        \n        return k"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return 0\n        \n        # jumps = [float('inf')] * len(nums)\n        # jumps[0] = 0\n        \n        # for i in range(1, len(nums)):\n        #     for j in range(i):\n        #         if nums[j] + j >= i:\n        #             jumps[i] = min(jumps[j] + 1, jumps[i])\n        \n        # return jumps[-1]\n        \n        # if len(nums) == 1:\n        #     return 0\n        \n        # jumps = 0\n        # curr_end = 0\n        # curr_far = 0\n        \n        # for i in range(len(nums) - 1):\n        #     curr_far = max(curr_far, nums[i] + i)\n        #     if i == curr_end:\n        #         jumps += 1\n        #         curr_end = curr_far\n        \n        # return jumps\n        \n        # if len(nums) == 1:\n        #     return 0\n        \n        # jumps = 0\n        # curr_end = 0\n        # curr_far = 0\n        \n        # for i in range(len(nums) - 1):\n        #     if nums[i] + i > curr_far:\n        #         jumps += 1\n        #         curr_end = curr_far\n        #         curr_far = nums[i] + i\n        \n        # return jumps\n        \n        if len(nums) == 1:\n            return 0\n        \n        jumps = 0\n        curr_end = 0\n        curr_far = 0\n        \n        for i in range(len(nums) - 1):\n            if nums[i] + i > curr_far:\n                jumps += 1\n                curr_end = curr_far\n            curr_far = max(curr_far, nums[i] + i)\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            profit = 0\n            for i in range(1, len(prices)):\n                if prices[i] > prices[i-1]:\n                    profit += prices[i]-prices[i-1]\n            return profit\n        \n        # if k >= len(prices)//2:\n        #     profit = 0\n        #     for i in range(1, len(prices)):\n        #         if prices[i] > prices[i-1]:\n        #             profit += prices[i]-prices[i-1]\n        #     return profit\n        \n        # profit = 0\n        # buy = [float('inf')]*k\n        # sell = [0]*k\n        \n        # for price in prices:\n        #     for i in range(k):\n        #         if buy[i] > price:\n        #             buy[i] = price\n        #         else:\n        #             sell[i] = max(sell[i], price-buy[i])\n        #             profit += sell[i]\n        #         # buy[i] = min(buy[i], price)\n        #         # profit += (sell[i]-buy[i])\n        #     # buy[i] = price\n        #     # profit += (sell[i]-buy[i])\n        #     # sell[i] = price\n        # # for i in range(k):\n        # #     if buy[i] > buy[k-1]:\n        # #         profit += (sell[i]-buy[i])\n        # # return profit\n        \n        # buy = [float('inf')]*k\n        # sell = [0]*k\n        \n        # for price in prices:\n        #     for i in range(k):\n        #         if buy[i] > price:\n        #             buy[i] = price\n        #         else:\n        #             sell[i] = max(sell[i], price-buy[i])\n        #             profit += sell[i]\n        #         # buy[i] = min(buy[i], price)\n        #         # profit += (sell[i]-buy[i])\n        #     # buy[i] = price\n        #     # profit += (sell[i]-buy[i])\n        #     # sell[i] = price\n        # # for i in range(k):\n        # #     if buy[i] > buy[k-1]:\n        # #         profit += (sell[i]-buy[i])\n        # # return profit\n        \n        # buy = [float('inf')]*k\n        # sell = [0]*k\n        \n        # for price in prices:\n        #     for i in range(k):\n        #         if buy[i] > price:\n        #             buy[i] = price\n        #             profit -= sell[i]\n        #         else:\n        #             sell[i] = max(sell[i], price-buy[i])\n        #             profit += sell[i]\n        #     # buy[i] = min(buy[i], price)\n        #     # profit += (sell[i]-buy[i])\n        #     # sell[i] = price\n        # # for i in range(k):\n        # #     if buy[i] > buy[k-1]:\n        # #         profit += (sell[i]-buy[i])\n        # # return profit\n        \n        # buy = [float('inf')]*k\n        # sell = [0]*k\n        \n        # for price in prices:\n        #     for i in range(k):\n        #         if buy[i] > price:\n        #             buy[i] = price\n        #             profit -= sell[i]\n        #         else:\n        #             if i > 0:\n        #                 profit -= sell[i-1]\n        #             sell[i] = max(sell[i], price-buy[i])\n        #             profit += sell[i]\n        #     # buy[i] = min(buy[i], price)\n        #     # profit += (sell[i]-buy[i])\n        #     # sell["}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hexadecimal = '0123456789abcdef'\n        res = ''\n        \n        while num > 0 and len(res) < 8:\n            res = hexadecimal[num % 16] + res\n            num //= 16\n        \n        return res if res else '0'"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and index as value\n        # iterate through the string and update the index\n        # iterate through the dictionary and return the first index with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and index as value\n        # iterate through the string and update the index\n        # iterate through the dictionary and return the first index with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        # iterate through the string and update the count\n        # iterate through the dictionary and return the first character with count as 1\n        # if no such character return -1\n        \n        # create a dictionary with character as key and count as value\n        #"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if indexDiff < 0 or valueDiff < 0:\n            return False\n        \n        # sort the nums\n        nums.sort()\n        \n        # for each num, check if there is any num in nums[i] + valueDiff and num in nums[i] - valueDiff\n        # if so, return True\n        # if not, return False\n        for i in range(len(nums) - 1):\n            if nums[i] + valueDiff >= nums[i + 1] and nums[i] - valueDiff <= nums[i + 1]:\n                return True\n            if nums[i] - valueDiff > nums[i + 1] and nums[i] + valueDiff <= nums[i + 1]:\n                return True\n            \n        # if nums is sorted, check if there is any num in nums[i] + valueDiff and num in nums[i] - valueDiff\n        # if so, return True\n        # if not, return False\n        if nums[-1] + valueDiff >= nums[-2] and nums[-1] - valueDiff <= nums[-2]:\n            return True\n        if nums[-1] - valueDiff > nums[-2] and nums[-1] + valueDiff <= nums[-2]:\n            return True\n        \n        # if nums is not sorted, check if there is any num in nums[i] + indexDiff and num in nums[i] - indexDiff\n        # if so, return True\n        # if not, return False\n        if nums[-1] + indexDiff >= nums[-2] and nums[-1] - indexDiff <= nums[-2]:\n            return True\n        if nums[-1] - indexDiff > nums[-2] and nums[-1] + indexDiff <= nums[-2]:\n            return True\n        \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Count the number of 0's, 1's, and 2's\n        # 2. Use the count to place the 0's, 1's, and 2's in the correct order\n        # 3. Do it in-place\n        \n        # 1\n        count = [0, 0, 0]\n        for num in nums:\n            count[num] += 1\n        \n        # 2\n        for i in range(count[0]):\n            nums[i] = 0\n        for i in range(count[0], count[0] + count[1]):\n            nums[i] = 1\n        for i in range(count[0] + count[1], len(nums)):\n            nums[i] = 2\n        \n        # 3\n        # nums[:count[0]] = [0] * count[0]\n        # nums[count[0]:count[0] + count[1]] = [1] * count[1]\n        # nums[count[0] + count[1]:] = [2] * count[2]\n        \n        # 3\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] == 2:\n                nums[left], nums[right] = nums[right], nums[left]\n                right -= 1\n            elif nums[left] == 0:\n                left += 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        max_count = 0\n        \n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(count, max_count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left, right = 0, 0\n        curr = root\n        \n        while curr:\n            left += 1\n            curr = curr.left\n        \n        curr = root\n        \n        while curr:\n            right += 1\n            curr = curr.right\n        \n        if left == right:\n            return (2**left) - 1\n        \n        left, right = 0, left\n        ans = 0\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if self.isLeftFull(root, mid):\n                ans = (2**right) + left\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return (2**right) + ans"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Initialize result and carry\n        result, carry = 0, 0\n        \n        # Iterate through both num1 and num2 in reverse order\n        for i, j in zip(reversed(num1), reversed(num2)):\n            # Get current digit in num1 and num2\n            digit1, digit2 = int(i), int(j)\n            # Get sum and carry\n            total = digit1 + digit2 + carry\n            # Get current digit in result\n            result = str(total % 10) + str(result)\n            # Get carry\n            carry = total // 10\n        \n        # If carry is still 1, append it to result\n        if carry:\n            result = str(carry) + result\n        \n        # Return result\n        return result"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        res, sign, num, prev_num = 0, 1, 0, 0\n        \n        for i in range(len(s)):\n            if s[i] == '+':\n                sign = 1\n            elif s[i] == '-':\n                sign = -1\n            elif s[i] == '(':\n                res, prev_num, sign = res + sign * num, res, 0\n            elif s[i] == ')':\n                res = res + sign * num + prev_num\n                num, sign = res, 1\n            elif s[i] == ' ':\n                continue\n            else:\n                num = num * 10 + int(s[i])\n                \n            res = res + sign * num\n            \n        return res + sign * num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # greedy: pick up the projects with the smallest capital\n        # if k projects are already purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any more\n        # otherwise, we can purchase a project\n        # if k projects are purchased, we can't purchase any"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) % 2 != 0:\n            return False\n        \n        stack = []\n        d = {')':'(', ']':'[', '}':'{'}\n        \n        for i in s:\n            if i not in d:\n                stack.append(i)\n            elif stack and d[i] == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        \n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums)-2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, then the permutation is sorted in descending order, \n        # so we just reverse it to get the next permutation\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums)-1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums_dict = {}\n        # for i, num in enumerate(nums):\n        #     if num not in nums_dict:\n        #         nums_dict[num] = i\n        #     elif i - nums_dict[num] <= k:\n        #         return True\n        #     else:\n        #         nums_dict[num] = i\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums_dict = {}\n        # for i, num in enumerate(nums):\n        #     if num not in nums_dict:\n        #         nums_dict[num] = i\n        #     elif i - nums_dict[num] <= k:\n        #         return True\n        #     else:\n        #         nums_dict[num] = i\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums_dict = {}\n        # for i, num in enumerate(nums):\n        #     if num not in nums_dict:\n        #         nums_dict[num] = i\n        #     elif i - nums_dict[num] <= k:\n        #         return True\n        #     else:\n        #         nums_dict[num] = i\n        # return False\n        \n        if len(nums) <= 1:\n            return False\n        \n        nums_dict = {}\n        for i, num in enumerate(nums):\n            if num not in nums_dict:\n                nums_dict[num] = i\n            elif i - nums_dict[num] <= k:\n                return True\n            else:\n                nums_dict[num] = i\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        \n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i]-nums[i-1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = collections.deque()\n        q.append(root)\n        res = []\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the index of each couple\n        # and the number of swaps needed to make each couple side by side\n        # we will use this to keep track of the number of swaps needed\n        # to make each couple side by side\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use this to keep track of the number of couples\n        # we have seen so far\n        # we will also use"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [False] * (len(s2) + 1)\n        \n        for i in range(len(s2)):\n            if s2[i] == s3[i]:\n                dp[i+1] = True\n            else:\n                dp[i+1] = dp[i]\n        \n        for i in range(len(s1)):\n            dp[0] = dp[0] or dp[1] if s1[i] == s3[i] else False\n            for j in range(1, len(s2)):\n                if s1[i] == s3[i+j] and s2[j] == s3[i+j]:\n                    dp[j+1] = dp[j] or dp[j-1]\n                elif s1[i] == s3[i+j]:\n                    dp[j+1] = dp[j]\n                elif s2[j] == s3[i+j]:\n                    dp[j+1] = dp[j-1]\n                else:\n                    dp[j+1] = False\n        \n        return dp[-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        res = 0\n        \n        for i, j in zip(g, s):\n            if i > res and j > res:\n                res += 1\n        \n        return res"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a dictionary with the first row of the keyboard\n        row1 = {'q','w','e','r','t','y','u','i','o','p'}\n        # create a dictionary with the second row of the keyboard\n        row2 = {'a','s','d','f','g','h','j','k','l'}\n        # create a dictionary with the third row of the keyboard\n        row3 = {'z','x','c','v','b','n'}\n        \n        # create a list to store the words that can be typed using only one row of the keyboard\n        res = []\n        \n        # iterate through the words\n        for word in words:\n            # if the word is in the first row of the keyboard, add it to the list\n            if word[0].lower() in row1:\n                if word in res:\n                    continue\n                res.append(word)\n            # if the word is in the second row of the keyboard, add it to the list\n            elif word[0].lower() in row2:\n                if word in res:\n                    continue\n                res.append(word)\n            # if the word is in the third row of the keyboard, add it to the list\n            elif word[0].lower() in row3:\n                if word in res:\n                    continue\n                res.append(word)\n                \n        # return the list\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        curr = dummy\n        prev = None\n        curr_pos = 1\n        \n        while curr_pos < left:\n            prev = curr\n            curr = curr.next\n            curr_pos += 1\n        \n        prev_rev = None\n        curr_rev = curr.next\n        \n        while curr_pos <= right:\n            curr_next = curr.next\n            curr.next = prev_rev\n            prev_rev = curr\n            curr = curr_next\n            curr_pos += 1\n        \n        prev.next = curr_rev\n        left_rev = prev\n        \n        curr = head\n        curr_pos = 1\n        \n        while curr_pos < left:\n            prev = curr\n            curr = curr.next\n            curr_pos += 1\n        \n        curr_next = curr.next\n        curr.next = curr_rev\n        \n        while curr_pos <= right:\n            curr_next_next = curr_next.next\n            curr_next.next = prev\n            prev = curr_next\n            curr_next = curr_next_next\n            curr_pos += 1\n        \n        if left_rev:\n            head = left_rev\n        else:\n            head = curr\n        \n        head.next = prev\n        \n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the prefix to the end of the string\n        # return the reversed string\n        \n        # reverse the string\n        # find the longest pal"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        # create a hashmap to store the count of each character in t\n        # we will use this to keep track of how many characters we need to find in t\n        # and how many characters we have found so far\n        # we will also keep track of the characters we have found so far in order to \n        # keep track of the window\n        # we will also keep track of the left and right pointers\n        # we will initialize the left and right pointers to 0\n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        need = {}\n        for char in t:\n            if char not in need:\n                need[char] = 0\n            need[char] += 1\n        \n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        have = 0\n        count = len(need)\n        window = 0\n        left = 0\n        right = 0\n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap to have all the characters in t\n        # we will also initialize the count to have all the characters in t\n        # we will also initialize the window to be empty\n        # we will also initialize the answer to be empty\n        # we will iterate through the string s\n        \n        # we will also initialize the hashmap"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 2:\n            return False\n        \n        if distance[3] == 0 and distance[1] == 0 and distance[2] > 0:\n            return True\n        \n        if distance[2] == 0 and distance[0] > 0 and distance[1] > 0 and distance[3] > 0:\n            return True\n        \n        if distance[3] > 0 and distance[4] == distance[2] and distance[5] == distance[0]:\n            return True\n        \n        if distance[1] > 0 and distance[2] > 0 and distance[5] > 0 and distance[4] > 0 and distance[1] + distance[5] >= distance[2] and distance[3] + distance[5] >= distance[4]:\n            return True\n        \n        if distance[1] > 0 and distance[2] > 0 and distance[5] > 0 and distance[4] > 0 and distance[1] + distance[3] >= distance[4] and distance[2] + distance[5] >= distance[3]:\n            return True\n        \n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iterate through the dictionary and add the odd values to a set\n        # if the set is empty, return the length of the string\n        # else, return the length of the string minus the number of odd values\n        \n        # create a dictionary to store the frequency of each letter\n        # iter"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        rootVal = postorder[-1]\n        rootIdx = inorder.index(rootVal)\n        \n        leftInorder = inorder[:rootIdx]\n        rightInorder = inorder[rootIdx+1:]\n        \n        leftPostorder = postorder[:len(leftInorder)]\n        rightPostorder = postorder[len(leftInorder):-1]\n        \n        root = TreeNode(rootVal)\n        root.left = self.buildTree(leftInorder, leftPostorder)\n        root.right = self.buildTree(rightInorder, rightPostorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the trees by height\n        trees = sorted([(tree[1], i, j) for i, row in enumerate(forest) for j, tree in enumerate(row) if tree > 1])\n        \n        # start from the top left corner\n        curr_r, curr_c = 0, 0\n        steps = 0\n        \n        # go through each tree and calculate the distance to the top, left, or right\n        for tree_height, tree_r, tree_c in trees:\n            # if we can't reach the tree, return -1\n            if curr_r == len(forest) or curr_c == len(forest[0]) or \\\n               (tree_r, tree_c) in {(curr_r, curr_c), (curr_r-1, curr_c), (curr_r, curr_c-1)}:\n                return -1\n            \n            # if we're going right, go right until we can't\n            if tree_c > curr_c:\n                while tree_r not in {curr_r, curr_r-1} or \\\n                      (tree_r, tree_c) not in {(curr_r, curr_c), (curr_r-1, curr_c)}:\n                    curr_c += 1\n            \n            # if we're going left, go left until we can't\n            elif tree_c < curr_c:\n                while tree_r not in {curr_r, curr_r-1} or \\\n                      (tree_r, tree_c) not in {(curr_r, curr_c), (curr_r-1, curr_c)}:\n                    curr_c -= 1\n            \n            # if we're going up, go up until we can't\n            elif tree_r > curr_r:\n                while tree_c not in {curr_c, curr_c-1} or \\\n                      (tree_r, tree_c) not in {(curr_r, curr_c), (curr_r, curr_c-1)}:\n                    curr_r += 1\n            \n            # if we're going down, go down until we can't\n            elif tree_r < curr_r:\n                while tree_c not in {curr_c, curr_c-1} or \\\n                      (tree_r, tree_c) not in {(curr_r, curr_c), (curr_r, curr_c-1)}:\n                    curr_r -= 1\n            \n            # add the distance to the tree to the total number of steps\n            steps += abs(tree_r - curr_r) + abs(tree_c - curr_c)\n        \n        # return the total number of steps\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the nums\n        nums.sort()\n        \n        # create a dictionary to store the cumulative sum and its frequency\n        cum_sum_freq = {}\n        \n        # cum_sum = 0, freq = 1\n        cum_sum_freq[0] = 1\n        \n        # cum_sum_sum = 0, freq = 2\n        cum_sum_freq[0] = 1\n        \n        # cum_sum_sum = 0, freq = 3\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 4\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 5\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 6\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 7\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 8\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 9\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 10\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 11\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 12\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 13\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 14\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 15\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 16\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 17\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 18\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 19\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 20\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 21\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 22\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 23\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 24\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 25\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 26\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 27\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 28\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 29\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 30\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 31\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 32\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 33\n        cum_sum_freq[0] = 1\n        \n        # cum_sum = 0, freq = 34\n        cum_sum_freq[0] = 1"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 2: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 3: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 4: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 5: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 6: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 7: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 8: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 9: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 10: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 11: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 12: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 13: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 14: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 15: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 16: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 17: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 18: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 19: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 20: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 21: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 22: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 23: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 24: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 25: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 26: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 27: Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Approach 28: Math\n        # Time Complexity: O("}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        if len(a) > len(b):\n            return len(a)\n        if len(b) > len(a):\n            return len(b)\n        return -1 if set(a).intersection(set(b)) else len(a) if a or b else -1"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q][::-1])\n            q = [child for node in q if node.left for child in (node.left, node.right) if child] or []\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        temp = x\n        \n        while temp > rev:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n            \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        one, two = 1, 1\n        \n        for i in range(1, len(s)):\n            curr, prev = int(s[i]), one\n            \n            if curr == '0':\n                one = 0\n                \n            if prev == 0 or curr > '9' or curr == '6' and prev > '2':\n                one = 0\n                \n            one, two = one + two, one\n            \n        return two"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        i = 0\n        for char in t:\n            if i == len(s):\n                return True\n            if char == s[i]:\n                i += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2**n - 1 is the number of gray codes we need to generate\n        # so we can use a list to store the gray codes\n        # and then we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise left shift operator to generate the next gray code\n        # we can use the bitwise right shift operator to generate the next gray code\n        # we can use the bitwise AND operator to generate the next gray code\n        # we can use the bitwise NOT operator to generate the next gray code\n        # we can use the bitwise OR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise AND operator to generate the next gray code\n        # we can use the bitwise NOT operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise AND operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can use the bitwise XOR operator to generate the next gray code\n        # we can"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        first = 1\n        second = 2\n        \n        for i in range(3, n+1):\n            third = first + second\n            first = second\n            second = third\n        \n        return second"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # create a set to store all the words in wordDict\n        wordSet = set(wordDict)\n        \n        # create a list of length s.length + 1 to store the answer\n        dp = [False] * (len(s) + 1)\n        \n        # set the first element of dp to True\n        dp[0] = True\n        \n        # iterate through the string s\n        for i in range(len(s)):\n            \n            # iterate through the list of words in wordSet\n            for j in wordSet:\n                \n                # if the substring starting at index i and ending at i + len(j) is in wordSet\n                # and the substring starting at 0 to i is True\n                # set the element at index i + len(j) to True\n                if s[i - len(j) : i] == j and dp[i - len(j)] == True:\n                    dp[i] = True\n        \n        # return the last element of dp\n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # inorder traversal\n        # if the inorder traversal is sorted, then it is a BST\n        # if the inorder traversal is not sorted, then it is not a BST\n        \n        # inorder traversal is sorted if the inorder traversal is sorted in ascending order\n        \n        # initialize prev to None\n        prev = None\n        \n        # initialize result to True\n        result = True\n        \n        # traverse inorder\n        # set result to False if prev is not None and root.val <= prev\n        # set prev to root.val\n        # traverse inorder\n        \n        if not root:\n            return result\n        \n        stack = []\n        \n        while True:\n            # if root is not None\n            if root:\n                # push root to stack\n                stack.append(root)\n                # set root to root.left\n                root = root.left\n            # else\n            else:\n                # if stack is empty\n                if not stack:\n                    # break\n                    break\n                # set root to pop stack\n                root = stack.pop()\n                # if prev is not None and root.val <= prev\n                if prev and prev.val >= root.val:\n                    # set result to False\n                    result = False\n                    # break\n                    break\n                # set prev to root.val\n                prev = root\n                # set root to root.right\n                root = root.right\n            # traverse inorder\n        \n        # return result\n        return result"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty, return intervals\n        if not newInterval:\n            return intervals\n        \n        # if newInterval ends before the first element in intervals, insert newInterval at the beginning\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if newInterval starts after the last element in intervals, insert newInterval at the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # otherwise, merge with the last element in intervals\n        intervals[-1][0] = min(intervals[-1][0], newInterval[0])\n        intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n        return intervals[:-1]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # if len(s) == 1:\n        #     return [[s]]\n        \n        # res = []\n        # dp = [True] + [False] * len(s)\n        \n        # for i in range(1, len(s) + 1):\n        #     for j in range(i):\n        #         if s[j] == s[i - 1] and (dp[i - 1] or dp[i - 2] if j >= 2 else True):\n        #             dp[i] = True\n        #             if i == len(s):\n        #                 res.append([s[j]] + res[j - 1] if res else [s[j]])\n        #             else:\n        #                 res.append(res[j - 1] + [s[j]] if res else [s[j]])\n        \n        # return res\n        \n        # dp = [True] + [False] * len(s)\n        # for i in range(1, len(s) + 1):\n        #     for j in range(i):\n        #         if s[j] == s[i - 1]:\n        #             dp[i] = dp[i - 1] or dp[i - 2]\n        #             if i == len(s):\n        #                 res.append([s[j]] + res[j - 1] if res else [s[j]])\n        #             else:\n        #                 res.append(res[j - 1] + [s[j]] if res else [s[j]])\n        \n        # return res\n        \n        # dp = [True] + [False] * len(s)\n        # for i in range(1, len(s) + 1):\n        #     for j in range(i - 1, -1, -1):\n        #         if s[j] == s[i - 1]:\n        #             dp[i] = dp[i] or dp[i - 1]\n        #             if i == len(s):\n        #                 res.append([s[j]] + res[j - 1] if res else [s[j]])\n        #             else:\n        #                 res.append(res[j - 1] + [s[j]] if res else [s[j]])\n        \n        # return res\n        \n        # dp = [True] + [False] * len(s)\n        # for i in range(1, len(s) + 1):\n        #     for j in range(i - 1, -1, -1):\n        #         if s[j] == s[i - 1] and (dp[i - 1] or dp[i - 2]):\n        #             dp[i] = True\n        #             if i == len(s):\n        #                 res.append([s[j]] + res[j - 1] if res else [s[j]])\n        #             else:\n        #                 res.append(res[j - 1] + [s[j]] if res else [s[j]])\n        \n        # return res\n        \n        dp = [True] + [False] * len(s)\n        res = []\n        for i in range(len(s)):\n            res.append([s[i]] if res else [])\n            for j in range(i, -1, -1):\n                if s[j] == s[i] and (dp[i] or dp[i - 1] if j > 0 else True):\n                    dp[i] = True\n                    if i == len(s) - 1:\n                        res[-1].append(s[j])\n                    else:\n                        res[-1] += [s[j]]\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize min_val, max_val, min_range, and min_range_idx\n        min_val, max_val = float('inf'), -float('inf')\n        min_range = [(nums[i][0], i) for i in range(len(nums))]\n        min_range.sort()\n        # Initialize min_range_idx\n        min_range_idx = len(nums)\n        \n        # Iterate over min_range\n        for i, num in enpx min_range:\n            # If min_range_idx is 0, then we have found the smallest range\n            if min_range_idx == 0:\n                return [min_val, max_val]\n            # If nums[min_range_idx][0] is the smallest value in the k lists, then update min_val\n            if nums[min_range_idx][0] == min_val:\n                min_val = nums[min_range_idx][0]\n            # Decrement min_range_idx\n            min_range_idx -= 1\n            # Update max_val\n            max_val = max(max_val, num)\n            # If nums[min_range_idx][0] is the largest value in the k lists, then update min_range\n            if nums[min_range_idx][0] == max_val:\n                min_range = sorted(min_range, key = lambda x: nums[x][1])\n                min_range_idx = 0\n                min_val = min_range[min_range_idx][0]\n                max_val = max_val\n        # Return min_range\n        return [min_val, max_val]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # pigs = ceil(log(buckets) / log(minutesToTest / minutesToDie + 1))\n        # return pigs if pigs (buckets) ** pigs (pigs) >= minutesToTest + 1\n        pigs = math.log(minutesToTest, minutesToDie + 1) / math.log(buckets)\n        pigs = math.ceil(pigs)\n        return pigs"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # sort the heights in the grid\n        # O(n log n)\n        h = sorted([grid[i][j] for i,j in enpx] + [grid[0][0]] * (n**2 - 1))\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2:\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - mid:\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2 + hi - lo:\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2 + hi - lo - (hi - lo):\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2 + hi - lo - (hi - lo) - (hi - lo):\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2 + hi - lo - (hi - lo) - (hi - lo) - (hi - lo):\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2 + hi - lo - (hi - lo) - (hi - lo) - (hi - lo) - (hi - lo):\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O(log n)\n        lo, hi = 0, n**2 - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid] <= h[n**2 - 1] - (n**2 - 1) // 2 + hi - lo - (hi - lo) - (hi - lo) - (hi - lo) - (hi - lo) - (hi - lo):\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        # binary search to find the smallest time that we can swim\n        # O("}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] = dp[j] + dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = 0\n        res_list = [0] * (len(num1) + len(num2))\n        \n        for i in reversed(range(len(num1))):\n            for j in reversed(range(len(num2))):\n                res = res_list[i + j + 1] + (num1[i] * num2[j])\n                res_list[i + j] += res // 10\n                res_list[i + j + 1] = res % 10\n        \n        for i in range(len(res_list) - 1):\n            if res_list[i] >= 10:\n                res_list[i + 1] += res_list[i] // 10\n                res_list[i] = res_list[i] % 10\n        \n        if res_list[-1] == 0:\n            res_list.pop()\n        \n        return ''.join(map(str, res_list))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only hold one stock at a time, then we can either buy or sell it.\n        ## 2. If we can only hold one transaction, then we can either buy or sell it.\n        ## 3. If we can hold at most two transactions, then we can either buy or sell it.\n        \n        ## 1. If we can only"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # create a dictionary to store the frequency of each number\n        freq = {}\n        for num in candidates:\n            if num not in freq:\n                freq[num] = 0\n            freq[num] += 1\n        \n        # create a list to store the combinations\n        combinations = []\n        \n        # create a set to store the unique combinations\n        unique_combinations = set()\n        \n        # iterate through the sorted candidates\n        for num in candidates:\n            # if the current number is greater than the target, we can no longer use it\n            if num > target:\n                break\n            \n            # if the current number is the same as the previous number, we have seen it before, so we can use it multiple times\n            if num in freq:\n                # update the frequency of the current number\n                freq[num] -= 1\n                \n                # if the frequency is 0, we have seen it before, so we can use it multiple times\n                if freq[num] == 0:\n                    del freq[num]\n                \n                # add the combination (num, num) to the combinations\n                combinations.append([num] * freq[num])\n                \n                # add the combination (num, num) to the unique combinations\n                unique_combinations.add(tuple(sorted([num] * freq[num])))\n                \n                # update the frequency of the current number\n                freq[num] += 1\n                \n            # if the current number is not the same as the previous number, we have not seen it before, so we can use it once\n            else:\n                # add the combination (num, 1) to the combinations\n                combinations.append([num])\n                \n                # add the combination (num, 1) to the unique combinations\n                unique_combinations.add((num,))\n                \n                # update the frequency of the current number\n                freq[num] = 1\n        \n        # create a dictionary to store the frequency of each combination\n        freq = {}\n        for combination in combinations:\n            if tuple(combination) not in freq:\n                freq[tuple(combination)] = 0\n            freq[tuple(combination)] += 1\n        \n        # create a list to store the final combinations\n        final_combinations = []\n        \n        # iterate through the sorted unique combinations\n        for combination in sorted(unique_combinations):\n            # if the combination is greater than the target, we can no longer use it\n            if sum(combination) > target:\n                break\n            \n            # if the combination is the same as the previous combination, we have seen it before, so we can use it multiple times\n            if combination in freq:\n                # add the combination to the final combinations\n                final_combinations.append(combination * freq[combination])\n                \n                # update the frequency of the combination\n                freq[combination] -= 1\n                \n                # if the frequency is 0, we have seen it before, so we can use it multiple times\n                if freq[combination] == 0:\n                    del freq[combination]\n            \n            # if the combination is not the same as the previous combination, we have not seen it before, so we can use it once\n            else:\n                # add the combination to the final combinations\n                final_combinations.append(combination)\n                \n                # update the frequency of the combination\n                freq[combination] = 1\n        \n        # sort the final combinations\n        final_combinations.sort()\n        \n        # return the final combinations\n        return final_combinations"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word[0].isupper() and word[1:].islower()):\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] > buy:\n        #         profit = max(profit, prices[i] - buy)\n        #     else:\n        #         buy = prices[i]\n        \n        # return profit\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] > buy:\n        #         profit += prices[i] - buy\n        #         buy = prices[i]\n        #     else:\n        #         buy = prices[i]\n        \n        # return profit\n        \n        if len(prices) < 2:\n            return 0\n        \n        profit = 0\n        buy = prices[0]\n        \n        for i in range(1, len(prices)):\n            if prices[i] > buy:\n                profit += prices[i] - buy\n                buy = prices[i]\n            else:\n                buy = prices[i]\n        \n        return profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # if not root:\n        #     return []\n        # stack = []\n        # res = []\n        # while root or stack:\n        #     if root:\n        #         stack.append(root)\n        #         root = root.left\n        #     else:\n        #         root = stack.pop()\n        #         res.append(root.val)\n        #         root = root.right\n        # return res\n        \n        # Recursive solution\n        if not root:\n            return []\n        if not root.left:\n            return [root.val] + self.inorderTraversal(root.right)\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        rootIdx = 0\n        \n        # find root in inorder\n        for i in range(len(inorder)):\n            if inorder[i] == root.val:\n                rootIdx = i\n                break\n        \n        # left subtree\n        root.left = self.buildTree(preorder[1:rootIdx], inorder[:rootIdx])\n        # right subtree\n        root.right = self.buildTree(preorder[rootIdx+1:], inorder[rootIdx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # count the number of '(' and ')'\n        left, right = 0, s.count('(')\n        # store the invalid pairs\n        invalid = set()\n        # iterate through the string\n        for char in s:\n            if char == '(':\n                left += 1\n            elif char == ')':\n                # if ')' is found, check if left is 0\n                if left == 0:\n                    # if it is, add it to the set\n                    right += 1\n                else:\n                    # otherwise, decrement left\n                    left -= 1\n        # add all the pairs to the set\n        for char in s:\n            if char == '(':\n                # if '(' is found, add it to the set\n                invalid.add(left)\n            elif char == ')':\n                # if ')' is found, check if right is 0\n                if right == 0:\n                    # if it is, add it to the set\n                    left += 1\n                else:\n                    # otherwise, decrement right\n                    right -= 1\n        # create a set of the unique values in the set\n        unique = set(invalid)\n        # create a list of the unique values in the set\n        unique_list = list(unique)\n        # sort the list in ascending order\n        unique_list.sort()\n        # create a list to store the final answer\n        ans = []\n        # iterate through the unique values in the set\n        for i in unique_list:\n            # if the number of '(' is equal to the number of ')'\n            if i == 0:\n                # add the string to the list\n                ans.append(s)\n            # otherwise, if the number of '(' is greater than the number of ')'\n            else:\n                # add the string to the list if it contains the number of ')'\n                # subtract the number of ')' from the total number of ')'\n                # if the number of ')' is greater than the number of '('\n                # add the string to the list\n                temp = s\n                # iterate through the string\n                for char in temp:\n                    # if the number of ')' is greater than the number of '('\n                    # and the number of ')' is not equal to the number of '('\n                    # and the number of ')' is not equal to the number of ')'\n                    # and the number of '(' is not equal to 0\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'\n                    # and the number of '(' is not equal to the number of ')'"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time Complexity: O(NlogK)\n        # Space Complexity: O(1)\n        \n        # Use a min heap to store the first element of each linked list\n        # Iterate through the heap and create a new linked list\n        # Connect the new linked list to the next node in the heap\n        # If the next node exists, add it to the heap\n        \n        # Initialize a new linked list\n        head = ListNode()\n        # Initialize a min heap\n        heap = []\n        \n        # Add the first element of each linked list to the heap\n        for l in lists:\n            if l:\n                heapq.heappush(heap, (l.val, id(l), l))\n        \n        # Iterate through the heap\n        curr = head\n        # Add the first element to the new linked list\n        while heap:\n            # Get the smallest element from the heap\n            val, idx, node = heapq.heappop(heap)\n            # Add the node to the new linked list\n            curr.next = node\n            # If the next node exists, add it to the heap\n            if node.next:\n                heapq.heappush(heap, (node.next.val, id(node.next), node.next))\n            # Move to the next node\n            curr = curr.next\n        # Return the new linked list\n        return head.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) < 2:\n        #     return 0\n        \n        # dp = [0] * (len(s) + 1)\n        # dp[0] = -1\n        \n        # for i in range(len(s)):\n        #     for j in range(i, -1, -1):\n        #         if s[j] == s[i] and (i < 1 or dp[i - 1] == -1 or dp[i - 1] == 0):\n        #             dp[i] = j\n        #             if j + 1 < len(dp):\n        #                 dp[i] += 1\n                \n        # if dp[-1] == -1:\n        #     return len(s) - 1\n        \n        # ans = 0\n        # for i in dp:\n        #     ans += 1\n        #     if i == -1:\n        #         ans -= 1\n        # return ans\n        \n        # dp = [0] * (len(s) + 1)\n        # dp[0] = 1\n        \n        # for i in range(len(s)):\n        #     dp[i + 1] = dp[i] + 1\n        #     for j in range(i, -1, -1):\n        #         if s[j] == s[i] and (i < 1 or dp[i - 1] == dp[i]):\n        #             dp[i + 1] = dp[i]\n        #             if j + 1 < len(dp):\n        #                 dp[i + 1] -= 1\n                \n        # if dp[-1] == 0:\n        #     return len(s) - 1\n        \n        # ans = 0\n        # for i in dp:\n        #     ans += 1\n        #     if i == 0:\n        #         ans -= 1\n        # return ans\n        \n        # dp = [0] * (len(s) + 1)\n        # dp[0] = 1\n        \n        # for i in range(len(s)):\n        #     dp[i + 1] = dp[i]\n        #     for j in range(i, -1, -1):\n        #         if s[j] == s[i] and (i < 1 or dp[i - 1] == dp[i]):\n        #             dp[i + 1] = dp[i]\n        #             if j + 1 < len(dp):\n        #                 dp[i + 1] += 1\n                \n        # if dp[-1] == 0:\n        #     return len(s) - 1\n        \n        # ans = 0\n        # for i in dp:\n        #     ans += 1\n        #     if i == 0:\n        #         ans -= 1\n        # return ans\n        \n        # dp = [0] * (len(s) + 1)\n        # dp[0] = 1\n        \n        # for i in range(len(s)):\n        #     dp[i + 1] = dp[i]\n        #     for j in range(i, -1, -1):\n        #         if s[j] == s[i] and (i < 1 or dp[i - 1] == dp[i]):\n        #             dp[i + 1] += 1\n        #             if j + 1 < len(dp):\n        #                 dp[i + 1] -= 1\n                \n        # if dp[-1] == 0:\n        #     return len(s) - 1\n        \n        # ans = 0\n        # for i in dp:\n        #     ans += 1\n        #     if i == 0:\n        #         ans -= 1\n        # return ans\n        \n        # dp = [0] * (len(s) + 1)\n        # dp[0] = 1\n        \n        # for i in range(len(s)):\n        #     dp[i + 1] = 1\n        #     for j in range(i, -1, -1):\n        #         if s[j] == s[i]"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Binary search for the first number that is less than or equal to k.\n        # 2. Count the number of 5's in that number's factorial.\n        # 3. Return k - number of 5's.\n        \n        low, high = 0, k # 0 5 10 15\n        ans = 0\n        \n        while low <= high:\n            mid = (low + high) // 5\n            if k <= mid * 5:\n                high = mid - 1\n            else:\n                ans, low = mid, mid + 1\n        \n        return ans"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a dictionary to store the reverse of each word\n        # and a set to store the index of each word\n        word_dict = {}\n        for i, word in enumerate(words):\n            if not word:\n                word_dict[\"\"] = set([0])\n            else:\n                word_dict[word[::-1]] = word_dict.get(word[::-1], set()) | {i}\n        \n        # create a set to store the index of each word\n        word_set = set()\n        for i, word in enumerate(words):\n            word_set.add(word)\n            \n        # create a result list\n        result = []\n        # iterate through each word in the dictionary\n        for word, index in word_dict.items():\n            # if the reversed word is in the set, then check if the reversed word is a palindrome\n            if word_dict.get(word[::-1], set()) & index:\n                # if the reversed word is a palindrome, then add the index of the word and its reverse to the result\n                result.append([index, word_dict[word[::-1]].pop()])\n            # if the word is not in the set, then check if the word is a palindrome\n            if \"\" in index:\n                # if the word is a palindrome, then add the index of the reversed word and its reverse to the result\n                result.append([word_dict[\"\"].pop(), index.pop()])\n            # iterate through each index of the word\n            for i in index:\n                # if the reversed word is in the set, then add the index of the word and its reverse to the result\n                if word_dict.get(word[::-1], set()) & word_set:\n                    result.append([i, word_dict[word[::-1]].pop()])\n        # return the result\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        # find the middle element\n        mid = len(nums)//2\n        \n        # create root node\n        root = TreeNode(nums[mid])\n        \n        # if left exists, create left subtree\n        if nums[:mid]:\n            root.left = self.sortedArrayToBST(nums[:mid])\n        \n        # if right exists, create right subtree\n        if nums[mid+1:]:\n            root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        total_infected, total_walls = 0, 0\n        \n        # Iterate through each row, keeping track of the number of infected and walls\n        for i, row in enumerate(isInfected):\n            infected, walls = 0, 0\n            for cell in row:\n                if cell == 1:\n                    infected += 1\n                elif infected > 0:\n                    walls += 1\n                    total_walls += 1\n                    infected -= 1\n            total_infected += infected\n            if infected > 0:\n                total_walls += 1\n        \n        # Iterate through each column, keeping track of the number of infected and walls\n        for j in range(n):\n            infected, walls = 0, 0\n            for i in range(m):\n                if isInfected[i][j] == 1:\n                    infected += 1\n                elif infected > 0:\n                    walls += 1\n                    total_walls += 1\n                    infected -= 1\n            total_infected += infected\n            if infected > 0:\n                total_walls += 1\n        \n        # Iterate through each row, keeping track of the number of infected and walls\n        # and the number of days until we can install walls\n        infected, walls, days = 0, 0, 0\n        for i, row in enumerate(isInfected):\n            for cell in row:\n                if cell == 1:\n                    infected += 1\n                elif infected > 0:\n                    walls += 1\n                    days += 1\n                    infected -= 1\n            if infected > 0:\n                days += 1\n        \n        # Iterate through each column, keeping track of the number of infected and walls\n        # and the number of days until we can install walls\n        infected, walls, days = 0, 0, 0\n        for j in range(n):\n            for i in range(m):\n                if isInfected[i][j] == 1:\n                    infected += 1\n                elif infected > 0:\n                    walls += 1\n                    days += 1\n                    infected -= 1\n            if infected > 0:\n                days += 1\n        \n        # Return the number of walls used to quarantine all the infected regions\n        # plus the number of days until we can install walls\n        return total_walls + days - 1, total_infected - walls"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        for i in range(m):\n            for j in range(n):\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                        if dp[ni][nj]:\n                            dp[ni][nj] = dp[ni][nj]\n                        else:\n                            dp[ni][nj] = 1\n                res = max(res, 1 + dp[i][j] if dp[i][j] else 1)\n                \n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                        if dp[i][j]:\n                            dp[i][j] = max(dp[i][j], 1 + dp[ni][nj])\n                        else:\n                            dp[i][j] = 1\n                res = max(res, 1 + dp[i][j] if dp[i][j] else 1)\n        \n        return res"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of 1's in the binary representation of n\n        # 2. count the number of 1's in the binary representation of n+1\n        # 3. the number of 1's in the binary representation of n is the number of 1's in the binary representation of n+1 // 2\n        #    if the last digit of n is 1, then the number of 1's in the binary representation of n+1 // 2 is the number of 1's in the binary representation of n+1 // 2 + 1\n        #    if the last digit of n is 0, then the number of 1's in the binary representation of n+1 // 2 is the number of 1's in the binary representation of n+1 // 2\n        # 4. the number of 1's in the binary representation of n is the number of 1's in the binary representation of n+1 // 2\n        \n        if n < 0:\n            return 0\n        \n        count = 0\n        power = 1\n        \n        while n > 0:\n            count += (n // 10) * power + (n % 10 == 1)\n            power *= 10\n            n //= 10\n            \n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set to store all the words in wordDict\n        wordSet = set(wordDict)\n        \n        # create a dictionary to store the results\n        dp = {0:True}\n        \n        # iterate through the string s\n        for i in range(len(s)):\n            \n            # if the current word is in the set, add it to the dictionary\n            if s[i] in wordSet:\n                # if the current word is in the dictionary, add it to the dictionary\n                if i+1 not in dp:\n                    dp[i+1] = False\n                # if the current word is in the dictionary, add it to the dictionary\n                elif dp[i]:\n                    dp[i+1] = True\n                \n            # if the current word is not in the set, check if the previous words are in the dictionary\n            # if the previous words are in the dictionary, add it to the dictionary\n            elif i > 0 and s[i-1] in wordSet and s[i-1] not in dp:\n                dp[i] = True\n            # if the previous words are in the dictionary, add it to the dictionary\n            elif i > 0 and s[i-1] in wordSet and dp[i]:\n                dp[i] = dp[i-1]\n            # if the previous words are not in the dictionary, add it to the dictionary\n            else:\n                dp[i] = False\n        \n        # if the last word is in the set, add it to the dictionary\n        if s[-1] in wordSet:\n            if len(dp) not in dp:\n                dp[len(dp)] = False\n            elif dp[len(dp)]:\n                dp[len(dp)] = True\n        # if the last word is not in the set, check if the previous words are in the dictionary\n        # if the previous words are in the dictionary, add it to the dictionary\n        elif len(dp) > 0 and s[-1] not in wordSet and dp[len(dp)]:\n            dp[len(dp)] = True\n        # if the previous words are not in the dictionary, add it to the dictionary\n        else:\n            dp[len(dp)] = False\n        \n        # if the last word is in the set, add it to the dictionary\n        if s[-1] in wordSet:\n            if len(dp) not in dp:\n                dp[len(dp)] = False\n            elif dp[len(dp)]:\n                dp[len(dp)] = True\n        # if the last word is not in the set, check if the previous words are in the dictionary\n        # if the previous words are in the dictionary, add it to the dictionary\n        elif len(dp) > 0 and s[-1] not in wordSet and dp[len(dp)]:\n            dp[len(dp)] = True\n        # if the previous words are not in the dictionary, add it to the dictionary\n        else:\n            dp[len(dp)] = False\n        \n        # if the last word is in the set, add it to the dictionary\n        if s[-1] in wordSet:\n            if len(dp) not in dp:\n                dp[len(dp)] = False\n            elif dp[len(dp)]:\n                dp[len(dp)] = True\n        # if the last word is not in the set, check if the previous words are in the dictionary\n        # if the previous words are in the dictionary, add it to the dictionary\n        elif len(dp) > 0 and s[-1] not in wordSet and dp[len(dp)]:\n            dp[len(dp)] = True\n        # if the previous words are not in the dictionary, add it to the dictionary\n        else:\n            dp[len(dp)] = False\n        \n        # if the last word is in the set, add it to the dictionary\n        if s[-1] in wordSet:\n            if len(dp) not in dp:\n                dp[len(dp)] = False\n            elif dp[len(dp)]:\n                dp[len(dp)] = True\n        # if the last word is not in the set, check if the previous words are in the dictionary\n        # if the previous words are in the dictionary, add it to the dictionary\n        elif len(dp) > 0 and s[-1] not in word"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        level = 0\n        queue = collections.deque()\n        queue.append(root)\n        \n        while queue:\n            level += 1\n            level_nodes = []\n            \n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if level % 2 == 1:\n                    level_nodes.append(node.val)\n                else:\n                    level_nodes.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            res.append(level_nodes)\n        \n        return res"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn > 10 or turnedOn < 0:\n            return []\n        \n        res = []\n        for h in range(11):\n            if h*6 + turnedOn < 12 or h*6 + turnedOn > 60:\n                continue\n            cnt = bin(turnedOn ^ (1 << h)).count('1')\n            if cnt > h or cnt > turnedOn:\n                res.append('{}:{:02d}'.format(h, turnedOn - cnt))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        res = []\n        for i in range(numRows):\n            if i == 0:\n                res.append([1])\n            elif i == 1:\n                res.append([1,1])\n            else:\n                temp = [1]\n                for j in range(1, i):\n                    temp.append(res[-1][j] + res[-1][j-1])\n                temp.append(1)\n                res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        # 3^19 = 1162261467\n        # 3^20 = 1164510091\n        # 3^21 = 11692650\n        # 3^22 = 117067677\n        # 3^23 = 1175463641\n        # 3^24 = 1180646753\n        # 3^25 = 1185510067\n        # 3^26 = 1191129253\n        # 3^27 = 1196732353\n        # 3^28 = 1202437309\n        # 3^29 = 1208255021\n        # 3^30 = 1214185377\n        # 3^31 = 1220228385\n        # 3^32 = 1226384057\n        # 3^33 = 1232652293\n        # 3^34 = 1239032193\n        # 3^35 = 1245523757\n        # 3^36 = 1252126985\n        # 3^37 = 1258841877\n        # 3^38 = 1265668421\n        # 3^39 = 1272606617\n        # 3^40 = 1279656453\n        # 3^41 = 1286817913\n        # 3^42 = 1294091087\n        # 3^43 = 1301475977\n        # 3^44 = 1308972573\n        # 3^45 = 1316581865\n        # 3^46 = 1324303841\n        # 3^47 = 1332138493\n        # 3^48 = 1340085813\n        # 3^49 = 1348145801\n        # 3^50 = 1356318447\n        # 3^51 = 1364603741\n        # 3^52 = 1373001763\n        # 3^53 = 1381512503\n        # 3^54 = 1390135953\n        # 3^55 = 1398872103\n        # 3^56 = 1407720943\n        # 3^57 = 1416682463\n        # 3^58 = 1425756653\n        # 3^59 = 1434943503\n        # 3^60 = 1444243003\n        # 3^61 = 1453655143\n        # 3^62 = 1463180013\n        # 3^63 = 1472817603\n        # 3^64 = 1482567903\n        # 3^65 = 1492430903\n        # 3^66 = 1502406593\n        # 3^67 = 1512494963\n        # 3^68 = 1522696003\n        # 3^69 = 1532909703\n        # 3^70 = 1543136053\n        # 3^71 = 1553375043\n        # 3^72"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Approach 1: Recursive DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Intuition:\n        ## We can use a global variable to keep track of the maximum path sum.\n        ## We can use a helper function to recursively traverse the tree and return the maximum path sum along with the maximum path sum found so far.\n        ## We can use a helper function to recursively traverse the tree and return the maximum path sum along with the maximum path sum found so far.\n        ## We can use a helper function to recursively traverse the tree and return the maximum path sum along with the maximum path sum found so far.\n        \n        ## Algorithm:\n        ## Initialize a global variable to keep track of the maximum path sum to zero.\n        ## Initialize a helper function to recursively traverse the tree and return the maximum path sum along with the maximum path sum found so far.\n        ## Set the maximum path sum to zero.\n        ## Recursively traverse the tree using the helper function.\n        ## Return the maximum path sum found so far.\n        \n        ## Code:\n        self.maxSum = float('-inf')\n        \n        def helper(root):\n            if not root:\n                return 0\n            \n            leftSum = helper(root.left)\n            rightSum = helper(root.right)\n            \n            leftSum = max(leftSum, 0)\n            rightSum = max(rightSum, 0)\n            \n            currSum = root.val + leftSum + rightSum\n            \n            self.maxSum = max(self.maxSum, currSum)\n            \n            return root.val + max(leftSum, rightSum)\n        \n        helper(root)\n        return self.maxSum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        # sort the heightMap by the first column\n        # and then by the last column\n        # we can use a min heap to keep track of the min height in each row\n        # we can also use a min heap to keep track of the min height in each column\n        # we can also use a set to keep track of the visited cells\n        \n        m, n = len(heightMap), len(heightMap[0])\n        min_row, min_col, min_heap, min_set = [float('inf')] * m, [float('inf')] * n, [], set()\n        \n        for i in range(m):\n            min_row[i] = heightMap[i][0]\n            min_heap.append((heightMap[i][0], i))\n            min_set.add((i, 0))\n            \n        for j in range(1, n):\n            min_col[j] = heightMap[0][j]\n            min_heap.append((heightMap[0][j], j))\n            min_set.add((0, j))\n            \n        ans = 0\n        \n        for height, i in min_heap:\n            if min_col[j] > height:\n                ans += height\n                \n            # we can use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row\n            # we can also use a min heap to keep track of the min height in each column\n            # we can also use a set to keep track of the visited cells\n            \n            # we can also use a min heap to keep track of the min height in each row"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase and remove non-alphanumeric characters\n        s = s.lower()\n        s = ''.join(filter(str.isalnum, s))\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # sort the nums\n        nums.sort()\n        \n        # initialize the result\n        res = []\n        \n        # iterate over the nums\n        for i in range(len(nums)-k+1):\n            \n            # if k is even, then the median is the mean of the two middle values\n            if k % 2 == 0:\n                res.append((nums[i] + nums[i+k//2])/2.0)\n            # if k is odd, then the median is the middle value\n            else:\n                res.append(nums[i+k//2])\n        \n        return res"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next or k == 0:\n            return head\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the kth node from the end\n        kth = head\n        for i in range(length - k % length):\n            kth = kth.next\n        \n        # if the linked list is empty or k is 0, return head\n        if not kth:\n            return head\n        \n        # set the new head\n        new_head = kth\n        \n        # find the new tail\n        curr = head\n        while curr.next != kth:\n            curr = curr.next\n        \n        # set the new tail\n        curr.next = None\n        \n        # return the new head\n        curr.next = head\n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # sort the positions by left coordinate\n        positions.sort(key=lambda x: x[0])\n        \n        # create a dictionary to store the height of each square\n        height = {}\n        \n        # initialize the tallest height to 0\n        tallest = 0\n        \n        # iterate through the sorted positions\n        for left, heighti in positions:\n            \n            # update the tallest height\n            tallest = max(tallest, heighti)\n            \n            # update the height of each square\n            for i in height.keys() | {left}:\n                \n                # if the square is on the left side of another square, update the height\n                if i > left:\n                    height[i] = height.get(i, 0) + heighti\n                \n                # otherwise, update the height of the right side of the square\n                else:\n                    height[i] = max(height.get(i, 0), heighti)\n        \n        # create a dictionary to store the tallest height at each position\n        tallest_height = {0: 0}\n        \n        # iterate through the sorted positions\n        for left, heighti in sorted(height.items()):\n            \n            # update the tallest height\n            tallest = max(tallest, tallest_height[left] + heighti)\n            \n            # update the tallest height at each position\n            tallest_height[left] = tallest\n        \n        # return the tallest height at each position\n        return [tallest_height[i] for i in range(left, tallest)]"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        ans = 0\n        \n        if root.left and root.left.left == None and root.left.right == None:\n            ans += root.left.val\n        \n        return ans + self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]: return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        ans = float('-inf')\n        prefixSum = [0] * n\n        \n        if ans == float('-inf'):\n            for row in matrix:\n                for i, num in enpxSum = [0] + prefixSum, 0\n                for num in row:\n                    i = prefixSum.index(num if k == 0 else num - k)\n                    ans = max(ans, prefixSum[i] if ans != float('-inf') else 0)\n                    ans = ans if ans != float('-inf') else num\n                    ans = ans + prefixSum[i] if ans != float('-inf') else num\n                    ans = ans if ans != float('-inf') else 0\n                    ans = ans + (prefixSum[i] if ans != float('-inf') else 0)\n                    ans = ans if ans != float('-inf') else num\n                for num in prefixSum:\n                    ans = ans if ans != float('-inf') else num\n                    ans = ans if ans != float('-inf') else 0\n                    ans = ans + num\n                    ans = ans if ans != float('-inf') else num\n                prefixSum.append(0)\n            if ans == float('-inf'): return ans\n            \n            prefixSum = [0]\n            ans = float('-inf')\n            for num in prefixSum:\n                ans = ans if ans != float('-inf') else num\n                ans = ans if ans != float('-inf') else 0\n                ans = ans if ans != float('-inf') else num\n                ans = ans if ans != float('-inf') else 0\n                ans = ans if ans != float('-inf') else num\n            for row in matrix:\n                prefixSum = [0]\n                for num in row:\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)\n                    prefixSum.append(prefixSum[-1] if ans != float('-inf') else 0)"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        sign = 1\n        if (dividend < 0) ^ (divisor < 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        \n        while dividend >= divisor:\n            temp, i = divisor, 1\n            \n            while dividend >= temp:\n                dividend -= temp\n                quotient += i\n                i <<= 1\n                temp <<= 1\n                \n        if sign == 1:\n            if quotient > 2147483647:\n                return 2147483647\n            return quotient\n        else:\n            if quotient < -2147483648:\n                return -2147483648\n            return -quotient"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        R, C = len(board), len(board[0])\n        \n        # mark all the O's that touch the border as 'M'\n        for r in range(R):\n            for c in (0, C-1):\n                if board[r][c] == 'O':\n                    board[r][c] = 'M'\n            for c in range(C):\n                if board[r][c] == 'O':\n                    if r and board[r-1][c] == 'O':\n                        board[r][c] = 'M'\n                else:\n                    if r and board[r-1][c] == 'M':\n                        board[r][c] = 'M'\n        \n        # flip all the 'M's to 'O's\n        for r in range(R):\n            for c in (0, C-1):\n                if board[r][c] == 'M':\n                    board[r][c] = 'O'\n            for c in range(C):\n                if board[r][c] == 'M':\n                    if r and board[r-1][c] == 'M':\n                        board[r][c] = 'O'\n                else:\n                    if r and board[r-1][c] == 'M':\n                        board[r][c] = 'O'\n        \n        # mark all the O's that don' #t touch the border as 'X'\n        for r in range(R):\n            for c in (0, C-1):\n                if board[r][c] == 'O':\n                    board[r][c] = 'M'\n            for c in range(C):\n                if board[r][c] == 'M':\n                    if r and board[r-1][c] == 'M':\n                        board[r][c] = 'M'\n                else:\n                    if r and board[r-1][c] == 'M':\n                        board[r][c] = 'M'\n        \n        # flip all the 'M's to 'O's\n        for r in range(R):\n            for c in (0, C-1):\n                if board[r][c] == 'M':\n                    board[r][c] = 'O'\n            for c in range(C):\n                if board[r][c] == 'M':\n                    if r and board[r-1][c] == 'M':\n                        board[r][c] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary with the complement as the key\n        \n        # create a"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if not any(abs(x)==24 or x==24 for x in collections.Counter(cards).values()):\n            return False\n        \n        seen=set()\n        for x1,x2,x3,x4 in itertools.permutations(cards,4):\n            for p in [2,3]:\n                if (x1*p,x2*p,x3*p,x4*p) in seen or \\\n                (x1*p,x2*p,x4*p,x3*p) in seen or \\\n                (x1*p,x3*p,x2*p,x4*p) in seen or \\\n                (x2*p,x3*p,x1*p,x4*p) in seen:\n                    return True\n                seen.add((x1*p,x2*p,x3*p,x4*p))\n        return False"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the pattern is empty, then the only way to match is if the string is also empty\n        if not p:\n            return not s\n        \n        # if the pattern is not empty, then the first character of the pattern must be '*'\n        if p[0] != '*':\n            # if the string is empty, then the pattern cannot match the string\n            if not s or len(s) != len(p):\n                return False\n            # if the first character of the string is not the same as the first character of the pattern, then the pattern cannot match the string\n            if p[0] != s[0] and p[0] != '?':\n                return False\n        \n        # initialize the starIndex to -1\n        starIndex = -1\n        # initialize the matchIndex to -1\n        matchIndex = 0\n        \n        # loop through the pattern\n        for i in range(len(p)):\n            # if the current character of the pattern is '*'\n            if p[i] == '*':\n                # if the starIndex is -1, then set it to the current matchIndex\n                if starIndex == -1:\n                    starIndex = matchIndex\n                # if the current character of the pattern is also '*'\n                else:\n                    # set the starIndex to the next matchIndex\n                    starIndex = starIndex + 1\n                    # if the next character of the pattern is also '*'\n                    if p[starIndex] == '*':\n                        # set the starIndex to the next matchIndex\n                        starIndex = starIndex + 1\n            # if the current character of the pattern is not '*'\n            else:\n                # if the starIndex is -1, then set it to -1\n                if starIndex == -1:\n                    starIndex = -1\n                # if the current character of the pattern is also not '*'\n                else:\n                    # if the next character of the pattern is also not '*'\n                    if p[starIndex + 1] != '*':\n                        # if the current character of the string is not the same as the current character of the pattern, or if the next character of the pattern is not the same as the current character of the pattern, then the pattern cannot match the string\n                        if p[i] != s[matchIndex] and p[i] != '?' or p[starIndex] != s[matchIndex]:\n                            # set the starIndex to -1\n                            starIndex = -1\n                    # if the next character of the pattern is also '*'\n                    else:\n                        # set the starIndex to the next matchIndex\n                        starIndex = starIndex + 1\n                # if the current character of the pattern is not '?'\n                if p[i] != '?' and p[i] != s[matchIndex]:\n                    # set the starIndex to -1\n                    starIndex = -1\n                # increment the matchIndex\n                matchIndex = matchIndex + 1\n        \n        # if the starIndex is -1, then the pattern cannot match the string\n        if starIndex == -1:\n            return False\n        # if the starIndex is less than the length of the string, then the pattern cannot match the string\n        if starIndex >= len(s):\n            return False\n        \n        # if the starIndex is less than the length of the pattern, then the pattern cannot match the string\n        if starIndex < len(p):\n            # if the next character of the pattern is not '*'\n            if p[starIndex + 1] != '*':\n                # if the next character of the pattern is also not '*'\n                if p[starIndex + 1] != s[starIndex] and p[starIndex + 1] != '?' or p[starIndex] != s[starIndex]:\n                    # return False\n                    return False\n            # return True\n            return True\n        \n        # return True\n        return True"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        # check if the majority element exists\n        count = 0\n        for num in nums:\n            if num == candidate:\n                count += 1\n        \n        if count > len(nums) // 2:\n            return candidate\n        else:\n            return None"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add the flights to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap with an empty list\n        # if the airport is in the hashmap, add the flight to the end of the list\n        \n        # create a hashmap to store the airports and their corresponding flights\n        # sort the flights in the hashmap by their destination\n        # iterate through the hashmap in lexical order and add"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        if len(nums) < 4:\n            return res\n        \n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            left = i + 1\n            right = len(nums) - 1\n            \n            # 2 sum\n            while left < right:\n                if nums[i] + nums[left] + nums[right] > target:\n                    right -= 1\n                elif nums[i] + nums[left] + nums[right] < target:\n                    left += 1\n                else:\n                    if nums[right] == nums[right-1]:\n                        right -= 1\n                    elif nums[left] == nums[left+1]:\n                        left += 1\n                    else:\n                        res.append([nums[i], nums[left], nums[right], nums[right-1]])\n                        right -= 1\n        \n        # 3 sum\n        for i in range(len(res)):\n            if i > 0 and res[i] == res[i-1]:\n                continue\n            \n            left = i + 1\n            right = len(res) - 1\n            \n            # 2 sum\n            while left < right:\n                if res[i] + res[left] + res[right] > target:\n                    right -= 1\n                elif res[i] + res[left] + res[right] < target:\n                    left += 1\n                else:\n                    if res[right] == res[right-1]:\n                        right -= 1\n                    elif res[left] == res[left+1]:\n                        left += 1\n                    else:\n                        res.append(res[i])\n                        right -= 1\n        \n        # 2 sum\n        res2 = []\n        for i in range(len(res)):\n            if i > 0 and res[i] == res[i-1]:\n                continue\n            \n            left = i + 1\n            right = len(res) - 1\n            \n            # 2 sum\n            while left < right:\n                if res[i] + res[left] + res[right] > target:\n                    right -= 1\n                elif res[i] + res[left] + res[right] < target:\n                    left += 1\n                else:\n                    if res[right] == res[right-1]:\n                        right -= 1\n                    elif res[left] == res[left+1]:\n                        left += 1\n                    else:\n                        res2.append([res[i], res[left], res[right]])\n                        right -= 1\n        \n        # 3 sum\n        for i in range(len(res2)):\n            if i > 0 and res2[i] == res2[i-1]:\n                continue\n            \n            left = i + 1\n            right = len(res2) - 1\n            \n            # 2 sum\n            while left < right:\n                if res2[i] + res2[left] + res2[right] > target:\n                    right -= 1\n                elif res2[i] + res2[left] + res2[right] < target:\n                    left += 1\n                else:\n                    if res2[right] == res2[right-1]:\n                        right -= 1\n                    elif res2[left] == res2[left+1]:\n                        left += 1\n                    else:\n                        res2.append(res2[i])\n                        right -= 1\n        \n        return res2"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left and height\n        # if left is the same, sort by right\n        # if right is the same, sort by height\n        # if left and right are the same, sort by height\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        # if left and right are the same, sort by left\n        # if left is the same, sort by right\n        # if right is the same, sort by left\n        #"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the list\n        s.reverse()\n        \n        # or we can use the built-in function reverse()\n        # s.reverse()"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        \n        # for i in range(1, len(triangle)):\n        #     triangle[i][0] += triangle[i-1][0]\n        #     for j in range(1, len(triangle[i])):\n        #         triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        \n        # return triangle[-1][-1]\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        \n        # for i in range(1, len(triangle)):\n        #     triangle[i][0] += triangle[i-1][0]\n        #     for j in range(1, len(triangle[i])):\n        #         triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        \n        # return triangle[-1][-1]\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        \n        # for i in range(1, len(triangle)):\n        #     triangle[i][0] += triangle[i-1][0]\n        #     for j in range(1, len(triangle[i])):\n        #         triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        \n        # return triangle[-1][-1]\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        \n        # for i in range(1, len(triangle)):\n        #     triangle[i][0] += triangle[i-1][0]\n        #     for j in range(1, len(triangle[i])):\n        #         triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        \n        # return triangle[-1][-1]\n        \n        if len(triangle) == 1:\n            return triangle[0][0]\n        \n        for i in range(1, len(triangle)):\n            triangle[i][0] += triangle[i-1][0]\n            for j in range(1, len(triangle[i])):\n                triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        \n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = {1:\"One\", 2:\"Two\", 3:\"Three\", 4:\"Four\", 5:\"Five\", 6:\"Six\", 7:\"Seven\", 8:\"Eight\", 9:\"Nine\"}\n        teens = {10:\"Ten\", 11:\"Eleven\", 12:\"Twelve\", 13:\"Thirteen\", 14:\"Fourteen\", 15:\"Fifteen\", 16:\"Sixteen\", 17:\"Seventeen\", 18:\"Eighteen\", 19:\"Nineteen\"}\n        tens = {20:\"Twenty\", 30:\"Thirty\", 40:\"Forty\", 50:\"Fifty\", 60:\"Sixty\", 70:\"Seventy\", 80:\"Eighty\", 90:\"Ninety\"}\n        thousands = {1000:\"Thousand\", 1000000:\"Million\", 1000000000:\"Billion\"}\n        \n        res = \"\"\n        \n        for k, v in thousands.items():\n            if num // k:\n                res += ones[num // k] + \" \" + v + \" \"\n                num %= k\n                \n        if num:\n            if num // 100:\n                res += ones[num // 100] + \" Hundred \"\n                num %= 100\n                \n            if num in teens:\n                res += teens[num]\n            elif num in tens:\n                res += tens[num]\n            elif num:\n                res += ones[num // 10] + \" \" + ones[num % 10]\n                \n        return res.strip() if res else \"Zero\""}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i][j] + dp[i-1][j-1] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k][j-1] if i > j <= k\n        # dp[i][j] = dp[i][j] - dp[i-k][j] if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k][j] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k][j] if i > j <= k\n        # dp[i][j] = dp[i][j] - dp[i-k][j] if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k][j] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k][j] if i > j <= k\n        # dp[i][j] = dp[i][j] - dp[i-k] if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i > j <= k\n        # dp[i][j] = dp[i][j] - 1 if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i > j <= k\n        # dp[i][j] = dp[i][j] - 1 if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i > j <= k\n        # dp[i][j] = dp[i][j] - 2 if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i > j <= k\n        # dp[i][j] = dp[i][j] - 2 if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i > j <= k\n        # dp[i][j] = dp[i][j] - 2 if i > k\n        \n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i <= j <= k\n        # dp[i][j] = dp[i][j] + dp[i][j-1] - dp[i-k] if i > j <= k\n        # dp[i][j] = dp[i][j] - 2 if i > k"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # curr is the node before the node to be swapped\n        curr = dummy\n        \n        # while curr.next and curr.next.next:\n        while curr.next and curr.next.next:\n            # temp is the node to be swapped\n            temp = curr.next\n            # next is the node to be swapped\n            next = curr.next.next\n            \n            # curr.next = next.next\n            # temp.next = next\n            # curr.next = temp\n            \n            # curr = next\n            curr.next = next.next\n            temp.next = next\n            next.next = curr\n            \n            curr = curr.next\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and targetSum == root.val:\n            return True\n        \n        if root.left:\n            return self.hasPathSum(root.left, targetSum - root.val)\n        \n        if root.right:\n            return self.hasPathSum(root.right, targetSum - root.val)\n        \n        return False"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # traverse the linked list\n        curr = head\n        \n        # traverse the linked list and add nodes to the appropriate dummy nodes\n        while curr:\n            if curr.val < x:\n                curr1.next = curr\n                curr1 = curr1.next\n            else:\n                curr2.next = curr\n                curr2 = curr2.next\n            curr = curr.next\n        \n        # connect the two dummy nodes\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        # return the new head of the linked list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with more than two parents\n        # 3. if there is a cycle, return the node with two parents\n        # 4. if there is no cycle, return the node with more than two parents\n        \n        # 1.\n        parent = {}\n        child = {}\n        two_parents = 0\n        more_than_two_parents = 0\n        \n        for u, v in edges:\n            if u in parent:\n                two_parents += 1\n            else:\n                parent[u] = 1\n            if v in child:\n                more_than_two_parents += 1\n            else:\n                child[v] = 1\n                \n        if two_parents == 2:\n            return [u, v]\n        \n        # 2.\n        if more_than_two_parents == 0:\n            return []\n        \n        # 3.\n        for u, v in edges:\n            if u in parent and child.get(v, 0):\n                return [u, v]\n        \n        # 4.\n        return [u, v]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        used = [False] * len(nums)\n        ## 2 pointers\n        prev = None\n        ## 2 pointers\n        prev2 = None\n        \n        for i in range(len(nums)):\n            ## if prev is same as curr, skip\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            ## if prev2 is same as curr, skip\n            if prev2 is not None and nums[i] == prev2:\n                continue\n            ## if prev is None, add to res\n            if prev is None:\n                res.append([nums[i]])\n            ## else add to prev\n            else:\n                prev.append(nums[i])\n            ## set prev2 to prev\n            prev2 = prev\n            ## set prev to curr\n            prev = prev[-1]\n            ## set used to True\n            used[i] = True\n            \n        ## if prev2 is None, add to res\n        if prev2 is None:\n            res.append([prev])\n        ## else add to prev2\n        else:\n            prev2.append(prev)\n        \n        ## create new res\n        new_res = []\n        ## for each num in res\n        for num in res:\n            ## create new res\n            new_res.append(list(num))\n            ## for each num in num\n            for num in num:\n                ## add num to new res\n                new_res[-1].append(num)\n        \n        return new_res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## XOR all the numbers in the list\n        ## The XOR operator is a binary operator that returns 1 if exactly one of its operands is 1.\n        ## If both operands are 0 or 1, the result is 0.\n        ## If one operand is 0 and the other is 1, the result is 1.\n        ## If one operand is 1 and the other is 0, the result is 1.\n        ## The XOR operator is commutative, so a ^ b == b ^ a.\n        ## The XOR operator is associative, so a ^ (b ^ c) == (a ^ b) ^ c.\n        ## The XOR operator is distributive over addition, so a ^ b == b ^ a ^ 0 and a ^ 0 == a ^ a ^ 0.\n        ## The XOR operator is distributive over multiplication, so a ^ b * c == a ^ b ^ c.\n        ## The XOR operator is distributive over bit-shift, so a ^ b << c == a ^ b ^ c.\n        ## The XOR operator is distributive over OR, so a ^ b | c == a ^ b ^ c.\n        ## The XOR operator is distributive over AND, so a ^ b & c == a ^ b ^ c.\n        ## The XOR operator is distributive over exclusive OR, so a ^ b ^ c | d == a ^ b ^ c ^ d.\n        ## The XOR operator is distributive over exclusive AND, so a & b ^ c | d == a & b ^ c ^ d.\n        ## The XOR operator is distributive over complement, so ~a ^ b == ~a & b or a ^ b & ~b.\n        ## The XOR operator is distributive over exclusive OR and complement, so a ^ b ^ c ^ d & e == a ^ b ^ c ^ d ^ e.\n        ## The XOR operator is distributive over exclusive AND and complement, so a & b ^ c ^ d & e == a & b ^ c ^ d & e.\n        ## The XOR operator is distributive over OR and complement, so a | b ^ c ^ d & e == a | b ^ c ^ d & e.\n        ## The XOR operator is distributive over AND and complement, so a & b ^ c ^ d & e == a & b ^ c ^ d & e.\n        ## The XOR operator is distributive over exclusive OR and AND, so a ^ b & c ^ d & e | f == a ^ b & c ^ d & e ^ f.\n        ## The XOR operator is distributive over exclusive AND and AND, so a & b ^ c & d & e ^ f == a & b ^ c & d & e ^ f.\n        ## The XOR operator is distributive over exclusive OR and OR, so a ^ b | c & d & e ^ f == a ^ b & c & d & e ^ f.\n        ## The XOR operator is distributive over exclusive AND and OR, so a & b ^ c & d & e ^ f == a & b ^ c & d & e ^ f.\n        ## The XOR operator is distributive over exclusive OR and AND and complement, so a ^ b ^ c & d & e ^ f | g == a ^ b ^ c & d & e ^ f ^ g.\n        ## The XOR operator is distributive over exclusive AND and AND and complement, so a & b ^ c & d & e ^ f ^ g == a & b ^ c & d & e ^ f ^ g.\n        ## The XOR operator is distributive over exclusive OR and OR and complement, so a ^ b | c & d & e ^ f ^ g == a ^ b & c & d & e ^ f ^ g.\n        ## The XOR operator is distributive over exclusive AND and OR and complement, so a & b ^ c & d & e ^ f ^ g == a & b ^ c & d & e ^ f ^ g.\n        ## The XOR operator is distributive over exclusive OR and AND and complement and exclusive OR, so a ^ b & c & d & e ^ f ^ g | h ^ i == a ^ b & c & d & e ^ f ^ g ^ h ^ i.\n        ## The XOR operator is distributive over exclusive AND and AND and complement and exclusive AND, so a & b ^ c & d & e ^ f ^ g | h & i == a & b ^ c & d & e ^ f ^ g"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## count = 0\n        ## for i in s[::-1]:\n        ##     if i == ' ':\n        ##         if count > 0:\n        ##             continue\n        ##         else:\n        ##             continue\n        ##     count += 1\n        ## return count\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        count = 0\n        for i in s[::-1]:\n            if i == ' ' and count > 0:\n                continue\n            elif i != ' ':\n                count += 1\n            else:\n                continue\n        return count"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][n-1] = 1\n        res = 0\n        \n        for r in range(n-2, -1, -1):\n            new_dp = dp[:]\n            for c1, c2 in zip(new_dp[r], new_dp[r+1]):\n                if grid[r+1] == 1 and c1 == 1:\n                    res += 1\n                c1, c2 = c1-1, c2\n                if c1 >= 0:\n                    new_dp[c1] += 1\n                if c2 >= 0:\n                    new_dp[c2] += 1\n            for c1, c2 in zip(dp[r], dp[r+1]):\n                if grid[r] == 1 and c1 == 1:\n                    res += 1\n                c1, c2 = c1-1, c2\n                if c1 >= 0:\n                    new_dp[c1] += 1\n                if c2 >= 0:\n                    new_dp[c2] += 1\n            dp = new_dp\n            \n        res += dp[0]\n        return res"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2^n is the number of possible combinations\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        \n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible combinations modulo 10^9 + 7\n        # 2^n % 10^9 + 7 is the number of possible"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        seen = set()\n        \n        while n not in seen:\n            seen.add(n)\n            n = sum(int(i)**2 for i in str(n))\n            if n == 1:\n                return True\n        return False"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        low = 0\n        high = len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return low"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = len(nums) - 1\n        # for i in range(last_pos, -1, -1):\n        #     if i + nums[i] >= last_pos:\n        #         last_pos = i\n        # return last_pos == 0\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i + nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >= len(nums) - 1:\n        #         return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # last_pos = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if last_pos < i:\n        #         return False\n        #     last_pos = max(last_pos, i)\n        #     if last_pos >="}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not grid:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        for i in range(1, m):\n            grid[i][0] += grid[i-1]\n        \n        for j in range(1, n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = '1'\n        for i in range(2, n+1):\n            curr = ''\n            count = 1\n            for j in range(1, len(prev)):\n                if prev[j] == prev[j-1]:\n                    count += 1\n                else:\n                    curr += str(count) + prev[j-1]\n                    count = 1\n            curr += str(count) + prev[-1]\n            prev = curr\n        return prev"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary Search\n        # Find the largest sum in nums\n        # If the largest sum is too large, then we can increase the largest sum\n        # If the largest sum is too small, then we can decrease the largest sum\n        # We can use binary search to find the largest sum\n        \n        # Initialize the left and right pointers\n        left, right = max(nums), sum(nums)\n        \n        # Binary Search\n        while left < right:\n            # Initialize the mid variable\n            mid = left + (right - left) // 2\n            # Initialize the count variable\n            count = 1\n            # Initialize the sum variable\n            currSum = 0\n            # Iterate through the nums array\n            for num in nums:\n                # If the current sum plus the current num is greater than the mid, then increase the count\n                if currSum + num > mid:\n                    # Increase the count\n                    count += 1\n                    # Set the currSum to the current num\n                    currSum = num\n                # Otherwise, set the currSum to the current sum plus the current num\n                else:\n                    currSum += num\n            # If the count is greater than k, then we can increase the largest sum\n            # If the count is less than k, then we can decrease the largest sum\n            if count > k:\n                # Set the left pointer to the mid + 1\n                left = mid + 1\n            # Otherwise, set the right pointer to the mid\n            else:\n                # Set the right pointer to the mid\n                right = mid\n        # Return the right pointer\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        low = 0\n        high = len(nums)-1\n        \n        while low <= high:\n            mid = (low + high)//2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[low] <= nums[mid]:\n                if nums[low] <= target < nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                if nums[mid] < target <= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}\n        \n        res = ['']\n        \n        for digit in digits:\n            res = [p + q for p in res for q in phone[digit]]\n        \n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # create a dictionary to store the frequency of each number\n        freq = {}\n        for num in candidates:\n            if num not in freq:\n                freq[num] = 1\n            else:\n                freq[num] += 1\n        \n        # create a list to store the combinations\n        combinations = []\n        \n        # iterate through the sorted candidates\n        for num in candidates:\n            # if the number is greater than the target, we can't make a combination\n            if num > target:\n                break\n            \n            # if the number is equal to the target, add it to the combinations\n            if num == target:\n                combinations.append([num])\n                \n            # if the number is not equal to the target, find the number of combinations that sum up to the target minus the number\n            # and add the number to each combination\n            if num < target:\n                count = target // num\n                for combination in combinations:\n                    if len(combination) == count:\n                        combinations.append(combination + [num])\n                    else:\n                        combinations.append(combination)\n        \n        # create a dictionary to store the frequency of each combination\n        freq_comb = {}\n        for combination in combinations:\n            if tuple(combination) not in freq_comb:\n                freq_comb[tuple(combination)] = 1\n            else:\n                freq_comb[tuple(combination)] += 1\n        \n        # create a list to store the unique combinations\n        unique_combinations = []\n        \n        # iterate through the sorted combinations\n        for combination in sorted(freq_comb):\n            # if the combination is greater than the target, we can't make a unique combination\n            if combination > target:\n                break\n            \n            # if the combination is equal to the target, add it to the unique combinations\n            if combination == target:\n                unique_combinations.append(combination)\n                \n            # if the combination is not equal to the target, find the number of unique combinations that sum up to the target minus the combination\n            # and add the combination to each unique combination\n            if combination < target:\n                count = target // combination\n                for unique_combination in unique_combinations:\n                    if len(unique_combination) == count:\n                        unique_combinations.append(unique_combination + [combination])\n                    else:\n                        unique_combinations.append(unique_combination)\n        \n        # create a dictionary to store the frequency of each unique combination\n        freq_unique_comb = {}\n        for unique_combination in unique_combinations:\n            if tuple(unique_combination) not in freq_unique_comb:\n                freq_unique_comb[tuple(unique_combination)] = 1\n            else:\n                freq_unique_comb[tuple(unique_combination)] += 1\n        \n        # create a list to store the unique combinations\n        unique_combinations = []\n        \n        # iterate through the sorted unique combinations\n        for unique_combination in sorted(freq_unique_comb):\n            # if the unique combination is greater than the target, we can't make a unique combination\n            if unique_combination > target:\n                break\n            \n            # if the unique combination is equal to the target, add it to the unique combinations\n            if unique_combination == target:\n                unique_combinations.append(unique_combination)\n                \n            # if the unique combination is not equal to the target, find the number of unique combinations that sum up to the target minus the unique combination\n            # and add the unique combination to each unique combination\n            if unique_combination < target:\n                count = target // unique_combination\n                for unique_combination in unique_combinations:\n                    if len(unique_combination) == count:\n                        unique_combinations.append(unique_combination + [unique_combination])\n                    else:\n                        unique_combinations.append(unique_combination)\n        \n        # create a list to store the combinations\n        combinations = []\n        \n        # iterate through the sorted unique combinations\n        for unique_combination in sorted(freq_unique_comb):\n            # if the unique combination is greater than the target, we can't make a combination\n            if unique_combination > target:\n                break"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # convert n to a list\n        nums = list(n)\n        \n        # if n is 0, return 1\n        if nums[0] == '0':\n            return '1'\n        \n        # if n is 9, return 8\n        if nums[-1] == '9':\n            return str(int(n[:-1])-1) if int(n[:-1]) > 0 else '9'\n        \n        # if n is odd, find the closest palindrome\n        if len(nums) % 2 == 1:\n            # find the closest palindrome\n            half = len(nums) // 2\n            left, right = nums[:half], nums[half+1:]\n            if right:\n                if right[-1] > nums[half]:\n                    right = sorted(right)[::-1]\n                    while right and right[-1] <= nums[half]:\n                        right.pop()\n                    if right:\n                        right[-1] = str(int(right[-1]) + 1)\n                        return ''.join(left + right)\n                else:\n                    right = sorted(right)[::-1]\n                    while right and right[-1] <= nums[half]:\n                        right.pop()\n                    if right:\n                        right[-1] = str(int(right[-1]) + 1)\n                        return ''.join(left + right)\n            else:\n                right = sorted(left)[::-1]\n                while right and right[-1] <= nums[half]:\n                    right.pop()\n                if right:\n                    right[-1] = str(int(right[-1]) + 1)\n                    return ''.join(left + right)\n            # if no closest palindrome, return the closest smaller palindrome\n            if left:\n                left = sorted(left)[::-1]\n                left[-1] = str(int(left[-1]) + 1)\n                return ''.join(left)\n            else:\n                return '0'\n        \n        # if n is even, find the closest palindrome\n        else:\n            # find the closest palindrome\n            half = len(nums) // 2\n            left, right = nums[:half], nums[half:]\n            if right:\n                if right[-1] > nums[half]:\n                    right = sorted(right)[::-1]\n                    while right and right[-1] <= nums[half]:\n                        right.pop()\n                    if right:\n                        right[-1] = str(int(right[-1]) + 1)\n                        return ''.join(left + right)\n                else:\n                    right = sorted(right)[::-1]\n                    while right and right[-1] <= nums[half]:\n                        right.pop()\n                    if right:\n                        right[-1] = str(int(right[-1]) + 1)\n                        return ''.join(left + right)\n            else:\n                right = sorted(left)[::-1]\n                while right and right[-1] <= nums[half]:\n                    right.pop()\n                if right:\n                    right[-1] = str(int(right[-1]) + 1)\n                    return ''.join(left + right)\n            # if no closest palindrome, return the closest smaller palindrome\n            if left:\n                left = sorted(left)[::-1]\n                left[-1] = str(int(left[-1]) + 1)\n                return ''.join(left)\n            else:\n                return '0'"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        top, bottom, left, right = 0, n-1, 0, n-1\n        num = 1\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x > 0:\n            rev = 0\n            while x:\n                rev = rev * 10 + x % 10\n                x = x // 10\n            if rev > 2**31 - 1:\n                return 0\n            else:\n                return rev\n        elif x < 0:\n            rev = -1 * abs(x)\n            rev = 0\n            while rev:\n                rev = rev * 10 + rev % 10\n                rev = rev // 10\n            if rev < -2**31:\n                return 0\n            else:\n                return -1 * rev\n        else:\n            return 0"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## transpose the matrix\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        ## reverse each row\n        for row in matrix:\n            row.reverse()\n        \n        ## swap the elements in each row\n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # initialize max_prod and min_prod with the first element\n        max_prod = nums[0]\n        min_prod = nums[0]\n        res = max_prod\n        \n        # iterate through the rest of the array\n        for i in range(1, len(nums)):\n            # if the current element is 0, set max_prod and min_prod to 0\n            if nums[i] == 0:\n                max_prod = 0\n                min_prod = 0\n            # otherwise, update max_prod and min_prod based on the current element\n            else:\n                # if the current element is positive, update max_prod and min_prod\n                if nums[i] > 0:\n                    max_prod = max(max_prod * nums[i], nums[i])\n                    min_prod = min_prod * nums[i]\n                # if the current element is negative, update max_prod and min_prod\n                else:\n                    temp = max_prod\n                    max_prod = max(min_prod * nums[i], nums[i])\n                    min_prod = temp * nums[i]\n            # update res with the maximum of max_prod and res\n            res = max(max_prod, res)\n        # return res\n        return res"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is 0, then we can't jump to it\n        if stones[-1] == 0:\n            return False\n        \n        # create a dictionary with the stone as the key and a set of possible jumps as the value\n        # we can jump to a stone if we can jump to the previous stone and the jump distance is 1, 2, or 3\n        # we can't jump to a stone if we can't jump to the previous stone\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 2\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 3\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 4\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 5\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 6\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 7\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 8\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 9\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 10\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 11\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 12\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 13\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 14\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 15\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 16\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 17\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 18\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 19\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 20\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 21\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 22\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 23\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 24\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 25\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 26\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 27\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 28\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 29\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 30\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 31\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance is 32\n        # we can't jump to a stone if we can't jump to the previous stone and the jump distance"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        # use a dictionary to store the score and its index\n        # iterate through the sorted score and assign the rank\n        # if the score is in the dictionary, then assign the rank\n        # else assign the rank as the index+1\n        \n        # Time Complexity: O(nlogn)\n        # Space Complexity: O(n)\n        \n        if not score:\n            return []\n        \n        sorted_score = sorted(score, reverse=True)\n        rank_dict = {}\n        \n        for i, score in enumerate(sorted_score):\n            if score not in rank_dict:\n                rank_dict[score] = i\n        \n        res = []\n        \n        for score in score:\n            if score in rank_dict:\n                if len(res) == 0:\n                    res.append(\"Gold Medal\")\n                elif len(res) == 1:\n                    res.append(\"Silver Medal\")\n                elif len(res) == 2:\n                    res.append(\"Bronze Medal\")\n                else:\n                    res.append(str(len(res)+1))\n            else:\n                res.append(str(len(rank_dict)+1))\n        \n        return res"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the last index of each character\n        # if the character is already in the dictionary, update the last index\n        # if the character is not in the dictionary, add it to the dictionary\n        # keep track of the max length\n        # keep track of the current length\n        # iterate through the string\n        # if the character is in the dictionary, update the max length if the current length is greater than the max length\n        # update the current length\n        # update the last index of the character\n        # return the max length\n        \n        if not s:\n            return 0\n        \n        last_index = {}\n        max_length = 0\n        current_length = 0\n        \n        for i, char in enumerate(s):\n            if char in last_index:\n                max_length = max(max_length, current_length)\n                current_length = i - last_index[char]\n            else:\n                current_length += 1\n            last_index[char] = i\n        max_length = max(max_length, current_length)\n        return max_length"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_dict = collections.Counter(words)\n        word_len = len(words[0])\n        word_count = len(word_dict)\n        res = []\n        \n        for i in range(word_len):\n            word_seen = collections.defaultdict(int)\n            left = right = 0\n            \n            for right in range(len(s)):\n                if right - left  == len(words) * word_len:\n                    if word_seen[s[right - word_len]] == word_count:\n                        del word_seen[s[right - word_len]]\n                    else:\n                        word_seen[s[right - word_len]] -= 1\n                if s[right] not in word_dict:\n                    left = right\n                    word_seen.clear()\n                else:\n                    word_seen[s[right]] += 1\n                    \n                if right - left + 1 == word_count:\n                    res.append(i)\n                    \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array and then count the number of chunks\n        # if the last element is the max, then we have a chunk\n        # otherwise, we have a chunk\n        arr.sort()\n        chunks = 0\n        max_num = 0\n        for i in arr:\n            if i > max_num:\n                max_num = i\n                chunks += 1\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        sorted_head = ListNode(0)\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            sorted_tail = sorted_head\n            \n            while sorted_tail.next and sorted_tail.next.val < curr.val:\n                sorted_tail = sorted_tail.next\n                \n            curr.next = sorted_tail.next\n            sorted_tail.next = curr\n            \n            curr = temp\n            \n        return sorted_head.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        \n        while head:\n            if head.next and head.val == head.next.val:\n                curr = head\n                while curr and curr.val == head.val:\n                    curr = curr.next\n                prev.next = curr\n                head = curr\n            else:\n                prev = head\n                head = head.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        for i, n in enumerate(nums):\n            # skip if we've already seen this number\n            if i > 0 and n == nums[i-1]:\n                continue\n            \n            # use two-sum to find the other two numbers\n            left, right = i+1, len(nums)-1\n            target = -n\n            \n            # skip if we've already seen this number\n            while left >= right:\n                if nums[left] + nums[right] > target:\n                    right -= 1\n                elif nums[left] + nums[right] < target:\n                    left += 1\n                else:\n                    # we've found the triplet\n                    if right == i+1 or nums[right] != nums[right-1]:\n                        res.append([n, nums[left], nums[right]])\n                    right -= 1\n                    left += 1\n        \n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # initialize a 2D array with the length of word1 + 1 and word2 + 1\n        # the first row and column will always be 0\n        # the first row will be the number of deletions\n        # the first column will be the number of insertions\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # iterate through the 2D array\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                # if the characters are the same, no deletion or insertion needed\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                # if the characters are different, we need to find the number of deletions or insertions\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # subtract the number of deletions from the number of insertions\n        # the number of insertions will be the number of operations needed\n        return len(word1) - dp[-1][-1] + len(word2) - dp[-1][-1]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor the two numbers and count the number of 1's\n        # then use the built-in function bin() to convert the number to binary\n        # then count the number of 1's in the binary representation\n        return bin(x ^ y).count('1')"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        paths = []\n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        if root.left:\n            for path in self.binaryTreePaths(root.left):\n                paths.append(str(root.val) + '->' + path)\n        if root.right:\n            for path in self.binaryTreePaths(root.right):\n                paths.append(str(root.val) + '->' + path)\n        \n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums = sorted(nums)\n        \n        # count the number of reverse pairs\n        ans = 0\n        cnt = 0\n        for i in nums[::-1]:\n            ans += cnt\n            if i > 2 * 2407602598:\n                ans -= 1\n                cnt += 1\n        return ans\n        \n        # use binary search to count the number of reverse pairs\n        # nums = sorted(nums)\n        # ans = 0\n        # for i in nums[::-1]:\n        #     ans += bisect_left(nums, 2 * i)\n        # return ans\n        \n        # use binary search to count the number of reverse pairs\n        # nums = sorted(nums)\n        # ans = 0\n        # cnt = 0\n        # for i in nums[::-1]:\n        #     ans += cnt\n        #     if i > 2500000027:\n        #         ans -= 1\n        #         cnt += 1\n        # return ans"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     return (ty - sy) % sx == 0\n        # return (tx - sx) % sy == 0\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     if (ty - sy) % sx == 0:\n        #         return (ty - sy) % sx == 0\n        #     else:\n        #         return False\n        # else:\n        #     if (tx - sx) % sy == 0:\n        #         return (tx - sx) % sy == 0\n        #     else:\n        #         return False\n        \n        if tx < sx or ty < sy:\n            return False\n        if sx == tx and sy == ty:\n            return True\n        if tx > ty:\n            if (ty - sy) % sx == 0:\n                return (ty - sy) % sx == 0\n            else:\n                return False\n        else:\n            if (tx - sx) % sy == 0:\n                return (tx - sx) % sy == 0\n            else:\n                return False\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     if (ty - sy) % sx == 0:\n        #         return (ty - sy) % sx == 0\n        #     else:\n        #         return False\n        # else:\n        #     if (tx - sx) % sy == 0:\n        #         return (tx - sx) % sy == 0\n        #     else:\n        #         return False\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     if (ty - sy) % sx == 0:\n        #         return (ty - sy) % sx == 0\n        #     else:\n        #         return False\n        # else:\n        #     if (tx - sx) % sy == 0:\n        #         return (tx - sx) % sy == 0\n        #     else:\n        #         return False\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     if (ty - sy) % sx == 0:\n        #         return (ty - sy) % sx == 0\n        #     else:\n        #         return False\n        # else:\n        #     if (tx - sx) % sy == 0:\n        #         return (tx - sx) % sy == 0\n        #     else:\n        #         return False\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     if (ty - sy) % sx == 0:\n        #         return (ty - sy) % sx == 0\n        #     else:\n        #         return False\n        # else:\n        #     if (tx - sx) % sy == 0:\n        #         return (tx - sx) % sy == 0\n        #     else:\n        #         return False\n        \n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy == ty:\n        #     return True\n        # if tx > ty:\n        #     if (ty - sy) % sx == 0:\n        #         return (ty - sy) % sx == 0\n        #     else:\n        #         return False\n        # else:\n        #     if (tx - sx) % sy == 0:\n        #         return (tx - sx) % sy == 0\n        #     else:\n        #         return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i,j in zip(v1,v2):\n            if i > j:\n                return 1\n            if i < j:\n                return -1\n        if len(v1) > len(v2):\n            for i in v2:\n                if i:\n                    return 1\n            return 0\n        if len(v1) < len(v2):\n            for i in v1:\n                if i:\n                    return -1\n            return 0\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] > buy:\n        #         profit += prices[i] - buy\n        #         buy = prices[i]\n        #     else:\n        #         buy = prices[i]\n        \n        # return profit\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] > buy:\n        #         profit += prices[i] - buy\n        #         buy = prices[i]\n        #     else:\n        #         buy = prices[i]\n        \n        # return profit\n        \n        if len(prices) < 2:\n            return 0\n        \n        profit = 0\n        buy = prices[0]\n        \n        for i in range(1, len(prices)):\n            if prices[i] > buy:\n                profit += prices[i] - buy\n                buy = prices[i]\n            else:\n                buy = prices[i]\n        \n        return profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end time\n        courses.sort(key=lambda x: x[1])\n        \n        # greedy: sort by duration\n        # if duration > end, remove the longest course\n        # if duration <= end, add the course to the end\n        # if duration == end, add the course to the end\n        # if duration > end, add the course to the end\n        # if duration == end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course\n        # if duration < end, add the course to the end\n        # if duration < end, remove the longest course"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    return dummy.next\n                kth = kth.next\n            if not kth:\n                return dummy.next\n            \n            # reverse the nodes in the k group\n            curr = prev.next\n            for i in range(k):\n                temp = curr.next\n                curr.next = prev.next\n                prev.next = curr\n                curr = temp\n            # update the pointers\n            temp = kth.next\n            kth.next = None\n            prev = kth\n            # update the head\n            head = temp\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(set(s)) != 0:\n        #     return False\n        \n        # return s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # for i in range(1, n // 2 + 1):\n        #     if n % i == 0 and s[:i] * (n // i) == s:\n        #         return True\n        # return False\n        \n        # if len(set(s)) == 1:\n        #     return False\n        \n        # return s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(set(s)) == 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set(s))) == 0 and s[1:] * 2 in s\n        \n        # if len(s) <= 1:\n        #     return False\n        \n        # n = len(s)\n        # return n % (len(set"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2*(2i-1)/(i+1)\n        # dp[0] = 1, dp[1] = 1\n        # dp[2] = 2, dp[3] = 5\n        # dp[4] = 5, dp[5] = 11\n        # dp[6] = 11, dp[7] = 26\n        # dp[8] = 26, dp[9] = 56\n        # dp[10] = 56, dp[11] = 126\n        # dp[12] = 126, dp[13] = 252\n        # dp[14] = 252, dp[15] = 524\n        # dp[16] = 524, dp[17] = 1058\n        # dp[18] = 1058, dp[19] = 2300\n        \n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j]*dp[i-j-1]\n            dp[i] *= 2\n            if i%2 == 1:\n                dp[i] //= 2\n        \n        return dp[-1]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers in the array\n        # 2. XOR all the numbers in the array with the same number\n        # 3. The number that does not have a pair will be the answer\n        \n        # 1\n        single = 0\n        for num in nums:\n            single ^= num\n        \n        # 2\n        # 3\n        # 4\n        # 5\n        # 6\n        # 7\n        # 8\n        # 9\n        # 10\n        # 11\n        # 12\n        # 13\n        # 14\n        # 15\n        # 16\n        # 17\n        # 18\n        # 19\n        # 20\n        # 21\n        # 22\n        # 23\n        # 24\n        # 25\n        # 26\n        # 27\n        # 28\n        # 29\n        # 30\n        # 31\n        # 32\n        # 33\n        # 34\n        # 35\n        # 36\n        # 37\n        # 38\n        # 39\n        # 40\n        # 41\n        # 42\n        # 43\n        # 44\n        # 45\n        # 46\n        # 47\n        # 48\n        # 49\n        # 50\n        # 51\n        # 52\n        # 53\n        # 54\n        # 55\n        # 56\n        # 57\n        # 58\n        # 59\n        # 60\n        # 61\n        # 62\n        # 63\n        # 64\n        # 65\n        # 66\n        # 67\n        # 68\n        # 69\n        # 70\n        # 71\n        # 72\n        # 73\n        # 74\n        # 75\n        # 76\n        # 77\n        # 78\n        # 79\n        # 80\n        # 81\n        # 82\n        # 83\n        # 84\n        # 85\n        # 86\n        # 87\n        # 88\n        # 89\n        # 90\n        # 91\n        # 92\n        # 93\n        # 94\n        # 95\n        # 96\n        # 97\n        # 98\n        # 99\n        # 100\n        # 101\n        # 102\n        # 103\n        # 104\n        # 105\n        # 106\n        # 107\n        # 108\n        # 109\n        # 110\n        # 111\n        # 112\n        # 113\n        # 114\n        # 115\n        # 116\n        # 117\n        # 118\n        # 119\n        # 120\n        # 121\n        # 122\n        # 123\n        # 124\n        # 125\n        # 126\n        # 127\n        # 128\n        # 129\n        # 130\n        # 131\n        # 132\n        # 133\n        # 134\n        # 135\n        # 136\n        # 137\n        # 138\n        # 139\n        # 140\n        # 141\n        # 142\n        # 143\n        # 144\n        # 145\n        # 146\n        # 147\n        # 148\n        # 149\n        # 150\n        # 151\n        #"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # count the frequency of each letter in target\n        # target_count = {letter: frequency}\n        target_count = collections.Counter(target)\n        \n        # sticker_freq = {frequency: list of stickers with that frequency}\n        sticker_freq = collections.defaultdict(list)\n        \n        # add stickers to sticker_freq\n        for sticker in stickers:\n            sticker_count = collections.Counter(sticker)\n            for letter in target_count:\n                sticker_freq[sticker_count[letter]].append(sticker)\n        \n        # dp[i] = min number of stickers needed to spell out target with i stickers\n        dp = collections.defaultdict(lambda: float('inf'))\n        dp[0] = 0\n        \n        # iterate through sticker_freq\n        for sticker_count, stickers in sticker_freq.items():\n            for sticker in stickers:\n                # for each sticker, update dp with the number of stickers needed to spell out target with i-1 stickers\n                for sticker_count_prev in set(dp) - {sticker_count}:\n                    dp[sticker_count_prev] = min(dp[sticker_count_prev], dp[sticker_count] + 1)\n                # update dp with the number of stickers needed to spell out target with i stickers\n                dp[sticker_count] = min(dp[sticker_count], dp[sticker_count_prev] + 1)\n        \n        # return the number of stickers needed to spell out target if it is possible, otherwise -1\n        return dp[target_count] if dp[target_count] < float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if string is empty, return 0\n        if not s:\n            return 0\n        \n        # initialize counter to 1\n        res = 1\n        \n        # iterate through string\n        for i in range(1, len(s)):\n            # if current character is same as previous, increment counter\n            if s[i] == s[i-1]:\n                res += 1\n            # otherwise, counter is the same as previous\n            else:\n                res = 1\n        \n        # return counter\n        return res"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        low = 1\n        high = x\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return high"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map roman numerals to their values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize result to 0\n        result = 0\n        \n        # iterate through the string in reverse order\n        for i in range(len(s)-1, -1, -1):\n            # if the current roman numeral is less than the next roman numeral, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add it to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## O(n) time and O(n) space\n        ## set is faster than dictionary\n        ## set is faster than sorting\n        ## set is faster than sorting and dictionary\n        ## set is faster than sorting and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary\n        ## set is faster than sorting and dictionary and dictionary and dictionary and dictionary and dictionary and dictionary and"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     if q and q[0] == i - k:\n        #         q.pop(0)\n        #     while q and nums[q[-1]] < n:\n        #         q.pop()\n        #     q.append(i)\n        #     if i >= k - 1:\n        #         res.append(nums[q[0]])\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     while q and q[-1][0] <= n:\n        #         q.pop()\n        #     q.append((n, i))\n        #     if i >= k - 1:\n        #         res.append(q[0][0])\n        #         if q[0][1] == i - k + 1:\n        #             q.pop(0)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     while q and q[-1][0] <= n:\n        #         q.pop()\n        #     q.append((n, i))\n        #     if i >= k - 1:\n        #         res.append(q[0][0])\n        #         if q[0][1] == i - k + 1:\n        #             q.pop(0)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     while q and q[-1][0] <= n:\n        #         q.pop()\n        #     q.append((n, i))\n        #     if i >= k - 1:\n        #         res.append(q[-1][0])\n        #         if q[-1][1] == i - k + 1:\n        #             q.pop()\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     while q and q[-1][0] <= n:\n        #         q.pop()\n        #     q.append((n, i))\n        #     if i >= k - 1:\n        #         if not q:\n        #             res.append(q[0][0])\n        #         elif q[0][1] == i - k + 1:\n        #             q.pop(0)\n        #         else:\n        #             res.append(q[-1][0])\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     while q and q[-1][0] <= n:\n        #         q.pop()\n        #     q.append((n, i))\n        #     if i >= k - 1:\n        #         if not q:\n        #             res.append(q[0][0])\n        #         elif q[0][1] == i - k + 1:\n        #             q.pop(0)\n        #         else:\n        #             res.append(q[-1][0])\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # res = []\n        # q = []\n        # for i, n in enumerate(nums):\n        #     while q and q[-1][0] <= n:\n        #         q.pop()\n        #     q.append((n, i))\n        #     if i >= k - 1:\n        #         if not q:\n        #             res.append(q[0][0])\n        #         else:\n        #             res.append(q[-1][0"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        \n        # if not nums2:\n        #     if len(nums1) % 2 == 1:\n        #         return nums1[len(nums1) // 2]\n        #     else:\n        #         return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0\n        \n        # left, right = 0, len(nums1)\n        \n        # while left <= right:\n        #     mid1 = (left + right) // 2\n        #     mid2 = (len(nums1) + len(nums2) + 1) // 2 - mid1\n        \n        #     if mid1 < len(nums1) and nums2[mid2 - 1] > nums1[mid1]:\n        #         left = mid1 + 1\n        #     elif mid1 > 0 and nums1[mid1 - 1] > nums2[mid2]:\n        #         right = mid1 - 1\n        #     else:\n        #         if len(nums1) % 2 == 1:\n        #             return nums1[mid1]\n        #         if mid1 == 0:\n        #             return (nums1[mid1] + nums2[mid2]) / 2.0\n        #         if mid2 == 0:\n        #             return nums1[mid1]\n        #         return (nums1[mid1] + nums2[mid2]) / 2.0\n        \n        # return 0.0\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        \n        if len(nums1) % 2 == 1:\n            return nums1[len(nums1) // 2]\n        else:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums)-1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     elif nums[mid] < nums[right]:\n        #         right = mid\n        # return nums[right]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums)-1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     elif nums[mid] < nums[right]:\n        #         right = mid\n        # return nums[right]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        res = [1]\n        \n        for i in range(1, rowIndex + 1):\n            res.append(res[i - 1] * (rowIndex - i) // i)\n            \n        return res"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if not root:\n        #     return []\n        \n        # res = []\n        # if not root.left and not root.right and root.val == targetSum:\n        #     return [[targetSum]]\n        \n        # if root.left:\n        #     for path in self.pathSum(root.left, targetSum - root.val):\n        #         res.append([root.val] + path)\n        \n        # if root.right:\n        #     for path in self.pathSum(root.right, targetSum - root.val):\n        #         res.append([root.val] + path)\n        \n        # if not res:\n        #     return []\n        \n        # return res\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return [[targetSum]]\n        \n        res = {}\n        if root.left:\n            for path in self.pathSum(root.left, targetSum - root.val):\n                if path not in res:\n                    res[path] = 0\n                res[path] += 1\n            res[tuple([root.val])] = 1 if not res else res[tuple([root.val])]\n        else:\n            if 0 not in res:\n                res[tuple([root.val])] = 1\n            else:\n                res[tuple([root.val])] = 0\n        \n        if root.right:\n            for path in self.pathSum(root.right, targetSum - root.val):\n                if path not in res:\n                    res[path] = 0\n                res[path] += 1\n        else:\n            if 0 not in res:\n                res[tuple([root.val])] = 1\n            else:\n                res[tuple([root.val])] = 0\n        \n        if not res:\n            return []\n        \n        ans = []\n        for path, count in res.items():\n            if count > 1:\n                ans.append([root.val] * count)\n            else:\n                ans.append([root.val])\n        \n        return ans"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the square root of area\n        # 2. find the largest number that can divide area\n        # 3. return the largest number and the number divided by the largest number\n        # 4. if area is perfect square, return [area, 1]\n        \n        sqrt = area ** 0.5\n        \n        if sqrt.is_integer():\n            return [int(sqrt), 1]\n        \n        largest = int(area ** 0.5)\n        \n        while area % largest:\n            largest -= 1\n        \n        return [area // largest, largest]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        graph = collections.defaultdict(set)\n        for word in wordSet:\n            for i in range(len(word)):\n                key = word[:i] + '*' + word[i+1:]\n                graph[key].add(word)\n        \n        # build a distance dict\n        dist = {beginWord: 0}\n        q = collections.deque([beginWord])\n        level = 1\n        # BFS\n        while q:\n            for _ in range(len(q)):\n                curr = q.popleft()\n                if curr == endWord:\n                    break\n                for key in graph[curr]:\n                    if key not in dist:\n                        q.append(key)\n                        dist[key] = dist[curr] + 1\n            level += 1\n        \n        # BFS again\n        if endWord not in dist:\n            return []\n        \n        # build ans\n        ans = [[endWord]] if endWord in dist else []\n        level = 2\n        while ans and dist[ans[-1][-1]]:\n            newAns = []\n            for word in ans:\n                for key in graph[word[-1]]:\n                    if level - dist[key] > 1:\n                        newAns.append(key)\n                        if key not in dist:\n                            q.append(key)\n                            dist[key] = level\n                    elif level - dist[key] == 1:\n                        newAns.append(key)\n            ans = newAns\n            level += 1\n        \n        return ans if endWord in dist else []"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return 1 + max(left, right)\n        \n        return height(root) != -1 # if height == -1, then it is not balanced"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        return n & (n - 1) == 0"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        \n        while i < len(nums):\n            j = len(res)\n            \n            while j and nums[i] == nums[j-1] and nums[j-1] == nums[j]:\n                j -= 1\n                \n            start = 0 if j == 0 else res[j-1]\n            \n            for subset in res[j:]:\n                res.append(subset[:] + [nums[i]])\n                \n            if j == 0:\n                res.append([nums[i]])\n                \n            i += 1\n            \n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Monotonic Stack\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # We will use a stack to store the index of the bars.\n        # If the current bar is higher than the bar at the top of the stack, we push it to the stack.\n        # If the current bar is lower than the bar at the top of the stack, we pop the top of the stack and calculate the area with the popped bar as the right boundary and the current bar as the left boundary.\n        # We repeat this process until we reach the end of the input or until the stack is empty.\n        # At the end, if the stack is not empty, we pop the remaining bars from the stack and calculate the area with a right boundary of \n        # the last popped bar set to the length of the input and a left boundary set to the empty stack.\n        # The area calculated is the largest rectangle in the histogram.\n        \n        # Initialize the stack with a pair of (-1, -1) indicating that there is no bar before the first bar.\n        # Initialize the area to be returned to 0.\n        # Iterate through the input heights.\n        # If the current bar is higher than the bar at the top of the stack, we push it to the stack.\n        # If the current bar is lower than the bar at the top of the stack, we pop the top of the stack and calculate the area with the popped bar as the right boundary and the current bar as the left boundary.\n        # We add the area calculated to the area to be returned.\n        # If the stack is not empty, we pop the remaining bars from the stack and calculate the area with a right boundary of \n        # the last popped bar set to the length of the input and a left boundary set to the empty stack.\n        # The area calculated is the largest rectangle in the histogram.\n        \n        # Initialize the stack with a pair of (-1, -1) indicating that there is no bar before the first bar.\n        # Initialize the area to be returned to 0.\n        # Iterate through the input heights.\n        # If the current bar is higher than the bar at the top of the stack, we push it to the stack.\n        # If the current bar is lower than the bar at the top of the stack, we pop the top of the stack and calculate the area with the popped bar as the right boundary and the current bar as the left boundary.\n        # We add the area calculated to the area to be returned.\n        # If the stack is not empty, we pop the remaining bars from the stack and calculate the area with a right boundary of \n        # the last popped bar set to the length of the input and a left boundary set to the empty stack.\n        # The area calculated is the largest rectangle in the histogram.\n        \n        # Initialize the stack with a pair of (-1, -1) indicating that there is no bar before the first bar.\n        # Initialize the area to be returned to 0.\n        # Iterate through the input heights.\n        # If the current bar is higher than the bar at the top of the stack, we push it to the stack.\n        # If the current bar is lower than the bar at the top of the stack, we pop the top of the stack and calculate the area with the popped bar as the right boundary and the current bar as the left boundary.\n        # We add the area calculated to the area to be returned.\n        # If the stack is not empty, we pop the remaining bars from the stack and calculate the area with a right boundary of \n        # the last popped bar set to the length of the input and a left boundary set to the empty stack.\n        # The area calculated is the largest rectangle in the histogram.\n        \n        # Initialize the stack with a pair of (-1, -1) indicating that there is no bar before the first bar.\n        # Initialize the area to be returned to 0.\n        # Iterate through the input heights.\n        # If the current bar is higher than the bar at the top of the stack, we push it to the stack.\n        # If the current bar is lower than the bar at the top of the stack, we pop the top of the stack and calculate the area with the popped bar as the right boundary and the current bar as the left boundary.\n        # We add the area calculated to the area to be returned.\n        # If the stack is not empty, we pop the remaining bars from the stack and calculate the area with a right boundary of"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        \n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        \n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_set = set()\n        y_set = set()\n        area = 0\n        left = float('inf')\n        right = -float('inf')\n        top = float('inf')\n        bottom = -float('inf')\n        \n        for x1, y1, x2, y2 in rectangles:\n            left = min(left, x1)\n            right = max(right, x2)\n            top = max(top, y2)\n            bottom = min(bottom, y1)\n            area += (x2 - x1) * (y2 - y1)\n            \n            if (x1, y1) in x_set or (x1, y2) in x_set or (x2, y1) in x_set or (x2, y2) in x_set:\n                x_set.remove((x1, y1))\n                x_set.remove((x1, y2))\n                x_set.remove((x2, y1))\n                x_set.remove((x2, y2))\n            else:\n                x_set.add((x1, y1))\n                x_set.add((x1, y2))\n                x_set.add((x2, y1))\n                x_set.add((x2, y2))\n                \n            if (y1, x1) in y_set or (y1, x2) in y_set or (y2, x1) in y_set or (y2, x2) in y_set:\n                y_set.remove((y1, x1))\n                y_set.remove((y1, x2))\n                y_set.remove((y2, x1))\n                y_set.remove((y2, x2))\n            else:\n                y_set.add((y1, x1))\n                y_set.add((y1, x2))\n                y_set.add((y2, x1))\n                y_set.add((y2, x2))\n                \n        if len(x_set) != 4 or len(y_set) != 4 or area != (right - left) * (top - bottom):\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = ''\n        while columnNumber > 0:\n            columnNumber, rem = divmod(columnNumber - 1, 26)\n            ans = chr(65 + rem) + ans\n        return ans"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maxSum and curSum with the first element\n        maxSum = curSum = nums[0]\n        \n        # Iterate through the list starting from the second element\n        for i in nums[1:]:\n            # If curSum is less than 0, set it to 0\n            if curSum < 0:\n                curSum = 0\n            # Add the current element to curSum\n            curSum += i\n            # Update maxSum if curSum is greater than maxSum\n            maxSum = max(maxSum, curSum)\n        # Return maxSum\n        return maxSum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with 5\n        # if board is solved, return 0\n        \n        # convert board to a 1D array\n        # 0 is the blank space\n        # 1-5 are the numbers\n        # swap 0 with"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and t[i] in t_to_s:\n                if s_to_t[s[i]] != t[i] or t_to_s[t[i]] != s[i]:\n                    return False\n            elif s[i] in s_to_t or t[i] in t_to_s:\n                return False\n            else:\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # if target is not in nums, return False\n        if target not in nums:\n            return False\n        \n        # if target is in nums, use binary search to find the index of target\n        left, right = 0, len(nums)-1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] > nums[right]: # nums[mid] is on the right side\n                if nums[mid] > target and nums[left] <= target: # target is on the right side\n                    right = mid - 1\n                else: # target is on the left side\n                    left = mid + 1\n            else: # nums[mid] is on the left side\n                if nums[mid] < target and nums[right] >= target: # target is on the left side\n                    left = mid + 1\n                else: # target is on the right side\n                    right = mid - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        \n        dp = [0] * n\n        dp[0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j > 0:\n                    dp[j] += dp[j-1]\n                    \n        for j in range(n-1, -1, -1):\n            if dp[j] == 0 and obstacleGrid[m-1][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] = dp[j-1]\n                \n        return dp[n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        one, two = 1, 1\n        \n        for i in range(1, len(s)):\n            curr, prev = int(s[i]), one\n            \n            if curr == '0':\n                if s[i-1] == '0':\n                    return 0\n                one = two\n            elif curr > '6' or (curr == '2' and s[i-1] == '0'):\n                one = two\n            else:\n                two, one = one, one + two\n                \n        return one"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = float('inf')\n        closestSum = float('inf')\n        \n        for i in range(len(nums)-2):\n            left = i+1\n            right = len(nums)-1\n            \n            while left < right:\n                currSum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - closestSum) > abs(target - currSum):\n                    closestSum = currSum\n                    \n                if currSum > target:\n                    right -= 1\n                else:\n                    left += 1\n                    \n                if closestSum == target:\n                    return closestSum\n                    \n            if closest == float('inf'):\n                closest = nums[i] + nums[i+1] + nums[i+2]\n            elif abs(target - closest) > abs(target - closestSum):\n                closest = nums[i] + nums[i+1] + nums[i+2]\n                \n        return closestSum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.maxDepth(root.left)\n        right_height = self.maxDepth(root.right)\n        \n        return 1 + max(left_height, right_height)"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1_dict = {}\n        for num in nums1:\n            if num not in nums1_dict:\n                nums1_dict[num] = 1\n            else:\n                nums1_dict[num] += 1\n        \n        res = []\n        for num in nums2:\n            if num in nums1_dict and nums1_dict[num] > 0:\n                res.append(num)\n                nums1_dict[num] -= 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        prev = None\n        ans = float('inf')\n        curr = root\n        \n        while curr:\n            if curr.left:\n                # find the inorder predecessor\n                pred = curr.left\n                while pred.right and pred.right != curr:\n                    pred = pred.right\n                \n                if pred.right:\n                    # update the answer\n                    ans = min(ans, curr.val - prev)\n                    \n                # update the predecessor\n                pred.right = curr\n                \n                # move to the right child\n                curr = curr.left\n            else:\n                # update the answer\n                if prev:\n                    ans = min(ans, curr.val - prev)\n                \n                # move to the right child\n                prev = curr\n                curr = curr.right\n        \n        return ans"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        # find the frequency of each node\n        # use a dictionary to store the frequency\n        # use a variable to store the max frequency\n        # use a list to store the modes\n        # iterate through the dictionary\n        # if the frequency is equal to the max frequency, add the node to the list\n        # if the frequency is greater than the max frequency, reset the max frequency and add the node to the list\n        # return the list\n        \n        freq = {}\n        max_freq = 0\n        modes = []\n        \n        def inorder(root):\n            if root:\n                if root.left:\n                    inorder(root.left)\n                if root.val in freq:\n                    freq[root.val] += 1\n                else:\n                    freq[root.val] = 1\n                if freq[root.val] > max_freq:\n                    max_freq = freq[root.val]\n                    modes = [root.val]\n                elif freq[root.val] == max_freq:\n                    modes.append(root.val)\n                if root.right:\n                    inorder(root.right)\n        \n        inorder(root)\n        return modes if max_freq > 1 else modes or [root.val]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle not in haystack:\n            return -1\n        \n        return haystack.find(needle)"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Count the number of lower, upper, and digit\n        low, up, digit = 0, 0, 0\n        for c in password:\n            if c.islower():\n                low += 1\n            elif c.isupper():\n                up += 1\n            else:\n                digit += 1\n        \n        # 2. Count the number of repeating characters\n        prev_rep = 0\n        rep = 0\n        prev_char = ''\n        for c in password:\n            if c == prev_char:\n                rep += 1\n            else:\n                if rep >= 3:\n                    prev_rep = rep\n                    rep = 1\n                else:\n                    rep = 0\n                prev_char = c\n        \n        if rep >= 3:\n            prev_rep = rep\n            rep = 1\n        else:\n            rep = 0\n        \n        # 3. Count the number of extra characters\n        extra = 0\n        if len(password) < 6:\n            extra = 6 - len(password)\n        elif len(password) > 20:\n            extra = len(password) - 20\n        \n        # 4. Count the number of steps\n        step = 0\n        if low == 0 and up == 0 and digit == 0:\n            step = 1\n        elif low == 0 and up == 0 and digit != 0:\n            step = 3\n        elif low == 0 and up != 0 and digit == 0:\n            step = 2\n        elif low != 0 and up == 0 and digit == 0:\n            step = 2\n        elif low != 0 and up != 0 and digit == 0:\n            step = 1\n        else:\n            step = 0\n        \n        # 5. Update the number of steps\n        step += extra\n        step += prev_rep\n        step += rep\n        \n        if step > 2:\n            step = 2\n        \n        return step"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2 is the only prime factor that has a 5 in it's prime factorization\n        # 2^2 = 4, 2^3 = 8, 2^4 = 16, 2^5 = 32, 2^6 = 64, 2^7 = 128, 2^8 = 256, 2^9 = 512, 2^10 = 1024\n        # 2^2 * 2^3 = 2^5 = 32, 2^2 * 2^4 = 2^6 = 64, 2^3 * 2^2 = 2^7 = 128, 2^3 * 2^4 = 2^8 = 512, 2^3 * 2^6 = 2^9 = 1024\n        # 2^2 * 2^3 * 2^4 = 2^6 = 64, 2^2 * 2^3 * 2^5 = 2^7 = 128, 2^3 * 2^4 * 2^2 = 2^8 = 512, 2^3 * 2^4 * 2^6 = 2^9 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 = 2^8 = 512, 2^3 * 2^4 * 2^5 * 2^2 = 2^9 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 = 2^9 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 = 2^10 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 = 2^11 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 = 2^12 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 = 2^13 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 * 2^2 = 2^14 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 * 2^11 = 2^15 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 * 2^11 * 2^3 = 2^16 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 * 2^11 * 2^4 = 2^17 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 * 2^11 * 2^5 = 2^18 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 * 2^10 * 2^11 * 2^6 = 2^19 = 1024\n        # 2^2 * 2^3 * 2^4 * 2^5 * 2^6 * 2^7 * 2^8 * 2^9 *"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        idx = 0\n        down = True\n        \n        for c in s:\n            if idx == numRows:\n                idx -= 2\n                down = False\n            if idx < 0:\n                down = True\n                idx += 2\n            res[idx] += c\n            if down:\n                idx += 1\n            else:\n                idx -= 1\n                \n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height)-1\n        left_max, right_max = 0, 0\n        res = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n                left += 1\n            else:\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n                right -= 1\n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## use the array as a hash table\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array again and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array again and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1) space\n        ## use the array as a set\n        ## iterate through the array and mark the index of each number as negative\n        ## iterate through the array and add all the positive numbers to the result\n        \n        ## O(n) time and O(1)"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # sort the nums in descending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order\n        # use a dict to store the nums and their index\n        # use a list to store the nums in ascending order\n        # use a set to store the nums in ascending order"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key = lambda x: (x[1], -x[0]))\n        ans = two = 0\n        \n        # sort by end, then by start\n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then sort by start\n        \n        # if end is same, then sort by end\n        # if end is same, then"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        \n        if not left and not right:\n            return True\n        \n        if not left or not right:\n            return False\n        \n        if left.val != right.val:\n            return False\n        \n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # count the number of each element\n        # use a dict to store the count of each element\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        # use a dict to store the count of each element in the order of the element name\n        #"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # if not root:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # Recursive solution\n        if not root:\n            return []\n        res = []\n        res.append(root.val)\n        if root.left:\n            res += self.preorderTraversal(root.left)\n        if root.right:\n            res += self.preorderTraversal(root.right)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n <= 0:\n        #     return False\n        # while n % 4 == 0:\n        #     n = n // 4\n        # return n == 1\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x55555555 != 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x555555555 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5a5a5a5a == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5c5c5c5c == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5d5d5d5d == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5f5f5f5f == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff5 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffffb == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffffd == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff7 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff9 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff11 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff13 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff17 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff19 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff1f == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff3 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff7 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff9 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffffb == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) == 0 and n & 0x5fffffff5 == 0\n        \n        # if n <= 0:\n        #     return False\n        # return n & (n - 1) =="}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap left and right child\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the left and right child\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        # return root\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        res = []\n        left = right = 0\n        \n        # dp[i] represents the number of valid parentheses ending with the ith parenthesis\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(n):\n            left = right = 0\n            # valid parentheses ending with the ith parenthesis\n            for j in range(i, -1, -1):\n                if '(' == parens[j]:\n                    left += 1\n                else:\n                    if left > 0:\n                        right += 1\n                    else:\n                        # ')' can only be added if there is a valid '('\n                        continue\n                \n            # valid parentheses ending with the ith parenthesis\n            dp[left] += dp[right]\n            # '(' can only be added if there is a valid ')'\n            if left > 0:\n                dp[left] += 1\n        \n        # all valid parentheses\n        ans = []\n        for i in dp:\n            ans.append('(') if i > 0 else ans.append(')')\n            # ')' can only be added if there is a valid '('\n            if i > 1:\n                ans.append(')')\n        \n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the number of patches needed and the current number of elements in nums\n        patches, curr = 0, 0\n        \n        # Initialize the upper bound to 1\n        upper = 1\n        \n        # Iterate over the numbers in nums\n        for num in nums:\n            \n            # If the current number is greater than the upper bound, add one patch and update the upper bound\n            if num > upper:\n                patches += 1\n                upper += upper\n            \n            # If the current number is less than the upper bound, update the upper bound to the current number plus the upper bound\n            else:\n                upper += num\n                \n            # If the current number plus the upper bound is greater than the upper bound, add one patch and update the upper bound\n            if upper > n:\n                patches += 1\n                upper = num + upper\n                \n        # If the upper bound is still greater than the upper bound, add the remaining numbers in nums to the upper bound\n        if upper > n:\n            patches += len(nums)\n            \n        # Return the number of patches needed\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) < 2:\n        #     return 0\n        \n        # stack = []\n        # max_len = 0\n        # last_index = -1\n        \n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         stack.append(i)\n        #     else:\n        #         if stack:\n        #             max_len = max(max_len, i - stack[-1])\n        #         else:\n        #             last_index = i\n        #             stack.append(i)\n        \n        # if not stack:\n        #     return len(s)\n        \n        # max_len = max_len if max_len else len(s)\n        \n        # stack = []\n        # max_len = 0\n        \n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         stack.append(i)\n        #     else:\n        #         if stack:\n        #             max_len = max(max_len, i - stack[-1])\n        #             stack.pop()\n        \n        # if stack:\n        #     max_len = max_len if max_len else len(s)\n        \n        # return max_len\n        \n        # if len(s) < 2:\n        #     return 0\n        \n        # left = 0\n        # right = 0\n        # last_index = -1\n        \n        # for i in s:\n        #     if i == '(':\n        #         left += 1\n        #         right = 0\n        #     else:\n        #         if left > 0:\n        #             left -= 1\n        #             right += 1\n        #         else:\n        #             right = 0\n        #             last_index = i\n        # if last_index == -1:\n        #     return left\n        \n        # left = 0\n        # right = 0\n        \n        # for i in reversed(s):\n        #     if i == ')':\n        #         right += 1\n        #         right = 0\n        #     else:\n        #         if right > 0:\n        #             right -= 1\n        #             right += 1\n        #         else:\n        #             right = 0\n        #             left += 1\n        \n        # if right == 0:\n        #     return left\n        \n        # left = 0\n        # right = 0\n        \n        # for i in reversed(s):\n        #     if i == '(':\n        #         left += 1\n        #         right = 0\n        #     else:\n        #         if left > 0:\n        #             left -= 1\n        #             right += 1\n        #         else:\n        #             right = 0\n        #             right += 1\n        \n        # return right\n        \n        if len(s) < 2:\n            return 0\n        \n        left = 0\n        right = 0\n        last_index = -1\n        \n        for i in s:\n            if i == '(':\n                left += 1\n                right = 0\n            else:\n                if left > 0:\n                    left -= 1\n                    right += 1\n                else:\n                    right = 0\n                    last_index = i\n            if right > right and last_index != -1:\n                right = 0\n                left += 1\n        \n        if last_index == -1:\n            return left\n        \n        left = 0\n        right = 0\n        \n        for i in reversed(s):\n            if i == ')':\n                right += 1\n                right = 0\n            else:\n                if right > 0:\n                    right -= 1\n                    right += 1\n                else:\n                    right = 0\n                    left += 1\n        \n        return right"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        res = ''\n        if (numerator > 0) ^ (denominator > 0):\n            res += '-'\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        res += str(numerator // denominator)\n        \n        numerator %= denominator\n        if numerator == 0:\n            return res\n        \n        res += '.'\n        seen = {}\n        res += ''.join('(' if numerator in seen else '')\n        seen[numerator] = len(res)\n        numerator *= 10\n        \n        while numerator:\n            res += str(numerator // denominator)\n            numerator %= denominator\n            if numerator in seen:\n                res = res[:seen[numerator]] + '(' + res[seen[numerator]:] + ')'\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Find the middle of the linked list\n        ## 2. Split the linked list into two halves\n        ## 3. Recursively sort the two halves\n        ## 4. Merge the two sorted halves\n        \n        ## Solution 2: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Count the number of nodes in the linked list\n        ## 2. Find the middle of the linked list\n        ## 3. Split the linked list into two halves\n        ## 4. Recursively sort the two halves\n        ## 5. Merge the two sorted halves\n        ## 6. If the number of nodes is odd, set the middle node to the next node\n        ## 7. Return the sorted linked list\n        \n        ## Solution 3: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Count the number of nodes in the linked list\n        ## 2. Find the middle of the linked list\n        ## 3. Split the linked list into two halves\n        ## 4. Recursively sort the two halves\n        ## 5. Merge the two sorted halves\n        ## 6. If the number of nodes is odd, set the middle node to the next node\n        ## 7. Return the sorted linked list\n        \n        ## Solution 4: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Count the number of nodes in the linked list\n        ## 2. Find the middle of the linked list\n        ## 3. Split the linked list into two halves\n        ## 4. Recursively sort the two halves\n        ## 5. Merge the two sorted halves\n        ## 6. If the number of nodes is odd, set the middle node to the next node\n        ## 7. Return the sorted linked list\n        \n        ## Solution 5: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Count the number of nodes in the linked list\n        ## 2. Find the middle of the linked list\n        ## 3. Split the linked list into two halves\n        ## 4. Recursively sort the two halves\n        ## 5. Merge the two sorted halves\n        ## 6. If the number of nodes is odd, set the middle node to the next node\n        ## 7. Return the sorted linked list\n        \n        ## Solution 6: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Count the number of nodes in the linked list\n        ## 2. Find the middle of the linked list\n        ## 3. Split the linked list into two halves\n        ## 4. Recursively sort the two halves\n        ## 5. Merge the two sorted halves\n        ## 6. If the number of nodes is odd, set the middle node to the next node\n        ## 7. Return the sorted linked list\n        \n        ## Solution 7: Merge Sort\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Approach: Merge Sort\n        ## 1. Count the number of nodes in the linked list\n        ## 2. Find the middle of the linked list\n        ## 3. Split the linked list into two halves\n        ## 4. Rec"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key = lambda x: (x[0], -x[1]))\n        \n        # longest increasing subsequence\n        nums = []\n        \n        for _, height in envelopes:\n            if not nums or nums[-1] < height:\n                nums.append(height)\n            else:\n                left, right = 0, len(nums)\n                \n                while left < right:\n                    mid = (left + right) // 2\n                    \n                    if nums[mid] < height:\n                        left = mid + 1\n                    else:\n                        right = mid\n                \n                nums[left] = height\n                \n        return len(nums)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m) space\n        ## row and col are set to 0 if theres a 0 in the matrix\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        ## if theres a 0 in the matrix, set the first row and col to 0\n        \n        ## O(1) space\n        ## if theres a 0 in the first row, set the first row to 0\n        ## if theres a 0 in the first col, set the first col to 0\n        #"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # set slow and fast pointers\n        slow = dummy\n        fast = head\n        \n        # move fast pointer n steps ahead\n        for i in range(n):\n            fast = fast.next\n        \n        # move slow and fast pointers until fast pointer reaches the end\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # if the node to be removed is the head, return the next node\n        if slow == dummy:\n            return head.next\n        \n        # remove the node\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # use set to store the unique elements in nums1\n        # use set to store the unique elements in nums2\n        # use set to store the intersection\n        # return the intersection\n        \n        nums1_set = set(nums1)\n        nums2_set = set(nums2)\n        \n        if len(nums1_set) > len(nums2_set):\n            return self.intersection(nums2_set, nums1_set)\n        \n        intersection = set()\n        \n        for num in nums1_set:\n            if num in nums2_set:\n                intersection.add(num)\n        \n        return list(intersection)"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # nSum, nMax, ans = sum(machines), 0, 0\n        # for i in sorted(machines):\n        #     nSum, nMax = nSum + i, nMax + i - nSum\n        # for i in nMax:\n        #     ans = max(ans, i)\n        #     ans = max(ans, nSum - i)\n        # return ans\n        \n        nSum, nMax, ans = sum(machines), 0, 0\n        for i in sorted(machines):\n            nSum, nMax = nSum + i, nMax + i - nSum\n            ans = max(ans, nMax)\n        if nSum % 2 != 0:\n            return -1\n        nSum = nSum // 2\n        for i in nMax:\n            ans = max(ans, i)\n            ans = max(ans, nSum - i)\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # if k == 1:\n        #     return 1\n        \n        # count = 0\n        # curr = 1\n        # row = 1\n        # col = n\n        \n        # while curr <= k:\n        #     if col == n:\n        #         row += 1\n        #         curr = row\n        #     elif row == m:\n        #         col += 1\n        #         curr = curr + 1\n        #     else:\n        #         if row + 1 < m:\n        #             row += 1\n        #             curr += 1\n        #         else:\n        #             col += 1\n        #             curr += 1\n        # count = row\n        \n        # return count\n        \n        # if k == 1:\n        #     return m * n\n        \n        # count = 1\n        # row = 1\n        # col = n\n        \n        # while count < k:\n        #     if col == n:\n        #         row += 1\n        #         col = m\n        #     elif row == m:\n        #         col += 1\n        #         row = 1\n        #     else:\n        #         if row + 1 < m and col + 1 < n:\n        #             row += 1\n        #             col += 1\n        #         elif row + 1 < m:\n        #             row += 1\n        #         else:\n        #             col += 1\n        #     count += 1\n        \n        # return row\n        \n        # if k == 1:\n        #     return m * n\n        \n        # count = 1\n        # row = 1\n        # col = n\n        \n        # while count < k:\n        #     if col == n:\n        #         row += 1\n        #         col = m\n        #     elif row == m:\n        #         col += 1\n        #         row = 1\n        #     else:\n        #         if row + 1 < m and col + 1 < n:\n        #             row += 1\n        #             col += 1\n        #         elif row + 1 < m:\n        #             row += 1\n        #         else:\n        #             col += 1\n        #     count += 1\n        \n        # return row\n        \n        # if k == 1:\n        #     return m * n\n        \n        # count = 1\n        # row = 1\n        # col = n\n        \n        # while count < k:\n        #     if col == n:\n        #         row += 1\n        #         col = m\n        #     elif row == m:\n        #         col += 1\n        #         row = 1\n        #     else:\n        #         if row + 1 < m and col + 1 < n:\n        #             row += 1\n        #             col += 1\n        #         elif row + 1 < m:\n        #             row += 1\n        #         else:\n        #             col += 1\n        #     count += 1\n        \n        # return row\n        \n        # if k == 1:\n        #     return m * n\n        \n        # count = 1\n        # row = 1\n        # col = n\n        \n        # while count < k:\n        #     if col == n:\n        #         row += 1\n        #         col = m\n        #     elif row == m:\n        #         col += 1\n        #         row = 1\n        #     else:\n        #         if row + 1 < m and col + 1 < n:\n        #             row += 1\n        #             col += 1\n        #         elif row + 1 < m:\n        #             row += 1\n        #         else:\n        #             col += 1\n        #     count += 1\n        \n        # return row\n        \n        # if k == 1:\n        #     return m * n\n        \n        # count = 1\n        # row = 1\n        # col = n\n        \n        # while count < k:\n        #     if col == n:\n        #         row += 1\n        #         col = m\n        #     elif row == m:\n        #         col += 1\n        #         row = 1\n        #     else:\n        #         if row + 1 < m and col + 1 < n:\n        #             row += 1\n        #             col += 1\n        #         elif row + 1 < m:\n        #             row += 1"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle of the linked list\n        # use slow and fast pointers\n        slow = fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into two parts\n        # left and right\n        # left is the left subtree\n        # right is the right subtree\n        # prev is the new head of the right subtree\n        # slow is the new head of the left subtree\n        prev.next = None\n        \n        # create the BST\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1 or (list2 and list1.val > list2.val):\n            list1, list2 = list2, list1\n        \n        curr = list1\n        \n        while list1 and list2:\n            if list1.val > list2.val:\n                list1, list2 = list2, list1\n            curr.next = list1\n            list1 = list1.next\n            curr = curr.next\n        \n        if list2:\n            curr.next = list2\n        \n        return curr"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        # initialize the heights list\n        heights = [0] * (len(matrix[0]) + 1)\n        # initialize the result\n        result = 0\n        \n        # iterate through the matrix\n        for row in matrix:\n            # iterate through the row\n            for i, val in enumerate(row):\n                # if the current value is 1, add 1 to the heights list\n                if val == '1':\n                    heights[i] += 1\n                # otherwise, set the value to 0\n                else:\n                    heights[i] = 0\n            # call the helper function to find the largest rectangle in the current row\n            result = max(result, self.largestRectangleArea(heights))\n            # reset the heights list\n            heights = [0] * (len(heights))\n        \n        # return the result\n        return result\n    \n    def largestRectangleArea(self, heights):\n        # initialize the stack\n        stack = []\n        # add 0 to the stack\n        heights.append(0)\n        # iterate through the heights list\n        for i, val in enumerate(heights):\n            # if the stack is empty or the current value is greater than the top of the stack, append the index to the stack\n            if not stack or val > heights[stack[-1]]:\n                stack.append(i)\n            # otherwise, pop the stack until the top of the stack is greater than or equal to the current value\n            else:\n                # pop the stack and add the index to the result\n                while stack and heights[stack[-1]] >= val:\n                    result = heights[stack.pop()] * (i - stack[-1] - 1)\n                # append the index to the stack\n                stack.append(i)\n        # return the result\n        return sum(result for _, result in enumerate(stack))"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the nums\n        nums.sort()\n        \n        # create a list to store the subsets\n        subsets = [[]]\n        \n        # iterate through nums\n        for num in nums:\n            # create a new list to store the subsets\n            newSubsets = []\n            # iterate through the existing subsets\n            for subset in subsets:\n                # add the new subset to the new list\n                newSubset = subset + [num]\n                # add the new subset to the list\n                newSubsets.append(newSubset)\n            # add the new subsets to the list\n            subsets.extend(newSubsets)\n            # add the new subset to the list\n            subsets.append(newSubset)\n        \n        # return the sorted subsets\n        return sorted(subsets)"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums)-1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     elif nums[mid] < nums[right]:\n        #         right = mid\n        # return nums[right]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums)-1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     elif nums[mid] < nums[right]:\n        #         right = mid\n        # return nums[right]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[right]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        # 2. check if there is e\n        # 3. check if there is + or -\n        # 4. check if there is a dot\n        # 5. check if there is a digit\n        # 6. check if there is a digit\n        \n        s = s.strip()\n        if 'e' in s or 'E' in s:\n            nums, exp = s.split('e')\n            if '+' in nums or '-' in nums:\n                nums = nums.replace('+', '').replace('-', '')\n            if '.' in nums:\n                nums, exp = nums.split('.')\n            if exp == '':\n                return False\n            if exp == '' or nums == '' or nums.isdigit() == False:\n                return False\n            if exp[0] == '+' or exp[0] == '-':\n                exp = exp[1:]\n            if exp == '' or exp.isdigit() == False:\n                return False\n        elif s == '':\n            return False\n        else:\n            if s[0] == '+' or s[0] == '-':\n                s = s[1:]\n            if s == '' or s.isdigit() == False:\n                return False\n        if s == '' or s.isdigit() == False:\n            return False\n        return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # create a dictionary with the roman numerals and their values\n        roman_dict = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}\n        \n        # create a string to store the roman numeral\n        roman_numeral = ''\n        \n        # iterate through the dictionary and add the roman numerals to the string\n        for key in sorted(roman_dict.keys(), reverse = True):\n            while num >= key:\n                roman_numeral += roman_dict[key]\n                num -= key\n        return roman_numeral"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## XOR\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## XOR all the characters in s and t\n        ## Then XOR the two values\n        \n        ## a ^ a = 0\n        ## a ^ 0 = a\n        \n        ## a ^ b ^ a = b\n        \n        ## a ^ b ^ a ^ b = a\n        \n        ## a ^ 0 ^ b ^ a ^ b = b\n        \n        ## a ^ b ^ 0 ^ a ^ b = a\n        \n        ## a ^ b ^ b ^ a ^ a = b\n        \n        ## a ^ b ^ b ^ a ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ a ^ a = 0\n        \n        ## a ^ b ^ 0 ^ b ^ a ^ a = 0\n        \n        ## a ^ b ^ b ^ 0 ^ a ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ a ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ b ^ a ^ b = 0\n        \n        ## a ^ b ^ 0 ^ b ^ b ^ a ^ a = 0\n        \n        ## a ^ b ^ b ^ 0 ^ b ^ a ^ b = 0\n        \n        ## a ^ b ^ b ^ b ^ 0 ^ a ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ a ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ b ^ 0 ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ 0 ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ 0 ^ b ^ b = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ 0 ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ b ^ 0 ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ 0 ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ 0 ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ 0 ^ b = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ b ^ 0 ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ 0 ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ 0 ^ b ^ b = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ 0 ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ b ^ 0 ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ 0 ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ 0 ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ 0 ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ a = 0\n        \n        ## a ^ b ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ 0 ^ b ^ b ^ b ^ b ^ b = 0\n        \n        ## a ^ b ^ 0 ^ b ^ b"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # create a set for each row, col, and 3x3 box\n        rowSet = [set() for _ in range(9)]\n        colSet = [set() for _ in range(9)]\n        boxSet = [set() for _ in range(9)]\n        \n        # populate the sets with the values in the board\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    num = int(board[i][j])\n                    rowSet[i].add(num)\n                    colSet[j].add(num)\n                    boxSet[i//3*3 + j//3].add(num)\n        \n        # iterate through the board and check if the number is valid\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    candidates = set(range(1, 10)) - rowSet[i] - colSet[j] - boxSet[i//3*3 + j//3]\n                    if len(candidates) == 1:\n                        board[i][j] = str(candidates.pop())\n                    else:\n                        return False\n        \n        # recursively solve the remaining board\n        return True if self.solve(board, rowSet, colSet, boxSet) else board\n    \n    def solve(self, board, rowSet, colSet, boxSet):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    candidates = set(range(1, 10)) - rowSet[i] - colSet[j] - boxSet[i//3*3 + j//3]\n                    if len(candidates) == 1:\n                        board[i][j] = str(candidates.pop())\n                        rowSet[i].add(candidates.pop())\n                        colSet[j].add(candidates.pop())\n                        boxSet[i//3*3 + j//3].add(candidates.pop())\n                        if not self.solve(board, rowSet, colSet, boxSet):\n                            board[i][j] = '.'\n                            rowSet[i].remove(candidates.pop())\n                            colSet[j].remove(candidates.pop())\n                            boxSet[i//3*3 + j//3].remove(candidates.pop())\n                        else:\n                            return True\n                else:\n                    num = int(board[i][j])\n                    rowSet[i].add(num)\n                    colSet[j].add(num)\n                    boxSet[i//3*3 + j//3].add(num)\n        return True"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first and second node where the inorder traversal is not in ascending order\n        # swap the values of the two nodes\n        # inorder traversal is in ascending order\n        \n        # inorder traversal\n        prev, first, second = None, None, None\n        curr = root\n        \n        while curr:\n            if curr.left:\n                prev = curr.left\n                # find the first node where the inorder traversal is not in ascending order\n                if prev.val > curr.val:\n                    if not first:\n                        first = prev\n                    second = curr\n                # inorder traversal is in ascending order\n                curr = curr.left\n            else:\n                # inorder traversal\n                if prev and prev.val > curr.val:\n                    if not first:\n                        first = prev\n                    second = curr\n                # inorder traversal is in ascending order\n                curr = curr.right\n                \n        # swap the values of the two nodes\n        first.val, second.val = second.val, first.val\n        \n        # inorder traversal is in ascending order\n        return root"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        # reverse the second half of the linked list\n        # compare the first half and the second half\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            slow, prev, slow.next = slow.next, slow, prev\n        \n        # compare the first half and the second half\n        left, right = head, prev\n        while right:\n            if left.val != right.val:\n                return False\n            left, right = left.next, right.next\n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        low = 0\n        high = num\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        ans = [0]\n        \n        for i in range(1, n+1):\n            ans.append(ans[-1] + (i & 1))\n        \n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # if head.val == val:\n        #     head = head.next\n        #     return head\n        \n        # curr = head\n        # while curr and curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return head\n        \n        # prev = dummy\n        # curr = head\n        # while curr:\n        #     if curr.val == val:\n        #         prev.next = curr.next\n        #     else:\n        #         prev = curr\n        #         prev_prev = prev\n        #     curr = curr.next\n        # return prev_prev.next if prev_prev else None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        dp = {}\n        \n        for i in range(len(s1)):\n            for j in range(i, len(s1)):\n                if (s1[j], s1[i]) not in dp:\n                    dp[(s1[j], s1[i])] = 1\n                else:\n                    dp[(s1[j], s1[i])] += 1\n        \n        for i in range(len(s1)):\n            for j in range(len(s1)-1, i, -1):\n                if (s2[j], s2[i]) not in dp:\n                    dp[(s2[j], s2[i])] = 1\n                else:\n                    dp[(s2[j], s2[i])] += 1\n        \n        for k, v in dp.items():\n            if v > 1:\n                return False\n        \n        if len(s1) == 1:\n            return True\n        \n        dp = {}\n        \n        for i in range(len(s1)):\n            for j in range(i, len(s1)):\n                if (s1[j], s1[i]) not in dp:\n                    dp[(s1[j], s1[i])] = 1\n                else:\n                    dp[(s1[j], s1[i])] += 1\n        \n        for i in range(len(s1)):\n            for j in range(len(s1)-1, i, -1):\n                if (s2[j], s2[i]) not in dp:\n                    dp[(s2[j], s2[i])] = 1\n                else:\n                    dp[(s2[j], s2[i])] += 1\n        \n        for k, v in dp.items():\n            if v > 1:\n                return False\n        \n        if len(s1) == 1:\n            return True\n        \n        for i in range(1, len(s1)):\n            if (s1[:i], s1[i:]) not in dp and (s1[len(s1)-i:], s1[:len(s1)-i]) not in dp:\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of directories\n        path = path.split('/')\n        \n        # create a stack to store the directories\n        stack = []\n        \n        # iterate through the list of directories\n        for directory in path:\n            # if the directory is '..', remove the last directory in the stack if it is not empty\n            if directory == '..':\n                if stack:\n                    stack.pop()\n            # if the directory is not '..', add it to the stack\n            elif directory and directory != '.':\n                stack.append(directory)\n        \n        # join the stack with a '/' and return the result\n        return '/' + '/'.join(stack) if stack else '/'"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            curr = trie\n            for char in word:\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n            curr['#'] = True\n        \n        R, C = len(board), len(board[0])\n        res, seen = set(), set()\n        \n        # build trie from words\n        for word in words:\n            curr = trie\n            for char in word:\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n            curr['#'] = True\n        \n        # search for words in each direction\n        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        for r in range(R):\n            for c in range(C):\n                curr = trie\n                for dr, dc in DIRS:\n                    if board[r][c] in curr:\n                        curr = curr[board[r][c]]\n                        if '#' in curr:\n                            res.add(word)\n                            seen.add(word)\n        \n        # search for words in each of the 4 directions\n        for r, c in itertools.product(range(R), range(C)):\n            curr = trie\n            if board[r][c] in curr:\n                curr = curr[board[r][c]]\n                if '#' in curr:\n                    res.add(seen.pop())\n        \n        return sorted(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        # if sorted(s) == sorted(t):\n        #     return True\n        \n        # return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # count = {}\n        \n        # for char in s:\n        #     if char not in count:\n        #         count[char] = 0\n        #     count[char] += 1\n        \n        # for char in t:\n        #     if char not in count or count[char] == 0:\n        #         return False\n        #     count[char] -= 1\n        \n        # for char in count:\n        #     if count[char] != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # count = {}\n        \n        # for char in s:\n        #     if char not in count:\n        #         count[char] = 0\n        #     count[char] += 1\n        \n        # for char in t:\n        #     if char not in count or count[char] == 0:\n        #         return False\n        #     count[char] -= 1\n        \n        # for char in count:\n        #     if count[char] != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # count = {}\n        \n        # for char in s:\n        #     count[char] = count.get(char, 0) + 1\n        \n        # for char in t:\n        #     if char not in count or count[char] == 0:\n        #         return False\n        #     count[char] -= 1\n        \n        # for char in count:\n        #     if count[char] != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # count = {}\n        \n        # for char in set(s):\n        #     count[char] = count.get(char, 0) + 1\n        \n        # for char in t:\n        #     if char not in count or count[char] == 0:\n        #         return False\n        #     count[char] -= 1\n        \n        # for char in count:\n        #     if count[char] != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # count = {}\n        \n        # for char in set(s):\n        #     count[ord(char)] = count.get(ord(char), 0) + 1\n        \n        # for char in t:\n        #     if char not in count or count[char] == 0:\n        #         return False\n        #     count[ord(char)] -= 1\n        \n        # for char in count:\n        #     if count[char] != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # counter = [0] * 26\n        \n        # for char in s:\n        #     counter[ord(char) - ord('a')] += 1\n        \n        # for char in t:\n        #     counter[ord(char) - ord('a')] -= 1\n        \n        # for char in counter:\n        #     if char != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # counter = [0] * 128\n        \n        # for char in s:\n        #     counter[ord(char)] += 1\n        \n        # for char in t:\n        #     counter[ord(char)] -= 1\n        \n        # for char in counter:\n        #     if char != 0:\n        #         return False\n        \n        # return True\n        \n        # if len(s"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the number of each row, col, and 3x3 box\n        # 2. iterate through the board and check if the number is already in the dictionary\n        # 3. if it is, add 1 to the corresponding counter in the dictionary\n        # 4. if it is not, add it to the dictionary with a counter of 1\n        # 5. if the counter is 2, return False\n        # 6. if the counter is 3, return False\n        # 7. if the counter is 1, return True\n        \n        rowDict = {}\n        colDict = {}\n        boxDict = {}\n        \n        for i in range(9):\n            rowDict = {}\n            colDict = {}\n            boxDict = {}\n            for j in range(9):\n                if board[i][j] in rowDict:\n                    rowDict[board[i][j]] += 1\n                else:\n                    rowDict[board[i][j]] = 1\n                if board[j][i] in colDict:\n                    colDict[board[j][i]] += 1\n                else:\n                    colDict[board[j][i]] = 1\n                boxNum = (i // 3) * 3 + j // 3\n                if boxNum in boxDict:\n                    boxDict[boxNum] += 1\n                else:\n                    boxDict[boxNum] = 1\n                if boxDict[boxNum] == 2:\n                    return False\n                if boxDict[boxNum] == 3:\n                    return False\n                if boxDict[boxNum] == 1:\n                    return True\n            for k in rowDict:\n                if rowDict[k] == 2:\n                    return False\n                if rowDict[k] == 3:\n                    return False\n                if rowDict[k] == 1:\n                    return True\n            for l in colDict:\n                if colDict[l] == 2:\n                    return False\n                if colDict[l] == 3:\n                    return False\n                if colDict[l] == 1:\n                    return True\n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        \n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n                \n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split()\n        \n        # reverse each word\n        s = ' '.join(s[::-1])\n        \n        # return the reversed string\n        return s"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in columnTitle:\n            res = res * 26 + (ord(i) - ord('A'))\n        return res + 1 if columnTitle else 0"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        total = candies[-1]\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = candies[i+1] + 1\n            total += candies[i]\n        \n        return total"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = head\n        fast = head\n        \n        # if the list has odd number of nodes, move fast pointer to the second node\n        if not head or not head.next:\n            return head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        second = slow.next\n        slow.next = None\n        # reverse the second half of the linked list\n        prev = None\n        curr = second\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the first and second half of the linked list\n        first = head\n        \n        while second:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        # return the head of the reordered linked list\n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(pattern) != len(set(pattern)):\n            return False\n        \n        d = {}\n        s = s.split()\n        \n        if len(s) != len(pattern):\n            return False\n        \n        for i, j in zip(pattern, s):\n            if i not in d:\n                if j in d.values():\n                    return False\n                d[i] = j\n            elif d[i] != j:\n                return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return [nums]\n        \n        # res = []\n        # for i in range(len(nums)):\n        #     new_nums = nums[:]\n        #     new_nums.pop(i)\n        #     for p in self.permute(new_nums):\n        #         res.append([nums[i]] + p)\n        # return res\n        \n        res = []\n        if len(nums) == 1:\n            return [nums]\n        \n        seen = set()\n        for num in nums:\n            if num not in seen:\n                res.append([num])\n                seen.add(num)\n            else:\n                res[-1].append(num)\n        \n        res2 = []\n        for p in res:\n            res2.append(p[::-1])\n        \n        return res + res2"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # start from the bottom left corner\n        # if target is less than the current element, then it is not in the current row\n        # if target is greater than the current element, then it is in the next row\n        \n        # if target is less than the first element in the first row, then it is not in the matrix\n        # if target is greater than the first element in the first row, then it is in the second row\n        \n        # if target is less than the first element in the last row, then it is not in the matrix\n        # if target is greater than the first element in the last row, then it is in the second to last row\n        \n        # if target is less than the first element in the first column, then it is not in the matrix\n        # if target is greater than the first element in the first column, then it is in the second column\n        \n        # if target is less than the first element in the last column, then it is not in the matrix\n        # if target is greater than the first element in the last column, then it is in the second to last column\n        \n        if not matrix or not matrix[0] or target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        # start from the bottom left corner\n        row = len(matrix) - 1\n        col = 0\n        \n        while row >= 0 and col < len(matrix[0]):\n            if target < matrix[row][col]:\n                row -= 1\n            elif target > matrix[row][col]:\n                col += 1\n            else:\n                return True\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        dummy = ListNode()\n        # Initialize a pointer to the new linked list\n        curr = dummy\n        # Initialize a variable to keep track of the carry over\n        carry = 0\n        \n        # Iterate over the two linked lists\n        while l1 or l2 or carry:\n            # If both linked lists are empty, set the value of the new node to 0\n            if not l1 and not l2:\n                curr.next = ListNode(0)\n            # If only one linked list is empty, set the value of the new node to the value of the non-empty linked list\n            elif not l1:\n                curr.next = ListNode(l2.val + carry)\n                l2 = l2.next\n            # If only one linked list is empty, set the value of the new node to the value of the non-empty linked list\n            elif not l2:\n                curr.next = ListNode(l1.val + carry)\n                l1 = l1.next\n            # Otherwise, add the values of the two linked lists and the carry over to the new node\n            else:\n                curr.next = ListNode((l1.val + l2.val + carry) % 10)\n                carry = (l1.val + l2.val + carry) // 10\n                l1 = l1.next\n                l2 = l2.next\n            # Move the pointer to the next node\n            curr = curr.next\n        # Return the new linked list\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. get the binary representation of num\n        # 2. flip the bits\n        # 3. get the complement\n        \n        # 1\n        binary_num = bin(num)[2:]\n        # 2\n        complement_binary_num = ''.join('1' if bit == '0' else '0' for bit in binary_num)\n        # 3\n        complement_num = int(complement_binary_num, 2)\n        \n        return complement_num"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        prev = 0\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-2] == nums[i-1] - nums[i- 2]:\n                prev += 1\n                count += prev\n            else:\n                prev = 0\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res, curr, currLen = [], [], 0\n        \n        for word in words:\n            if currLen + len(word) + len(curr) > maxWidth:\n                if len(curr) == 1:\n                    res.append(curr[0] + ' ' * (maxWidth - currLen))\n                else:\n                    numSpaces, extraSpaces = (maxWidth - currLen) // (len(curr) - 1), (maxWidth - currLen) % (len(curr) - 1)\n                    res.append(''.join(curr[i] + ' ' * numSpaces + ' ' if i < len(curr) - 1 else curr[i] + ' ' * extraSpaces))\n                curr, currLen = [], 0\n            curr.append(word)\n            currLen += len(word)\n        \n        if curr:\n            if len(curr) == 1:\n                res.append(curr[0] + ' ' * (maxWidth - currLen))\n            else:\n                numSpaces, extraSpaces = (maxWidth - currLen) // (len(curr) - 1), (maxWidth - currLen) % (len(curr) - 1)\n                res.append(''.join(curr[i] + ' ' * numSpaces + ' ' if i < len(curr) - 1 else curr[i] + ' ' * extraSpaces))\n        \n        return [' '.join(res[i] + ' ' * (maxWidth - len(res[i])) for i in range(len(res))] if res else ['']"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # if not root:\n        #     return []\n        # stack, res = [], []\n        # while True:\n        #     while root:\n        #         if root.right:\n        #             stack.append(root.right)\n        #         if root.left:\n        #             root = root.left\n        #         else:\n        #             if not stack:\n        #                 break\n        #             root = stack.pop()\n        #             res.append(root.val)\n        #             root = None\n        #     if not stack:\n        #         break\n        #     root = stack.pop()\n        #     res.append(root.val)\n        #     root = None\n        # return res\n        \n        # Recursive solution\n        res = []\n        if not root:\n            return res\n        if root.left:\n            res += self.postorderTraversal(root.left)\n        if root.right:\n            res += self.postorderTraversal(root.right)\n        res.append(root.val)\n        return res"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, (right - left) * min(height[left], height[right]))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the words by length\n        words.sort(key=len)\n        \n        # create a set to store the words\n        wordSet = set(words)\n        \n        # create a dictionary to store the words that have been concatenated\n        # if a word is concatenated, we can use the first word to check if it is in the dictionary\n        # if it is, we can use the second word to check if it is in the dictionary\n        # if it is not, we can use the word to check if it is in the dictionary\n        wordDict = {}\n        \n        # create a list to store the concatenated words\n        res = []\n        \n        # iterate through the words\n        for word in words:\n            # if the word is in the dictionary, we can use it to check if it is concatenated\n            # if it is, we can use it to check if it is concatenated\n            # if it is not, we can use it to check if it is concatenated\n            if word in wordDict:\n                res.append(word)\n            # if the word is not in the dictionary, we can use it to check if it is concatenated\n            # if it is, we can use it to check if it is concatenated\n            # if it is not, we can use it to check if it is concatenated\n            else:\n                # create a variable to store the number of 2 words that are concatenated\n                found = 2\n                # iterate through the word\n                for i in range(1, len(word)):\n                    # if the first word is in the dictionary, we can use it to check if it is concatenated\n                    # if it is, we can use it to check if it is concatenated\n                    # if it is not, we can use it to check if it is concatenated\n                    if word[:i] in wordDict and word[i:] in wordDict:\n                        found = 1\n                    # if the first word is not in the dictionary, we can use it to check if it is concatenated\n                    # if it is, we can use it to check if it is concatenated\n                    # if it is not, we can use it to check if it is concatenated\n                    elif word[:i] in wordDict:\n                        found = 2\n                    # if the first word is not in the dictionary, we can use it to check if it is concatenated\n                    # if it is, we can use it to check if it is concatenated\n                    # if it is not, we can use it to check if it is concatenated\n                    elif word[i:] in wordDict:\n                        found = 2\n                # if the number of 2 words that are concatenated is 1, we can use the word to check if it is concatenated\n                if found == 1:\n                    res.append(word)\n                # if the number of 2 words that are concatenated is 2, we can use the word to check if it is concatenated\n                if found == 2:\n                    wordDict[word] = 1\n        \n        # return the concatenated words\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = -num\n        \n        res = ''\n        \n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res if res else '0' if num == 0 else '-' + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n is a multiple of 4, then we can't win\n        return n % 4 != 0\n        \n        \n# Time Complexity: O(1)\n# Space Complexity: O(1)"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D array to store the state of the board\n        # 2. 1D array to store the column state\n        # 3. 1D array to store the diagonal state\n        # 4. 1D array to store the anti-diagonal state\n        \n        # 1\n        board = [[0] * n for _ in range(n)]\n        # 2\n        col = [0] * n\n        # 3\n        d1 = [0] * (2 * n)\n        # 4\n        d2 = [0] * (2 * n)\n        \n        res = 0\n        \n        for row in range(n):\n            for col in range(n):\n                if board[row][col] == 1 or col in col or row + col in d1 or row - col in d2:\n                    continue\n                res += 1\n                board[row][col] = 1\n                col[col] = 1\n                d1[row + col] = 1\n                d2[row - col] = 1\n        \n        return res"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        ## 1. create a 2D matrix of size n x n with all elements as '.'\n        ## 2. create a 2D matrix of size n x 2 with all elements as 0\n        ## 3. create a 2D matrix of size n x 2 with all elements as 0\n        ## 4. create a set to store the column indices of the queens\n        ## 5. create a set to store the row indices of the queens\n        ## 6. create a set to store the diagonal indices of the queens\n        ## 7. create a set to store the anti-diagonal indices of the queens\n        ## 8. iterate over the rows\n        ## 9. iterate over the columns\n        ## 10. if the current cell is a 'Q' and the current row, column, diagonal, anti-diagonal indices are not in the set, add the cell to the solution\n        ## 11. if the current cell is a 'Q' and the current row, column, diagonal, anti-diagonal indices are in the set, add the cell to the solution\n        ## 12. if the current cell is not a 'Q' and the current row, column, diagonal, anti-diagonal indices are not in the set, add the cell to the solution\n        ## 13. if the current cell is not a 'Q' and the current row, column, diagonal, anti-diagonal indices are in the set, add the cell to the solution\n        ## 14. return the solution\n        \n        board = [['.'] * n for _ in range(n)]\n        cols, rows, dg, adg = set(), set(), set(), set()\n        \n        for row in range(n):\n            for col in range(n):\n                if board[row][col] == 'Q':\n                    if row in rows or col in cols or row + col in dg or row - col in adg:\n                        return []\n                    board[row][col] = 'Q'\n                    rows.add(row)\n                    cols.add(col)\n                    dg.add(row + col)\n                    adg.add(row - col)\n        \n        res = []\n        self.backtrack(board, 0, cols, rows, dg, adg, res)\n        return res\n        \n    def backtrack(self, board, row, cols, rows, dg, adg, res):\n        if row == len(board):\n            res.append([''.join(row) for row in board])\n            return\n        \n        for col in range(len(board)):\n            if col in cols or row + col in dg or row - col in adg or board[row][col] == 'Q':\n                continue\n            board[row][col] = 'Q'\n            cols.add(col)\n            rows.add(row)\n            dg.add(row + col)\n            adg.add(row - col)\n            self.backtrack(board, row + 1, cols, rows, dg, adg, res)\n            board[row][col] = '.'\n            cols.remove(col)\n            rows.remove(row)\n            dg.remove(row + col)\n            adg.remove(row - col)"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not word:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and self.dfs(board, i, j, visited, word[1:]):\n                    return True\n        \n        return False\n        \n    def dfs(self, board, i, j, visited, word):\n        if not word:\n            return True\n        \n        m, n = len(board), len(board[0])\n        \n        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in visited:\n            return False\n        \n        visited.add(board[i][j])\n        \n        res = self.dfs(board, i+1, j, visited, word) or \\\n            self.dfs(board, i-1, j, visited, word) or \\\n            self.dfs(board, i, j+1, visited, word) or \\\n            self.dfs(board, i, j-1, visited, word)\n        \n        visited.remove(board[i][j])\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m + n:\n        #         nums1[m] = i\n        #         m += 1\n        \n        # m = 0\n        # for i in nums2:\n        #     nums1[m] = i\n        #     m += 1\n        \n        # nums1.sort()\n        \n        # m, n = 0, 0\n        # for i in sorted(nums1 + nums2):\n        #     if m < m"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # set the three largest numbers to be the first three numbers\n        # if the third largest number is larger than the first two, replace the third largest number with the third largest number\n        # if the third largest number is larger than the first number, replace the third largest number with the first number\n        # if the third largest number is larger than the second number, replace the third largest number with the second number\n        # if the third largest number is larger than the third number, return the third largest number\n        # if the third largest number is not larger than the first two, return the first number\n        \n        # set the three largest numbers to be the first three numbers\n        first_three = set(nums[:3])\n        \n        # if the third largest number is larger than the first two, replace the third largest number with the third largest number\n        if nums[2] in first_three:\n            first_three.remove(nums[2])\n            first_three.add(nums[2])\n        # if the third largest number is larger than the first number, replace the third largest number with the first number\n        elif nums[0] > nums[2]:\n            first_three.remove(nums[0])\n            first_three.add(nums[0])\n        # if the third largest number is larger than the second number, replace the third largest number with the second number\n        elif nums[1] > nums[2]:\n            first_three.remove(nums[1])\n            first_three.add(nums[1])\n        # if the third largest number is larger than the third number, return the third largest number\n        elif nums[2] > nums[0] and nums[2] > nums[1]:\n            return nums[2]\n        # if the third largest number is not larger than the first two, return the first number\n        else:\n            return nums[0]\n        \n        # if the third largest number is larger than the first two, replace the third largest number with the third largest number\n        if nums[2] in first_three:\n            first_three.remove(nums[2])\n            first_three.add(nums[2])\n        # if the third largest number is larger than the first number, replace the third largest number with the first number\n        elif nums[0] > nums[2]:\n            first_three.remove(nums[0])\n            first_three.add(nums[0])\n        # if the third largest number is larger than the second number, replace the third largest number with the second number\n        elif nums[1] > nums[2]:\n            first_three.remove(nums[1])\n            first_three.add(nums[1])\n        # if the third largest number is larger than the third number, return the third largest number\n        elif nums[2] > nums[0] and nums[2] > nums[1]:\n            return nums[2]\n        # if the third largest number is not larger than the first two, return the first number\n        else:\n            return nums[0]\n        \n        # if the third largest number is larger than the first two, replace the third largest number with the third largest number\n        if nums[2] in first_three:\n            first_three.remove(nums[2])\n            first_three.add(nums[2])\n        # if the third largest number is larger than the first number, replace the third largest number with the first number\n        elif nums[0] > nums[2]:\n            first_three.remove(nums[0])\n            first_three.add(nums[0])\n        # if the third largest number is larger than the second number, replace the third largest number with the second number\n        elif nums[1] > nums[2]:\n            first_three.remove(nums[1])\n            first_three.add(nums[1])\n        # if the third largest number is larger than the third number, return the third largest number\n        elif nums[2] > nums[0] and nums[2] > nums[1]:\n            return nums[2]\n        # if the third largest number is not larger than the first two, return the first number\n        else:\n            return nums[0]\n        \n        # if the third largest number is larger than the first two, replace the third largest number with the third largest number"}]}