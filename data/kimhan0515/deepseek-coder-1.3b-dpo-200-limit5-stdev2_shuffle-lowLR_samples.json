{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert all negative numbers to positive numbers\n        # 2. convert all numbers to their corresponding index\n        # 3. iterate through the array and check if the number at that index is positive\n        # 4. if the number at that index is positive, convert it to negative\n        # 5. if the number at that index is negative, convert it to positive\n        # 6. iterate through the array again and find the first positive number\n        # 7. return the index + 1\n        \n        # 1. convert all negative numbers to positive numbers\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                nums[i] = 0\n        \n        # 2. convert all numbers to their corresponding index\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nums[nums[i] - 1] = -abs(nums[nums[i] - 1])\n        \n        # 3. iterate through the array and check if the number at that index is positive\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. if the number at that index is positive, convert it to negative\n        # 5. if the number at that index is negative, convert it to positive\n        # 6. iterate through the array again and find the first positive number\n        # 7. return the index + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        nums = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            fact //= i\n            ans += str(nums[k//fact])\n            nums.remove(nums[k//fact])\n            k %= fact\n        \n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                # return the indices of the two numbers\n                return [num_dict[target - num] + 1, i + 1]\n            # add the number to the dictionary with its index as the value\n            num_dict[num] = i"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if op:\n                    backtrack(j + 1, curr, curr, res, op + '+' + str(curr))\n                    backtrack(j + 1, -curr, curr, res, op + '-' + str(curr))\n                else:\n                    backtrack(j + 1, curr, curr, res, str(curr))\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1\n        ## if sum(gas) == sum(cost) return 0\n        \n        ## if sum(gas) < sum(cost) return -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace('*', ''):\n            return not s\n        \n        star = p.find('*')\n        if star == -1:\n            return False\n        \n        if p[star - 1] == '*' and self.isMatch(s, p[star:]):\n            return True\n        \n        for i in range(len(s)):\n            if p[star] == '.' or p[star] == s[i]:\n                if self.isMatch(s[i + 1:], p[star + 1:]):\n                    return True\n        return False"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for num in nums:\n                while out and k > 0 and out[-1] < num:\n                    out.pop()\n                    k -= 1\n                out.append(num)\n            return out\n        \n        def merge(nums1, nums2, k):\n            out = []\n            while len(nums1) + len(nums2) > k:\n                if not nums1:\n                    return nums2[-k:]\n                if not nums2:\n                    return nums1[-k:]\n                if nums1[-1] > nums2[-1]:\n                    nums1.pop()\n                else:\n                    nums2.pop()\n            return nums1 + nums2\n        \n        return max(merge(pick(nums1, i), pick(nums2, k - i), k) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1 - dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            count, left = 0, 0\n            for num in nums:\n                count += left\n                left += num - nums[left] <= mid\n            if count < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and s[l] not in vowels:\n                l += 1\n            while l < r and s[r] not in vowels:\n                r -= 1\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## sum(n) - sum(nums)\n        ## sum(n) = n(n+1)/2\n        ## sum(nums) = n(n+1)/2 - sum(n)\n        ## sum(nums) = n(n+1) - sum(n)\n        ## sum(nums) - sum(n) = n(n+1) - sum(n)\n        ## sum(nums) - sum(n) = n(n+1) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)(n/2) - sum(n)\n        ## sum(nums) - sum(n) = (n+1)("}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        \n        # BFS\n        # Time:"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)-1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if i < len(b):\n                if b[i] == '1':\n                    carry += 1\n            res.append(str(carry % 2))\n            carry //= 2\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        \n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        \n        return [left_idx, binary_search(nums, target, False) - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j] + max(prices[i] - prices[i - 1], 0), dp[i - 1][j - 1] + prices[i] - prices[i - 1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        if num < 0:\n            num = 2 ** 32 + num\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # iterate over the string and update the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate over the string again and return the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    if abs(i - j) <= indexDiff:\n                        return True\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for i in nums:\n            if i == 1:\n                curr_count += 1\n            else:\n                max_count = max(max_count, curr_count)\n                curr_count = 0\n                \n        return max(max_count, curr_count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # add the two numbers\n        # convert the numbers to ints\n        # add the numbers\n        # convert the sum back to a string\n        # return the sum\n        \n        # convert the numbers to ints\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add the two numbers\n        sum = num1 + num2\n        \n        # convert the sum back to a string\n        return str(sum)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] in '+-' or i == len(s) - 1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack[-1] *= num\n                elif sign == '/':\n                    stack[-1] = int(stack[-1] / num)\n                sign = s[i]\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # heapify profits\n        heap = []\n        for c, p in sorted_capital:\n            if c <= w:\n                heapq.heappush(heap, -p)\n            else:\n                break\n        \n        # iterate over sorted capital\n        for i in range(k):\n            if heap:\n                w += -heapq.heappop(heap)\n            else:\n                break\n        \n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '[':\n                stack.append(']')\n            elif i == '{':\n                stack.append('}')\n            elif stack and i == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first element from the end that is smaller than its next element\n        # find the first element from the end that is greater than its next element\n        # swap the two elements\n        # reverse the elements after the first element\n        \n        # find the first element from the end that is smaller than its next element\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # find the first element from the end that is greater than its next element\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two elements\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the elements after the first element\n        nums[i + 1:] = nums[len(nums) - 1: i:-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        d = {}\n        \n        for i, n in enumerate(nums):\n            if n in d and i - d[n] <= k:\n                return True\n            d[n] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        \n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n            queue = queue[len(level):]\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        return len(couples) - len(set(couples))"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        for word in words:\n            if word[0] in row1:\n                r = row1\n            elif word[0] in row2:\n                r = row2\n            else:\n                r = row3\n            for c in word:\n                if c not in r:\n                    break\n            else:\n                ans.append(word)\n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        \n        curr = prev.next\n        for _ in range(right - left):\n            nxt = curr.next\n            curr.next = nxt.next\n            nxt.next = prev.next\n            prev.next = nxt\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # for example, abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that can be centered at the beginning of the string\n        # abcba is the longest palindrome that"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s) + 1\n        min_start = 0\n        min_end = 0\n        \n        for end in range(len(s)):\n            if s[end] in t_dict:\n                s_dict[s[end]] -= 1\n                if s_dict[s[end]] < t_dict[s[end]]:\n                    if end - start + 1 < min_len:\n                        min_len = end - start + 1\n                        min_start = start\n                        min_end = end\n                    s_dict[s[start]] += 1\n                    start += 1\n        \n        if min_len == len(s) + 1:\n            return \"\"\n        \n        return s[min_start:min_end + 1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 2] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # Initialize the length of the longest palindrome to 0\n        longest_palindrome = 0\n        \n        # Iterate through the string and update the frequency of each character\n        for char in s:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Iterate through the dictionary and check for odd-length palindromes\n        for char, count in freq.items():\n            if count % 2 == 0:\n                longest_palindrome += count\n            else:\n                longest_palindrome += count - 1\n        \n        # If the length of the string is odd, add 1 to the longest palindrome\n        if len(s) % 2 == 1:\n            longest_palindrome += 1\n        \n        return longest_palindrome"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0 and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\n        trees.sort(key=lambda x: x[0])\n        steps = 0\n        for tree, x, y in trees:\n            steps += bfs((x, y), (m - 1, n - 1))\n            if steps < 0:\n                return steps\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. calculate the prefix sum\n        # 2. sort the prefix sum\n        # 3. use two pointers to find the range sum\n        # 4. use binary search to find the range sum\n        # 5. use hashmap to store the range sum\n        # 6. return the range sum\n        \n        # 1. calculate the prefix sum\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        # 2. sort the prefix sum\n        prefix_sum.sort()\n        \n        # 3. use two pointers to find the range sum\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if prefix_sum[j] - prefix_sum[i] >= lower and prefix_sum[j] - prefix_sum[i] <= upper:\n                    ans += 1\n        \n        # 4. use binary search to find the range sum\n        # 5. use hashmap to store the range sum\n        # 6. return the range sum\n        ans = 0\n        prefix_sum = {0: 1}\n        for i in range(n):\n            ans += prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_sum[prefix_"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2*n)**0.5 - 1)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        \n        i = 0\n        for c in t:\n            if i == len(s):\n                return True\n            if c == s[i]:\n                i += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number we can generate\n        # 2. 2^n - 1 is the max number we can generate\n        # 3. 2^n - 1 is the max number we can generate\n        # 4. 2^n - 1 is the max number we can generate\n        # 5. 2^n - 1 is the max number we can generate\n        # 6. 2^n - 1 is the max number we can generate\n        # 7. 2^n - 1 is the max number we can generate\n        # 8. 2^n - 1 is the max number we can generate\n        # 9. 2^n - 1 is the max number we can generate\n        # 10. 2^n - 1 is the max number we can generate\n        # 11. 2^n - 1 is the max number we can generate\n        # 12. 2^n - 1 is the max number we can generate\n        # 13. 2^n - 1 is the max number we can generate\n        # 14. 2^n - 1 is the max number we can generate\n        # 15. 2^n - 1 is the max number we can generate\n        # 16. 2^n - 1 is the max number we can generate\n        # 17. 2^n - 1 is the max number we can generate\n        # 18. 2^n - 1 is the max number we can generate\n        # 19. 2^n - 1 is the max number we can generate\n        # 20. 2^n - 1 is the max number we can generate\n        # 21. 2^n - 1 is the max number we can generate\n        # 22. 2^n - 1 is the max number we can generate\n        # 23. 2^n - 1 is the max number we can generate\n        # 24. 2^n - 1 is the max number we can generate\n        # 25. 2^n - 1 is the max number we can generate\n        # 26. 2^n - 1 is the max number we can generate\n        # 27. 2^n - 1 is the max number we can generate\n        # 28. 2^n - 1 is the max number we can generate\n        # 29. 2^n - 1 is the max number we can generate\n        # 30. 2^n - 1 is the max number we can generate\n        # 31. 2^n - 1 is the max number we can generate\n        # 32. 2^n - 1 is the max number we can generate\n        # 33. 2^n - 1 is the max number we can generate\n        # 34. 2^n - 1 is the max number we can generate\n        # 35. 2^n - 1 is the max number we can generate\n        # 36. 2^n - 1 is the max number we can generate\n        # 37. 2^n - 1 is the max number we can generate\n        # 38. 2^n - 1 is the max number we can generate\n        # 39. 2^n - 1 is the max number we can generate\n        # 40. 2^n - 1 is the max number we can generate\n        # 41. 2^n - 1 is the max number we can generate\n        # 42. 2^n - 1 is the max number we can generate\n        # 43. 2^n - 1 is the max number we can generate\n        # 44. 2^n - 1 is the max number we can generate\n        # 45. 2^n - 1 is the max number we can generate\n        # 46. 2^n - 1 is the max number we can generate\n        # 47. 2^n - 1 is the max number we can generate\n        # 48. 2^n - 1 is the max number we can generate\n        # 49. 2^n - 1 is the max number we can generate\n        # 5"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a, b = 1, 2\n        for i in range(3, n+1):\n            a, b = b, a+b\n        return b"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for word in wordDict:\n                if s[i:i+len(word)] == word:\n                    dp[i+len(word)] = dp[i+len(word)] or dp[i]\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an element in the list, merge the new interval with the element\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n            \n            # if the new interval overlaps with an element in the list, merge the new interval with the element\n            if newInterval[0] <= intervals[i][1] and newInterval[1] >= intervals[i][0]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the end\n        return intervals + [newInterval]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the min and max of all the numbers in the list\n        min_num = float('inf')\n        max_num = float('-inf')\n        for num in nums:\n            for n in num:\n                min_num = min(min_num, n)\n                max_num = max(max_num, n)\n        \n        # find the range\n        range_ = max_num - min_num\n        heap = [(nums[i][0], i, 0) for i in range(len(nums))]\n        heapq.heapify(heap)\n        while len(heap) == len(nums):\n            curr_min, curr_idx, curr_num = heapq.heappop(heap)\n            if max_num - curr_min < range_:\n                range_ = max_num - curr_min\n                res = [curr_min, curr_min + range_]\n            if curr_num + 1 < len(nums[curr_idx]):\n                heapq.heappush(heap, (nums[curr_idx][curr_num + 1], curr_idx, curr_num + 1))\n        return res"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 1 bucket, 2 pigs can test 2 buckets, 3 pigs can test 4 buckets, 4 pigs can test 8 buckets, 5 pigs can test 16 buckets, 6 pigs can test 32 buckets, 7 pigs can test 64 buckets, 8 pigs can test 128 buckets, 9 pigs can test 256 buckets, 10 pigs can test 512 buckets, 11 pigs can test 1024 buckets, 12 pigs can test 2048 buckets, 13 pigs can test 4096 buckets, 14 pigs can test 8192 buckets, 15 pigs can test 16384 buckets, 16 pigs can test 32768 buckets, 17 pigs can test 65536 buckets, 18 pigs can test 131072 buckets, 19 pigs can test 262144 buckets, 20 pigs can test 524288 buckets, 21 pigs can test 1048576 buckets, 22 pigs can test 2097152 buckets, 23 pigs can test 4194304 buckets, 24 pigs can test 8388608 buckets, 25 pigs can test 16777216 buckets, 26 pigs can test 33554432 buckets, 27 pigs can test 67108864 buckets, 28 pigs can test 134217728 buckets, 29 pigs can test 268435456 buckets, 30 pigs can test 536870912 buckets, 31 pigs can test 1073741824 buckets, 32 pigs can test 2147483648 buckets, 33 pigs can test 4294967296 buckets, 34 pigs can test 8589934592 buckets, 35 pigs can test 17179869184 buckets, 36 pigs can test 34359738368 buckets, 37 pigs can test 68719476736 buckets, 38 pigs can test 137438953472 buckets, 39 pigs can test 274877906944 buckets, 40 pigs can test 549755813888 buckets, 41 pigs can test 1099511627776 buckets, 42 pigs can test 2199023255552 buckets, 43 pigs can test 4398046511104 buckets, 44 pigs can test 8796093022208 buckets, 45 pigs can test 17592186044416 buckets, 46 pigs can test 35184372088832 buckets, 47 pigs can test 70368744177664 buckets, 48 pigs can test 140737488355328 buckets, 49 pigs can test 281474976710656 buckets, 50 pigs can test 562949952421312 buckets, 51 pigs can test 1125899904842624 buckets, 52 pigs can test 2251799809685248 buckets, 53 pigs can test 4503599619370496 buckets, 54 p"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set([(0, 0)])\n        ans = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            ans = max(ans, t)\n            if i == j == n - 1:\n                return ans\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n        return ans"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m*n\n        grid = [[0]*n for _ in range(m)]\n        \n        # fill the first row with 1s\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # fill the first column with 1s\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # fill the rest of the grid\n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i + j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res) - 1):\n            res[i + 1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        \n        i = res.index(\"0\")\n        if i == 0:\n            return \"0\"\n        else:\n            return \"\".join(res[i:])"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            for j in range(i, len(candidates)):\n                if j > i and candidates[j] == candidates[j-1]:\n                    continue\n                cur.append(candidates[j])\n                dfs(j+1, cur, total+candidates[j])\n                cur.pop()\n        dfs(0, [], 0)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper():\n            return False\n        else:\n            return True"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did not pass all test cases\n        \n        ## Approach:\n        ## 1. Iterate through the array and find the min price\n        ## 2. Iterate through the array and find the max profit\n        ## 3. Return the max profit\n        \n        ## Initialize variables\n        max_profit = 0\n        min_price = float('inf')\n        \n        ## Iterate through the array\n        for price in prices:\n            ## If the price is less than the min price, update the min price\n            if price < min_price:\n                min_price = price\n            ## Otherwise, update the max profit\n            else:\n                max_profit = max(max_profit, price - min_price)\n        \n        ## Return the max profit\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if len(lists) > 1 else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3. return the difference\n        \n        # 1. find the first number that has k zeros\n        # 2. find the last number that has k zeros\n        # 3."}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(word):\n            return word == word[::-1]\n        \n        res = []\n        for i, word in enumerate(words):\n            for j in range(len(words)):\n                if i == j:\n                    continue\n                if is_palindrome(word + words[j]):\n                    res.append([i, j])\n                if is_palindrome(words[j] + word):\n                    res.append([j, i])\n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    return res\n                res += 1\n                for i, j in infected:\n                    for x, y in ((i, j-1), (i, j+1), (i-1, j), (i+1, j)):\n                        if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                            isInfected[x][y] = 2\n            return res\n        \n        def build(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    return res\n                res += 1\n                for i, j in infected:\n                    for x, y in ((i, j-1), (i, j+1), (i-1, j), (i+1, j)):\n                        if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                            isInfected[x][y] = 2\n            return res\n        \n        return spread(isInfected) + build(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, dp, i, j))\n        \n        return res\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, x, y))\n        \n        return dp[i][j] + 1"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = set(wordDict)\n        \n        # create a list of all the words in the string\n        word_list_s = set(s.split())\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list_s if word in word_list]\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = [word for word in word_list"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            result.append(level)\n            left_to_right = not left_to_right\n            \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return \"%d:%02d\" % (h, m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.append(get_time(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        pascal = [[1] * i for i in range(1, numRows + 1)]\n        \n        for i in range(2, numRows):\n            for j in range(1, i):\n                pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j]\n        \n        return pascal"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left_gain + right_gain + node.val)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        for i in range(n):\n            heapq.heappush(heap, (heightMap[0][i], 0, i))\n            heapq.heappush(heap, (heightMap[m-1][i], m-1, i))\n        \n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            if (i, j) not in seen:\n                seen.add((i, j))\n                ans += h - heightMap[i][j]\n                for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                        heapq.heappush(heap, (max(heightMap[ni][nj], h), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # O(n) time, O(n) space\n        # Use a max heap to store the first half of the array\n        # Use a min heap to store the second half of the array\n        # If the size of the two heaps is uneven, the median is the max of the first half\n        # If the size of the two heaps is even, the median is the mean of the two maxes\n        # If the size of the two heaps is even, the median is the mean of the two medians\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of the second half\n        # If the size of the two heaps is uneven, the median is the min of"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for _ in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums.sort()\n                j = bisect.bisect_left(sums, k)\n                if j < m:\n                    res = max(res, sums[j] - k)\n                for i in range(m - 1, -1, -1):\n                    sums[i] += sums[i - 1]\n                    j = bisect.bisect_left(sums, k)\n                    if j < m:\n                        res = max(res, sums[j] - k)\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend/divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend)/abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n            \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n            \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n            \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        nums_dict = {}\n        \n        # iterate over the list of numbers\n        for i, num in enumerate(nums):\n            \n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in nums_dict:\n                \n                # return the indices of the two numbers\n                return [nums_dict[target - num], i]\n            \n            # add the number to the dictionary with its index as the value\n            nums_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_a, new_b = a + b, a - b\n                            elif op == '-':\n                                new_a, new_b = a - b, b - a\n                            elif op == '*':\n                                new_a, new_b = a * b, a / b\n                            else:\n                                new_a, new_b = b / a, a / b\n                            if new_b > 1e-6 and backtrack([new_a] + cards[:i] + cards[i+1:j] + cards[j+1:], new_b):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return False\n        \n        # if p is a single character, then s must also be a single character\n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        # if p is not a single character, then s must be a single character\n        if p[0] != '*':\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not a single character, then s can be empty\n        if p[0] != '*':\n            return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s can be empty\n        if p[0] == '"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100388/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/pro"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n            \n        # dfs\n        route = []\n        def dfs(node):\n            # if there is no more nodes to visit, add to the route\n            if len(graph[node]) == 0:\n                return True\n            # visit all the neighbors of the current node\n            for neighbor in graph[node]:\n                # remove the neighbor from the graph\n                graph[node].remove(neighbor)\n                # if the dfs returns true, add the neighbor to the route\n                if dfs(neighbor):\n                    route.append(neighbor)\n                    return True\n            # if the dfs returns false, remove the node from the graph\n            # and add it to the route\n            route.append(node)\n            return False\n        \n        dfs(\"JFK\")\n        return route[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = [[0, 0]]\n        \n        # iterate over the buildings\n        for building in buildings:\n            # get the left and right edges\n            left, right, height = building\n            \n            # iterate over the result list\n            for i, (x, h) in enpx, enumerate(result):\n                # if the current building is on the left edge of the current building\n                if left <= x:\n                    # if the current building is taller than the previous building\n                    if height > h:\n                        # add the current building to the result list\n                        result[i] = [left, height]\n                    # if the current building is shorter than the previous building\n                    else:\n                        # remove the previous building from the result list\n                        result.pop(i)\n                        # if the result list is empty\n                        if not result:\n                            # add the current building to the result list\n                            result.append([left, height])\n                        # if the result list is not empty\n                        else:\n                            # if the current building is taller than the previous building\n                            if height > result[-1][1]:\n                                # add the current building to the result list\n                                result.append([left, height])\n                            # if the current building is shorter than the previous building\n                            else:\n                                # remove the previous building from the result list\n                                result.pop()\n                                # if the result list is empty\n                                if not result:\n                                    # add the current building to the result list\n                                    result.append([left, height])\n                                # if the result list is not empty\n                                else:\n                                    # if the current building is taller than the previous building\n                                    if height > result[-1][1]:\n                                        # add the current building to the result list\n                                        result.append([left, height])\n                                    # if the current building is shorter than the previous building\n                                    else:\n                                        # remove the previous building from the result list\n                                        result.pop()\n                                        # if the result list is empty\n                                        if not result:\n                                            # add the current building to the result list\n                                            result.append([left, height])\n                                        # if the result list is not empty\n                                        else:\n                                            # if the current building is taller than the previous building\n                                            if height > result[-1][1]:\n                                                # add the current building to the result list\n                                                result.append([left, height])\n                                            # if the current building is shorter than the previous building\n                                            else:\n                                                # remove the previous building from the result list\n                                                result.pop()\n                                                # if the result list is empty\n                                                if not result:\n                                                    # add the current building to the result list\n                                                    result.append([left, height])\n                                                # if the result list is not empty\n                                                else:\n                                                    # if the current building is taller than the previous building\n                                                    if height > result[-1][1]:\n                                                        # add the current building to the result list\n                                                        result.append([left, height])\n                                                    # if the current building is shorter than the previous building\n                                                    else:\n                                                        # remove the previous building from the result list\n                                                        result.pop()\n                                                        # if the result list is empty\n                                                        if not result:\n                                                            # add the current building to the result list\n                                                            result.append([left, height])\n                                                        # if the result list is not empty\n                                                        else:\n                                                            # if the current building is taller than the previous building\n                                                            if height > result[-1][1]:\n                                                                # add the current building to the result list\n                                                                result.append([left, height])\n                                                            # if the current building is shorter than the previous building\n                                                            else:\n                                                                # remove the previous building from the result list\n                                                                result.pop()\n                                                                # if the result list is empty\n                                                                if not result:\n                                                                    # add the current building to the result list\n                                                                    result.append([left, height])\n                                                                # if the result list is not empty\n                                                                else:\n                                                                    # if the current building is taller than the previous building\n                                                                    if height > result[-1][1]:\n                                                                        # add the current building to the result list\n                                                                        result.append([left, height])\n                                                                    # if the current building is shorter than the previous building\n                                                                    else:\n                                                                        # remove the previous building from the result list\n                                                                        result.pop()"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + (\" \" + helper(num % 10))\n            if num < 1000:\n                return ones[num // 100] + \" Hundred\" + (\" \" + helper(num % 100))\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand\" + (\" \" + helper(num % 1000))\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million\" + (\" \" + helper(num % 1000000))\n            return helper(num // 1000000000) + \" Billion\" + (\" \" + helper(num % 1000000000))\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(0, k+1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if j >= i:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % MOD\n        \n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        for edge in edges:\n            if edge[1] in parent:\n                return [parent[edge[1]], edge[1]]\n            parent[edge[1]] = edge[0]\n        \n        # find the node with only one parent\n        for edge in edges:\n            if edge[0] in parent:\n                continue\n            if edge[1] in parent:\n                return [parent[edge[1]], edge[1]]\n            parent[edge[1]] = edge[0]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2*sum(set(nums))-sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split()[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + grid[i][j2]\n                    if j1 > 0:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1 - 1][j2] + grid[i][j1] + grid[i][j2])\n                    if j2 < n - 1:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1][j2 + 1] + grid[i][j1] + grid[i][j2])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if grid[n - 1][j1] * grid[n - 1][j2] > 0)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] + i >= len(nums)-1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        # return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '11131221133112132132221'\n        \n        if n == 12:\n            return '311311222123213221131112311312211'\n        \n        if n == 13:\n            return '1321131112311311221123123112111312211'\n        \n        if n == 14:\n            return '111312211331121321322212311312211231131122211'\n        \n        if n == 15:\n            return '31131122212321322113111231131221123113112221123113112211'\n        \n        if n == 16:\n            return '132113111231131122112312311211131221123113112221123113112211232211312111312211'\n        \n        if n == 17:\n            return '11131221133112132132221231131221123113112221123113112211232211312111312211231131122112322113112211'\n        \n        if n == 18:\n            return '3113112221232132211311123113122112311311222112311311221123221131211131221123113112211232211311221123222113111211'\n        \n        if n == 19:\n            return '13211311123113112211231231121113122112311311222112311311221123221131211131221123113112211232211311221123222113111211221123113112211'\n        \n        if n == 20:\n            return '111312211331121321322212311312211231131122211231131"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            subarrays = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    subarrays += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return subarrays <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in that half\n        if nums[pivot] <= target <= nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        # if the target is in the second half of the array, search in that half\n        else:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n    \n    def binary_search(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        res = ['']\n        \n        for digit in digits:\n            for letter in phone[digit]:\n                res = [x + letter for x in res]\n        \n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            dfs(i, cur, total + candidates[i])\n            cur.append(candidates[i])\n            dfs(i, cur, total)\n            cur.pop()\n        dfs(0, [], 0)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # convert n to int\n        num = int(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list of digits\n        n_list_digits = [int(i) for i in n_list]\n        \n        # convert n to list of digits\n        n_list_digits_reverse = n_list_digits[::-1]\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str = ''.join([str(i) for i in n_list_digits_reverse])\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int = int(n_list_digits_reverse_str)\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one = n_list_digits_reverse_str_int + 1\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str = str(n_list_digits_reverse_str_int_plus_one)\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len = len(n_list_digits_reverse_str_int_plus_one_str)\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half = n_list_digits_reverse_str_int_plus_one_str_len // 2\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one = n_list_digits_reverse_str_int_plus_one_str_len_half - 1\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str = n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str = str(n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str)\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len = len(n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str)\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len_half = n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len // 2\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len_half_minus_one = n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len_half - 1\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len_half_minus_one_str = n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one_str_str_len_half_minus_one\n        \n        # convert n to list of digits\n        n_list_digits_reverse_str_int_plus_one_str_len_half_minus_one"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        \n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = temp"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = max_prod\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n            \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is 0, return False\n        if stones[-1] == 0:\n            return False\n        \n        # create a dictionary to store the stone positions\n        stone_dict = {stone: True for stone in stones}\n        \n        # create a set to store the last stone position\n        last_stone = stones[-1]\n        \n        # create a set to store the last stone position\n        last_stone_set = set()\n        \n        # loop through the stones\n        for stone in stones:\n            \n            # if the stone is the last stone, return True\n            if stone == last_stone:\n                return True\n            \n            # loop through the stones\n            for i in range(stone + 1, last_stone + 1):\n                \n                # if the stone is in the stone_dict, update the stone_dict\n                if i in stone_dict:\n                    stone_dict[i] = True\n                    \n                # if the stone is not in the stone_dict, return False\n                else:\n                    return False\n                    \n            # update the last stone position\n            last_stone = stone\n            \n        # return False if the last stone position is not in the stone_dict\n        return False if last_stone not in stone_dict else True"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the corresponding rank\n        score_rank = {score_sorted[i]: i+1 for i in range(len(score_sorted))}\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, s in enumerate(score):\n            ranks[score_rank[s] - 1] = \"Gold Medal\" if i == 0 else \"Silver Medal\" if i == 1 else \"Bronze Medal\" if i == 2 else str(i+1)\n        \n        return ranks"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 1\n        start = 0\n        end = 0\n        char_map = {}\n        \n        while end < len(s):\n            if s[end] in char_map:\n                start = max(start, char_map[s[end]] + 1)\n            max_len = max(max_len, end - start + 1)\n            char_map[s[end]] = end\n            end += 1\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] >= 0:\n                        word_count -= 1\n                else:\n                    left = j + word_len\n                    word_dict_copy = word_dict.copy()\n                if word_count == 0:\n                    res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = max(arr)\n        max_idx = arr.index(max_val)\n        max_cnt = 1\n        \n        for i in range(max_idx):\n            if arr[i] > max_val:\n                max_val = arr[i]\n                max_cnt += 1\n        \n        return max_cnt"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            if curr.next.val == curr.next.next.val:\n                val = curr.next.val\n                while curr.next and curr.next.val == val:\n                    curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left_paths + right_paths]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid\n            while i < mid:\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - mid\n                i += 1\n            nums[left:right+1] = sorted(nums[left:right+1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid+1, right)\n            count += merge(nums, left, mid+1, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums)-1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i >= len(v1):\n                if v1[-1] > 0:\n                    return 1\n            elif i >= len(v2):\n                if v2[-1] > 0:\n                    return -1\n            else:\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to priority queue\n            heapq.heappush(pq, -duration)\n            \n            # add to total time\n            total += duration\n            \n            # if total time exceeds end date, remove from priority queue\n            if total > end:\n                total += heapq.heappop(pq)\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    break\n                kth = kth.next\n            if not kth:\n                break\n            # reverse the nodes in the range\n            # prev -> kth\n            # kth -> curr\n            # curr -> kth.next\n            curr = kth.next\n            for i in range(k):\n                temp = curr.next\n                curr.next = curr.next.next\n                curr.next.next = prev.next\n                prev.next = curr\n            prev = kth\n        \n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * dp[n-i]\n        # dp[0] = 1, dp[1] = 1\n        # dp[2] = dp[0] * dp[1] + dp[1] * dp[0]\n        # dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0]\n        # dp[4] = dp[0] * dp[3] + dp[1] * dp[2] + dp[2] * dp[1] + dp[3] * dp[0]\n        # dp[5] = dp[0] * dp[4] + dp[1] * dp[3] + dp[2] * dp[2] + dp[3] * dp[1] + dp[4] * dp[0]\n        # dp[6] = dp[0] * dp[5] + dp[1] * dp[4] + dp[2] * dp[3] + dp[3] * dp[2] + dp[4] * dp[1] + dp[5] * dp[0]\n        # dp[7] = dp[0] * dp[6] + dp[1] * dp[5] + dp[2] * dp[4] + dp[3] * dp[3] + dp[4] * dp[2] + dp[5] * dp[1] + dp[6] * dp[0]\n        # dp[8] = dp[0] * dp[7] + dp[1] * dp[6] + dp[2] * dp[5] + dp[3] * dp[4] + dp[4] * dp[3] + dp[5] * dp[2] + dp[6] * dp[1] + dp[7] * dp[0]\n        # dp[9] = dp[0] * dp[8] + dp[1] * dp[7] + dp[2] * dp[6] + dp[3] * dp[5] + dp[4] * dp[4] + dp[5] * dp[3] + dp[6] * dp[2] + dp[7] * dp[1] + dp[8] * dp[0]\n        # dp[10] = dp[0] * dp[9] + dp[1] * dp[8] + dp[2] * dp[7] + dp[3] * dp[6] + dp[4] * dp[5] + dp[5] * dp[4] + dp[6] * dp[3] + dp[7] * dp[2] + dp[8] * dp[1] + dp[9] * dp[0]\n        # dp[11] = dp[0] * dp[10] + dp[1] * dp[9] + dp[2] * dp[8] + dp[3] * dp[7] + dp[4] * dp[6] + dp[5] * dp[5] + dp[6] * dp[4] + dp[7] * dp[3] + dp[8] * dp[2] + dp[9] * dp[1] + dp[10] * dp[0]\n        # dp[12] = dp[0] * dp[11] + dp[1] * dp[10] + dp[2] * dp[9] + dp[3] * dp[8] + dp[4] * dp[7] + dp[5] * dp[6] + dp[6] * dp[5] + dp[7] * dp[4] + dp[8] * dp"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a dictionary to store the frequency of each number\n        ## 2. iterate through the dictionary and return the number with frequency 1\n        \n        freq = {}\n        for num in nums:\n            if num not in freq:\n                freq[num] = 1\n            else:\n                freq[num] += 1\n        \n        for num in freq:\n            if freq[num] == 1:\n                return num"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to spell out target[0:i]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min("}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        total = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total -= roman_dict[s[i]]\n            else:\n                total += roman_dict[s[i]]\n        return total"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the deque and output list\n        dq = collections.deque()\n        output = []\n        \n        # Iterate over the input array\n        for i in range(len(nums)):\n            \n            # Remove any elements that are out of the current window\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            \n            # Remove any elements that are smaller than the current element\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            \n            # Add the current element to the deque\n            dq.append(i)\n            \n            # Add the maximum element to the output list\n            if i >= k - 1:\n                output.append(nums[dq[0]])\n        \n        return output"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0\n        else:\n            return nums1[len(nums1) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not found, return the first element\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found,"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build a queue and a set to store the shortest path\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        found = False\n        \n        # BFS\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    found = True\n                    break\n                for i in range(len(word)):\n                    for neighbor in graph[word[:i] + \"*\" + word[i+1:]]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            if found:\n                break\n        \n        # build the shortest path\n        res = []\n        while queue:\n            word = queue.popleft()\n            if word == endWord:\n                break\n            for i in range(len(word)):\n                for neighbor in graph[word[:i] + \"*\" + word[i+1:]]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.appendleft(neighbor)\n                        res.append([beginWord, neighbor])\n        \n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n            else:\n                res += [r + [nums[i]] for r in res if r[-1] <= nums[i]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uae4c\uc9c0 \uc21c\ud68c\ud558\uba74\uc11c"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        return area == (x_max - x_min) * (y_max - y_min)"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [board[0][0]*10 + board[0][1]*1 + board[0][2],\n                    board[1][0]*10 + board[1][1]*1 + board[1][2]]\n        \n        # convert board_1d to a set\n        board_1d_set = set(board_1d)\n        \n        # convert board_1d to a string\n        board_1d_str = str(board_1d)\n        \n        # convert board_1d_str to a list\n        board_1d_list = list(board_1d_str)\n        \n        # convert board_1d_list to a set\n        board_1d_list_set = set(board_1d_list)\n        \n        # convert board_1d_list_set to a string\n        board_1d_list_str = str(board_1d_list_set)\n        \n        # convert board_1d_list_str to a list\n        board_1d_list_str_list = list(board_1d_list_str)\n        \n        # convert board_1d_list_str_list to a set\n        board_1d_list_str_list_set = set(board_1d_list_str_list)\n        \n        # convert board_1d_list_str_list_set to a string\n        board_1d_list_str_list_str = str(board_1d_list_str_list_set)\n        \n        # convert board_1d_list_str_list_str to a list\n        board_1d_list_str_list_str_list = list(board_1d_list_str_list_str)\n        \n        # convert board_1d_list_str_list_str_list to a set\n        board_1d_list_str_list_str_list_set = set(board_1d_list_str_list_str_list)\n        \n        # convert board_1d_list_str_list_str_list_set to a string\n        board_1d_list_str_list_str_list_str = str(board_1d_list_str_list_str_list_set)\n        \n        # convert board_1d_list_str_list_str_list_str to a list\n        board_1d_list_str_list_str_list_str_list = list(board_1d_list_str_list_str_list_str)\n        \n        # convert board_1d_list_str_list_str_list_str_list to a set\n        board_1d_list_str_list_str_list_str_list_set = set(board_1d_list_str_list_str_list_str_list)\n        \n        # convert board_1d_list_str_list_str_list_str_list_set to a string\n        board_1d_list_str_list_str_list_str_list_str = str(board_1d_list_str_list_str_list_str_list_set)\n        \n        # convert board_1d_list_str_list_str_list_str_list_str to a list\n        board_1d_list_str_list_str_list_str_list_str_list = list(board_1d_list_str_list_str_list_str_list_str)\n        \n        # convert board_1d_list_str_list_str_list_str_list_str_list to a set\n        board_1d_list_str_list_str_list_str_list_str_list_set = set(board_1d_list_str_list_str_list_str_list_str_list)\n        \n        # convert board_1d_list_str_list_str_list_str_list_str_list_set to a string\n        board_1d_list_str_list_str_list_str_list_str_list_str = str(board_1d_list_str_list_str_list_str_list_str_list_set)\n        \n        # convert board_1d_list_str_list_"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in that half\n        if nums[pivot] <= target <= nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        # if the target is in the second half of the array, search in that half\n        else:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n    \n    def binary_search(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum > target:\n                    right -= 1\n                else:\n                    left += 1\n        \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        return min(b-a for a, b in zip(inorder(root), inorder(root)[1:]))"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        return sorted(collections.Counter(dfs(root)).most_common(1)[0][0] if dfs(root) else []"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, replace 3 repeating characters in a row\n        # 3. if not, replace 2 repeating characters in a row\n        # 4. if not, replace 1 repeating character\n        # 5. if not, add 1 character\n        # 6. if not, add 1 character\n        # 7. if not, add 1 character\n        # 8. if not, add 1 character\n        # 9. if not, add 1 character\n        # 10. if not, add 1 character\n        # 11. if not, add 1 character\n        # 12. if not, add 1 character\n        # 13. if not, add 1 character\n        # 14. if not, add 1 character\n        # 15. if not, add 1 character\n        # 16. if not, add 1 character\n        # 17. if not, add 1 character\n        # 18. if not, add 1 character\n        # 19. if not, add 1 character\n        # 20. if not, add 1 character\n        # 21. if not, add 1 character\n        # 22. if not, add 1 character\n        # 23. if not, add 1 character\n        # 24. if not, add 1 character\n        # 25. if not, add 1 character\n        # 26. if not, add 1 character\n        # 27. if not, add 1 character\n        # 28. if not, add 1 character\n        # 29. if not, add 1 character\n        # 30. if not, add 1 character\n        # 31. if not, add 1 character\n        # 32. if not, add 1 character\n        # 33. if not, add 1 character\n        # 34. if not, add 1 character\n        # 35. if not, add 1 character\n        # 36. if not, add 1 character\n        # 37. if not, add 1 character\n        # 38. if not, add 1 character\n        # 39. if not, add 1 character\n        # 40. if not, add 1 character\n        # 41. if not, add 1 character\n        # 42. if not, add 1 character\n        # 43. if not, add 1 character\n        # 44. if not, add 1 character\n        # 45. if not, add 1 character\n        # 46. if not, add 1 character\n        # 47. if not, add 1 character\n        # 48. if not, add 1 character\n        # 49. if not, add 1 character\n        # 50. if not, add 1 character\n        # 51. if not, add 1 character\n        # 52. if not, add 1 character\n        # 53. if not, add 1 character\n        # 54. if not, add 1 character\n        # 55. if not, add 1 character\n        # 56. if not, add 1 character\n        # 57. if not, add 1 character\n        # 58. if not, add 1 character\n        # 59. if not, add 1 character\n        # 60. if not, add 1 character\n        # 61. if not, add 1 character\n        # 62. if not, add 1 character\n        # 63. if not, add 1 character\n        # 64. if not, add 1 character\n        # 65. if not, add 1 character\n        # 66. if not, add 1 character\n        # 67. if not, add 1 character\n        # 68. if not, add 1 character\n        # 69. if not, add 1 character\n        # 70. if not, add 1 character\n        # 71. if not, add 1 character\n        # 72. if not, add 1 character\n        # 73. if not, add 1 character\n        # 7"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the left and right max height\n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        \n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i-1], height[i-1])\n        \n        for i in range(len(height)-2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i+1])\n        \n        # 3. find the water\n        water = 0\n        for i in range(len(height)):\n            water += min(left_max[i], right_max[i]) - height[i]\n        \n        return water"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use binary search to find the number of smaller elements to the right\n        # 5. use binary search to find the number of smaller elements to the left\n        # 6. use binary search to find the number of smaller elements to the right\n        # 7. use binary search to find the number of smaller elements to the left\n        # 8. use binary search to find the number of smaller elements to the right\n        # 9. use binary search to find the number of smaller elements to the left\n        # 10. use binary search to find the number of smaller elements to the right\n        # 11. use binary search to find the number of smaller elements to the left\n        # 12. use binary search to find the number of smaller elements to the right\n        # 13. use binary search to find the number of smaller elements to the left\n        # 14. use binary search to find the number of smaller elements to the right\n        # 15. use binary search to find the number of smaller elements to the left\n        # 16. use binary search to find the number of smaller elements to the right\n        # 17. use binary search to find the number of smaller elements to the left\n        # 18. use binary search to find the number of smaller elements to the right\n        # 19. use binary search to find the number of smaller elements to the left\n        # 20. use binary search to find the number of smaller elements to the right\n        # 21. use binary search to find the number of smaller elements to the left\n        # 22. use binary search to find the number of smaller elements to the right\n        # 23. use binary search to find the number of smaller elements to the left\n        # 24. use binary search to find the number of smaller elements to the right\n        # 25. use binary search to find the number of smaller elements to the left\n        # 26. use binary search to find the number of smaller elements to the right\n        # 27. use binary search to find the number of smaller elements to the left\n        # 28. use binary search to find the number of smaller elements to the right\n        # 29. use binary search to find the number of smaller elements to the left\n        # 30. use binary search to find the number of smaller elements to the right\n        # 31. use binary search to find the number of smaller elements to the left\n        # 32. use binary search to find the number of smaller elements to the right\n        # 33. use binary search to find the number of smaller elements to the left\n        # 34. use binary search to find the number of smaller elements to the right\n        # 35. use binary search to find the number of smaller elements to the left\n        # 36. use binary search to find the number of smaller elements to the right\n        # 37. use binary search to find the number of smaller elements to the left\n        # 38. use binary search to find the number of smaller elements to the right\n        # 39. use binary search to find the number of smaller elements to the left\n        # 40. use binary search to find the number of smaller elements to the right\n        # 41. use binary search to find the number of smaller elements to the left\n        # 42. use binary search to find the number of smaller elements to the right\n        # 43. use binary search to find the number of smaller elements to the left\n        # 44. use binary search to find the number of smaller elements to the right\n        # 45. use binary search to find the number of smaller elements to the left\n        # 46. use binary search to find the number of smaller elements to the right\n        # 47. use binary search to find the number of smaller elements to the left\n        # 48. use binary search to find the number of smaller elements to the right\n        # 49. use binary search to find the number of smaller elements to the left\n        # 50. use binary search to find the number of smaller elements to the right\n        # 51. use binary search to find the number of smaller elements to the left\n        # 52. use binary search to find the number of smaller elements to the right\n        #"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by the end of the interval\n        intervals.sort(key=lambda x: x[1])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max value of the interval\n        max_val = -1\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the interval is not empty\n            if interval[0] > max_val:\n                # update the result\n                res += 2\n                # update the max value of the interval\n                max_val = interval[1]\n            # if the interval is not empty\n            elif interval[0] > max_val - 1:\n                # update the result\n                res += 1\n                # update the max value of the interval\n                max_val = interval[1]\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the formula into tokens\n        # 2. build a stack of tokens\n        # 3. build a stack of counts\n        # 4. build a stack of atoms\n        # 5. build a stack of counts\n        # 6. build a stack of atoms\n        # 7. build a stack of counts\n        # 8. build a stack of atoms\n        # 9. build a stack of counts\n        # 10. build a stack of atoms\n        # 11. build a stack of counts\n        # 12. build a stack of atoms\n        # 13. build a stack of counts\n        # 14. build a stack of atoms\n        # 15. build a stack of counts\n        # 16. build a stack of atoms\n        # 17. build a stack of counts\n        # 18. build a stack of atoms\n        # 19. build a stack of counts\n        # 20. build a stack of atoms\n        # 21. build a stack of counts\n        # 22. build a stack of atoms\n        # 23. build a stack of counts\n        # 24. build a stack of atoms\n        # 25. build a stack of counts\n        # 26. build a stack of atoms\n        # 27. build a stack of counts\n        # 28. build a stack of atoms\n        # 29. build a stack of counts\n        # 30. build a stack of atoms\n        # 31. build a stack of counts\n        # 32. build a stack of atoms\n        # 33. build a stack of counts\n        # 34. build a stack of atoms\n        # 35. build a stack of counts\n        # 36. build a stack of atoms\n        # 37. build a stack of counts\n        # 38. build a stack of atoms\n        # 39. build a stack of counts\n        # 40. build a stack of atoms\n        # 41. build a stack of counts\n        # 42. build a stack of atoms\n        # 43. build a stack of counts\n        # 44. build a stack of atoms\n        # 45. build a stack of counts\n        # 46. build a stack of atoms\n        # 47. build a stack of counts\n        # 48. build a stack of atoms\n        # 49. build a stack of counts\n        # 50. build a stack of atoms\n        # 51. build a stack of counts\n        # 52. build a stack of atoms\n        # 53. build a stack of counts\n        # 54. build a stack of atoms\n        # 55. build a stack of counts\n        # 56. build a stack of atoms\n        # 57. build a stack of counts\n        # 58. build a stack of atoms\n        # 59. build a stack of counts\n        # 60. build a stack of atoms\n        # 61. build a stack of counts\n        # 62. build a stack of atoms\n        # 63. build a stack of counts\n        # 64. build a stack of atoms\n        # 65. build a stack of counts\n        # 66. build a stack of atoms\n        # 67. build a stack of counts\n        # 68. build a stack of atoms\n        # 69. build a stack of counts\n        # 70. build a stack of atoms\n        # 71. build a stack of counts\n        # 72. build a stack of atoms\n        # 73. build a stack of counts\n        # 74. build a stack of atoms\n        # 75. build a stack of counts\n        # 76. build a stack of atoms\n        # 77. build a stack of counts\n        # 78. build a stack of atoms\n        # 79. build a stack of counts\n        # 80. build a stack of atoms\n        # 81. build a stack of counts\n        # 82. build a stack of atoms\n        # 83. build a stack of counts\n        # 84. build a stack of atoms\n        # 85. build a stack of counts\n        # 86. build a stack of atoms"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        nums_len = len(nums)\n        nums_sum = 0\n        \n        # iterate\n        for i in range(nums_len):\n            nums_sum += nums[i]\n            if nums_sum >= n:\n                break\n            else:\n                patches += 1\n        \n        # edge case\n        if nums_sum < n:\n            return patches\n        \n        # iterate\n        while nums_sum < n:\n            nums_sum += nums_sum + 1\n            patches += 1\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. recursion\n        # 6. math\n        # 7. bit manipulation\n        # 8. string\n        # 9. stack\n        # 10. hash table\n        # 11. math\n        # 12. math\n        # 13. math\n        # 14. math\n        # 15. math\n        # 16. math\n        # 17. math\n        # 18. math\n        # 19. math\n        # 20. math\n        # 21. math\n        # 22. math\n        # 23. math\n        # 24. math\n        # 25. math\n        # 26. math\n        # 27. math\n        # 28. math\n        # 29. math\n        # 30. math\n        # 31. math\n        # 32. math\n        # 33. math\n        # 34. math\n        # 35. math\n        # 36. math\n        # 37. math\n        # 38. math\n        # 39. math\n        # 40. math\n        # 41. math\n        # 42. math\n        # 43. math\n        # 44. math\n        # 45. math\n        # 46. math\n        # 47. math\n        # 48. math\n        # 49. math\n        # 50. math\n        # 51. math\n        # 52. math\n        # 53. math\n        # 54. math\n        # 55. math\n        # 56. math\n        # 57. math\n        # 58. math\n        # 59. math\n        # 60. math\n        # 61. math\n        # 62. math\n        # 63. math\n        # 64. math\n        # 65. math\n        # 66. math\n        # 67. math\n        # 68. math\n        # 69. math\n        # 70. math\n        # 71. math\n        # 72. math\n        # 73. math\n        # 74. math\n        # 75. math\n        # 76. math\n        # 77. math\n        # 78. math\n        # 79. math\n        # 80. math\n        # 81. math\n        # 82. math\n        # 83. math\n        # 84. math\n        # 85. math\n        # 86. math\n        # 87. math\n        # 88. math\n        # 89. math\n        # 90. math\n        # 91. math\n        # 92. math\n        # 93. math\n        # 94. math\n        # 95. math\n        # 96. math\n        # 97. math\n        # 98. math\n        # 99. math\n        # 100. math\n        # 101. math\n        # 102. math\n        # 103. math\n        # 104. math\n        # 105. math\n        # 106. math\n        # 107. math\n        # 108. math\n        # 109. math\n        # 110. math\n        # 111. math\n        # 112. math\n        # 113. math\n        # 114. math\n        # 115. math\n        # 116. math\n        # 117. math\n        # 118. math\n        # 119. math\n        # 120. math\n        # 121. math\n        # 122. math\n        # 123. math\n        # 124. math\n        # 125"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        res = \"\"\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        \n        numerator %= denominator\n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + \"(\" + res[seen[numerator]:] + \")\"\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        l1 = self.sortList(head)\n        l2 = self.sortList(mid)\n        \n        return self.merge(l1, l2)\n    \n    def merge(self, l1, l2):\n        dummy = cur = ListNode()\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        \n        cur.next = l1 or l2\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Use a dynamic programming approach to find the longest increasing subsequence\n        # in the sorted envelopes\n        dp = [envelopes[0][1]]\n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left = 0\n                right = len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = envelopes[i][1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O("}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = head\n        \n        # move fast pointer n steps\n        for i in range(n):\n            fast = fast.next\n        \n        # move both pointers until fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node\n        slow.next = slow.next.next\n        \n        # return the head of the modified list\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) // len(machines)\n        ans = 0\n        curr = 0\n        \n        for i in machines:\n            curr += i - avg\n            ans = max(ans, abs(curr))\n        \n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        root.right = self.sortedListToBST(slow.next.next)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list2, list1\n        \n        head = list1\n        \n        while list1.next:\n            if list1.next.val > list2.val:\n                list1 = list1.next\n            else:\n                temp = list1.next\n                list1.next = list2\n                list2 = list1.next\n                list1.next.next = temp\n                list1 = list1.next\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        \n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        for i, h in enumerate(heights + [0]):\n            while stack and heights[stack[-1]] > h:\n                cur_height = heights[stack.pop()]\n                cur_width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, cur_height * cur_width)\n            stack.append(i)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        \n        for num in nums:\n            res += [curr + [num] for curr in res]\n        \n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[right]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        first_node = second_node = prev = TreeNode(float('-inf'))\n        \n        # traverse the tree in-order\n        def inorder(node):\n            nonlocal first_node, second_node, prev\n            if node:\n                inorder(node.left)\n                if prev.val > node.val:\n                    if first_node.val == float('-inf'):\n                        first_node = prev\n                    second_node = node\n                prev = node\n                inorder(node.right)\n        \n        inorder(root)\n        \n        # swap the values of the two nodes\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        first_node = second_node = prev = TreeNode(float('-inf'))\n        \n        # traverse the tree in-order\n        def inorder(node):\n            nonlocal first_node, second_node, prev\n            if node:\n                inorder(node.left)\n                if prev.val > node.val:\n                    if first_node.val == float('-inf'):\n                        first_node = prev\n                    second_node = node\n                prev = node\n                inorder(node.right)\n        \n        inorder(root)\n        \n        # swap the values of the two nodes\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        first_node = second_node = prev = TreeNode(float('-inf'))\n        \n        # traverse the tree in-order\n        def inorder(node):\n            nonlocal first_node, second_node, prev\n            if node:\n                inorder(node.left)\n                if prev.val > node.val:\n                    if first_node.val == float('-inf'):\n                        first_node = prev\n                    second_node = node\n                prev = node\n                inorder(node.right)\n        \n        inorder(root)\n        \n        # swap the values of the two nodes\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        ans = [0]\n        for i in range(1, n+1):\n            ans.append(ans[i >> 1] + (i & 1))\n        \n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node):\n            if node not in node.children:\n                return False\n            char = board[i][j]\n            node = node.children[char]\n            if '*' in node:\n                res.add(node['*'])\n            board[i][j] = '#'\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '#':\n                    dfs(x, y, node)\n            board[i][j] = char\n            return True\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['*'] = word\n        \n        m, n = len(board), len(board[0])\n        res = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    dfs(i, j, trie)\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for c in s_dict:\n            if s_dict[c] != t_dict.get(c, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 1440000\n        # 26^5 = 73720000\n        # 26^6 = 3689600000\n        # 26^7 = 195312500000\n        # 26^8 = 1125899906842624\n        # 26^9 = 677626319032390625\n        # 26^10 = 414273689857890625\n        # 26^11 = 237986414993237307625\n        # 26^12 = 137798364982474609375\n        # 26^13 = 788819132450158603515625\n        # 26^14 = 4118095612252639130859375\n        # 26^15 = 22592478061263765625000000\n        # 26^16 = 132462390306132812500000000\n        # 26^17 = 762311951801718750000000000\n        # 26^18 = 38115597590085937500000000000\n        # 26^19 = 1905779879504392875000000000000\n        # 26^20 = 102488393875019531250000000000000\n        # 26^21 = 51244196937500776367187500000000000\n        # 26^22 = 25622098418750038208007812500000000000\n        # 26^23 = 128110492093750019140625000000000000000\n        # 26^24 = 6405524604875000590820312500000000000000\n        # 26^25 = 320276230243750007904101562500000000000000\n        # 26^26 = 160138115121875000490205830078125000000000000\n        # 26^27 = 800690575609375000245102539062500000000000000\n        # 26^28 = 36034528780487500012255117187500000000000000000\n        # 26^29 = 1801726438524375000612755688437500000000"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        second = slow.next\n        prev = None\n        while second:\n            temp = second.next\n            second.next = prev\n            prev = second\n            second = temp\n        \n        # merge the first and second halves\n        first = head\n        second = prev\n        while second:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(s) != len(pattern):\n            return False\n        \n        d = {}\n        for i, j in zip(pattern, s):\n            if i not in d:\n                if j in d.values():\n                    return False\n                d[i] = j\n            elif d[i] != j:\n                return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a variable to store the carry over\n        carry = 0\n        \n        # while either of the linked lists are not empty\n        while l1 or l2 or carry:\n            # if the linked list 1 is not empty\n            if l1:\n                # add the value of the node to the carry over\n                carry += l1.val\n                # move the pointer to the next node\n                l1 = l1.next\n            # if the linked list 2 is not empty\n            if l2:\n                # add the value of the node to the carry over\n                carry += l2.val\n                # move the pointer to the next node\n                l2 = l2.next\n            # create a new node with the sum of the carry over and the current value\n            curr.next = ListNode(carry % 10)\n            # move the pointer to the next node\n            curr = curr.next\n            # divide the carry over by 10\n            carry //= 10\n            \n        # return the dummy node's next node\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert to binary\n        ## 2. flip the bits\n        ## 3. convert back to decimal\n        \n        ## 1. convert to binary\n        binary = bin(num)[2:]\n        \n        ## 2. flip the bits\n        binary = binary.replace('0', '2').replace('1', '0').replace('2', '1')\n        \n        ## 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        ans = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n            ans += dp[i]\n        \n        return ans"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur_len = 0\n        cur_words = []\n        \n        for word in words:\n            if cur_len + len(word) + len(cur_words) > maxWidth:\n                for i in range(maxWidth - cur_len):\n                    cur_words[i % (len(cur_words) - 1 or 1)] += ' '\n                res.append(''.join(cur_words))\n                cur_len = 0\n                cur_words = []\n            cur_len += len(word)\n            cur_words.append(word)\n        return res + [' '.join(cur_words).ljust(maxWidth)]"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # O(n) time and O(1) space\n        # Two pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # O(nlogn) time and O(1) space\n        # Binary search\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # O(n) time and O(n) space\n        # Prefix sum\n        # max_area = 0\n        # prefix_sum = [0]\n        # for h in height:\n        #     prefix_sum.append(prefix_sum[-1] + h)\n        # for i in range(len(height)):\n        #     max_area = max(max_area, (prefix_sum[-1] - prefix_sum[i]) * height[i])\n        # return max_area\n        \n        # O(n) time and O(1) space\n        # Two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # O(n) time and O(1) space\n        # Prefix sum\n        # max_area = 0\n        # prefix_sum = [0]\n        # for h in height:\n        #     prefix_sum.append(prefix_sum[-1] + h)\n        # for i in range(len(height)):\n        #     max_area = max(max_area, (prefix_sum[-1] - prefix_sum[i]) * height[i])\n        # return max_area\n        \n        # O(n) time and O(1) space\n        # Prefix sum\n        # max_area = 0\n        # prefix_sum = [0]\n        # for h in height:\n        #     prefix_sum.append(prefix_sum[-1] + h)\n        # for i in range(len(height)):\n        #     max_area = max(max_area, (prefix_sum[-1] - prefix_sum[i]) * height[i])\n        # return max_area\n        \n        # O(n) time and O(1) space\n        # Prefix sum\n        # max_area = 0\n        # prefix_sum = [0]\n        # for h in height:\n        #     prefix_sum.append(prefix_sum[-1] + h)\n        # for i in range(len(height)):\n        #     max_area = max(max_area, (prefix_sum[-1] - prefix_sum[i]) * height[i])\n        # return max_area\n        \n        # O(n) time and O(1) space\n        # Prefix sum\n        # max_area = 0\n        # prefix_sum = [0]\n        # for h in height:\n        #     prefix_sum.append(prefix_sum[-1] + h)\n        # for i in range(len(height)):\n        #     max_area = max(max_area, (prefix_sum[-1] - prefix_sum[i]) * height[i])\n        # return max_area\n        \n        # O"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time: O(N^2)\n        # Space: O(N)\n        # 1. Build a set of words\n        # 2. Iterate through each word in words\n        # 3. For each word, check if it can be formed by concatenating other words in the set\n        # 4. If it can, add it to the result\n        # 5. If it cannot, add it to the set\n        \n        word_set = set(words)\n        result = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        \n        return result\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and (suffix in word_set or self.dfs(suffix, word_set)):\n                return True\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        \n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res if sign == 1 else \"-\" + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row + col}, diag2 | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.'] * n for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        return nums[-1] if len(nums) < 3 else nums[-3]"}]}