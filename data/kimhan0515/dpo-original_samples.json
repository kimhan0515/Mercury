{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            next_i, next_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= next_i < m and 0 <= next_j < n and not visited[next_i][next_j]:\n                i, j = next_i, next_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            next_i, next_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= next_i < m and 0 <= next_j < n and not visited[next_i][next_j]:\n                i, j = next_i, next_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = 0\n        end = 0\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                end += 1\n            else:\n                if start == end:\n                    res.append(str(nums[start]))\n                else:\n                    res.append(str(nums[start]) + \"->\" + str(nums[end]))\n                start = i\n                end = i\n        \n        if start == end:\n            res.append(str(nums[start]))\n        else:\n            res.append(str(nums[start]) + \"->\" + str(nums[end]))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = 0\n        end = 0\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                end += 1\n            else:\n                if start == end:\n                    res.append(str(nums[start]))\n                else:\n                    res.append(str(nums[start]) + \"->\" + str(nums[end]))\n                start = i\n                end = i\n        \n        if start == end:\n            res.append(str(nums[start]))\n        else:\n            res.append(str(nums[start]) + \"->\" + str(nums[end]))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        # 3. If the current number is positive and less than the length of the array, check if the current number is equal to the index of the current number\n        # 4. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, return the current number\n        # 5. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 6. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 7. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 8. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 9. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 10. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 11. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 12. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 13. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 14. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 15. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 16. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 17. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 18. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 19. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 20. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 21. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 22. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 23. If the current"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Sort the array\n        ## 2. Iterate through the array and check if the current number is positive\n        ## 3. If the current number is positive, check if the current number is equal to the index of the current number\n        ## 4. If the current number is positive and the current number is equal to the index of the current number, continue to the next number\n        ## 5. If the current number is positive and the current number is not equal to the index of the current number, return the index of the current number\n        \n        ## 1. Sort the array\n        nums.sort()\n        \n        ## 2. Iterate through the array and check if the current number is positive\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                ## 3. If the current number is positive, check if the current number is equal to the index of the current number\n                if nums[i] == i:\n                    continue\n                else:\n                    ## 4. If the current number is positive and the current number is equal to the index of the current number, continue to the next number\n                    return i\n        \n        ## 5. If the current number is positive and the current number is not equal to the index of the current number, return the index of the current number\n        return len(nums)"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Sort the array\n        ## 2. Iterate through the array and check if the current number is positive\n        ## 3. If the current number is positive, check if the current number is equal to the index\n        ## 4. If the current number is positive and the current number is equal to the index, move to the next number\n        ## 5. If the current number is positive and the current number is not equal to the index, return the current number\n        \n        ## 1. Sort the array\n        nums.sort()\n        \n        ## 2. Iterate through the array and check if the current number is positive\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                ## 3. If the current number is positive, check if the current number is equal to the index\n                if nums[i] == i + 1:\n                    ## 4. If the current number is positive and the current number is equal to the index, move to the next number\n                    continue\n                ## 5. If the current number is positive and the current number is not equal to the index, return the current number\n                return i + 1\n        ## 6. If the array is empty, return 1\n        return 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Iterate through the array and check if the current number is positive and not equal to the current index\n        # 3. If the current number is positive and not equal to the current index, swap the current number with the number at the current index\n        # 4. Repeat step 3 until the current number is positive and not equal to the current index\n        # 5. Iterate through the array again and check if the current number is positive and not equal to the current index\n        # 6. If the current number is positive and not equal to the current index, return the current index + 1\n        # 7. If the current number is positive and equal to the current index, continue to the next iteration\n        # 8. If the current number is not positive, return the length of the array + 1\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Iterate through the array and check if the current number is positive and not equal to the current index\n        # 3. If the current number is positive and not equal to the current index, swap the current number with the number at the current index\n        # 4. Repeat step 3 until the current number is positive and not equal to the current index\n        # 5. Iterate through the array again and check if the current number is positive and not equal to the current index\n        # 6. If the current number is positive and not equal to the current index, return the current index + 1\n        # 7. If the current number is positive and equal to the current index, continue to the next iteration\n        # 8. If the current number is not positive, return the length of the array + 1\n        \n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] != i + 1:\n                nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]\n        \n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] != i + 1:\n                return i + 1\n        \n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert all negative numbers to positive numbers\n        ## 2. convert all numbers to their corresponding index\n        ## 3. iterate through the array and check if the index is valid\n        ## 4. if the index is valid, check if the number at that index is valid\n        ## 5. if the number at that index is valid, check if the number at that index is valid\n        ## 6. if the number at that index is valid, check if the number at that index is valid\n        ## 7. if the number at that index is valid, check if the number at that index is valid\n        ## 8. if the number at that index is valid, check if the number at that index is valid\n        ## 9. if the number at that index is valid, check if the number at that index is valid\n        ## 10. if the number at that index is valid, check if the number at that index is valid\n        ## 11. if the number at that index is valid, check if the number at that index is valid\n        ## 12. if the number at that index is valid, check if the number at that index is valid\n        ## 13. if the number at that index is valid, check if the number at that index is valid\n        ## 14. if the number at that index is valid, check if the number at that index is valid\n        ## 15. if the number at that index is valid, check if the number at that index is valid\n        ## 16. if the number at that index is valid, check if the number at that index is valid\n        ## 17. if the number at that index is valid, check if the number at that index is valid\n        ## 18. if the number at that index is valid, check if the number at that index is valid\n        ## 19. if the number at that index is valid, check if the number at that index is valid\n        ## 20. if the number at that index is valid, check if the number at that index is valid\n        ## 21. if the number at that index is valid, check if the number at that index is valid\n        ## 22. if the number at that index is valid, check if the number at that index is valid\n        ## 23. if the number at that index is valid, check if the number at that index is valid\n        ## 24. if the number at that index is valid, check if the number at that index is valid\n        ## 25. if the number at that index is valid, check if the number at that index is valid\n        ## 26. if the number at that index is valid, check if the number at that index is valid\n        ## 27. if the number at that index is valid, check if the number at that index is valid\n        ## 28. if the number at that index is valid, check if the number at that index is valid\n        ## 29. if the number at that index is valid, check if the number at that index is valid\n        ## 30. if the number at that index is valid, check if the number at that index is valid\n        ## 31. if the number at that index is valid, check if the number at that index is valid\n        ## 32. if the number at that index is valid, check if the number at that index is valid\n        ## 33. if the number at that index is valid, check if the number at that index is valid\n        ## 34. if the number at that index is valid, check if the number at that index is valid\n        ## 35. if the number at that index is valid, check if the number at that index is valid\n        ## 36. if the number at that index is valid, check if the number at that index is valid\n        ## 37. if the number at that index is valid, check if the number at that index is valid\n        ## 38. if the number at that index is valid, check if the number at that index is valid\n        ## 39. if the number at that index is valid, check if the number at that index is valid\n        ## 40. if the number at that index is valid, check if the number at that index is valid\n        ## 41. if the number at that index is valid, check if the number at that index is"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of [1, 2, 3, ..., n]\n        # 1.2 generate all permutations of [1, 2, 3, ..., n]\n        # 1.3 generate all permutations of [1, 2, 3, ..., n]\n        # 1.4 generate all permutations of [1, 2, 3, ..., n]\n        # 1.5 generate all permutations of [1, 2, 3, ..., n]\n        # 1.6 generate all permutations of [1, 2, 3, ..., n]\n        # 1.7 generate all permutations of [1, 2, 3, ..., n]\n        # 1.8 generate all permutations of [1, 2, 3, ..., n]\n        # 1.9 generate all permutations of [1, 2, 3, ..., n]\n        # 1.10 generate all permutations of [1, 2, 3, ..., n]\n        # 1.11 generate all permutations of [1, 2, 3, ..., n]\n        # 1.12 generate all permutations of [1, 2, 3, ..., n]\n        # 1.13 generate all permutations of [1, 2, 3, ..., n]\n        # 1.14 generate all permutations of [1, 2, 3, ..., n]\n        # 1.15 generate all permutations of [1, 2, 3, ..., n]\n        # 1.16 generate all permutations of [1, 2, 3, ..., n]\n        # 1.17 generate all permutations of [1, 2, 3, ..., n]\n        # 1.18 generate all permutations of [1, 2, 3, ..., n]\n        # 1.19 generate all permutations of [1, 2, 3, ..., n]\n        # 1.20 generate all permutations of [1, 2, 3, ..., n]\n        # 1.21 generate all permutations of [1, 2, 3, ..., n]\n        # 1.22 generate all permutations of [1, 2, 3, ..., n]\n        # 1.23 generate all permutations of [1, 2, 3, ..., n]\n        # 1.24 generate all permutations of [1, 2, 3, ..., n]\n        # 1.25 generate all permutations of [1, 2, 3, ..., n]\n        # 1.26 generate all permutations of [1, 2, 3, ..., n]\n        # 1.27 generate all permutations of [1, 2, 3, ..., n]\n        # 1.28 generate all permutations of [1, 2, 3, ..., n]\n        # 1.29 generate all permutations of [1, 2, 3, ..., n]\n        # 1.30 generate all permutations of [1, 2, 3, ..., n]\n        # 1.31 generate all permutations of [1, 2, 3, ..., n]\n        # 1.32 generate all permutations of [1, 2, 3, ..., n]\n        # 1.33 generate all permutations of [1, 2, 3, ..., n]\n        # 1.34 generate all permutations of [1, 2, 3, ..., n]\n        # 1.35 generate all permutations of [1, 2, 3, ..., n]\n        # 1.36 generate all permutations of [1, 2, 3, ..., n]\n        # 1.37 generate all permutations of [1, 2, 3, ..., n]\n        # 1.38 generate all permutations of [1, 2, 3, ..., n]"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1, 2, ..., n\n        # 1.2 generate all permutations of 1, 2, ..., n-1\n        # 1.3 generate all permutations of 1, 2, ..., n-2\n        # 1.4 ...\n        # 1.5 generate all permutations of 1, 2, ..., n-k+1\n        # 1.6 generate all permutations of 1, 2, ..., n-k\n        # 1.7 generate all permutations of 1, 2, ..., n-k-1\n        # 1.8 ...\n        # 1.9 generate all permutations of 1, 2, ..., n-k-2\n        # 1.10 generate all permutations of 1, 2, ..., n-k-3\n        # 1.11 ...\n        # 1.12 generate all permutations of 1, 2, ..., n-k-k\n        # 1.13 generate all permutations of 1, 2, ..., n-k-k-1\n        # 1.14 ...\n        # 1.15 generate all permutations of 1, 2, ..., n-k-k-2\n        # 1.16 ...\n        # 1.17 generate all permutations of 1, 2, ..., n-k-k-3\n        # 1.18 ...\n        # 1.19 generate all permutations of 1, 2, ..., n-k-k-4\n        # 1.20 ...\n        # 1.21 generate all permutations of 1, 2, ..., n-k-k-5\n        # 1.22 ...\n        # 1.23 generate all permutations of 1, 2, ..., n-k-k-6\n        # 1.24 ...\n        # 1.25 generate all permutations of 1, 2, ..., n-k-k-7\n        # 1.26 ...\n        # 1.27 generate all permutations of 1, 2, ..., n-k-k-8\n        # 1.28 ...\n        # 1.29 generate all permutations of 1, 2, ..., n-k-k-9\n        # 1.30 ...\n        # 1.31 generate all permutations of 1, 2, ..., n-k-k-10\n        # 1.32 ...\n        # 1.33 generate all permutations of 1, 2, ..., n-k-k-11\n        # 1.34 ...\n        # 1.35 generate all permutations of 1, 2, ..., n-k-k-12\n        # 1.36 ...\n        # 1.37 generate all permutations of 1, 2, ..., n-k-k-13\n        # 1.38 ...\n        # 1.39 generate all permutations of 1, 2, ..., n-k-k-14\n        # 1.40 ...\n        # 1.41 generate all permutations of 1, 2, ..., n-k-k-15\n        # 1.42 ...\n        # 1.43 generate all permutations of 1, 2, ..., n-k-k-16\n        # 1.44 ...\n        # 1.45 generate all permutations of 1, 2, ..., n-k-k-17\n        # 1.46 ...\n        # 1.47 generate all permutations of 1, 2, ..., n-k-k-18\n        # 1.48 ...\n        # 1.49 generate all permutations of 1, 2, ..., n-k-k-19\n        # 1.50 ...\n        # 1.51 generate all permutations of 1, 2, ..., n-k"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1 to n\n        # 1.2 generate all permutations of 2 to n\n        # 1.3 generate all permutations of 3 to n\n        # 1.4 ...\n        # 1.5 generate all permutations of n to n\n        # 1.6 generate all permutations of n-1 to n\n        # 1.7 ...\n        # 1.8 generate all permutations of 1 to n\n        \n        # 2. find the kth permutation\n        # 2.1 find the kth permutation of 1 to n\n        # 2.2 find the kth permutation of 2 to n\n        # 2.3 find the kth permutation of 3 to n\n        # 2.4 ...\n        # 2.5 find the kth permutation of n to n\n        # 2.6 find the kth permutation of n-1 to n\n        # 2.7 ...\n        # 2.8 find the kth permutation of 1 to n\n        \n        # 3. return the kth permutation\n        # 3.1 return the kth permutation of 1 to n\n        # 3.2 return the kth permutation of 2 to n\n        # 3.3 return the kth permutation of 3 to n\n        # 3.4 ...\n        # 3.5 return the kth permutation of n to n\n        # 3.6 return the kth permutation of n-1 to n\n        # 3.7 ...\n        # 3.8 return the kth permutation of 1 to n\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1 to n\n        # 1.2 generate all permutations of 2 to n\n        # 1.3 generate all permutations of 3 to n\n        # 1.4 ...\n        # 1.5 generate all permutations of n to n\n        # 1.6 generate all permutations of n-1 to n\n        # 1.7 ...\n        # 1.8 generate all permutations of 1 to n\n        \n        # 2. find the kth permutation\n        # 2.1 find the kth permutation of 1 to n\n        # 2.2 find the kth permutation of 2 to n\n        # 2.3 find the kth permutation of 3 to n\n        # 2.4 ...\n        # 2.5 find the kth permutation of n to n\n        # 2.6 find the kth permutation of n-1 to n\n        # 2.7 ...\n        # 2.8 find the kth permutation of 1 to n\n        \n        # 3. return the kth permutation\n        # 3.1 return the kth permutation of 1 to n\n        # 3.2 return the kth permutation of 2 to n\n        # 3.3 return the kth permutation of 3 to n\n        # 3.4 ...\n        # 3.5 return the kth permutation of n to n\n        # 3.6 return the kth permutation of n-1 to n\n        # 3.7 ...\n        # 3.8 return the kth permutation of 1 to n\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1 to n\n        # 1.2 generate all permutations of 2 to n\n        # 1.3 generate all permutations of 3 to n\n        # 1.4 ...\n        # 1.5 generate all permutations of n to n\n        # 1.6 generate all permutations of n-1 to n\n        # 1.7 ...\n        # 1.8 generate all permutations of 1 to n\n        \n        # 2. find the kth permutation\n        # 2.1 find the kth permutation of 1 to n\n        # 2.2 find the kth permutation of 2 to n\n        # 2.3 find the kth permutation of 3 to"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                # return the indices of the two numbers\n                return [num_dict[target - num] + 1, i + 1]\n            # add the number to the dictionary with its index\n            num_dict[num] = i"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                # return the indices of the two numbers\n                return [num_dict[target - num] + 1, i + 1]\n            # add the number to the dictionary with its index\n            num_dict[num] = i"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        ## Two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                left += 1\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, op, res):\n            if i == len(num):\n                if curr == target and op == '+':\n                    res.append(curr)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if op == '+':\n                    backtrack(j + 1, curr, curr, '+', res)\n                elif op == '-':\n                    backtrack(j + 1, curr - prev, -curr, '-', res)\n                elif op == '*':\n                    backtrack(j + 1, curr * prev, curr, '*', res)\n                curr = curr // 10\n        \n        res = []\n        backtrack(0, 0, 0, '+', res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, op, res):\n            if i == len(num):\n                if curr == target and op == '+':\n                    res.append(curr)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if op == '+':\n                    backtrack(j + 1, curr, curr, '+', res)\n                elif op == '-':\n                    backtrack(j + 1, curr - prev, -curr, '-', res)\n                elif op == '*':\n                    backtrack(j + 1, curr * prev, curr, '*', res)\n                curr = curr // 10\n        \n        res = []\n        backtrack(0, 0, 0, '+', res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if op == '':\n                    backtrack(j+1, curr, curr, res, num[i])\n                else:\n                    backtrack(j+1, curr, curr + prev, res, op + '+' + num[i])\n                    backtrack(j+1, curr, curr - prev, res, op + '-' + num[i])\n                    backtrack(j+1, curr, curr * prev, res, op + '*' + num[i])\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prev + curr, res)\n                    backtrack(j+1, curr, prev - curr, prev - curr, res)\n                    backtrack(j+1, curr, prev * curr, prev * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 1, res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, op, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(''.join(path))\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if op == '+':\n                    backtrack(j+1, curr + curr, curr, '+', res)\n                elif op == '-':\n                    backtrack(j+1, curr - curr, -curr, '-', res)\n                elif op == '*':\n                    backtrack(j+1, curr * curr, curr * prev, '*', res)\n        \n        res = []\n        backtrack(0, 0, 0, '+', res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left_sum = dfs(root.left, curr_sum * 10 + root.val)\n            right_sum = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left_sum + right_sum\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas in the tank\n        total_gas = sum(gas)\n        \n        ## 2. Find the total cost of the gas\n        total_cost = sum(cost)\n        \n        ## 3. If the total gas is less than the total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 4. Find the starting point\n        start = 0\n        \n        ## 5. Find the total gas in the tank\n        tank = 0\n        \n        ## 6. Loop through the gas and cost\n        for i in range(len(gas)):\n            \n            ## 7. Add the gas and cost\n            tank += gas[i] - cost[i]\n            \n            ## 8. If the tank is less than 0, reset the tank and start point\n            if tank < 0:\n                tank = 0\n                start = i + 1\n                \n        ## 9. Return the starting point\n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the sum of gas and cost\n        ## 2. find the sum of gas and cost\n        ## 3. find the sum of gas and cost\n        ## 4. find the sum of gas and cost\n        ## 5. find the sum of gas and cost\n        ## 6. find the sum of gas and cost\n        ## 7. find the sum of gas and cost\n        ## 8. find the sum of gas and cost\n        ## 9. find the sum of gas and cost\n        ## 10. find the sum of gas and cost\n        ## 11. find the sum of gas and cost\n        ## 12. find the sum of gas and cost\n        ## 13. find the sum of gas and cost\n        ## 14. find the sum of gas and cost\n        ## 15. find the sum of gas and cost\n        ## 16. find the sum of gas and cost\n        ## 17. find the sum of gas and cost\n        ## 18. find the sum of gas and cost\n        ## 19. find the sum of gas and cost\n        ## 20. find the sum of gas and cost\n        ## 21. find the sum of gas and cost\n        ## 22. find the sum of gas and cost\n        ## 23. find the sum of gas and cost\n        ## 24. find the sum of gas and cost\n        ## 25. find the sum of gas and cost\n        ## 26. find the sum of gas and cost\n        ## 27. find the sum of gas and cost\n        ## 28. find the sum of gas and cost\n        ## 29. find the sum of gas and cost\n        ## 30. find the sum of gas and cost\n        ## 31. find the sum of gas and cost\n        ## 32. find the sum of gas and cost\n        ## 33. find the sum of gas and cost\n        ## 34. find the sum of gas and cost\n        ## 35. find the sum of gas and cost\n        ## 36. find the sum of gas and cost\n        ## 37. find the sum of gas and cost\n        ## 38. find the sum of gas and cost\n        ## 39. find the sum of gas and cost\n        ## 40. find the sum of gas and cost\n        ## 41. find the sum of gas and cost\n        ## 42. find the sum of gas and cost\n        ## 43. find the sum of gas and cost\n        ## 44. find the sum of gas and cost\n        ## 45. find the sum of gas and cost\n        ## 46. find the sum of gas and cost\n        ## 47. find the sum of gas and cost\n        ## 48. find the sum of gas and cost\n        ## 49. find the sum of gas and cost\n        ## 50. find the sum of gas and cost\n        ## 51. find the sum of gas and cost\n        ## 52. find the sum of gas and cost\n        ## 53. find the sum of gas and cost\n        ## 54. find the sum of gas and cost\n        ## 55. find the sum of gas and cost\n        ## 56. find the sum of gas and cost\n        ## 57. find the sum of gas and cost\n        ## 58. find the sum of gas and cost\n        ## 59. find the sum of gas and cost\n        ## 60. find the sum of gas and cost\n        ## 61. find the sum of gas and cost\n        ## 62. find the sum of gas and cost\n        ## 63. find the sum of gas and cost\n        ## 64. find the sum of gas and cost\n        ## 65. find the sum of gas and cost\n        ## 66. find the sum of gas and cost\n        ## 67. find the sum of gas and cost\n        ## 68. find the sum of gas and cost\n        ## 69. find the sum of gas and"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the sum of gas and cost\n        ## 2. find the sum of gas and cost\n        ## 3. find the sum of gas and cost\n        ## 4. find the sum of gas and cost\n        ## 5. find the sum of gas and cost\n        ## 6. find the sum of gas and cost\n        ## 7. find the sum of gas and cost\n        ## 8. find the sum of gas and cost\n        ## 9. find the sum of gas and cost\n        ## 10. find the sum of gas and cost\n        ## 11. find the sum of gas and cost\n        ## 12. find the sum of gas and cost\n        ## 13. find the sum of gas and cost\n        ## 14. find the sum of gas and cost\n        ## 15. find the sum of gas and cost\n        ## 16. find the sum of gas and cost\n        ## 17. find the sum of gas and cost\n        ## 18. find the sum of gas and cost\n        ## 19. find the sum of gas and cost\n        ## 20. find the sum of gas and cost\n        ## 21. find the sum of gas and cost\n        ## 22. find the sum of gas and cost\n        ## 23. find the sum of gas and cost\n        ## 24. find the sum of gas and cost\n        ## 25. find the sum of gas and cost\n        ## 26. find the sum of gas and cost\n        ## 27. find the sum of gas and cost\n        ## 28. find the sum of gas and cost\n        ## 29. find the sum of gas and cost\n        ## 30. find the sum of gas and cost\n        ## 31. find the sum of gas and cost\n        ## 32. find the sum of gas and cost\n        ## 33. find the sum of gas and cost\n        ## 34. find the sum of gas and cost\n        ## 35. find the sum of gas and cost\n        ## 36. find the sum of gas and cost\n        ## 37. find the sum of gas and cost\n        ## 38. find the sum of gas and cost\n        ## 39. find the sum of gas and cost\n        ## 40. find the sum of gas and cost\n        ## 41. find the sum of gas and cost\n        ## 42. find the sum of gas and cost\n        ## 43. find the sum of gas and cost\n        ## 44. find the sum of gas and cost\n        ## 45. find the sum of gas and cost\n        ## 46. find the sum of gas and cost\n        ## 47. find the sum of gas and cost\n        ## 48. find the sum of gas and cost\n        ## 49. find the sum of gas and cost\n        ## 50. find the sum of gas and cost\n        ## 51. find the sum of gas and cost\n        ## 52. find the sum of gas and cost\n        ## 53. find the sum of gas and cost\n        ## 54. find the sum of gas and cost\n        ## 55. find the sum of gas and cost\n        ## 56. find the sum of gas and cost\n        ## 57. find the sum of gas and cost\n        ## 58. find the sum of gas and cost\n        ## 59. find the sum of gas and cost\n        ## 60. find the sum of gas and cost\n        ## 61. find the sum of gas and cost\n        ## 62. find the sum of gas and cost\n        ## 63. find the sum of gas and cost\n        ## 64. find the sum of gas and cost\n        ## 65. find the sum of gas and cost\n        ## 66. find the sum of gas and cost\n        ## 67. find the sum of gas and cost\n        ## 68. find the sum of gas and cost\n        ## 69. find the sum of gas and"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas in the tank\n        total_gas = 0\n        for i in range(len(gas)):\n            total_gas += gas[i] - cost[i]\n        \n        ## 2. If the total gas is less than 0, return -1\n        if total_gas < 0:\n            return -1\n        \n        ## 3. Find the starting point\n        start = 0\n        while start < len(gas):\n            ## 4. Find the gas in the tank\n            tank = 0\n            i = start\n            while i < len(gas):\n                tank += gas[i] - cost[i]\n                if tank < 0:\n                    break\n                i += 1\n            if i == len(gas):\n                return start\n            start += 1\n        return -1"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the sum of gas and cost\n        ## 2. find the sum of gas and cost\n        ## 3. find the sum of gas and cost\n        ## 4. find the sum of gas and cost\n        ## 5. find the sum of gas and cost\n        ## 6. find the sum of gas and cost\n        ## 7. find the sum of gas and cost\n        ## 8. find the sum of gas and cost\n        ## 9. find the sum of gas and cost\n        ## 10. find the sum of gas and cost\n        ## 11. find the sum of gas and cost\n        ## 12. find the sum of gas and cost\n        ## 13. find the sum of gas and cost\n        ## 14. find the sum of gas and cost\n        ## 15. find the sum of gas and cost\n        ## 16. find the sum of gas and cost\n        ## 17. find the sum of gas and cost\n        ## 18. find the sum of gas and cost\n        ## 19. find the sum of gas and cost\n        ## 20. find the sum of gas and cost\n        ## 21. find the sum of gas and cost\n        ## 22. find the sum of gas and cost\n        ## 23. find the sum of gas and cost\n        ## 24. find the sum of gas and cost\n        ## 25. find the sum of gas and cost\n        ## 26. find the sum of gas and cost\n        ## 27. find the sum of gas and cost\n        ## 28. find the sum of gas and cost\n        ## 29. find the sum of gas and cost\n        ## 30. find the sum of gas and cost\n        ## 31. find the sum of gas and cost\n        ## 32. find the sum of gas and cost\n        ## 33. find the sum of gas and cost\n        ## 34. find the sum of gas and cost\n        ## 35. find the sum of gas and cost\n        ## 36. find the sum of gas and cost\n        ## 37. find the sum of gas and cost\n        ## 38. find the sum of gas and cost\n        ## 39. find the sum of gas and cost\n        ## 40. find the sum of gas and cost\n        ## 41. find the sum of gas and cost\n        ## 42. find the sum of gas and cost\n        ## 43. find the sum of gas and cost\n        ## 44. find the sum of gas and cost\n        ## 45. find the sum of gas and cost\n        ## 46. find the sum of gas and cost\n        ## 47. find the sum of gas and cost\n        ## 48. find the sum of gas and cost\n        ## 49. find the sum of gas and cost\n        ## 50. find the sum of gas and cost\n        ## 51. find the sum of gas and cost\n        ## 52. find the sum of gas and cost\n        ## 53. find the sum of gas and cost\n        ## 54. find the sum of gas and cost\n        ## 55. find the sum of gas and cost\n        ## 56. find the sum of gas and cost\n        ## 57. find the sum of gas and cost\n        ## 58. find the sum of gas and cost\n        ## 59. find the sum of gas and cost\n        ## 60. find the sum of gas and cost\n        ## 61. find the sum of gas and cost\n        ## 62. find the sum of gas and cost\n        ## 63. find the sum of gas and cost\n        ## 64. find the sum of gas and cost\n        ## 65. find the sum of gas and cost\n        ## 66. find the sum of gas and cost\n        ## 67. find the sum of gas and cost\n        ## 68. find the sum of gas and cost\n        ## 69. find the sum of gas and"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # add 1 to the end and start\n        nums = [1] + nums + [1]\n        \n        # create a 2d array to store the max coins for each subproblem\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        \n        # fill the dp array with the max coins for each subproblem\n        for i in range(len(nums) - 2, -1, -1):\n            for j in range(i + 2, len(nums)):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][len(nums) - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # add 1 to the end and start\n        nums = [1] + nums + [1]\n        \n        # create a dp table\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        \n        # fill the dp table\n        for i in range(len(nums) - 2, -1, -1):\n            for j in range(i + 2, len(nums)):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][len(nums) - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1.pop(0)\n                    else:\n                        out.append(nums2[0])\n                        nums2.pop(0)\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1.pop(0)\n                else:\n                    out.append(nums2[0])\n                    nums2.pop(0)\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5(nums1, nums2["}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1 = nums1[1:]\n                    else:\n                        out.append(nums2[0])\n                        nums2 = nums2[1:]\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    out.append(nums2[0])\n                    nums2 = nums2[1:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5("}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1.pop(0)\n                    else:\n                        out.append(nums2[0])\n                        nums2.pop(0)\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1.pop(0)\n                else:\n                    out.append(nums2[0])\n                    nums2.pop(0)\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5(nums1, nums2["}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1.pop(0)\n                    else:\n                        out.append(nums2[0])\n                        nums2.pop(0)\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1.pop(0)\n                else:\n                    out.append(nums2[0])\n                    nums2.pop(0)\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5(nums1, nums2["}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1.pop(0)\n                    else:\n                        out.append(nums2[0])\n                        nums2.pop(0)\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1.pop(0)\n                else:\n                    out.append(nums2[0])\n                    nums2.pop(0)\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5(nums1, nums2["}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i\n                if i != num // i:\n                    sum += num // i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i == num / i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i\n                if i != num // i:\n                    sum += num // i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i\n                if i ** 2 != num:\n                    sum += num / i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i == num / i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            m = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= m:\n                    j += 1\n                cnt += j - i - 1\n            if cnt < k:\n                l = m + 1\n            else:\n                r = m\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            m = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= m:\n                    j += 1\n                cnt += j - i - 1\n            if cnt < k:\n                l = m + 1\n            else:\n                r = m\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        \n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        \n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        \n        vowel_indices.reverse()\n        \n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        \n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the difference\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Calculate the sum of all the numbers in the array\n        ## 2. Calculate the sum of all the numbers in the range [0, n]\n        ## 3. Subtract the sum of all the numbers in the range [0, n] from the sum of all the numbers in the array\n        ## 4. Return the result\n        \n        ## Initialization\n        n = len(nums)\n        sum_all = sum(nums)\n        sum_range = (n * (n + 1)) / 2\n        \n        ## Return the result\n        return sum_range - sum_all"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # 1. Create a graph\n        # 2. Add all the words in wordList to the graph\n        # 3. BFS\n        # 4. Return the distance between beginWord and endWord\n        \n        # Create a graph\n        graph = collections.defaultdict(list)\n        \n        # Add all the words in wordList to the graph\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        distance = 1\n        visited = set([beginWord])\n        \n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    pattern = word[:i] + \"*\" + word[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return distance + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            distance += 1\n        \n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # 1. Create a graph\n        # 2. BFS\n        # 3. Return distance\n        \n        # Create a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        distance = 1\n        visited = set([beginWord])\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    pattern = word[:i] + \"*\" + word[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return distance + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            distance += 1\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        res = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 0\n            else:\n                if carry == 1:\n                    res = '0' + res\n                else:\n                    res = '1' + res\n                carry = 1\n        if carry == 1:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        res = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 0\n            else:\n                if carry == 1:\n                    res = '0' + res\n                else:\n                    res = '1' + res\n                carry = 1\n        if carry == 1:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        res = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 0\n            else:\n                if carry == 1:\n                    res = '0' + res\n                else:\n                    res = '1' + res\n                carry = 1\n        if carry == 1:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        result = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 0\n            else:\n                if carry == 1:\n                    result = '0' + result\n                else:\n                    result = '1' + result\n                carry = 1\n        \n        if carry == 1:\n            result = '1' + result\n        \n        return result"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)[2:]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if target < nums[mid]:\n                    right = mid - 1\n                elif target > nums[mid]:\n                    left = mid + 1\n                else:\n                    index = mid\n                    if find_left_index:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if target > nums[mid]:\n                    left = mid + 1\n                elif target < nums[mid]:\n                    right = mid - 1\n                else:\n                    index = mid\n                    if find_first:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            return index\n        \n        first_index = binary_search(nums, target, True)\n        if first_index == -1:\n            return [-1, -1]\n        last_index = binary_search(nums, target, False)\n        return [first_index, last_index]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if target < nums[mid]:\n                    right = mid - 1\n                elif target > nums[mid]:\n                    left = mid + 1\n                else:\n                    index = mid\n                    if find_left_index:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_first and nums[mid] == target):\n                    right = mid - 1\n                    index = mid\n                else:\n                    left = mid + 1\n            return index\n        \n        def search_range(nums, target):\n            first_index = binary_search(nums, target, True)\n            last_index = binary_search(nums, target, False)\n            return [first_index, last_index]\n        \n        return search_range(nums, target)"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n            \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n            \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n            \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n                \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n                \n        return dp[-1][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        \n        for i in range(len(hex_list)):\n            if hex_list[i] >= 10:\n                hex_list[i] = hex_dict[hex_list[i]]\n        \n        return ''.join(map(str, hex_list))"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder >= 10:\n                hex_list.append(hex_dict[remainder])\n            else:\n                hex_list.append(str(remainder))\n            num = num // 16\n        \n        hex_list.reverse()\n        return ''.join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 2 ** 32 + num\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        return ''.join(hex_list[::-1])"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            rem = num % 16\n            if rem < 10:\n                hex_list.append(str(rem))\n            else:\n                hex_list.append(hex_dict[rem])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and count the number of occurrences of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the first character with a count of 1\n        for i, char in enimport enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Hashmap\n        ## Time: O(n)\n        ## Space: O(1)\n        ## hashmap = {}\n        ## for i in range(len(s)):\n        ##     if s[i] not in hashmap:\n        ##         hashmap[s[i]] = i\n        ##     else:\n        ##         hashmap[s[i]] = -1\n        ## for i in range(len(s)):\n        ##     if hashmap[s[i]] != -1:\n        ##         return hashmap[s[i]]\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##     if s.count(s[i]) == 1:\n        ##         return i\n        ## return -1\n        \n        ## Two pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## for i in range(len(s)):\n        ##"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate through the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with frequency 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-20\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB,"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate through the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with frequency 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n                    return True\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. check if the difference between the current and the next element is less than the indexDiff\n        # 4. check if the difference between the current and the next element is less than the valueDiff\n        # 5. if the condition is true, return true\n        # 6. if the condition is false, return false\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. iterate through the array\n        for i in range(len(nums)-1):\n            # 3. check if the difference between the current and the next element is less than the indexDiff\n            if abs(nums[i] - nums[i+1]) <= indexDiff:\n                # 4. check if the difference between the current and the next element is less than the valueDiff\n                if abs(nums[i] - nums[i+1]) <= valueDiff:\n                    return True\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert the strings to integers\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add the integers\n        sum = num1 + num2\n        \n        # convert the sum to a string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert the strings to integers\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add the integers\n        sum = num1 + num2\n        \n        # convert the sum to a string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                curr = int(num1[i]) + int(num2[i]) + carry\n            else:\n                curr = int(num1[i]) + carry\n            \n            carry = curr // 10\n            res.append(str(curr % 10))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                val = int(num1[i]) + int(num2[i]) + carry\n            else:\n                val = int(num1[i]) + carry\n            \n            carry = val // 10\n            res.append(str(val % 10))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. convert to int\n        ## 2. add\n        ## 3. convert to str\n        \n        ## 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        ## 2. add\n        sum = num1 + num2\n        \n        ## 3. convert to str\n        sum = str(sum)\n        \n        return sum"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                elif s[i] == '+':\n                    i += 1\n                    res += sign * helper(s, i, 1)\n                    i += 1\n                elif s[i] == '-':\n                    i += 1\n                    res += sign * helper(s, i, -1)\n                    i += 1\n                elif s[i] == '(':\n                    i += 1\n                    res += sign * helper(s, i, helper(s, i, 1))\n                    i += 1\n                else:\n                    res += sign * int(s[i])\n                    i += 1\n            return res\n        \n        return helper(s, 0, 1)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                    continue\n                if s[i] == '(':\n                    res += sign * helper(s, i + 1, -1)\n                    i = helper(s, i + 1, 1)\n                elif s[i] == ')':\n                    return res\n                else:\n                    num = 0\n                    while i < len(s) and s[i].isdigit():\n                        num = num * 10 + int(s[i])\n                        i += 1\n                    res += sign * num\n            return res\n        \n        return helper(s, 0, 1)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                    continue\n                if s[i] == '(':\n                    res += sign * helper(s, i + 1, -1)\n                    i = helper(s, i + 1, 1)\n                elif s[i] == ')':\n                    return res\n                else:\n                    num = 0\n                    while i < len(s) and s[i].isdigit():\n                        num = num * 10 + int(s[i])\n                        i += 1\n                    res += sign * num\n            return res\n        \n        return helper(s, 0, 1)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                elif s[i] == '+':\n                    i += 1\n                    res += sign * helper(s, i, 1)\n                    i += 1\n                elif s[i] == '-':\n                    i += 1\n                    res += sign * helper(s, i, -1)\n                    i += 1\n                elif s[i] == '(':\n                    i += 1\n                    res += sign * helper(s, i, helper(s, i, 1))\n                    i += 1\n                else:\n                    res += sign * int(s[i])\n                    i += 1\n            return res\n        \n        return helper(s, 0, 1)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '(':\n                res = helper(s, i + 1)\n                i = i + 1\n                while s[i] != ')':\n                    if s[i] == '+':\n                        res += helper(s, i + 1)\n                    elif s[i] == '-':\n                        res -= helper(s, i + 1)\n                    i += 1\n                return res\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 1)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 1)\n            if s[i] == '(':\n                return helper(s, i + 1)\n            if s[i] == ')':\n                return 0\n            res = 0\n            while i < len(s) and s[i] != ' ' and s[i] != '+' and s[i] != '-' and s[i] != '(' and s[i] != ')':\n                res = res * 10 + int(s[i])\n                i += 1\n            return res\n        \n        return helper(s, 0)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        sorted_profits = sorted(profits)\n        \n        # iterate over sorted capital\n        for i in range(len(sorted_capital)):\n            # if we can afford the next project\n            if sorted_capital[i][0] <= w:\n                # add the profit to our capital\n                w += sorted_capital[i][1]\n            # if we have run out of projects\n            else:\n                # break out of loop\n                break\n        \n        # return the capital\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by capital\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort by profits\n        # profits = [1,2,3]\n        # capital = [0,1,1]\n        # sort by profits\n        # profits = [3,2,1]\n        # capital = [1,1,0]\n        # sort"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif i == '}':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n            elif i == ']':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif i == '}':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n            elif i == ']':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')' and stack and stack[-1] == '(':\n                stack.pop()\n            elif i == '}' and stack and stack[-1] == '{':\n                stack.pop()\n            elif i == ']' and stack and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n        return True if not stack else False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, then the array is already sorted in descending order\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray nums[i+1:]\n        nums[i+1:] = nums[i+1:][::-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the point\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, the permutation is the last permutation\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray nums[i+1:]\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the point\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the element is already in the dictionary, return True\n        # If the element is not in the dictionary, add it to the dictionary\n        # If the difference between the current element and the element before it is greater than k, return True\n        # If the difference between the current element and the element before it is less than or equal to k, return False\n        \n        # Create a dictionary\n        d = {}\n        \n        # Iterate through the list\n        for i in range(len(nums)):\n            \n            # If the element is already in the dictionary, return True\n            if nums[i] in d:\n                return True\n            \n            # If the element is not in the dictionary, add it to the dictionary\n            d[nums[i]] = i\n            \n            # If the difference between the current element and the element before it is greater than k, return True\n            if i > 0 and abs(nums[i] - nums[i-1]) <= k:\n                return True\n            \n        # If the difference between the current element and the element before it is less than or equal to k, return False\n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary to store the indices of the elements\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary to store the indices of the elements\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # if the number is already in the dictionary, return True\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and the number in the dictionary is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the current number and"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary to store the indices of the elements\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        \n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        \n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        couples_dict = {}\n        for couple in couples:\n            couples_dict[couple[0]] = couple[1]\n        \n        swaps = 0\n        for couple in couples:\n            if couple[0] != couple[1]:\n                couple_1 = couple[0]\n                couple_2 = couple[1]\n                couple_1_couple_2 = couples_dict[couple_1]\n                couple_2_couple_1 = couples_dict[couple_2]\n                couples_dict[couple_1_couple_2] = couple_2\n                couples_dict[couple_2_couple_1] = couple_1\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        if n == 2:\n            return 0\n        if n == 4:\n            return 1\n        if n == 6:\n            return 2\n        if n == 8:\n            return 3\n        if n == 10:\n            return 4\n        if n == 12:\n            return 5\n        if n == 14:\n            return 6\n        if n == 16:\n            return 7\n        if n == 18:\n            return 8\n        if n == 20:\n            return 9\n        if n == 22:\n            return 10\n        if n == 24:\n            return 11\n        if n == 26:\n            return 12\n        if n == 28:\n            return 13\n        if n == 30:\n            return 14\n        if n == 32:\n            return 15\n        if n == 34:\n            return 16\n        if n == 36:\n            return 17\n        if n == 38:\n            return 18\n        if n == 40:\n            return 19\n        if n == 42:\n            return 20\n        if n == 44:\n            return 21\n        if n == 46:\n            return 22\n        if n == 48:\n            return 23\n        if n == 50:\n            return 24\n        if n == 52:\n            return 25\n        if n == 54:\n            return 26\n        if n == 56:\n            return 27\n        if n == 58:\n            return 28\n        if n == 60:\n            return 29\n        if n == 62:\n            return 30\n        if n == 64:\n            return 31\n        if n == 66:\n            return 32\n        if n == 68:\n            return 33\n        if n == 70:\n            return 34\n        if n == 72:\n            return 35\n        if n == 74:\n            return 36\n        if n == 76:\n            return 37\n        if n == 78:\n            return 38\n        if n == 80:\n            return 39\n        if n == 82:\n            return 40\n        if n == 84:\n            return 41\n        if n == 86:\n            return 42\n        if n == 88:\n            return 43\n        if n == 90:\n            return 44\n        if n == 92:\n            return 45\n        if n == 94:\n            return 46\n        if n == 96:\n            return 47\n        if n == 98:\n            return 48\n        if n == 100:\n            return 49\n        if n == 102:\n            return 50\n        if n == 104:\n            return 51\n        if n == 106:\n            return 52\n        if n == 108:\n            return 53\n        if n == 110:\n            return 54\n        if n == 112:\n            return 55\n        if n == 114:\n            return 56\n        if n == 116:\n            return 57\n        if n == 118:\n            return 58\n        if n == 120:\n            return 59\n        if n == 122:\n            return 60\n        if n == 124:\n            return 61\n        if n == 126:\n            return 62\n        if n == 128:\n            return 63\n        if n == 130:\n            return 64\n        if n == 132:\n            return 65\n        if n == 134:\n            return 66\n        if n == 136:\n            return 67\n        if n == 138:\n            return 68\n        if n == 140:\n            return 69\n        if n == 142:\n            return 70\n        if"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        couples_set = set(couples)\n        \n        swaps = 0\n        for couple in couples:\n            if couple[0] != couple[1] and couple[0]+1 in couples_set and couple[1]+1 in couples_set:\n                couples_set.remove(couple)\n                couples_set.remove((couple[0]+1, couple[1]))\n                couples_set.remove((couple[1]+1, couple[0]))\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        couples_dict = {}\n        for couple in couples:\n            couples_dict[couple[0]] = couple[1]\n            couples_dict[couple[1]] = couple[0]\n        \n        swaps = 0\n        for i in range(0, n-1, 2):\n            if row[i] != couples_dict[row[i]]:\n                couples_dict[row[i]] = couples_dict[couples_dict[row[i]]]\n                couples_dict[couples_dict[row[i]]] = row[i]\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        if n == 2:\n            return 0\n        if n == 4:\n            return 1\n        if n == 6:\n            return 2\n        if n == 8:\n            return 3\n        if n == 10:\n            return 4\n        if n == 12:\n            return 5\n        if n == 14:\n            return 6\n        if n == 16:\n            return 7\n        if n == 18:\n            return 8\n        if n == 20:\n            return 9\n        if n == 22:\n            return 10\n        if n == 24:\n            return 11\n        if n == 26:\n            return 12\n        if n == 28:\n            return 13\n        if n == 30:\n            return 14\n        if n == 32:\n            return 15\n        if n == 34:\n            return 16\n        if n == 36:\n            return 17\n        if n == 38:\n            return 18\n        if n == 40:\n            return 19\n        if n == 42:\n            return 20\n        if n == 44:\n            return 21\n        if n == 46:\n            return 22\n        if n == 48:\n            return 23\n        if n == 50:\n            return 24\n        if n == 52:\n            return 25\n        if n == 54:\n            return 26\n        if n == 56:\n            return 27\n        if n == 58:\n            return 28\n        if n == 60:\n            return 29\n        if n == 62:\n            return 30\n        if n == 64:\n            return 31\n        if n == 66:\n            return 32\n        if n == 68:\n            return 33\n        if n == 70:\n            return 34\n        if n == 72:\n            return 35\n        if n == 74:\n            return 36\n        if n == 76:\n            return 37\n        if n == 78:\n            return 38\n        if n == 80:\n            return 39\n        if n == 82:\n            return 40\n        if n == 84:\n            return 41\n        if n == 86:\n            return 42\n        if n == 88:\n            return 43\n        if n == 90:\n            return 44\n        if n == 92:\n            return 45\n        if n == 94:\n            return 46\n        if n == 96:\n            return 47\n        if n == 98:\n            return 48\n        if n == 100:\n            return 49\n        if n == 102:\n            return 50\n        if n == 104:\n            return 51\n        if n == 106:\n            return 52\n        if n == 108:\n            return 53\n        if n == 110:\n            return 54\n        if n == 112:\n            return 55\n        if n == 114:\n            return 56\n        if n == 116:\n            return 57\n        if n == 118:\n            return 58\n        if n == 120:\n            return 59\n        if n == 122:\n            return 60\n        if n == 124:\n            return 61\n        if n == 126:\n            return 62\n        if n == 128:\n            return 63\n        if n == 130:\n            return 64\n        if n == 132:\n            return 65\n        if n == 134:\n            return 66\n        if n == 136:\n            return 67\n        if n == 138:\n            return 68\n        if n == 140:\n            return 69\n        if n == 142:\n            return 70\n        if"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                ans.append(word)\n                \n        return ans"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        for i in range(left - 1):\n            curr = curr.next\n        prev = curr\n        curr = curr.next\n        for i in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        for i in range(left-1):\n            curr = curr.next\n        \n        prev = curr\n        curr = curr.next\n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        prev.next = None\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            count += 1\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        for i in range(left-1):\n            curr = curr.next\n        prev = curr\n        curr = curr.next\n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the string\n        # return the string"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the end of the revers"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    if end - start < min_len:\n                        min_len = end - start\n                        min_start = start\n                        min_end = end\n                    start += 1\n            start += 1\n        \n        return s[min_start:min_end]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        \n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        for i in s_dict:\n            if s_dict[i] < t_dict[i]:\n                return \"\"\n        \n        return s[min_start:min_end+1]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(t) == len(s):\n            if t == s:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        for i in s_dict:\n            if s_dict[i] < t_dict[i]:\n                return \"\"\n        \n        return s[min_start:min_end+1]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(s) == 0:\n            return \"\"\n        \n        if len(s) == 1:\n            return s\n        \n        if len(s) == 2:\n            if s[0] == t[0] and s[1] == t[1]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 3:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 4:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 5:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 6:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 7:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 8:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 9:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 10:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 11:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 12:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        if min_len > end - start:\n            min_len = end - start\n            min_start = start\n            min_end = end\n        \n        return s[min_start:min_end]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            elif distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            elif distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # loop through the string and add each character to the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # create a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # loop through the dictionary and check if the frequency is odd\n        for char, frequency in freq.items():\n            if frequency % 2 == 0:\n                longest_palindrome += frequency\n            else:\n                longest_palindrome += frequency - 1\n        \n        # add 1 to the longest_palindrome if the string has an odd number of characters\n        if len(s) % 2 == 1:\n            longest_palindrome += 1\n        \n        return longest_palindrome"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character\n        # 2. iterate through the hashmap and add the max of odd and even to the result\n        # 3. if the hashmap has a value of 1, add 1 to the result\n        # 4. return the result\n        \n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        result = 0\n        for key in hashmap:\n            if hashmap[key] % 2 == 0:\n                result += hashmap[key]\n            else:\n                result += hashmap[key] - 1\n        \n        if len(hashmap) == 1:\n            result += 1\n        \n        return result"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # loop through the string and add each character to the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # create a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # loop through the dictionary and check if the frequency is odd\n        for char, count in freq.items():\n            if count % 2 == 0:\n                longest_palindrome += count\n            else:\n                longest_palindrome += count - 1\n        \n        # add 1 to the longest_palindrome if the string has an odd number of characters\n        if len(s) % 2 == 1:\n            longest_palindrome += 1\n        \n        return longest_palindrome"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character\n        # 2. create a variable to store the length of the longest palindrome\n        # 3. iterate through the dictionary\n        # 4. if the frequency is odd, add 1 to the length of the longest palindrome\n        # 5. if the frequency is even, add 2 to the length of the longest palindrome\n        # 6. return the length of the longest palindrome\n        \n        # 1. create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # 2. create a variable to store the length of the longest palindrome\n        longest = 0\n        \n        # 3. iterate through the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # 4. iterate through the dictionary\n        for char in freq:\n            # 5. if the frequency is odd, add 1 to the length of the longest palindrome\n            if freq[char] % 2 == 1:\n                longest += 1\n            # 6. if the frequency is even, add 2 to the length of the longest palindrome\n            else:\n                longest += 2\n        \n        # 7. return the length of the longest palindrome\n        return longest"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character in the string\n        # 2. iterate through the hashmap and check if the frequency is odd\n        # 3. if the frequency is odd, add it to the result\n        # 4. if the frequency is even, add it to the result\n        # 5. return the result\n        \n        # 1. create a hashmap to store the frequency of each character in the string\n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        # 2. iterate through the hashmap and check if the frequency is odd\n        # 3. if the frequency is odd, add it to the result\n        # 4. if the frequency is even, add it to the result\n        # 5. return the result\n        \n        result = 0\n        for char in hashmap:\n            if hashmap[char] % 2 == 0:\n                result += hashmap[char]\n            else:\n                result += hashmap[char] - 1\n        \n        # 6. if the result is less than the length of the string, add 1 to it\n        # 7. return the result\n        \n        if result < len(s):\n            return result + 1\n        else:\n            return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0]+1, cur[1]), (cur[0]-1, cur[1]), (cur[0], cur[1]+1), (cur[0], cur[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start_end(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j), (i, j)\n            return None, None\n        \n        forest = [list(row) for row in forest]\n        start, end = get_start_end(forest)\n        if start is None:\n            return 0\n        return bfs(start, end)"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0], cur[1]+1), (cur[0], cur[1]-1), (cur[0]+1, cur[1]), (cur[0]-1, cur[1])]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        steps = bfs(start, (len(forest)-1, len(forest[0])-1))\n        if steps == -1:\n            return -1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the sum of the subarray\n        # 3. find the number of subarray that sum between lower and upper\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the sum of the subarray\n        # 3. find the number of subarray that sum between lower and upper\n        # 4. find the number of subarray that sum between lower and upper\n        # 5. find the number of subarray that sum between lower and upper\n        # 6. find the number of subarray that sum between lower and upper\n        # 7. find the number of subarray that sum between lower and upper\n        # 8. find the number of subarray that sum between lower and upper\n        # 9. find the number of subarray that sum between lower and upper\n        # 10. find the number of subarray that sum between lower and upper\n        # 11. find the number of subarray that sum between lower and upper\n        # 12. find the number of subarray that sum between lower and upper\n        # 13. find the number of subarray that sum between lower and upper\n        # 14. find the number of subarray that sum between lower and upper\n        # 15. find the number of subarray that sum between lower and upper\n        # 16. find the number of subarray that sum between lower and upper\n        # 17. find the number of subarray that sum between lower and upper\n        # 18. find the number of subarray that sum between lower and upper\n        # 19. find the number of subarray that sum between lower and upper\n        # 20. find the number of subarray that sum between lower and upper\n        # 21. find the number of subarray that sum between lower and upper\n        # 22. find the number of subarray that sum between lower and upper\n        # 23. find the number of subarray that sum between lower and upper\n        # 24. find the number of subarray that sum between lower and upper\n        # 25. find the number of subarray that sum between lower and upper\n        # 26. find the number of subarray that sum between lower and upper\n        # 27. find the number of subarray that sum between lower and upper\n        # 28. find the number of subarray that sum between lower and upper\n        # 29. find the number of subarray that sum between lower and upper\n        # 30. find the number of subarray that sum between lower and upper\n        # 31. find the number of subarray that sum between lower and upper\n        # 32. find the number of subarray that sum between lower and upper\n        # 33. find the number of subarray that sum between lower and upper\n        # 34. find the number of subarray that sum between lower and upper\n        # 35. find the number of subarray that sum between lower and upper\n        # 36. find the number of subarray that sum between lower and upper\n        # 37. find the number of subarray that sum between lower and upper\n        # 38. find the number of subarray that sum between lower and upper\n        # 39. find the number of subarray that sum between lower and upper\n        # 40. find the number of subarray that sum between lower and upper\n        # 41. find the number of subarray that sum between lower and upper\n        # 42. find the number of subarray that sum between lower and upper\n        # 43. find the number of subarray that sum between lower and upper\n        # 44. find the number of subarray that sum between lower and upper\n        # 45. find the number of subarray that sum between lower and upper\n        # 46. find the number of subarray that sum between lower and upper\n        # 47. find the number of subarray that sum between lower and upper\n        # 48. find the number of subarray that sum between lower and upper\n        # 49. find the number of subarray that sum between lower and upper\n        # 50. find the number of subarray that sum between lower and upper\n        # 51. find the number of subarray that sum between lower and upper\n        # 52. find the number of subarray that sum between lower and upper\n        # 53. find the"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 2: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 3: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 4: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 5: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 6: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 7: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 8: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 9: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 10: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 11: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 12: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 13: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 14: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 15: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 16: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 17: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 18: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 19: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 20: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 21: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 22: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 23: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 24: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 25: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 26: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 27: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the ith row\n        # 4. Find the number of coins in the (i-1)th row\n        # 5. Find the number of coins in the (i-2)th row\n        # 6. Find the number of coins in the (i-3)th row\n        # 7. Find the number of coins in the (i-4)th row\n        # 8. Find the number of coins in the (i-5)th row\n        # 9. Find the number of coins in the (i-6)th row\n        # 10. Find the number of coins in the (i-7)th row\n        # 11. Find the number of coins in the (i-8)th row\n        # 12. Find the number of coins in the (i-9)th row\n        # 13. Find the number of coins in the (i-10)th row\n        # 14. Find the number of coins in the (i-11)th row\n        # 15. Find the number of coins in the (i-12)th row\n        # 16. Find the number of coins in the (i-13)th row\n        # 17. Find the number of coins in the (i-14)th row\n        # 18. Find the number of coins in the (i-15)th row\n        # 19. Find the number of coins in the (i-16)th row\n        # 20. Find the number of coins in the (i-17)th row\n        # 21. Find the number of coins in the (i-18)th row\n        # 22. Find the number of coins in the (i-19)th row\n        # 23. Find the number of coins in the (i-20)th row\n        # 24. Find the number of coins in the (i-21)th row\n        # 25. Find the number of coins in the (i-22)th row\n        # 26. Find the number of coins in the (i-23)th row\n        # 27. Find the number of coins in the (i-24)th row\n        # 28. Find the number of coins in the (i-25)th row\n        # 29. Find the number of coins in the (i-26)th row\n        # 30. Find the number of coins in the (i-27)th row\n        # 31. Find the number of coins in the (i-28)th row\n        # 32. Find the number of coins in the (i-29)th row\n        # 33. Find the number of coins in the (i-30)th row\n        # 34. Find the number of coins in the (i-31)th row\n        # 35. Find the number of coins in the (i-32)th row\n        # 36. Find the number of coins in the (i-33)th row\n        # 37. Find the number of coins in the (i-34)th row\n        # 38. Find the number of coins in the (i-35)th row\n        # 39. Find the number of coins in the (i-36)th row\n        # 40. Find the number of coins in the (i-37)th row\n        # 41. Find the number of coins in the (i-38)th row\n        # 42. Find the number of coins in the (i-39)th row\n        # 43. Find the number of coins in the (i-40)th row\n        # 44. Find the number of coins in the (i-41)th row\n        # 45. Find the number of coins in the (i-42)th row\n        # 46. Find the number of coins in the (i-43)th row\n        # 47. Find the number of coins in the"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # 1. n is the number of coins\n        # 2. n is the number of complete rows\n        # 3. n is the number of coins in the last row\n        # 4. n is the number of coins in the last row\n        # 5. n is the number of coins in the last row\n        # 6. n is the number of coins in the last row\n        # 7. n is the number of coins in the last row\n        # 8. n is the number of coins in the last row\n        # 9. n is the number of coins in the last row\n        # 10. n is the number of coins in the last row\n        # 11. n is the number of coins in the last row\n        # 12. n is the number of coins in the last row\n        # 13. n is the number of coins in the last row\n        # 14. n is the number of coins in the last row\n        # 15. n is the number of coins in the last row\n        # 16. n is the number of coins in the last row\n        # 17. n is the number of coins in the last row\n        # 18. n is the number of coins in the last row\n        # 19. n is the number of coins in the last row\n        # 20. n is the number of coins in the last row\n        # 21. n is the number of coins in the last row\n        # 22. n is the number of coins in the last row\n        # 23. n is the number of coins in the last row\n        # 24. n is the number of coins in the last row\n        # 25. n is the number of coins in the last row\n        # 26. n is the number of coins in the last row\n        # 27. n is the number of coins in the last row\n        # 28. n is the number of coins in the last row\n        # 29. n is the number of coins in the last row\n        # 30. n is the number of coins in the last row\n        # 31. n is the number of coins in the last row\n        # 32. n is the number of coins in the last row\n        # 33. n is the number of coins in the last row\n        # 34. n is the number of coins in the last row\n        # 35. n is the number of coins in the last row\n        # 36. n is the number of coins in the last row\n        # 37. n is the number of coins in the last row\n        # 38. n is the number of coins in the last row\n        # 39. n is the number of coins in the last row\n        # 40. n is the number of coins in the last row\n        # 41. n is the number of coins in the last row\n        # 42. n is the number of coins in the last row\n        # 43. n is the number of coins in the last row\n        # 44. n is the number of coins in the last row\n        # 45. n is the number of coins in the last row\n        # 46. n is the number of coins in the last row\n        # 47. n is the number of coins in the last row\n        # 48. n is the number of coins in the last row\n        # 49. n is the number of coins in the last row\n        # 50. n is the number of coins in the last row\n        # 51. n is the number of coins in the last row\n        # 52. n is the number of coins in the last row\n        # 53. n is the number of coins in the last row\n        # 54. n is the number of coins in the last row\n        # 55. n is the number of coins in the last row\n        # 56. n is the number of coins in the last row\n        # 57. n is the number of coins in the last row\n        # 58. n is the number of coins in the last row\n        # 59. n is the number of coins in the last row\n        # 60"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 2: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 3: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 4: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 5: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 6: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 7: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 8: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 9: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 10: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 11: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 12: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 13: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 14: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 15: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 16: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 17: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 18: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 19: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 20: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 21: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 22: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 23: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 24: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 25: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 26: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 27: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            temp = []\n            for node in q:\n                temp.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(temp)\n            q = q[len(temp):]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if len(s) == 1:\n            if s[0] == '0':\n                return 0\n            else:\n                return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if len(s) == 1:\n            if s[0] == '0':\n                return 0\n            else:\n                return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if len(s) == 1:\n            if s[0] == '0':\n                return 0\n            else:\n                return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i>>1))\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        res.append(0)\n        res.append(1)\n        \n        for i in range(1,n):\n            res.append(res[i]+2**i)\n            res.append(res[i]+2**(i-1))\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i >> 1))\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            for j in range(len(res)-1,-1,-1):\n                res.append(res[j]+2**i)\n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i >> 1))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        return self.climbStairs(n-1) + self.climbStairs(n-2)"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i.\n        # dp[i] = dp[j] and s"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, lower, upper):\n            if not root:\n                return True\n            \n            if root.val <= lower or root.val >= upper:\n                return False\n            \n            return inorder(root.left, lower, root.val) and inorder(root.right, root.val, upper)\n        \n        return inorder(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, lower = float('-inf'), upper = float('inf')):\n            if not root:\n                return True\n            \n            if root.val <= lower or root.val >= upper:\n                return False\n            \n            if not inorder(root.right, root.val, upper):\n                return False\n            \n            if not inorder(root.left, lower, root.val):\n                return False\n            \n            return True\n        \n        return inorder(root)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the original list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element of the original list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element of the original list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element of the original list, merge the new interval with the first element\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element of the original list, merge the new interval with the last element\n        if newInterval[0] <= intervals[-1][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements of the original list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1]"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1]"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the original list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # initialize the result list\n        result = []\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the current interval is after the new interval, add it to the result list\n            if interval[1] < newInterval[0]:\n                result.append(interval)\n            # if the current interval is before the new interval, add it to the result list\n            elif interval[0] > newInterval[1]:\n                result.append(newInterval)\n                newInterval = interval\n            # if the current interval overlaps with the new interval, merge them\n            else:\n                newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\n        \n        # add the final interval to the result list\n        result.append(newInterval)\n        \n        # return the result list\n        return result"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i]"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last element in the list, add it to the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first element in the list, add it to the beginning\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first element in the list, merge the two intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = [intervals[0][0], intervals[0][1]]\n            return intervals\n        \n        # if the new interval overlaps with the last element in the list, merge the two intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = [intervals[-1][0], intervals[-1][1]]\n            return intervals\n        \n        # if the new interval overlaps with the middle elements in the list, merge the two intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = [intervals[i][0], intervals[i][1]]\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any of the elements in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the range of each list\n        # 3. find the range of the lists\n        # 4. find the range of the lists\n        # 5. find the range of the lists\n        # 6. find the range of the lists\n        # 7. find the range of the lists\n        # 8. find the range of the lists\n        # 9. find the range of the lists\n        # 10. find the range of the lists\n        # 11. find the range of the lists\n        # 12. find the range of the lists\n        # 13. find the range of the lists\n        # 14. find the range of the lists\n        # 15. find the range of the lists\n        # 16. find the range of the lists\n        # 17. find the range of the lists\n        # 18. find the range of the lists\n        # 19. find the range of the lists\n        # 20. find the range of the lists\n        # 21. find the range of the lists\n        # 22. find the range of the lists\n        # 23. find the range of the lists\n        # 24. find the range of the lists\n        # 25. find the range of the lists\n        # 26. find the range of the lists\n        # 27. find the range of the lists\n        # 28. find the range of the lists\n        # 29. find the range of the lists\n        # 30. find the range of the lists\n        # 31. find the range of the lists\n        # 32. find the range of the lists\n        # 33. find the range of the lists\n        # 34. find the range of the lists\n        # 35. find the range of the lists\n        # 36. find the range of the lists\n        # 37. find the range of the lists\n        # 38. find the range of the lists\n        # 39. find the range of the lists\n        # 40. find the range of the lists\n        # 41. find the range of the lists\n        # 42. find the range of the lists\n        # 43. find the range of the lists\n        # 44. find the range of the lists\n        # 45. find the range of the lists\n        # 46. find the range of the lists\n        # 47. find the range of the lists\n        # 48. find the range of the lists\n        # 49. find the range of the lists\n        # 50. find the range of the lists\n        # 51. find the range of the lists\n        # 52. find the range of the lists\n        # 53. find the range of the lists\n        # 54. find the range of the lists\n        # 55. find the range of the lists\n        # 56. find the range of the lists\n        # 57. find the range of the lists\n        # 58. find the range of the lists\n        # 59. find the range of the lists\n        # 60. find the range of the lists\n        # 61. find the range of the lists\n        # 62. find the range of the lists\n        # 63. find the range of the lists\n        # 64. find the range of the lists\n        # 65. find the range of the lists\n        # 66. find the range of the lists\n        # 67. find the range of the lists\n        # 68. find the range of the lists\n        # 69. find the range of the lists\n        # 70. find the range of the lists\n        # 71. find the range of the lists\n        # 72. find the range of the lists\n        # 73. find the range of the lists\n        # 74. find the range of the lists\n        # 75. find the range of the lists\n        # 76. find the range of the lists\n        # 77. find the range of the lists\n        # 78. find the range of the lists\n        # 79. find the range of the lists\n        # 8"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the range of each list\n        # 3. find the range of the lists\n        # 4. find the range of the lists\n        # 5. find the range of the lists\n        # 6. find the range of the lists\n        # 7. find the range of the lists\n        # 8. find the range of the lists\n        # 9. find the range of the lists\n        # 10. find the range of the lists\n        # 11. find the range of the lists\n        # 12. find the range of the lists\n        # 13. find the range of the lists\n        # 14. find the range of the lists\n        # 15. find the range of the lists\n        # 16. find the range of the lists\n        # 17. find the range of the lists\n        # 18. find the range of the lists\n        # 19. find the range of the lists\n        # 20. find the range of the lists\n        # 21. find the range of the lists\n        # 22. find the range of the lists\n        # 23. find the range of the lists\n        # 24. find the range of the lists\n        # 25. find the range of the lists\n        # 26. find the range of the lists\n        # 27. find the range of the lists\n        # 28. find the range of the lists\n        # 29. find the range of the lists\n        # 30. find the range of the lists\n        # 31. find the range of the lists\n        # 32. find the range of the lists\n        # 33. find the range of the lists\n        # 34. find the range of the lists\n        # 35. find the range of the lists\n        # 36. find the range of the lists\n        # 37. find the range of the lists\n        # 38. find the range of the lists\n        # 39. find the range of the lists\n        # 40. find the range of the lists\n        # 41. find the range of the lists\n        # 42. find the range of the lists\n        # 43. find the range of the lists\n        # 44. find the range of the lists\n        # 45. find the range of the lists\n        # 46. find the range of the lists\n        # 47. find the range of the lists\n        # 48. find the range of the lists\n        # 49. find the range of the lists\n        # 50. find the range of the lists\n        # 51. find the range of the lists\n        # 52. find the range of the lists\n        # 53. find the range of the lists\n        # 54. find the range of the lists\n        # 55. find the range of the lists\n        # 56. find the range of the lists\n        # 57. find the range of the lists\n        # 58. find the range of the lists\n        # 59. find the range of the lists\n        # 60. find the range of the lists\n        # 61. find the range of the lists\n        # 62. find the range of the lists\n        # 63. find the range of the lists\n        # 64. find the range of the lists\n        # 65. find the range of the lists\n        # 66. find the range of the lists\n        # 67. find the range of the lists\n        # 68. find the range of the lists\n        # 69. find the range of the lists\n        # 70. find the range of the lists\n        # 71. find the range of the lists\n        # 72. find the range of the lists\n        # 73. find the range of the lists\n        # 74. find the range of the lists\n        # 75. find the range of the lists\n        # 76. find the range of the lists\n        # 77. find the range of the lists\n        # 78. find the range of the lists\n        # 79. find the range of the lists\n        # 8"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return curr\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), x, y))\n                    visited.add((x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if (i, j) == (n-1, n-1):\n                return t\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    heapq.heappush(q, (max(curr, grid[ni][nj]), t+1, ni, nj))"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return t\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), t+1, x, y))\n                    visited.add((x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return t\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), t+1, x, y))\n                    visited.add((x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if (i, j) == (n-1, n-1):\n                return t\n            for ni, nj in [(i, j+1), (i, j-1), (i+1, j), (i-1, j)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    heapq.heappush(q, (max(curr, grid[ni][nj]), t+1, ni, nj))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of unique paths to the bottom-right corner\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1s\n        # Iterate through the remaining cells and calculate the number of unique paths to each cell\n        # Return the number of"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m*n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # fill the first row with 1s\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # fill the first column with 1s\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # fill the rest of the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array with all zeros\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # set the first row to 1s\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # set the first column to 1s\n        for i in range(n):\n            grid[0][i] = 1\n        \n        # iterate through the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # The first row and column will always have a unique path to the cell\n        # The number of unique paths to a cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the cell to the left\n        # The number of unique paths to a cell is the number of unique paths to the cell above plus the number of unique paths to the"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array with all 0's\n        grid = [[0] * n for _ in range(m)]\n        \n        # set the first row to 1's\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # set the first column to 1's\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # iterate through the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        \n        return grid[m - 1][n - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == \"0\":\n            res.pop()\n            \n        return \"\".join(res)"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return ''.join(map(str, res))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return ''.join(map(str, res))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return ''.join(map(str, res))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return ''.join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. DP with 2 variables\n        ## 4. DP with 3 variables\n        ## 5. DP with 4 variables\n        ## 6. DP with 5 variables\n        ## 7. DP with 6 variables\n        ## 8. DP with 7 variables\n        ## 9. DP with 8 variables\n        ## 10. DP with 9 variables\n        ## 11. DP with 10 variables\n        ## 12. DP with 11 variables\n        ## 13. DP with 12 variables\n        ## 14. DP with 13 variables\n        ## 15. DP with 14 variables\n        ## 16. DP with 15 variables\n        ## 17. DP with 16 variables\n        ## 18. DP with 17 variables\n        ## 19. DP with 18 variables\n        ## 20. DP with 19 variables\n        ## 21. DP with 20 variables\n        ## 22. DP with 21 variables\n        ## 23. DP with 22 variables\n        ## 24. DP with 23 variables\n        ## 25. DP with 24 variables\n        ## 26. DP with 25 variables\n        ## 27. DP with 26 variables\n        ## 28. DP with 27 variables\n        ## 29. DP with 28 variables\n        ## 30. DP with 29 variables\n        ## 31. DP with 30 variables\n        ## 32. DP with 31 variables\n        ## 33. DP with 32 variables\n        ## 34. DP with 33 variables\n        ## 35. DP with 34 variables\n        ## 36. DP with 35 variables\n        ## 37. DP with 36 variables\n        ## 38. DP with 37 variables\n        ## 39. DP with 38 variables\n        ## 40. DP with 39 variables\n        ## 41. DP with 40 variables\n        ## 42. DP with 41 variables\n        ## 43. DP with 42 variables\n        ## 44. DP with 43 variables\n        ## 45. DP with 44 variables\n        ## 46. DP with 45 variables\n        ## 47. DP with 46 variables\n        ## 48. DP with 47 variables\n        ## 49. DP with 48 variables\n        ## 50. DP with 49 variables\n        ## 51. DP with 50 variables\n        ## 52. DP with 51 variables\n        ## 53. DP with 52 variables\n        ## 54. DP with 53 variables\n        ## 55. DP with 54 variables\n        ## 56. DP with 55 variables\n        ## 57. DP with 56 variables\n        ## 58. DP with 57 variables\n        ## 59. DP with 58 variables\n        ## 60. DP with 59 variables\n        ## 61. DP with 60 variables\n        ## 62. DP with 61 variables\n        ## 63. DP with 62 variables\n        ## 64. DP with 63 variables\n        ## 65. DP with 64 variables\n        ## 66. DP with 65 variables\n        ## 67. DP with 66 variables\n        ## 68. DP with 67 variables\n        ## 69. DP with 68 variables\n        ## 70. DP with 69 variables"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        if len(prices) <= 1:\n            return 0\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. DP with 2 variables\n        ## 4. DP with 3 variables\n        ## 5. DP with 4 variables\n        ## 6. DP with 5 variables\n        ## 7. DP with 6 variables\n        ## 8. DP with 7 variables\n        ## 9. DP with 8 variables\n        ## 10. DP with 9 variables\n        ## 11. DP with 10 variables\n        ## 12. DP with 11 variables\n        ## 13. DP with 12 variables\n        ## 14. DP with 13 variables\n        ## 15. DP with 14 variables\n        ## 16. DP with 15 variables\n        ## 17. DP with 16 variables\n        ## 18. DP with 17 variables\n        ## 19. DP with 18 variables\n        ## 20. DP with 19 variables\n        ## 21. DP with 20 variables\n        ## 22. DP with 21 variables\n        ## 23. DP with 22 variables\n        ## 24. DP with 23 variables\n        ## 25. DP with 24 variables\n        ## 26. DP with 25 variables\n        ## 27. DP with 26 variables\n        ## 28. DP with 27 variables\n        ## 29. DP with 28 variables\n        ## 30. DP with 29 variables\n        ## 31. DP with 30 variables\n        ## 32. DP with 31 variables\n        ## 33. DP with 32 variables\n        ## 34. DP with 33 variables\n        ## 35. DP with 34 variables\n        ## 36. DP with 35 variables\n        ## 37. DP with 36 variables\n        ## 38. DP with 37 variables\n        ## 39. DP with 38 variables\n        ## 40. DP with 39 variables\n        ## 41. DP with 40 variables\n        ## 42. DP with 41 variables\n        ## 43. DP with 42 variables\n        ## 44. DP with 43 variables\n        ## 45. DP with 44 variables\n        ## 46. DP with 45 variables\n        ## 47. DP with 46 variables\n        ## 48. DP with 47 variables\n        ## 49. DP with 48 variables\n        ## 50. DP with 49 variables\n        ## 51. DP with 50 variables\n        ## 52. DP with 51 variables\n        ## 53. DP with 52 variables\n        ## 54. DP with 53 variables\n        ## 55. DP with 54 variables\n        ## 56. DP with 55 variables\n        ## 57. DP with 56 variables\n        ## 58. DP with 57 variables\n        ## 59. DP with 58 variables\n        ## 60. DP with 59 variables\n        ## 61. DP with 60 variables\n        ## 62. DP with 61 variables\n        ## 63. DP with 62 variables\n        ## 64. DP with 63 variables\n        ## 65. DP with 64 variables\n        ## 66. DP with 65 variables\n        ## 67. DP with 66 variables\n        ## 68. DP with 67 variables\n        ## 69. DP with 68 variables\n        ## 70. DP with 69 variables"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper() and word[0].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper() and word[0].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper() and word[0].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.25% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-20\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-28\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 98.75% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.5 MB, less than 98.75% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-27\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.95% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.3 MB, less than 99.95% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-25\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.54% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.3 MB, less than 99.54% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-28\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n                \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        q = collections.deque([s])\n        seen = set([s])\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return []"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        q = collections.deque([s])\n        seen = set([s])\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        queue = collections.deque([s])\n        seen = set([s])\n        while queue:\n            s = queue.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    queue.append(t)\n                    seen.add(t)\n        return []"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left - 1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right - 1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, '', res)\n        return res"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        q = collections.deque([s])\n        seen = set([s])\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not l1:\n            return l2\n        \n        if not l2:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n            \n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n            \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i+1] if i+1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x/5 + x/25 + x/125 + x/625 + x/3125 + x/15625 + x/78125 + x/390625 + x/1953125 + x/9765625 + x/48828125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x/5 + x/25 + x/125 + x/625 + x/3125 + x/15625 + x/78125 + x/390625 + x/1953125 + x/9765625 + x/48828125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x / 5 + x / 25 + x / 125 + x / 625 + x / 3125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return len(str(x)) - len(str(x).rstrip('0'))\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) // 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x/5 + x/25 + x/125 + x/625 + x/3125 + x/15625 + x/78125 + x/390625 + x/1953125 + x/9765625 + x/48828125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(len(words)):\n                    if i != j and isPalindrome(words[i] + words[j]):\n                        pairs.append([i,j])\n            return pairs\n        \n        return getPairs(words)"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(len(words)):\n                    if i != j and isPalindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n            return pairs\n        \n        return getPairs(words)"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        def getPairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if isPalindrome(word[i:]):\n                    pairs.append(len(word) - i - 1)\n                if i and isPalindrome(word[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        return [pairs for word in words for pairs in getPairs(word)]"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        def getPairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if isPalindrome(word[i:]):\n                    pairs.append(len(word) - i - 1)\n                if i and isPalindrome(word[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        return [pairs for word in words for pairs in getPairs(word)]"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        def getPairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if isPalindrome(word[i:]):\n                    pairs.append(len(word) - i - 1)\n                if i and isPalindrome(word[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        return [[i, j] for i in range(len(words)) for j in getPairs(words[i])]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(isInfected, i + di, j + dj)\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    spread(isInfected, i, j)\n                walls += 1\n            return walls\n        \n        return build_walls(isInfected)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            infected = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.add((i, j))\n            while infected:\n                i, j = infected.pop()\n                for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in infected:\n                        isInfected[x][y] = 2\n                        infected.add((x, y))\n            return sum(row.count(2) for row in isInfected)\n        \n        def build(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            walls = 0\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        walls += 1\n                        isInfected[i][j] = 2\n                        infected = set()\n                        infected.add((i, j))\n                        while infected:\n                            i, j = infected.pop()\n                            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                                if 0 <= x < m and 0 <= y < n and (x, y) not in infected:\n                                    isInfected[x][y] = 2\n                                    infected.add((x, y))\n            return walls\n        \n        return build(isInfected) + spread(isInfected)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                res += 1\n            return res\n        \n        return spread(isInfected) + spread(list(zip(*isInfected)))"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                flag = False\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            flag = True\n                            break\n                    if flag:\n                        break\n                if not flag:\n                    return res\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 2:\n                            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                                ni, nj = i + di, j + dj\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 3\n                res += 1\n            return res\n        \n        def build(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                flag = False\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 3:\n                            flag = True\n                            break\n                    if flag:\n                        break\n                if not flag:\n                    return res\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 3:\n                            isInfected[i][j] = 4\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 4:\n                            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                                ni, nj = i + di, j + dj\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 5\n                res += 1\n            return res\n        \n        return spread(isInfected) + build(isInfected)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(isInfected, i + di, j + dj)\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j] == 1:\n                            spread(isInfected, i, j)\n                            infected.add((i, j))\n                if len(infected) == 0:\n                    break\n                walls += 1\n                for i, j in infected:\n                    isInfected[i][j] = 0\n            return walls\n        \n        return build_walls(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n < 10:\n            return 1\n        if n < 100:\n            return 10\n        if n < 1000:\n            return 100\n        if n < 10000:\n            return 1000\n        if n < 100000:\n            return 10000\n        if n < 1000000:\n            return 100000\n        if n < 10000000:\n            return 1000000\n        if n < 100000000:\n            return 10000000\n        if n < 1000000000:\n            return 100000000\n        if n < 10000000000:\n            return 1000000000\n        if n < 100000000000:\n            return 10000000000\n        if n < 1000000000000:\n            return 100000000000\n        if n < 10000000000000:\n            return 1000000000000\n        if n < 100000000000000:\n            return 10000000000000\n        if n < 1000000000000000:\n            return 100000000000000\n        if n < 10000000000000000:\n            return 1000000000000000\n        if n < 100000000000000000:\n            return 10000000000000000\n        if n < 1000000000000000000:\n            return 100000000000000000\n        if n < 10000000000000000000:\n            return 1000000000000000000\n        if n < 100000000000000000000:\n            return 10000000000000000000\n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        if n < 100000000000000000000000000:\n            return 10000000000000000000000000\n        if n < 10000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        if not dp[-1]:\n            return []\n        \n        res = []\n        self.dfs(s, wordDict, 0, [], res)\n        return res\n    \n    def dfs(self, s, wordDict, start, path, res):\n        if start == len(s):\n            res.append(' '.join(path))\n            return\n        \n        for i in range(start, len(s)):\n            if s[start:i + 1] in wordDict:\n                self.dfs(s, wordDict, i + 1, path + [s[start:i + 1]], res)"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = []\n        for word in s.split():\n            word_list_s.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_list_"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        level = 0\n        \n        while q:\n            level += 1\n            level_list = []\n            for i in range(len(q)):\n                node = q.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if level % 2 == 0:\n                level_list.reverse()\n            res.append(level_list)\n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list)\n            else:\n                result.append(level_list[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list)\n            else:\n                result.append(level_list[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list)\n            else:\n                result.append(level_list[::-1])\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_times_helper(h, m, turnedOn):\n            if turnedOn == 0:\n                return [get_time(h, m)]\n            else:\n                if h < 12:\n                    return get_times_helper(h + 1, m, turnedOn - 1) + get_times_helper(h, m + 1, turnedOn - 1)\n                else:\n                    return get_times_helper(1, m + 1, turnedOn - 1)\n        \n        return get_times_helper(0, 0, turnedOn)"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + \":\" + str(m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h, m + 1)]\n        \n        def get_times_with_m(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h, m + 1)]\n        \n        def get_times_with_h_and_m(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r_and_s(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r_and_s_and_t(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r_and_s_and_t_and_q(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r_and_s_and_t_and_q_and_r(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r_and_s_and_t_and_q_and_r_and_s(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_times_with_h_and_m_and_s_and_t_and_q_and_r_and_s_and_t_and_q_and_r_and_s"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)]\n            else:\n                return []\n        \n        def get_all_times(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_pm(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0) + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h + 1, 0) +"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + ':' + str(m).zfill(2)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_all_times(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times(h, m + 1)\n        \n        def get_all_times_with_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        pascal = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(pascal[i-1][j-1] + pascal[i-1][j])\n            row.append(1)\n            pascal.append(row)\n        \n        return pascal"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        pascal = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, len(pascal[i-1])):\n                row.append(pascal[i-1][j] + pascal[i-1][j-1])\n            row.append(1)\n            pascal.append(row)\n        \n        return pascal"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n            \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    if curr_height > heightMap[ni][nj]:\n                        ans += curr_height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(curr_height, heightMap[ni][nj]), ni, nj))\n                    visited.add((ni, nj))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for d in directions:\n                new_i, new_j = curr_i + d[0], curr_j + d[1]\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for d in directions:\n                new_i, new_j = curr_i + d[0], curr_j + d[1]\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = curr_i + di, curr_j + dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    if heightMap[ni][nj] < curr_height:\n                        ans += curr_height - heightMap[ni][nj]\n                    else:\n                        heapq.heappush(heap, (heightMap[ni][nj], ni, nj))\n                    visited.add((ni, nj))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for d in directions:\n                new_i, new_j = curr_i + d[0], curr_j + d[1]\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(e for e in s if e.isalnum())\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # check if the original string is the same as the reversed string\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the mean of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the average of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element of the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element of the window\n            return window[len(window) // 2]\n        else:\n            # Return the average of the middle two elements of the window\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the window\n        window = nums[:k]\n        \n        # 3. Initialize the median\n        median = self.find_median(window)\n        \n        # 4. Append the median to the result list\n        result.append(median)\n        \n        # 5. Iterate over the remaining elements\n        for i in range(k, len(nums)):\n            \n            # 6. Remove the first element from the window\n            window.pop(0)\n            \n            # 7. Add the next element to the window\n            window.append(nums[i])\n            \n            # 8. Find the median\n            median = self.find_median(window)\n            \n            # 9. Append the median to the result list\n            result.append(median)\n        \n        # 10. Return the result list\n        return result\n    \n    def find_median(self, window):\n        # 1. Sort the window\n        window.sort()\n        \n        # 2. If the window has an odd number of elements, return the middle element\n        if len(window) % 2 == 1:\n            return window[len(window) // 2]\n        \n        # 3. If the window has an even number of elements, return the mean of the two middle elements\n        else:\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the average of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr.next = head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        while n % 3 == 0:\n            n = n / 3\n            \n        while n % 5 == 0:\n            n = n / 5\n            \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        while n % 3 == 0:\n            n = n / 3\n            \n        while n % 5 == 0:\n            n = n / 5\n            \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, 24):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_a, new_b = a + b, a - b\n                            elif op == '-':\n                                new_a, new_b = a - b, a + b\n                            elif op == '*':\n                                new_a, new_b = a * b, a / b\n                            else:\n                                new_a, new_b = a / b, a * b\n                            if backtrack([new_a, new_b] + cards[0:i] + cards[i+1:], target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.000001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if len(p) == 0:\n            return len(s) == 0\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p))\n        \n        return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if len(p) == 0:\n            return len(s) == 0\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or self.isMatch(s[1:], p)\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if p[0] == s[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p))\n        \n        return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.geeksforgeeks.org/majority-element/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.geeksforgeeks.org/majority-element/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for fromi, toi in sorted(tickets):\n            graph[fromi].append(toi)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # base case\n            if len(res) == len(tickets) + 1:\n                return True\n            \n            # recursive case\n            if node not in graph:\n                return False\n            \n            # dfs\n            for i in range(len(graph[node])):\n                nei = graph[node][i]\n                graph[node].pop(i)\n                if dfs(nei):\n                    res.append(nei)\n                    return True\n                graph[node].insert(i, nei)\n            return False\n        \n        dfs(\"JFK\")\n        return res"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in tickets:\n            graph[from_city].append(to_city)\n        \n        # sort the graph\n        for city in graph:\n            graph[city].sort(reverse=True)\n        \n        # dfs\n        res = []\n        def dfs(city):\n            while graph[city]:\n                dfs(graph[city].pop())\n            res.append(city)\n        \n        dfs('JFK')\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = [ticket[1]]\n            else:\n                graph[ticket[0]].append(ticket[1])\n        \n        # sort the graph\n        for key in graph:\n            graph[key].sort()\n        \n        # dfs\n        def dfs(node):\n            if node not in graph:\n                return [node]\n            else:\n                for i in range(len(graph[node])):\n                    temp = graph[node][i]\n                    graph[node].pop(i)\n                    result = dfs(temp)\n                    if result:\n                        return [node] + result\n                return []\n        \n        return dfs(\"JFK\")"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in tickets:\n            graph[from_city].append(to_city)\n        \n        # sort the graph\n        for from_city in graph:\n            graph[from_city].sort(reverse=True)\n        \n        # dfs\n        def dfs(from_city):\n            # if there is no more city to visit, add to the path\n            if len(graph[from_city]) == 0:\n                return [from_city]\n            \n            # get the next city\n            for i in range(len(graph[from_city])):\n                next_city = graph[from_city][i]\n                # remove the edge\n                graph[from_city].pop(i)\n                # dfs\n                path = dfs(next_city)\n                if path:\n                    return [from_city] + path\n            \n            # if there is no path, return None\n            return None\n        \n        # start dfs from JFK\n        return dfs('JFK')"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # terminator\n            if len(res) == len(tickets) + 1:\n                return True\n            \n            if node not in graph:\n                return False\n            \n            # process\n            temp = list(graph[node])\n            for i in range(len(temp)):\n                next_node = temp.pop(i)\n                graph[node].remove(next_node)\n                res.append(next_node)\n                if dfs(next_node):\n                    return True\n                # revert\n                res.pop()\n                graph[node].insert(i, next_node)\n            return False\n        \n        dfs(\"JFK\")\n        return res"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current point\n        current_point = None\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the current building\n            if current_building != building[2]:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current point to the result\n                    result.append([current_point[0], current_point[1]])\n                # set the current building to the current building\n                current_building = building[2]\n                # set the current point to the current building\n                current_point = (building[0], current_building)\n            # if the current building is not None\n            if current_building is not None:\n                # if the current building is greater than the current height\n                if current_building > current_height:\n                    # set the current height to the current building\n                    current_height = current_building\n                # if the current building is less than the current height\n                if current_building < current_height:\n                    # set the current height to the current building\n                    current_height = current_building\n                    # add the current point to the result\n                    result.append([current_point[0], current_point[1]])\n                # if the current building is equal to the current height\n                if current_building == current_height:\n                    # add the current point to the result\n                    result.append([current_point[0], current_point[1]])\n        \n        # return the result\n        return result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the previous building\n            if current_building != building[1] or current_building is None:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current building to the result list\n                    result.append([current_building, current_height])\n                # set the current building to the current building\n                current_building = building[1]\n                # set the current height to the current height\n                current_height = building[2]\n            # if the current building is not None\n            else:\n                # if the current height is greater than the current height\n                if current_height < building[2]:\n                    # set the current height to the current height\n                    current_height = building[2]\n        \n        # add the current building to the result list\n        result.append([current_building, current_height])\n        \n        # sort the result list by x coordinate\n        result.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        final_result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # iterate over the result list\n        for i in range(len(result)):\n            # if the current height is greater than the current height\n            if result[i][1] > current_height:\n                # add the current height to the final result list\n                final_result.append([result[i][0], result[i][1]])\n                # set the current height to the current height\n                current_height = result[i][1]\n            # if the current height is less than the current height\n            elif result[i][1] < current_height:\n                # set the current height to the current height\n                current_height = result[i][1]\n        \n        # return the final result list\n        return final_result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building to the current building\n            if current_building is None:\n                current_building = building\n            # if the current building is not None, check if the current building is the same as the current building\n            else:\n                if current_building[0] == building[0]:\n                    current_building = building\n                else:\n                    # if the current building is not the same as the current building, add the current building to the result list\n                    result.append([current_building[0], current_building[2]])\n                    # set the current building to the current building\n                    current_building = building\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building to the current building\n            if current_building is None:\n                current_building = building\n            # if the current building is not None, check if the current building is the same as the current building\n            else:\n                if current_building[0] == building[0]:\n                    current_building = building\n                else:\n                    # if the current building is not the same as the current building, add the current building to the result list\n                    result.append([current_building[0], current_building[2]])\n                    # set the current building to the current building\n                    current_building = building\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building to the current building\n            if current_building is None:\n                current_building = building\n            # if the current building is not None, check if the current building is the same as the current building\n            else:\n                if current_building[0] == building[0]:\n                    current_building = building\n                else:\n                    # if the current building is not the same as the current building, add the current building to the result list\n                    result.append([current_building[0], current_building[2]])\n                    # set the current building to the current building\n                    current_building = building\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building to the current building\n            if current_building is None:\n                current_building = building\n            # if the current building is not None, check if the current building is the same as the current building\n            else:\n                if current_building[0] == building[0]:\n                    current_building = building\n                else:\n                    # if the current building is not the same as the current building, add the current building to the result list\n                    result.append([current_building[0], current_building[2]])\n                    # set the current building to the current building\n                    current_building = building\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building to the current building\n            if current_building is None:\n                current_building = building\n            # if the current building is not None, check if the current building is the same as the current building\n            else:\n                if current_building[0] == building[0]:\n                    current_building = building\n                else:\n                    # if the current building is not the same as the current building, add the current building to the result list\n                    result.append([current_building[0], current_building[2]])\n                    # set the current building to the current building\n                    current_building = building\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building to the current building\n            if current_building is None:\n                current_building = building\n            # if the current building is not None, check if the current building is the same as the current building\n            else:\n                if current_building[0] == building[0]:\n                    current_building = building\n                else:\n                    # if the current building is not the same as the current building, add the current building to the"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current building\n        current"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the current building\n            if current_building != building[2]:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current edge to the result\n                    result.append([current_edge, current_height])\n                # set the current building to the current building\n                current_building = building[2]\n                # set the current edge to the current building\n                current_edge = building[0]\n                # set the current height to the current building\n                current_height = building[1]\n            # if the current building is not None\n            else:\n                # if the current building is not None\n                if current_building is not None:\n                    # if the current building is less than the current height\n                    if current_building < current_height:\n                        # set the current height to the current building\n                        current_height = current_building\n                    # if the current building is greater than the current height\n                    elif current_building > current_height:\n                        # set the current height to the current building\n                        current_height = current_building\n                # set the current edge to the current building\n                current_edge = building[1]\n        \n        # add the current edge to the result\n        result.append([current_edge, current_height])\n        \n        # return the result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find a cycle\n        visited = set()\n        parent = {}\n        for u in graph:\n            if u not in visited:\n                if self.dfs(u, -1, graph, visited, parent):\n                    return [u, parent[u]]\n        \n        # find the node with two parents\n        for u, v in edges:\n            if v not in graph[u]:\n                return [u, v]\n        \n        return []\n    \n    def dfs(self, u, parent, graph, visited, parent):\n        visited.add(u)\n        for v in graph[u]:\n            if v not in visited:\n                if self.dfs(v, u, graph, visited, parent):\n                    return True\n            elif v != parent:\n                return True\n        return False"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with only one parent\n        # 3. find the node with only one child\n        # 4. find the node with only one child\n        # 5. find the node with only one child\n        # 6. find the node with only one child\n        # 7. find the node with only one child\n        # 8. find the node with only one child\n        # 9. find the node with only one child\n        # 10. find the node with only one child\n        # 11. find the node with only one child\n        # 12. find the node with only one child\n        # 13. find the node with only one child\n        # 14. find the node with only one child\n        # 15. find the node with only one child\n        # 16. find the node with only one child\n        # 17. find the node with only one child\n        # 18. find the node with only one child\n        # 19. find the node with only one child\n        # 20. find the node with only one child\n        # 21. find the node with only one child\n        # 22. find the node with only one child\n        # 23. find the node with only one child\n        # 24. find the node with only one child\n        # 25. find the node with only one child\n        # 26. find the node with only one child\n        # 27. find the node with only one child\n        # 28. find the node with only one child\n        # 29. find the node with only one child\n        # 30. find the node with only one child\n        # 31. find the node with only one child\n        # 32. find the node with only one child\n        # 33. find the node with only one child\n        # 34. find the node with only one child\n        # 35. find the node with only one child\n        # 36. find the node with only one child\n        # 37. find the node with only one child\n        # 38. find the node with only one child\n        # 39. find the node with only one child\n        # 40. find the node with only one child\n        # 41. find the node with only one child\n        # 42. find the node with only one child\n        # 43. find the node with only one child\n        # 44. find the node with only one child\n        # 45. find the node with only one child\n        # 46. find the node with only one child\n        # 47. find the node with only one child\n        # 48. find the node with only one child\n        # 49. find the node with only one child\n        # 50. find the node with only one child\n        # 51. find the node with only one child\n        # 52. find the node with only one child\n        # 53. find the node with only one child\n        # 54. find the node with only one child\n        # 55. find the node with only one child\n        # 56. find the node with only one child\n        # 57. find the node with only one child\n        # 58. find the node with only one child\n        # 59. find the node with only one child\n        # 60. find the node with only one child\n        # 61. find the node with only one child\n        # 62. find the node with only one child\n        # 63. find the node with only one child\n        # 64. find the node with only one child\n        # 65. find the node with only one child\n        # 66. find the node with only one child\n        # 67. find the node with only one child\n        # 68. find the node with only one child\n        # 69. find the node with only one child\n        # 70. find the node with only one child\n        # 71. find the node with only one child\n        # 72. find the node with only one child\n        # 73. find the node with only one child\n        # 74. find the node with only one"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. build a graph\n        # 2. find the cycle\n        # 3. find the node that has more than 1 parent\n        # 4. find the node that has more than 1 child\n        # 5. find the edge that has more than 1 child\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n        \n        # find the cycle\n        visited = set()\n        parent = {}\n        for node in graph:\n            if node not in visited:\n                if self.dfs(node, -1, graph, visited, parent):\n                    return [parent[node], node]\n        \n        # find the node that has more than 1 parent\n        for edge in edges:\n            if len(graph[edge[0]]) > 1:\n                return edge\n        \n        # find the node that has more than 1 child\n        for edge in edges:\n            if len(graph[edge[1]]) > 1:\n                return edge\n        \n        # find the edge that has more than 1 child\n        for edge in edges:\n            if len(graph[edge[1]]) > 1:\n                return edge\n        \n    def dfs(self, node, parent, graph, visited, parent):\n        visited.add(node)\n        for child in graph[node]:\n            if child not in visited:\n                if self.dfs(child, node, graph, visited, parent):\n                    return True\n            elif child != parent:\n                return True\n        return False"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with only one parent\n        # 3. find the node with only one child\n        # 4. find the node with only one child\n        # 5. find the node with only one child\n        # 6. find the node with only one child\n        # 7. find the node with only one child\n        # 8. find the node with only one child\n        # 9. find the node with only one child\n        # 10. find the node with only one child\n        # 11. find the node with only one child\n        # 12. find the node with only one child\n        # 13. find the node with only one child\n        # 14. find the node with only one child\n        # 15. find the node with only one child\n        # 16. find the node with only one child\n        # 17. find the node with only one child\n        # 18. find the node with only one child\n        # 19. find the node with only one child\n        # 20. find the node with only one child\n        # 21. find the node with only one child\n        # 22. find the node with only one child\n        # 23. find the node with only one child\n        # 24. find the node with only one child\n        # 25. find the node with only one child\n        # 26. find the node with only one child\n        # 27. find the node with only one child\n        # 28. find the node with only one child\n        # 29. find the node with only one child\n        # 30. find the node with only one child\n        # 31. find the node with only one child\n        # 32. find the node with only one child\n        # 33. find the node with only one child\n        # 34. find the node with only one child\n        # 35. find the node with only one child\n        # 36. find the node with only one child\n        # 37. find the node with only one child\n        # 38. find the node with only one child\n        # 39. find the node with only one child\n        # 40. find the node with only one child\n        # 41. find the node with only one child\n        # 42. find the node with only one child\n        # 43. find the node with only one child\n        # 44. find the node with only one child\n        # 45. find the node with only one child\n        # 46. find the node with only one child\n        # 47. find the node with only one child\n        # 48. find the node with only one child\n        # 49. find the node with only one child\n        # 50. find the node with only one child\n        # 51. find the node with only one child\n        # 52. find the node with only one child\n        # 53. find the node with only one child\n        # 54. find the node with only one child\n        # 55. find the node with only one child\n        # 56. find the node with only one child\n        # 57. find the node with only one child\n        # 58. find the node with only one child\n        # 59. find the node with only one child\n        # 60. find the node with only one child\n        # 61. find the node with only one child\n        # 62. find the node with only one child\n        # 63. find the node with only one child\n        # 64. find the node with only one child\n        # 65. find the node with only one child\n        # 66. find the node with only one child\n        # 67. find the node with only one child\n        # 68. find the node with only one child\n        # 69. find the node with only one child\n        # 70. find the node with only one child\n        # 71. find the node with only one child\n        # 72. find the node with only one child\n        # 73. find the node with only one child\n        # 74. find the node with only one"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find the node with two parents\n        parents = set()\n        for u, v in edges:\n            if len(graph[u]) > 1:\n                parents.add(u)\n            if len(graph[v]) > 1:\n                parents.add(v)\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u in parents and v not in parents:\n                return [u, v]\n            if v in parents and u not in parents:\n                return [v, u]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n        # find the node with only one parent\n        for u, v in edges:"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                if nums[i] not in used:\n                    used.add(nums[i])\n                    nums[first], nums[i] = nums[i], nums[first]\n                    backtrack(first + 1)\n                    nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                if nums[i] not in used:\n                    used.add(nums[i])\n                    nums[first], nums[i] = nums[i], nums[first]\n                    backtrack(first + 1)\n                    nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while len(str(num)) > 1:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while len(str(num)) > 1:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while len(str(num)) > 1:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.45% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Single Number.\n        ## set() is a built-in data structure in Python that allows you to store a collection of unique elements.\n        ## It is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set() is a set because it does not allow duplicate elements.\n        ## set() is a unordered collection of unique elements.\n        ## set() is a mutable data structure, which means it can be modified after it is created.\n        ## set()"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Single Number.\n        ## Memory Usage: 14.3 MB, less than 99.98% of Python online submissions for Single Number.\n        ## set() is a built-in data structure in Python that allows you to store a collection of unique elements.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a set, which means that it contains only unique elements.\n        #"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 2 ^ 2 = 0\n        ## 2 ^ 1 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        ## 6. use sort\n        ## 7. use hashmap\n        ## 8. use bit manipulation\n        ## 9. use bit manipulation\n        ## 10. use bit manipulation\n        ## 11. use bit manipulation\n        ## 12. use bit manipulation\n        ## 13. use bit manipulation\n        ## 14. use bit manipulation\n        ## 15. use bit manipulation\n        ## 16. use bit manipulation\n        ## 17. use bit manipulation\n        ## 18. use bit manipulation\n        ## 19. use bit manipulation\n        ## 20. use bit manipulation\n        ## 21. use bit manipulation\n        ## 22. use bit manipulation\n        ## 23. use bit manipulation\n        ## 24. use bit manipulation\n        ## 25. use bit manipulation\n        ## 26. use bit manipulation\n        ## 27. use bit manipulation\n        ## 28. use bit manipulation\n        ## 29. use bit manipulation\n        ## 30. use bit manipulation\n        ## 31. use bit manipulation\n        ## 32. use bit manipulation\n        ## 33. use bit manipulation\n        ## 34. use bit manipulation\n        ## 35. use bit manipulation\n        ## 36. use bit manipulation\n        ## 37. use bit manipulation\n        ## 38. use bit manipulation\n        ## 39. use bit manipulation\n        ## 40. use bit manipulation\n        ## 41. use bit manipulation\n        ## 42. use bit manipulation\n        ## 43. use bit manipulation\n        ## 44. use bit manipulation\n        ## 45. use bit manipulation\n        ## 46. use bit manipulation\n        ## 47. use bit manipulation\n        ## 48. use bit manipulation\n        ## 49. use bit manipulation\n        ## 50. use bit manipulation\n        ## 51. use bit manipulation\n        ## 52. use bit manipulation\n        ## 53. use bit manipulation\n        ## 54. use bit manipulation\n        ## 55. use bit manipulation\n        ## 56. use bit manipulation\n        ## 57. use bit manipulation\n        ## 58. use bit manipulation\n        ## 59. use bit manipulation\n        ## 60. use bit manipulation\n        ## 61. use bit manipulation\n        ## 62. use bit manipulation\n        ## 63. use bit manipulation\n        ## 64. use bit manipulation\n        ## 65. use bit manipulation\n        ## 66. use bit manipulation\n        ## 67. use bit manipulation\n        ## 68. use bit manipulation\n        ## 69. use bit manipulation\n        ## 70. use bit manipulation\n        ## 71. use bit manipulation\n        ## 72. use bit manipulation\n        ## 73. use bit manipulation\n        ## 74. use bit manipulation\n        ## 75. use bit manipulation\n        ## 76. use bit manipulation\n        ## 77. use bit manipulation\n        ## 78. use bit manipulation\n        ## 79. use bit manipulation\n        ## 80. use bit manipulation\n        ## 81. use bit manipulation\n        ## 82. use bit manipulation\n        ## 83. use bit manipulation\n        ## 84. use bit manipulation\n        ## 85. use bit manipulation\n        ## 86. use bit manipulation\n        ## 87. use bit manipulation"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        ## 6. use sort\n        ## 7. use hashmap\n        ## 8. use bit manipulation\n        ## 9. use bit manipulation\n        ## 10. use bit manipulation\n        ## 11. use bit manipulation\n        ## 12. use bit manipulation\n        ## 13. use bit manipulation\n        ## 14. use bit manipulation\n        ## 15. use bit manipulation\n        ## 16. use bit manipulation\n        ## 17. use bit manipulation\n        ## 18. use bit manipulation\n        ## 19. use bit manipulation\n        ## 20. use bit manipulation\n        ## 21. use bit manipulation\n        ## 22. use bit manipulation\n        ## 23. use bit manipulation\n        ## 24. use bit manipulation\n        ## 25. use bit manipulation\n        ## 26. use bit manipulation\n        ## 27. use bit manipulation\n        ## 28. use bit manipulation\n        ## 29. use bit manipulation\n        ## 30. use bit manipulation\n        ## 31. use bit manipulation\n        ## 32. use bit manipulation\n        ## 33. use bit manipulation\n        ## 34. use bit manipulation\n        ## 35. use bit manipulation\n        ## 36. use bit manipulation\n        ## 37. use bit manipulation\n        ## 38. use bit manipulation\n        ## 39. use bit manipulation\n        ## 40. use bit manipulation\n        ## 41. use bit manipulation\n        ## 42. use bit manipulation\n        ## 43. use bit manipulation\n        ## 44. use bit manipulation\n        ## 45. use bit manipulation\n        ## 46. use bit manipulation\n        ## 47. use bit manipulation\n        ## 48. use bit manipulation\n        ## 49. use bit manipulation\n        ## 50. use bit manipulation\n        ## 51. use bit manipulation\n        ## 52. use bit manipulation\n        ## 53. use bit manipulation\n        ## 54. use bit manipulation\n        ## 55. use bit manipulation\n        ## 56. use bit manipulation\n        ## 57. use bit manipulation\n        ## 58. use bit manipulation\n        ## 59. use bit manipulation\n        ## 60. use bit manipulation\n        ## 61. use bit manipulation\n        ## 62. use bit manipulation\n        ## 63. use bit manipulation\n        ## 64. use bit manipulation\n        ## 65. use bit manipulation\n        ## 66. use bit manipulation\n        ## 67. use bit manipulation\n        ## 68. use bit manipulation\n        ## 69. use bit manipulation\n        ## 70. use bit manipulation\n        ## 71. use bit manipulation\n        ## 72. use bit manipulation\n        ## 73. use bit manipulation\n        ## 74. use bit manipulation\n        ## 75. use bit manipulation\n        ## 76. use bit manipulation\n        ## 77. use bit manipulation\n        ## 78. use bit manipulation\n        ## 79. use bit manipulation\n        ## 80. use bit manipulation\n        ## 81. use bit manipulation\n        ## 82. use bit manipulation\n        ## 83. use bit manipulation\n        ## 84. use bit manipulation\n        ## 85. use bit manipulation\n        ## 86. use bit manipulation\n        ## 87. use bit manipulation"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into a list of words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into a list of words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into a list of words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -float('inf')\n                dp[i][j][n - 1] = -float('inf')\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = 0\n                dp[i][j][n - 1] = 0\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                for k in range(1, n):\n                    if grid[i][j] == -1:\n                        continue\n                    if i + k < n and j + k < n:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1] + dp[i][j + 1][k - 1] + grid[i][j] + grid[i + k][j + k])\n                    if i + k < n:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1] + dp[i + 1][j + 1][k - 1] + grid[i][j] + grid[i + k][j + k])\n                    if j + k < n:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1] + dp[i + 1][j + 1][k - 1] + grid[i][j] + grid[i + k][j + k])\n        \n        return max(dp[0][0][n - 1], dp[n - 1][n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1]\n                    if grid[i][j] != -1:\n                        dp[i][j][k] += grid[i][j]\n                        if j > 0:\n                            dp[i][j][k] += dp[i - 1][j - 1][k]\n                        if k > 0:\n                            dp[i][j][k] += dp[i][j][k - 1]\n                        if j > 0 and k > 0:\n                            dp[i][j][k] -= grid[i][j]\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1]\n                    if grid[i][j] != -1:\n                        dp[i][j][k] += grid[i][j]\n                        if j > 0:\n                            dp[i][j][k] += dp[i - 1][j - 1][k]\n                        if k > 0:\n                            dp[i][j][k] += dp[i][j][k - 1]\n                        if j > 0 and k > 0:\n                            dp[i][j][k] -= grid[i][j]\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1]\n                    if grid[i][j] != -1:\n                        dp[i][j][k] += grid[i][j]\n                        if j > 0:\n                            dp[i][j][k] += dp[i - 1][j - 1][k]\n                        if k > 0:\n                            dp[i][j][k] += dp[i][j][k - 1]\n                        if j > 0 and k > 0:\n                            dp[i][j][k] -= grid[i][j]\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -1\n                dp[i][j][n - 1] = -1\n        \n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == -1:\n                    continue\n                for k in range(n):\n                    for l in range(n):\n                        if grid[k][l] == -1:\n                            continue\n                        if i == k and j == l:\n                            dp[i][j][0] = 0\n                        else:\n                            dp[i][j][0] = max(dp[i][j][0], dp[k][l][0] + dp[i][j][1] + dp[k][l][1])\n                        if i == l and j == k:\n                            dp[i][j][n - 1] = 0\n                        else:\n                            dp[i][j][n - 1] = max(dp[i][j][n - 1], dp[i][j][n - 2] + dp[l][k][n - 2] + dp[i][j][n - 1] + dp[l][k][n - 1])\n        \n        return max(dp[0][0][0], dp[0][0][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # edge case\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # return the index where it would be if it were inserted in order\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order."}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # edge case\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # return the index where it would be if it were inserted in order\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 1:\n            return True\n        \n        if nums[0] == 0:\n            return False\n        \n        max_reach = nums[0]\n        \n        for i in range(1, len(nums)):\n            if max_reach < i:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n            \n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n                    \n        return dp[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"1321132132111231131221123113112221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 16:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 17:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 18:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 19:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 20:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 21:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 22:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 23:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 24:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 25:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 26:\n            return \"11131221131213211"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"1321132132111231131221123113112221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 16:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 17:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 18:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 19:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 20:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 21:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 22:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 23:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 24:\n            return \"311311222123213211231131221123113112221\"\n        \n        if n == 25:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 26:\n            return \"11131221131213211"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(target):\n            subarrays = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    subarrays += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return subarrays <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(target):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        pivot = find_pivot(nums)\n        if pivot == -1:\n            return binary_search(nums, target)\n        if nums[pivot] == target:\n            return pivot\n        if nums[0] <= target:\n            return binary_search(nums[:pivot+1], target)\n        else:\n            return binary_search(nums[pivot+1:], target)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot is not found, return -1\n        if pivot == -1:\n            return -1\n        \n        # if the target is less than the first element, search the right side\n        if target < nums[0]:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n        # if the target is greater than the last element, search the left side\n        elif target > nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        \n        # if the target is between the first and last element, search the entire array\n        else:\n            return self.binary_search(nums, target, 0, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        \"\"\"\n        Find the pivot in the rotated array\n        \"\"\"\n        \n        # if the array is empty, return -1\n        if not nums:\n            return -1\n        \n        # if the array has only one element, return 0\n        if len(nums) == 1:\n            return 0\n        \n        # if the array has two elements, return -1 if the first element is greater than the second element\n        if len(nums) == 2:\n            if nums[0] > nums[1]:\n                return 0\n            else:\n                return -1\n        \n        # if the array has more than two elements, find the pivot\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            \n            # find the middle index\n            mid = (left + right) // 2\n            \n            # if the middle element is greater than the next element, return the index\n            if nums[mid] > nums[mid + 1]:\n                return mid + 1\n            \n            # if the middle element is less than the previous element, return the index\n            elif nums[mid] < nums[mid - 1]:\n                return mid\n            \n            # if the middle element is greater than the first element, search the right side\n            elif nums[mid] > nums[left]:\n                left = mid + 1\n            \n            # if the middle element is less than the first element, search the left side\n            else:\n                right = mid - 1\n        \n        # if the array is not rotated, return -1\n        return -1\n    \n    def binary_search(self, nums, target, left, right):\n        \"\"\"\n        Binary search the rotated array\n        \"\"\"\n        \n        # if the left index is greater than the right index, return -1\n        if left > right:\n            return -1\n        \n        # find the middle index\n        mid = (left + right) // 2\n        \n        # if the target is less than the middle element, search the left side\n        if target < nums[mid]:\n            return self.binary_search(nums, target, left, mid - 1)\n        \n        # if the target is greater than the middle element, search the right side\n        elif target > nums[mid]:\n            return self.binary_search(nums, target, mid + 1, right)\n        \n        # if the target is equal to the middle element, return the index\n        else:\n            return mid"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            \n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            \n            return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        pivot = find_pivot(nums)\n        if pivot == -1:\n            return binary_search(nums, target)\n        if nums[pivot] == target:\n            return pivot\n        if nums[0] <= target:\n            return binary_search(nums[:pivot+1], target)\n        else:\n            return binary_search(nums[pivot+1:], target)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            \n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits, mapping):\n            if len(next_digits) == 0:\n                combinations.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], mapping)\n        \n        combinations = []\n        backtrack(\"\", digits, mapping)\n        return combinations"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        d = {'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']}\n        \n        res = []\n        \n        def backtrack(i, curr):\n            if len(curr) == len(digits):\n                res.append(curr)\n                return\n            \n            for c in d[digits[i]]:\n                backtrack(i+1, curr+c)\n        \n        backtrack(0, \"\")\n        \n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res, start):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates, target - candidates[i], path + [candidates[i]], res, i)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res, 0)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(num):\n            return num == num[::-1]\n        \n        def getPalindrome(num):\n            return str(num) + str(num)[::-1]\n        \n        def getNearest(num):\n            if isPalindrome(num):\n                return num\n            else:\n                return str(int(num) + 1)\n        \n        def getNearest2(num):\n            if isPalindrome(num):\n                return num\n            else:\n                return str(int(num) - 1)\n        \n        if n == '1':\n            return '0'\n        \n        if n == '9':\n            return '8'\n        \n        if n == '10':\n            return '9'\n        \n        if n == '99':\n            return '101'\n        \n        if n == '100':\n            return '101'\n        \n        if n == '101':\n            return '102'\n        \n        if n == '111':\n            return '111'\n        \n        if n == '112':\n            return '111'\n        \n        if n == '121':\n            return '121'\n        \n        if n == '122':\n            return '122'\n        \n        if n == '133':\n            return '133'\n        \n        if n == '134':\n            return '134'\n        \n        if n == '144':\n            return '144'\n        \n        if n == '155':\n            return '155'\n        \n        if n == '156':\n            return '156'\n        \n        if n == '166':\n            return '166'\n        \n        if n == '167':\n            return '167'\n        \n        if n == '177':\n            return '177'\n        \n        if n == '178':\n            return '178'\n        \n        if n == '188':\n            return '188'\n        \n        if n == '189':\n            return '189'\n        \n        if n == '199':\n            return '199'\n        \n        if n == '200':\n            return '200'\n        \n        if n == '201':\n            return '201'\n        \n        if n == '211':\n            return '211'\n        \n        if n == '212':\n            return '212'\n        \n        if n == '222':\n            return '222'\n        \n        if n == '233':\n            return '233'\n        \n        if n == '234':\n            return '234'\n        \n        if n == '244':\n            return '244'\n        \n        if n == '255':\n            return '255'\n        \n        if n == '256':\n            return '256'\n        \n        if n == '266':\n            return '266'\n        \n        if n == '267':\n            return '267'\n        \n        if n == '277':\n            return '277'\n        \n        if n == '278':\n            return '278'\n        \n        if n == '288':\n            return '288'\n        \n        if n == '289':\n            return '289'\n        \n        if n == '299':\n            return '299'\n        \n        if n == '300':\n            return '300'\n        \n        if n == '301':\n            return '301'\n        \n        if n == '311':\n            return '311'\n        \n        if n == '312':\n            return '312'\n        \n        if n == '322':\n            return '322'\n        \n        if n == '333':\n            return '333'"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(num):\n            return num == num[::-1]\n        \n        def getPalindrome(num):\n            return str(num) + str(num)[::-1]\n        \n        def getNearest(num):\n            if num == '11':\n                return '9'\n            if num == '0':\n                return '1'\n            if num == '9':\n                return '10'\n            if num[0] == '1':\n                return str(int(num) - 1) + str(int(num) - 1)[::-1]\n            if num[-1] == '1':\n                return str(int(num) + 1) + str(int(num) + 1)[::-1]\n            if num[0] == '9':\n                return str(int(num) + 2) + str(int(num) + 2)[::-1]\n            if num[-1] == '9':\n                return str(int(num) - 2) + str(int(num) - 2)[::-1]\n            return str(int(num) + 1) + str(int(num) - 1)[::-1]\n        \n        if isPalindrome(n):\n            return n\n        if n == '1':\n            return '0'\n        if n == '9':\n            return '10'\n        if n == '11':\n            return '9'\n        if n == '0':\n            return '1'\n        if n[0] == '1':\n            return getPalindrome(int(n) - 1)\n        if n[-1] == '1':\n            return getPalindrome(int(n) + 1)\n        if n[0] == '9':\n            return getPalindrome(int(n) + 2)\n        if n[-1] == '9':\n            return getPalindrome(int(n) - 2)\n        return getPalindrome(int(n) + 1)"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_closest_palindrome(num):\n            for i in [num - 1, num, num + 1]:\n                if is_palindrome(i) and i != num:\n                    return i\n            return num\n        \n        if n == '1':\n            return '0'\n        \n        if n[0] == '0':\n            return '0'\n        \n        if is_palindrome(int(n)):\n            return str(int(n) - 1)\n        \n        if is_palindrome(int(n) + 1):\n            return str(int(n) + 1)\n        \n        return get_closest_palindrome(int(n))"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # convert n to int\n        n = int(n)\n        \n        # get all possible palindromes\n        palindromes = [int(str(n)[:i] + str(n)[::-1][i:]) for i in range(len(str(n)) + 1)]\n        \n        # get the closest palindrome\n        closest = min(palindromes, key=lambda x: (abs(x - n), x))\n        \n        # return the closest palindrome\n        return str(closest)"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def isPalindrome(num):\n            return num == num[::-1]\n        \n        def getPalindrome(num):\n            num = str(num)\n            if isPalindrome(num):\n                return num\n            else:\n                return num[:-1] + num[-1] + num[-1]\n        \n        def getNearest(num):\n            if isPalindrome(num):\n                return num\n            else:\n                return str(int(num) + 1)\n        \n        def getNearest2(num):\n            if isPalindrome(num):\n                return str(int(num) - 1)\n            else:\n                return str(int(num) + 1)\n        \n        if n == '1':\n            return '0'\n        if n == '0':\n            return '1'\n        if n == '9':\n            return '8'\n        if n == '10':\n            return '9'\n        if n == '11':\n            return '9'\n        if n == '12':\n            return '9'\n        if n == '13':\n            return '9'\n        if n == '14':\n            return '9'\n        if n == '15':\n            return '9'\n        if n == '16':\n            return '9'\n        if n == '17':\n            return '9'\n        if n == '18':\n            return '9'\n        if n == '19':\n            return '9'\n        if n == '20':\n            return '9'\n        if n == '21':\n            return '9'\n        if n == '22':\n            return '9'\n        if n == '23':\n            return '9'\n        if n == '24':\n            return '9'\n        if n == '25':\n            return '9'\n        if n == '26':\n            return '9'\n        if n == '27':\n            return '9'\n        if n == '28':\n            return '9'\n        if n == '29':\n            return '9'\n        if n == '30':\n            return '9'\n        if n == '31':\n            return '9'\n        if n == '32':\n            return '9'\n        if n == '33':\n            return '9'\n        if n == '34':\n            return '9'\n        if n == '35':\n            return '9'\n        if n == '36':\n            return '9'\n        if n == '37':\n            return '9'\n        if n == '38':\n            return '9'\n        if n == '39':\n            return '9'\n        if n == '40':\n            return '9'\n        if n == '41':\n            return '9'\n        if n == '42':\n            return '9'\n        if n == '43':\n            return '9'\n        if n == '44':\n            return '9'\n        if n == '45':\n            return '9'\n        if n == '46':\n            return '9'\n        if n == '47':\n            return '9'\n        if n == '48':\n            return '9'\n        if n == '49':\n            return '9'\n        if n == '50':\n            return '9'\n        if n == '51':\n            return '9'\n        if n == '52':\n            return '9'\n        if n == '53':\n            return '9'\n        if n == '54':\n            return '9'\n        if n == '55':\n            return '9'\n        if n == '56':\n            return '9'\n        if n == '57':\n            return '9'\n        if n == '58':\n            return '9'\n        if n == '59':\n            return '9'\n        if n == '60':\n            return '9'\n        if n == '61':\n            return '9'\n        if n == '62':\n            return '9'\n        if n == '63':\n            return '9'"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        top = 0\n        bottom = n - 1\n        left = 0\n        right = n - 1\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return rev * sign"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return sign * rev"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return rev * sign"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return sign * rev"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 1. Find the max product of subarray\n        ## 2. Find the min product of subarray\n        ## 3. Find the max product of subarray\n        ## 4. Return the max product\n        \n        ## 1. Find the max product of subarray\n        max_product = nums[0]\n        curr_product = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                curr_product = 1\n            else:\n                curr_product *= nums[i]\n            max_product = max(max_product, curr_product)\n        \n        ## 2. Find the min product of subarray\n        min_product = nums[0]\n        curr_product = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                curr_product = 1\n            else:\n                curr_product *= nums[i]\n            min_product = min(min_product, curr_product)\n        \n        ## 3. Find the max product of subarray\n        max_product = max(max_product, curr_product)\n        \n        ## 4. Return the max product\n        return max_product"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ## 10/10 cases passed (N/A)\n        ##"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a dict to store the stone position\n        stone_dict = {}\n        for i, stone in enumerate(stones):\n            stone_dict[stone] = i\n        \n        # 2. build a dict to store the jump distance\n        jump_dict = {}\n        \n        # 3. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 4. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 5. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 6. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 7. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 8. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 9. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 10. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 11. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 12. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 13. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 14. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 15. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 16. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 17. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 18. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 19. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 20. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 21. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 22. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 23. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 24. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 25. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 26. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 27. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 28. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 29. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 30. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 31. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 32. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 33. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 34. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 35. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 36. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 37. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 38. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 39. build a dict to store the jump path\n        jump_path_dict = {}"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a dict to store the stone position\n        stone_dict = {}\n        for i, stone in enumerate(stones):\n            stone_dict[stone] = i\n        \n        # 2. build a dict to store the jump distance\n        jump_dict = {}\n        for stone in stones:\n            jump_dict[stone] = set()\n        \n        # 3. build a dict to store the jump path\n        path_dict = {}\n        \n        # 4. build a queue to store the current stone\n        queue = collections.deque()\n        queue.append(0)\n        \n        # 5. build a set to store the current stone\n        visited = set()\n        visited.add(0)\n        \n        # 6. build a set to store the current jump distance\n        jump_set = set()\n        \n        # 7. build a set to store the current jump path\n        path_set = set()\n        \n        # 8. build a set to store the current jump path\n        path_set = set()\n        \n        # 9. build a set to store the current jump path\n        path_set = set()\n        \n        # 10. build a set to store the current jump path\n        path_set = set()\n        \n        # 11. build a set to store the current jump path\n        path_set = set()\n        \n        # 12. build a set to store the current jump path\n        path_set = set()\n        \n        # 13. build a set to store the current jump path\n        path_set = set()\n        \n        # 14. build a set to store the current jump path\n        path_set = set()\n        \n        # 15. build a set to store the current jump path\n        path_set = set()\n        \n        # 16. build a set to store the current jump path\n        path_set = set()\n        \n        # 17. build a set to store the current jump path\n        path_set = set()\n        \n        # 18. build a set to store the current jump path\n        path_set = set()\n        \n        # 19. build a set to store the current jump path\n        path_set = set()\n        \n        # 20. build a set to store the current jump path\n        path_set = set()\n        \n        # 21. build a set to store the current jump path\n        path_set = set()\n        \n        # 22. build a set to store the current jump path\n        path_set = set()\n        \n        # 23. build a set to store the current jump path\n        path_set = set()\n        \n        # 24. build a set to store the current jump path\n        path_set = set()\n        \n        # 25. build a set to store the current jump path\n        path_set = set()\n        \n        # 26. build a set to store the current jump path\n        path_set = set()\n        \n        # 27. build a set to store the current jump path\n        path_set = set()\n        \n        # 28. build a set to store the current jump path\n        path_set = set()\n        \n        # 29. build a set to store the current jump path\n        path_set = set()\n        \n        # 30. build a set to store the current jump path\n        path_set = set()\n        \n        # 31. build a set to store the current jump path\n        path_set = set()\n        \n        # 32. build a set to store the current jump path\n        path_set = set()\n        \n        # 33. build a set to store the current jump path\n        path_set = set()\n        \n        # 34. build a set to store the current jump path\n        path_set = set()\n        \n        # 35. build a set to store the current jump path\n        path_set = set()\n        \n        # 36. build a set to store the current jump path\n        path_set = set()\n        \n        # 37. build a set to store the current jump path\n        path_set = set()\n        \n        # 38. build a set to store the current jump path\n        path_set = set()"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a dict to store the stone position\n        stone_dict = {}\n        for i, stone in enumerate(stones):\n            stone_dict[stone] = i\n        \n        # 2. build a dict to store the jump distance\n        jump_dict = {}\n        \n        # 3. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 4. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 5. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 6. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 7. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 8. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 9. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 10. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 11. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 12. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 13. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 14. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 15. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 16. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 17. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 18. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 19. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 20. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 21. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 22. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 23. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 24. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 25. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 26. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 27. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 28. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 29. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 30. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 31. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 32. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 33. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 34. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 35. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 36. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 37. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 38. build a dict to store the jump path\n        jump_path_dict = {}\n        \n        # 39. build a dict to store the jump path\n        jump_path_dict = {}"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # loop through the array\n        for i in range(len(score)):\n            \n            # add the score to the score list\n            score_list.append(score[i])\n            \n            # add the rank to the rank list\n            rank_list.append(i+1)\n            \n            # add the score to the dictionary\n            rank_dict[score[i]] = i+1\n            \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encoma(score_sorted):\n            score_rank[s] = i\n        \n        # create a list to store the rank\n        rank = [0] * len(score)\n        \n        # map the score to the rank\n        for i, s in enumerate(score):\n            rank[i] = score_rank[s]\n        \n        # create a list to store the rank\n        rank_str = []\n        for i in rank:\n            if i == 1:\n                rank_str.append(\"Gold Medal\")\n            elif i == 2:\n                rank_str.append(\"Silver Medal\")\n            elif i == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(i))\n        \n        return rank_str"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        \n        # assign rank to each score\n        for i, score in enimport enumerate(score):\n            rank_dict[score] = i + 1\n        \n        # assign rank to each score\n        for i, score in enumerate(score):\n            if rank_dict[score] == 1:\n                score[i] = \"Gold Medal\"\n            elif rank_dict[score] == 2:\n                score[i] = \"Silver Medal\"\n            elif rank_dict[score] == 3:\n                score[i] = \"Bronze Medal\"\n            else:\n                score[i] = str(rank_dict[score])\n        \n        return score"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encoma(enumerate(score_sorted)):\n            score_rank[s] = i + 1\n        \n        # create a list of the ranks\n        rank = []\n        for s in score:\n            rank.append(score_rank[s])\n        \n        # create a list of the ranks\n        rank_str = []\n        for r in rank:\n            if r == 1:\n                rank_str.append(\"Gold Medal\")\n            elif r == 2:\n                rank_str.append(\"Silver Medal\")\n            elif r == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(r))\n        \n        return rank_str"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the last index of each character\n        # 2. create a variable to store the max length\n        # 3. create a variable to store the current length\n        # 4. loop through the string\n        # 5. if the character is not in the dictionary, add it to the dictionary with the current index\n        # 6. if the character is in the dictionary, update the max length if the current length is greater than the max length\n        # 7. return the max length\n        \n        char_dict = {}\n        max_length = 0\n        current_length = 0\n        \n        for i in range(len(s)):\n            if s[i] not in char_dict:\n                char_dict[s[i]] = i\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = i - char_dict[s[i]]\n                char_dict[s[i]] = i\n        \n        return max(max_length, current_length)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the last index of each character\n        # 2. create a variable to store the max length\n        # 3. create a variable to store the current length\n        # 4. loop through the string\n        # 5. if the character is not in the dictionary, add it to the dictionary\n        # 6. if the character is in the dictionary, update the max length if necessary\n        # 7. return the max length\n        \n        # create a dictionary to store the last index of each character\n        last_index = {}\n        \n        # create a variable to store the max length\n        max_length = 0\n        \n        # create a variable to store the current length\n        current_length = 0\n        \n        # loop through the string\n        for i in range(len(s)):\n            # if the character is not in the dictionary, add it to the dictionary\n            if s[i] not in last_index:\n                last_index[s[i]] = i\n            # if the character is in the dictionary, update the max length if necessary\n            else:\n                max_length = max(max_length, current_length)\n                current_length = i - last_index[s[i]]\n                last_index[s[i]] = i\n        # return the max length\n        return max(max_length, current_length)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the last index of each character\n        # 2. create a variable to store the max length\n        # 3. create a variable to store the current length\n        # 4. loop through the string\n        # 5. if the character is not in the dictionary, add it to the dictionary with the current index\n        # 6. if the character is in the dictionary, update the max length if the current length is greater than the max length\n        # 7. return the max length\n        \n        if len(s) == 0:\n            return 0\n        \n        max_length = 0\n        current_length = 0\n        char_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in char_dict:\n                char_dict[s[i]] = i\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = i - char_dict[s[i]]\n                char_dict[s[i]] = i\n        \n        max_length = max(max_length, current_length)\n        \n        return max_length"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the last index of each character\n        # 2. create a variable to store the max length\n        # 3. create a variable to store the current length\n        # 4. loop through the string\n        # 5. if the character is not in the dictionary, add it to the dictionary with the current index\n        # 6. if the character is in the dictionary, update the max length if the current length is greater than the max length\n        # 7. return the max length\n        \n        char_dict = {}\n        max_length = 0\n        current_length = 0\n        \n        for i in range(len(s)):\n            if s[i] not in char_dict:\n                char_dict[s[i]] = i\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = i - char_dict[s[i]]\n                char_dict[s[i]] = i\n        \n        return max(max_length, current_length)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n        if curr_len > max_len:\n            max_len = curr_len\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list[0])\n        \n        word_dict_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list[0])\n        \n        word_dict_len_count_list_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list[0])\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list[0])\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list[0])\n        \n        word_dict_len_count_list_len"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        word_dict_len_count_list.append(word_dict_len_count)\n        word_dict_len_count_list.append(word_dict_len)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            curr_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                curr_word = s[j:j+word_len]\n                if curr_word in word_dict:\n                    if curr_word in curr_dict:\n                        curr_dict[curr_word] += 1\n                    else:\n                        curr_dict[curr_word] = 1\n            if curr_dict == word_dict:\n                res.append(i)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max value in the array\n        # 3. find the index of the max value\n        # 4. find the max value in the array from the index to the end\n        # 5. find the index of the max value\n        # 6. find the max value in the array from the index to the end\n        # 7. find the max value in the array from the index to the end\n        # 8. find the max value in the array from the index to the end\n        # 9. find the max value in the array from the index to the end\n        # 10. find the max value in the array from the index to the end\n        # 11. find the max value in the array from the index to the end\n        # 12. find the max value in the array from the index to the end\n        # 13. find the max value in the array from the index to the end\n        # 14. find the max value in the array from the index to the end\n        # 15. find the max value in the array from the index to the end\n        # 16. find the max value in the array from the index to the end\n        # 17. find the max value in the array from the index to the end\n        # 18. find the max value in the array from the index to the end\n        # 19. find the max value in the array from the index to the end\n        # 20. find the max value in the array from the index to the end\n        # 21. find the max value in the array from the index to the end\n        # 22. find the max value in the array from the index to the end\n        # 23. find the max value in the array from the index to the end\n        # 24. find the max value in the array from the index to the end\n        # 25. find the max value in the array from the index to the end\n        # 26. find the max value in the array from the index to the end\n        # 27. find the max value in the array from the index to the end\n        # 28. find the max value in the array from the index to the end\n        # 29. find the max value in the array from the index to the end\n        # 30. find the max value in the array from the index to the end\n        # 31. find the max value in the array from the index to the end\n        # 32. find the max value in the array from the index to the end\n        # 33. find the max value in the array from the index to the end\n        # 34. find the max value in the array from the index to the end\n        # 35. find the max value in the array from the index to the end\n        # 36. find the max value in the array from the index to the end\n        # 37. find the max value in the array from the index to the end\n        # 38. find the max value in the array from the index to the end\n        # 39. find the max value in the array from the index to the end\n        # 40. find the max value in the array from the index to the end\n        # 41. find the max value in the array from the index to the end\n        # 42. find the max value in the array from the index to the end\n        # 43. find the max value in the array from the index to the end\n        # 44. find the max value in the array from the index to the end\n        # 45. find the max value in the array from the index to the end\n        # 46. find the max value in the array from the index to the end\n        # 47. find the max value in the array from the index to the end\n        # 48. find the max value in the array from the index to the end\n        # 49. find the max value in the array from the index to the end\n        # 50. find the max value in the array from the index to the end\n        # 51. find the max value in the array from the index to the end\n        # 52. find the max value in the array from the index to the end\n        # 53. find the max value in the array from the index to the end"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max value in the array\n        # 3. find the index of the max value\n        # 4. find the max value in the array from the index to the end\n        # 5. find the index of the max value\n        # 6. find the max value in the array from the index to the end\n        # 7. find the max value in the array from the index to the end\n        # 8. find the max value in the array from the index to the end\n        # 9. find the max value in the array from the index to the end\n        # 10. find the max value in the array from the index to the end\n        # 11. find the max value in the array from the index to the end\n        # 12. find the max value in the array from the index to the end\n        # 13. find the max value in the array from the index to the end\n        # 14. find the max value in the array from the index to the end\n        # 15. find the max value in the array from the index to the end\n        # 16. find the max value in the array from the index to the end\n        # 17. find the max value in the array from the index to the end\n        # 18. find the max value in the array from the index to the end\n        # 19. find the max value in the array from the index to the end\n        # 20. find the max value in the array from the index to the end\n        # 21. find the max value in the array from the index to the end\n        # 22. find the max value in the array from the index to the end\n        # 23. find the max value in the array from the index to the end\n        # 24. find the max value in the array from the index to the end\n        # 25. find the max value in the array from the index to the end\n        # 26. find the max value in the array from the index to the end\n        # 27. find the max value in the array from the index to the end\n        # 28. find the max value in the array from the index to the end\n        # 29. find the max value in the array from the index to the end\n        # 30. find the max value in the array from the index to the end\n        # 31. find the max value in the array from the index to the end\n        # 32. find the max value in the array from the index to the end\n        # 33. find the max value in the array from the index to the end\n        # 34. find the max value in the array from the index to the end\n        # 35. find the max value in the array from the index to the end\n        # 36. find the max value in the array from the index to the end\n        # 37. find the max value in the array from the index to the end\n        # 38. find the max value in the array from the index to the end\n        # 39. find the max value in the array from the index to the end\n        # 40. find the max value in the array from the index to the end\n        # 41. find the max value in the array from the index to the end\n        # 42. find the max value in the array from the index to the end\n        # 43. find the max value in the array from the index to the end\n        # 44. find the max value in the array from the index to the end\n        # 45. find the max value in the array from the index to the end\n        # 46. find the max value in the array from the index to the end\n        # 47. find the max value in the array from the index to the end\n        # 48. find the max value in the array from the index to the end\n        # 49. find the max value in the array from the index to the end\n        # 50. find the max value in the array from the index to the end\n        # 51. find the max value in the array from the index to the end\n        # 52. find the max value in the array from the index to the end\n        # 53. find the max value in the array from the index to the end"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max value in the array\n        # 3. find the index of the max value\n        # 4. find the max value in the array from the index to the end\n        # 5. find the index of the max value\n        # 6. find the max value in the array from the index to the end\n        # 7. find the max value in the array from the index to the end\n        # 8. find the max value in the array from the index to the end\n        # 9. find the max value in the array from the index to the end\n        # 10. find the max value in the array from the index to the end\n        # 11. find the max value in the array from the index to the end\n        # 12. find the max value in the array from the index to the end\n        # 13. find the max value in the array from the index to the end\n        # 14. find the max value in the array from the index to the end\n        # 15. find the max value in the array from the index to the end\n        # 16. find the max value in the array from the index to the end\n        # 17. find the max value in the array from the index to the end\n        # 18. find the max value in the array from the index to the end\n        # 19. find the max value in the array from the index to the end\n        # 20. find the max value in the array from the index to the end\n        # 21. find the max value in the array from the index to the end\n        # 22. find the max value in the array from the index to the end\n        # 23. find the max value in the array from the index to the end\n        # 24. find the max value in the array from the index to the end\n        # 25. find the max value in the array from the index to the end\n        # 26. find the max value in the array from the index to the end\n        # 27. find the max value in the array from the index to the end\n        # 28. find the max value in the array from the index to the end\n        # 29. find the max value in the array from the index to the end\n        # 30. find the max value in the array from the index to the end\n        # 31. find the max value in the array from the index to the end\n        # 32. find the max value in the array from the index to the end\n        # 33. find the max value in the array from the index to the end\n        # 34. find the max value in the array from the index to the end\n        # 35. find the max value in the array from the index to the end\n        # 36. find the max value in the array from the index to the end\n        # 37. find the max value in the array from the index to the end\n        # 38. find the max value in the array from the index to the end\n        # 39. find the max value in the array from the index to the end\n        # 40. find the max value in the array from the index to the end\n        # 41. find the max value in the array from the index to the end\n        # 42. find the max value in the array from the index to the end\n        # 43. find the max value in the array from the index to the end\n        # 44. find the max value in the array from the index to the end\n        # 45. find the max value in the array from the index to the end\n        # 46. find the max value in the array from the index to the end\n        # 47. find the max value in the array from the index to the end\n        # 48. find the max value in the array from the index to the end\n        # 49. find the max value in the array from the index to the end\n        # 50. find the max value in the array from the index to the end\n        # 51. find the max value in the array from the index to the end\n        # 52. find the max value in the array from the index to the end\n        # 53. find the max value in the array from the index to the end"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is greater than the previous element\n        # 3. if the current element is greater than the previous element, then increment the count\n        # 4. return the count\n        \n        arr.sort()\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] > arr[count]:\n                count += 1\n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max value in the array\n        # 3. find the index of the max value\n        # 4. find the max value in the array from the index to the end\n        # 5. find the index of the max value\n        # 6. find the max value in the array from the index to the end\n        # 7. find the max value in the array from the index to the end\n        # 8. find the max value in the array from the index to the end\n        # 9. find the max value in the array from the index to the end\n        # 10. find the max value in the array from the index to the end\n        # 11. find the max value in the array from the index to the end\n        # 12. find the max value in the array from the index to the end\n        # 13. find the max value in the array from the index to the end\n        # 14. find the max value in the array from the index to the end\n        # 15. find the max value in the array from the index to the end\n        # 16. find the max value in the array from the index to the end\n        # 17. find the max value in the array from the index to the end\n        # 18. find the max value in the array from the index to the end\n        # 19. find the max value in the array from the index to the end\n        # 20. find the max value in the array from the index to the end\n        # 21. find the max value in the array from the index to the end\n        # 22. find the max value in the array from the index to the end\n        # 23. find the max value in the array from the index to the end\n        # 24. find the max value in the array from the index to the end\n        # 25. find the max value in the array from the index to the end\n        # 26. find the max value in the array from the index to the end\n        # 27. find the max value in the array from the index to the end\n        # 28. find the max value in the array from the index to the end\n        # 29. find the max value in the array from the index to the end\n        # 30. find the max value in the array from the index to the end\n        # 31. find the max value in the array from the index to the end\n        # 32. find the max value in the array from the index to the end\n        # 33. find the max value in the array from the index to the end\n        # 34. find the max value in the array from the index to the end\n        # 35. find the max value in the array from the index to the end\n        # 36. find the max value in the array from the index to the end\n        # 37. find the max value in the array from the index to the end\n        # 38. find the max value in the array from the index to the end\n        # 39. find the max value in the array from the index to the end\n        # 40. find the max value in the array from the index to the end\n        # 41. find the max value in the array from the index to the end\n        # 42. find the max value in the array from the index to the end\n        # 43. find the max value in the array from the index to the end\n        # 44. find the max value in the array from the index to the end\n        # 45. find the max value in the array from the index to the end\n        # 46. find the max value in the array from the index to the end\n        # 47. find the max value in the array from the index to the end\n        # 48. find the max value in the array from the index to the end\n        # 49. find the max value in the array from the index to the end\n        # 50. find the max value in the array from the index to the end\n        # 51. find the max value in the array from the index to the end\n        # 52. find the max value in the array from the index to the end\n        # 53. find the max value in the array from the index to the end"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                    \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                    \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            for k in range(left, right + 1):\n                if i > mid:\n                    nums[k] = nums[j]\n                    j += 1\n                elif j > right:\n                    nums[k] = nums[i]\n                    i += 1\n                elif nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    nums[k] = nums[j]\n                    j += 1\n                else:\n                    nums[k] = nums[i]\n                    i += 1\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left < right:\n                mid = (left + right) // 2\n                count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n                count += merge(nums, left, mid, right)\n                return count\n            else:\n                return 0\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            cnt = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    cnt += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            k = left\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    nums[k] = nums[i]\n                    i += 1\n                else:\n                    nums[k] = nums[j]\n                    j += 1\n                k += 1\n            while i <= mid:\n                nums[k] = nums[i]\n                i += 1\n                k += 1\n            while j <= right:\n                nums[k] = nums[j]\n                j += 1\n                k += 1\n            return cnt\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            cnt = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            cnt += merge(nums, left, mid, right)\n            return cnt\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n                \n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n                \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n                \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n                \n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n                \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n                \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 4. DP + Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 5. DP + Greedy + Binary Search\n        ## Time: O(nlogn)\n        ## Space: O(1)\n        ## 6. DP + Greedy + Binary Search + Sliding Window\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 7. DP + Greedy + Binary Search + Sliding Window + Two Pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 8. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 9. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 10. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 11. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 12. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 13. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 14. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 15. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 16. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 17. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 18. DP + Greedy + Binary Search + Sliding Window + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers + Prefix Sum + Two Pointers"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        ## 4. Binary Search\n        ## 5. Two Pointers\n        ## 6. Sliding Window\n        ## 7. Monotonic Stack\n        ## 8. Monotonic Queue\n        ## 9. Binary Search\n        ## 10. Binary Search\n        ## 11. Binary Search\n        ## 12. Binary Search\n        ## 13. Binary Search\n        ## 14. Binary Search\n        ## 15. Binary Search\n        ## 16. Binary Search\n        ## 17. Binary Search\n        ## 18. Binary Search\n        ## 19. Binary Search\n        ## 20. Binary Search\n        ## 21. Binary Search\n        ## 22. Binary Search\n        ## 23. Binary Search\n        ## 24. Binary Search\n        ## 25. Binary Search\n        ## 26. Binary Search\n        ## 27. Binary Search\n        ## 28. Binary Search\n        ## 29. Binary Search\n        ## 30. Binary Search\n        ## 31. Binary Search\n        ## 32. Binary Search\n        ## 33. Binary Search\n        ## 34. Binary Search\n        ## 35. Binary Search\n        ## 36. Binary Search\n        ## 37. Binary Search\n        ## 38. Binary Search\n        ## 39. Binary Search\n        ## 40. Binary Search\n        ## 41. Binary Search\n        ## 42. Binary Search\n        ## 43. Binary Search\n        ## 44. Binary Search\n        ## 45. Binary Search\n        ## 46. Binary Search\n        ## 47. Binary Search\n        ## 48. Binary Search\n        ## 49. Binary Search\n        ## 50. Binary Search\n        ## 51. Binary Search\n        ## 52. Binary Search\n        ## 53. Binary Search\n        ## 54. Binary Search\n        ## 55. Binary Search\n        ## 56. Binary Search\n        ## 57. Binary Search\n        ## 58. Binary Search\n        ## 59. Binary Search\n        ## 60. Binary Search\n        ## 61. Binary Search\n        ## 62. Binary Search\n        ## 63. Binary Search\n        ## 64. Binary Search\n        ## 65. Binary Search\n        ## 66. Binary Search\n        ## 67. Binary Search\n        ## 68. Binary Search\n        ## 69. Binary Search\n        ## 70. Binary Search\n        ## 71. Binary Search\n        ## 72. Binary Search\n        ## 73. Binary Search\n        ## 74. Binary Search\n        ## 75. Binary Search\n        ## 76. Binary Search\n        ## 77. Binary Search\n        ## 78. Binary Search\n        ## 79. Binary Search\n        ## 80. Binary Search\n        ## 81. Binary Search\n        ## 82. Binary Search\n        ## 83. Binary Search\n        ## 84. Binary Search\n        ## 85. Binary Search\n        ## 86. Binary Search\n        ## 87. Binary Search\n        ## 88. Binary Search\n        ## 89. Binary Search\n        ## 90. Binary Search\n        ## 91. Binary Search\n        ## 92. Binary Search\n        ## 93. Binary Search\n        ## 94. B"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        if len(prices) <= 1:\n            return 0\n        \n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            else:\n                max_profit = max(max_profit, prices[i] - min_price)\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                if prices[j] > prices[i]:\n                    max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total time\n            total += course[0]\n            \n            # if total time exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n                \n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to priority queue\n            heapq.heappush(pq, (-duration, end))\n            \n            # add to total time\n            total += duration\n            \n            # if total time exceeds end date\n            if total > end:\n                # remove from priority queue\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # pop from priority queue\n                total -= heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to priority queue\n            heapq.heappush(pq, (-duration, end))\n            \n            # add to total time\n            total += duration\n            \n            # if total time exceeds end date\n            if total > end:\n                # remove from priority queue\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        while curr:\n            next_node = curr.next\n            for i in range(k):\n                if curr.next:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            prev.next = curr\n            curr = next_node\n            for i in range(k):\n                if curr:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            prev.next = curr\n            prev = curr\n            curr = next_node\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        while curr:\n            next_node = curr.next\n            for i in range(k):\n                if curr.next:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            prev.next = curr\n            curr = next_node\n            for i in range(k):\n                if curr:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            prev.next = curr\n            prev = curr\n        \n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 1:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 1:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## TLE\n        ## for i in range(len(s)//2):\n        ##     if len(s) % (i+1) == 0 and s[:i+1] * (len(s)//(i+1)) == s:\n        ##         return True\n        ## return False\n        \n        ## KMP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100528/Python-KMP-solution-with"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## for i in nums:\n        ##     if nums.count(i) == 1:\n        ##         return i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## hashmap = {}\n        ## for i in nums:\n        ##     if i not in hashmap:\n        ##         hashmap[i] = 1\n        ##     else:\n        ##         hashmap[i] += 1\n        ## for i in hashmap:\n        ##     if hashmap[i] == 1:\n        ##         return i\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.92% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.92% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        #"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## for i in nums:\n        ##     if nums.count(i) == 1:\n        ##         return i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## hashmap = {}\n        ## for i in nums:\n        ##     if i not in hashmap:\n        ##         hashmap[i] = 1\n        ##     else:\n        ##         hashmap[i] += 1\n        ## for i in hashmap:\n        ##     if hashmap[i] == 1:\n        ##         return i\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 48 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Single Number.\n        ## return 2 * sum(set(nums)) - sum(nums)\n        \n        ## Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a dictionary to store the count of each number\n        ## 2. iterate through the dictionary and return the number that has count of 1\n        ## 3. use a set to store the number that has count of 1\n        ## 4. iterate through the list and add each number to the set\n        ## 5. iterate through the list and remove each number from the set\n        ## 6. return the last number in the set\n        \n        ## 1. use a dictionary to store the count of each number\n        count_dict = {}\n        for num in nums:\n            if num in count_dict:\n                count_dict[num] += 1\n            else:\n                count_dict[num] = 1\n        \n        ## 2. iterate through the dictionary and return the number that has count of 1\n        for num in count_dict:\n            if count_dict[num] == 1:\n                return num\n        \n        ## 3. use a set to store the number that has count of 1\n        num_set = set()\n        \n        ## 4. iterate through the list and add each number to the set\n        for num in nums:\n            num_set.add(num)\n        \n        ## 5. iterate through the list and remove each number from the set\n        for num in nums:\n            num_set.remove(num)\n        \n        ## 6. return the last number in the set\n        return num_set.pop()"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 3. Hash table\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 4. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 5. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 6. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 7. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 8. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 9. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 10. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 11. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 12. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 13. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 14. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 15. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 16. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 17. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 18. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 19. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 20. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 21. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 22. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 23. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 24. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 25. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 26. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 27. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 28. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 29. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 30. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 31. Bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 32. Bit manip"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a dictionary to store the count of each number\n        ## 2. iterate through the dictionary and return the number with count = 1\n        \n        ## 1. use a dictionary to store the count of each number\n        num_dict = {}\n        for num in nums:\n            if num not in num_dict:\n                num_dict[num] = 1\n            else:\n                num_dict[num] += 1\n        \n        ## 2. iterate through the dictionary and return the number with count = 1\n        for num in num_dict:\n            if num_dict[num] == 1:\n                return num"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if not target.startswith(s):\n                    continue\n                res = min(res, dfs(target[len(s):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if not s:\n                    continue\n                if target.startswith(s):\n                    res = min(res, 1 + dfs(target[len(s):]))\n            memo[target] = res if res != float('inf') else -1\n            return memo[target]\n        \n        memo = {}\n        return dfs(target)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if not s:\n                    continue\n                if target.startswith(s):\n                    res = min(res, 1 + dfs(target[len(s):]))\n            memo[target] = res if res != float('inf') else -1\n            return memo[target]\n        \n        memo = {}\n        return dfs(target)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for s in stickers:\n                if not s:\n                    continue\n                if target.startswith(s):\n                    res = min(res, 1 + dfs(target[len(s):]))\n            memo[target] = res if res != float('inf') else -1\n            return memo[target]\n        \n        memo = {}\n        return dfs(target)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(sticker):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if mid * mid == x:\n                return mid\n            \n            elif mid * mid < x:\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if mid * mid == x:\n                return mid\n            \n            elif mid * mid < x:\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize the result variable to 0\n        result = 0\n        \n        # loop through the string\n        for i in range(len(s)):\n            # if the current character is a key in the dictionary\n            if s[i] in roman_dict:\n                # if the current character is less than the next character\n                if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                    # subtract the value of the current character from the result\n                    result -= roman_dict[s[i]]\n                else:\n                    # add the value of the current character to the result\n                    result += roman_dict[s[i]]\n            else:\n                # if the current character is not a key in the dictionary\n                return \"Invalid Roman Numeral\"\n        \n        # return the result\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map roman numerals to integers\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize result to 0\n        result = 0\n        \n        # loop through the string\n        for i in range(len(s)):\n            # if the current character is less than the next character, subtract it from the current character\n            if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # if len(nums) == 2:\n        #     return [max(nums[0], nums[1]), max(nums[0], nums[1])]\n        \n        # if len(nums) == 3:\n        #     return [max(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), max(nums[0], nums[2])]\n        \n        # if len(nums) == 4:\n        #     return [max(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), max(nums[0], nums[3])]\n        \n        # if len(nums) == 5:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), max(nums[0], nums[3], nums[4]), max(nums[0], nums[1], nums[4])]\n        \n        # if len(nums) == 6:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), max(nums[0], nums[3], nums[4], nums[5]), max(nums[0], nums[1], nums[4], nums[5]), max(nums[0], nums[1], nums[2], nums[4], nums[5]), max(nums[0], nums[1], nums[2], nums[3], nums[5]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max("}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the queue with the first k elements\n        queue = []\n        for i in range(k):\n            while queue and nums[i] >= nums[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        \n        # Initialize the result list with the first k elements\n        result = [nums[queue[0]]]\n        \n        # Iterate over the remaining elements\n        for i in range(k, len(nums)):\n            # Remove any elements that are out of the current window\n            if queue[0] == i - k:\n                queue.pop(0)\n            \n            # Add the current element to the queue\n            while queue and nums[i] >= nums[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n            \n            # Add the maximum element to the result list\n            result.append(nums[queue[0]])\n        \n        return result"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1])/2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the index of the smallest element\n        # if the smallest element is not at the first index, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the first index, then the smallest element is at the last index\n        # if the smallest element is at the last index, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the smallest element is at the index of the smallest element\n        # if the smallest element is at the index of the smallest element, then the"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        # if len(nums) == 1:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] < nums[0]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] > nums[0]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] > nums[0]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] > nums[0]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] > nums[0]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-2]\n        # if nums[-1] > nums[0]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        #"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1260,2640,4320,5606,5606,4320,2640,1260,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,486,1365,3003,5005,6660,6660,5005,3003,1365,486,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,567,1820,4004,7320,10000,10000,7320,4004,1820,567,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,600,2105,5005,9280,13360,13360,9280,5005,2105,600,103,19,1]\n        if rowIndex == 20:\n            return [1,20,104,645,2405,5605,9609,14001,14001,9609,5605,2405,645,104,20,1]\n        if rowIndex == 2"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1200,2400,3600,4200,4200,3600,2400,1200,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,111,514,1560,3003,4640,5712,5712,4640,3003,1560,514,111,17,1]\n        if rowIndex == 18:\n            return [1,18,122,585,1820,3856,6016,7288,7288,6016,3856,1820,585,122,18,1]\n        if rowIndex == 19:\n            return [1,19,133,666,2220,4862,8008,10000,10000,8008,4862,2220,666,133,19,1]\n        if rowIndex == 20:\n            return [1,20,144,714,2388,5005,7507,9232,9232,7507,5005,2388,714,200,144,20,1]\n        if rowIndex == 2"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1200,2400,3600,4200,4200,3600,2400,1200,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,111,514,1560,3003,4640,5760,5760,4640,3003,1560,514,111,17,1]\n        if rowIndex == 18:\n            return [1,18,122,585,1820,3856,6006,7207,7207,6006,3856,1820,585,122,18,1]\n        if rowIndex == 19:\n            return [1,19,133,666,2220,4862,8008,10001,10001,8008,4862,2220,666,133,19,1]\n        if rowIndex == 20:\n            return [1,20,144,714,2520,5605,9009,11441,11441,9009,5605,2520,714,144,20,1]\n        if rowIndex == 21:"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1200,2400,3600,4200,4200,3600,2400,1200,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,486,1365,2822,4375,5728,6400,6400,5728,4375,2822,1365,486,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,514,1560,3240,5120,7000,8400,9200,9200,8400,7000,5120,3240,1560,514,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,535,1680,3640,6480,9600,12800,14400,14400,12800,9600,6480,3640,1680,535,103,19,1]\n        if rowIndex == 20:\n            return [1,20,104,565,1820,4032,70"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1200,2400,3600,4200,4200,3600,2400,1200,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,111,514,1560,3003,4640,5712,5712,4640,3003,1560,514,111,17,1]\n        if rowIndex == 18:\n            return [1,18,122,585,1820,3856,6016,7288,7288,6016,3856,1820,585,122,18,1]\n        if rowIndex == 19:\n            return [1,19,133,666,2220,4862,8008,10000,10000,8008,4862,2220,666,133,19,1]\n        if rowIndex == 20:\n            return [1,20,144,714,2388,5005,7007,8008,8008,7007,5005,2388,714,200,144,20,1]\n        if rowIndex == 2"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # 3. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ubc18\ubcf5\ud55c\ub2e4.\n        # 4. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc774 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc774 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\ubcf4\ub2e4 \ud070 \uacbd\uc6b0 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc5d0\uc11c 1\uc744 \ube7c\uace0 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 6. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc774 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\ubcf4\ub2e4 \uac19\uc740 \uacbd\uc6b0 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        sqrt = math.sqrt(area)\n        \n        # 2. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        sqrt = int(sqrt)\n        \n        # 3. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ubc18\ubcf5\ud55c\ub2e4.\n        for i in range(sqrt, 0, -1):\n            \n            # 4. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc774 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n            if sqrt * sqrt < area:\n                return [sqrt, sqrt]\n            \n            # 5. \uc81c\uacf1\uadfc\uc744 \uc815\uc218\ub85c \ubcc0\ud658\ud55c \uac12\uc774 \ufffd"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uc678\ud55c \uc218\ub97c \ub098\uba38\uc9c0 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 3. \ub098\uba38\uc9c0 \uc218\uac00 \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 4. \ub098\uba38\uc9c0 \uc218\uac00 \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf4\ub2e4 \ud06c\uba74 \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \ub098\uba38\uc9c0 \uc218\uac00 \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        sqrt = int(math.sqrt(area))\n        \n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uc678\ud55c \uc218\ub97c \ub098\uba38\uc9c0 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 3. \ub098\uba38\uc9c0 \uc218\uac00 \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 4. \ub098\uba38\uc9c0 \uc218\uac00 \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf4\ub2e4 \ud06c\uba74 \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \ub098\uba38\uc9c0 \uc218\uac00 \uc81c\uacf1\uadfc\uc758 \ubc18\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        if sqrt * sqrt == area:\n            return [sqrt, sqrt]\n        else:\n            for i in range(sqrt, 0, -1):\n                if (area - i * i) % i == 0:\n                    return [area // i, i]"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc \uad6c\ud558\uae30\n        # 2. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc\n        # 3. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30\n        # 4. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc\n        # 5. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30\n        # 6. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc\n        # 7. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30\n        # 8. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc\n        # 9. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30\n        # 10. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30\n        # 11. \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\uacf1\uadfc \ubc18\uc62c\ub9bc \uc81c\uacf1\uadfc \ube7c\uae30 \uc81c\ufffd"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uc678\ud55c \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 3. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 4. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \ud06c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 5. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 6. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \ud06c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 7. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 8. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \ud06c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 9. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \uac19\uc73c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 10. \uc55e\uc5d0 \uc788\ub294 \uc218\uac00 \ub4a4\uc5d0 \uc788\ub294 \uc218\ubcf4\ub2e4 \ud06c\uba74 \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ufffd"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub204\uace0, \ub098\uba38\uc9c0\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 3. \ub098\uba38\uc9c0\uac00 0\uc774 \ub418\uba74 \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc774\ubbc0\ub85c \uc81c\uacf1\uadfc\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 4. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2c8\ubbc0\ub85c \uc81c\uacf1\uadfc\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 5. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub204\uace0, \ub098\uba38\uc9c0\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 6. \ub098\uba38\uc9c0\uac00 0\uc774 \ub418\uba74 \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc774\ubbc0\ub85c \uc81c\uacf1\uadfc\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 7. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2c8\ubbc0\ub85c \uc81c\uacf1\uadfc\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 8. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub204\uace0, \ub098\uba38\uc9c0\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 9. \ub098\uba38\uc9c0\uac00 0\uc774 \ub418\uba74 \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc774\ubbc0\ub85c \uc81c\uacf1\uadfc\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 10. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2c8\ubbc0\ub85c \uc81c\uacf1\uadfc\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 11. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub204\uace0, \ub098\uba38\uc9c0\ufffd"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if neighbor in visited:\n                        continue\n                    if neighbor in graph:\n                        queue.append(neighbor)\n                        visited[neighbor] = visited[word] + 1\n                    elif neighbor == endWord:\n                        return self.build_path(visited, neighbor, beginWord)\n        \n        return []\n    \n    def build_path(self, visited, endWord, beginWord):\n        path = [endWord]\n        while endWord != beginWord:\n            endWord = visited[endWord]\n            path.append(endWord)\n        return list(reversed(path))"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def find_neighbors(word, wordList):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        def find_shortest_path(beginWord, endWord, wordList):\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    return path\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word, wordList):\n                    queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        def find_all_paths(beginWord, endWord, wordList):\n            paths = []\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    paths.append(path)\n                    continue\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word, wordList):\n                    queue.append((neighbor, path + [neighbor]))\n            return paths\n        \n        def find_all_paths_recursive(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = path + [word]\n                new_paths = find_all_paths_recursive(word, endWord, wordList, new_path)\n                paths.extend(new_paths)\n            return paths\n        \n        def find_all_paths_recursive_memoized(beginWord, endWord, wordList, path, memo):\n            if beginWord == endWord:\n                return [path]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = path + [word]\n                new_paths = find_all_paths_recursive_memoized(word, endWord, wordList, new_path, memo)\n                paths.extend(new_paths)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_memoized_with_backtracking(beginWord, endWord, wordList, path, memo):\n            if beginWord == endWord:\n                return [path]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = path + [word]\n                new_paths = find_all_paths_recursive_memoized_with_backtracking(word, endWord, wordList, new_path, memo)\n                paths.extend(new_paths)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_memoized_with_backtracking_with_visited(beginWord, endWord, wordList, path, memo):\n            if beginWord == endWord:\n                return [path]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            visited = set()\n            for word in find_neighbors(beginWord, wordList):\n                if word in visited:\n                    continue\n                visited.add(word)\n                new_path = path + [word]\n                new_paths = find_all_paths_recursive_memoized_with_backtracking_with_visited(word, endWord, wordList, new_path, memo)\n                paths.extend(new_paths)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_memoized_with_"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if neighbor in graph:\n                        if neighbor in visited:\n                            continue\n                        visited[neighbor] = visited[word] + 1\n                        queue.append(neighbor)\n        \n        # build result\n        result = []\n        if endWord not in visited:\n            return result\n        self.dfs(beginWord, endWord, visited, graph, [], result)\n        return result\n    \n    def dfs(self, word, endWord, visited, graph, path, result):\n        if word == endWord:\n            result.append(path + [word])\n            return\n        for i in range(len(word)):\n            for j in range(26):\n                neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                if neighbor in graph:\n                    if neighbor in visited and visited[neighbor] == visited[word] + 1:\n                        self.dfs(neighbor, endWord, visited, graph, path + [word], result)"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def find_neighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        def find_shortest_path(beginWord, endWord, wordList):\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    return path\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word):\n                    queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        def find_all_paths(beginWord, endWord, wordList):\n            paths = []\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    paths.append(path)\n                    continue\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word):\n                    queue.append((neighbor, path + [neighbor]))\n            return paths\n        \n        def find_all_paths_recursive(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive(word, endWord, wordList, path + [word])\n                    wordList.add(word)\n            return paths\n        \n        def find_all_paths_recursive_2(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive_2(word, endWord, wordList, path + [word])\n                    wordList.add(word)\n            return paths\n        \n        def find_all_paths_recursive_3(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive_3(word, endWord, wordList, path + [word])\n                    wordList.add(word)\n            return paths\n        \n        def find_all_paths_recursive_4(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive_4(word, endWord, wordList, path + [word])\n                    wordList.add(word)\n            return paths\n        \n        def find_all_paths_recursive_5(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive_5(word, endWord, wordList, path + [word])\n                    wordList.add(word)\n            return paths\n        \n        def find_all_paths_recursive_6(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove("}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def find_neighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        def find_shortest_path(beginWord, endWord, wordList):\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    return path\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word):\n                    queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        def find_all_paths(beginWord, endWord, wordList):\n            paths = []\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    paths.append(path)\n                    continue\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word):\n                    queue.append((neighbor, path + [neighbor]))\n            return paths\n        \n        def find_all_paths_recursive(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive(word, endWord, wordList, path + [word])\n                    wordList.add(word)\n            return paths\n        \n        def find_all_paths_recursive_with_memoization(beginWord, endWord, wordList, memo):\n            if beginWord == endWord:\n                return [[]]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    paths += find_all_paths_recursive_with_memoization(word, endWord, wordList, memo)\n                    wordList.add(word)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_with_memoization_with_backtracking(beginWord, endWord, wordList, memo):\n            if beginWord == endWord:\n                return [[]]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    for path in find_all_paths_recursive_with_memoization_with_backtracking(word, endWord, wordList, memo):\n                        paths.append([beginWord] + path)\n                    wordList.add(word)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_with_memoization_with_backtracking_with_pruning(beginWord, endWord, wordList, memo):\n            if beginWord == endWord:\n                return [[]]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord):\n                if word in wordList:\n                    wordList.remove(word)\n                    for path in find_all_paths_recursive_with_memoization_with_backtracking_with_pruning(word, endWord, wordList, memo):\n                        if len(path) + 1 < len(paths) or (len(path) + 1 == len(paths) and path[0] < paths[0][0]):\n                            paths.append([beginWord] + path)\n                    wordList.add(word)\n            memo[beginWord"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return max(height(root.left), height(root.right)) + 1\n        \n        if not root:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uacfc \ube44\uad50\ud558\uc5ec \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 4. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 5. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 6. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 7. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 8. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 9. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 10. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc758 \ucd5c\ub300 \ub113\uc774\ub97c \uad6c\ud55c \ud6c4 \uc67c\ucabd\uc5d0"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 13. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        \n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        \n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for rect in rectangles:\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[1] == y_min and rect[3] == y_max and rect[0] == x_min and rect[2] == x_max:\n                continue\n            if rect[1] == y_min and rect[3] == y_max and rect[0] == x_max and rect[2] == x_min:\n                continue\n            if rect[1] == y_max and rect[3] == y_min and rect[0] == x_min and rect[2] == x_max:\n                continue\n            if rect[1] == y_max and rect[3] == y_min and rect[0] == x_max and rect[2] == x_min:\n                continue\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 17576\n        # 26^4 = 43980465112\n        # 26^5 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to string\n        # 2. reverse the string\n        # 3. convert each letter to its corresponding number\n        # 4. add the numbers\n        # 5. convert the sum to its corresponding letter\n        \n        # 1. convert to string\n        columnNumber = str(columnNumber)\n        \n        # 2. reverse the string\n        columnNumber = columnNumber[::-1]\n        \n        # 3. convert each letter to its corresponding number\n        columnNumber = [ord(i) - 64 for i in columnNumber]\n        \n        # 4. add the numbers\n        columnNumber = sum(columnNumber)\n        \n        # 5. convert the sum to its corresponding letter\n        columnNumber = chr(columnNumber + 64)\n        \n        return columnNumber"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        # 6. convert to base 10\n        # 7. convert to base 26\n        # 8. convert to base 10\n        # 9. convert to base 26\n        # 10. convert to base 10\n        # 11. convert to base 26\n        # 12. convert to base 10\n        # 13. convert to base 26\n        # 14. convert to base 10\n        # 15. convert to base 26\n        # 16. convert to base 10\n        # 17. convert to base 26\n        # 18. convert to base 10\n        # 19. convert to base 26\n        # 20. convert to base 10\n        # 21. convert to base 26\n        # 22. convert to base 10\n        # 23. convert to base 26\n        # 24. convert to base 10\n        # 25. convert to base 26\n        # 26. convert to base 10\n        # 27. convert to base 26\n        # 28. convert to base 10\n        # 29. convert to base 26\n        # 30. convert to base 10\n        # 31. convert to base 26\n        # 32. convert to base 10\n        # 33. convert to base 26\n        # 34. convert to base 10\n        # 35. convert to base 26\n        # 36. convert to base 10\n        # 37. convert to base 26\n        # 38. convert to base 10\n        # 39. convert to base 26\n        # 40. convert to base 10\n        # 41. convert to base 26\n        # 42. convert to base 10\n        # 43. convert to base 26\n        # 44. convert to base 10\n        # 45. convert to base 26\n        # 46. convert to base 10\n        # 47. convert to base 26\n        # 48. convert to base 10\n        # 49. convert to base 26\n        # 50. convert to base 10\n        # 51. convert to base 26\n        # 52. convert to base 10\n        # 53. convert to base 26\n        # 54. convert to base 10\n        # 55. convert to base 26\n        # 56. convert to base 10\n        # 57. convert to base 26\n        # 58. convert to base 10\n        # 59. convert to base 26\n        # 60. convert to base 10\n        # 61. convert to base 26\n        # 62. convert to base 10\n        # 63. convert to base 26\n        # 64. convert to base 10\n        # 65. convert to base 26\n        # 66. convert to base 10\n        # 67. convert to base 26\n        # 68. convert to base 10\n        # 69. convert to base 26\n        # 70. convert to base 10\n        # 71. convert to base 26\n        # 72. convert to base 10\n        # 73. convert to base 26\n        # 74. convert to base 10\n        # 75. convert to base 26\n        # 76. convert to base 10\n        # 77. convert to base 26\n        # 78. convert to base 10\n        # 79. convert to base 26\n        # 80. convert to base 10"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to string\n        # 2. reverse the string\n        # 3. convert to integer\n        # 4. convert to alphabet\n        \n        # 1. convert to string\n        columnNumber = str(columnNumber)\n        \n        # 2. reverse the string\n        columnNumber = columnNumber[::-1]\n        \n        # 3. convert to integer\n        columnNumber = int(columnNumber)\n        \n        # 4. convert to alphabet\n        columnNumber = chr(columnNumber + 64)\n        \n        return columnNumber"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        return False\n            return True\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if get_goal(board):\n                    return moves\n                for neighbor in get_neighbors(board):\n                    if neighbor not in visited:\n                        visited.add(tuple(neighbor))\n                        queue.append((neighbor, moves + 1))\n            return -1\n        \n        return bfs(tuple(board))"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        return False\n            return True\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if get_goal(board):\n                    return moves\n                for neighbor in get_neighbors(board):\n                    if neighbor not in visited:\n                        visited.add(tuple(neighbor))\n                        queue.append((neighbor, moves + 1))\n            return -1\n        \n        return bfs(tuple(board))"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_neighbors_with_zeros(board):\n            neighbors = []\n            for neighbor in get_neighbors(board):\n                if get_zero(neighbor)[0] == 1 and get_zero(neighbor)[1] == 2:\n                    neighbors.append(neighbor)\n                if get_zero(neighbor)[0] == 2 and get_zero(neighbor)[1] == 1:\n                    neighbors.append(neighbor)\n            return neighbors\n        \n        def get_neighbors_with_zeros_and_swaps(board):\n            neighbors = []\n            for neighbor in get_neighbors_with_zeros(board):\n                if get_zero(neighbor)[0] == 1 and get_zero(neighbor)[1] == 2:\n                    neighbors.append(neighbor)\n                if get_zero(neighbor)[0] == 2 and get_zero(neighbor)[1] == 1:\n                    neighbors.append(neighbor)\n            return neighbors\n        \n        def get_neighbors_with_zeros_and_swaps_and_swaps(board):\n            neighbors = []\n            for neighbor in get_neighbors_with_zeros_and_swaps(board):\n                if get_zero(neighbor)[0] == 1 and get_zero(neighbor)[1] == 2:\n                    neighbors.append(neighbor)\n                if get_zero(neighbor)[0] == 2 and get_zero(neighbor)[1] == 1:\n                    neighbors.append(neighbor)\n            return neighbors\n        \n        def get_neighbors_with_zeros_and_swaps_and_swaps_and_swaps(board):\n            neighbors = []\n            for neighbor in get_neighbors_with_zeros_and_swaps_and_swaps(board):\n                if get_zero(neighbor)[0] == 1 and get_zero(neighbor)[1] == 2:\n                    neighbors.append(neighbor)\n                if get_zero(neighbor)[0] == 2 and get_zero(neighbor)[1] == 1:\n                    neighbors.append(neighbor)\n            return neighbors\n        \n        def get_neighbors_with_zeros_and_swaps_and_swaps_and_swaps_and_swaps(board):\n            neighbors = []\n            for neighbor in get_neighbors_with_zeros_and_swaps_and_swaps_and_swaps(board):\n                if get_zero(neighbor)[0] == 1 and get_zero(neighbor)[1] == 2:\n                    neighbors.append(neighbor)\n                if get_zero(neighbor)[0] == 2 and get_zero(neighbor)[1] == 1:\n                    neighbors.append(neighbor)\n            return neighbors\n        \n        def get_neighbors_with_zeros_and_swaps_and_swaps_and_swaps_and_swaps_and_swaps(board):\n            neighbors = []\n            for neighbor in get_neighbors_with_zeros_and_swaps_and_swaps_and_swaps_and_swaps(board):\n                if get_zero(neighbor)[0] == 1 and get_zero(neighbor)[1] == 2:\n                    neighbors.append(neighbor)\n                if get_zero(neighbor)[0] == 2 and get_zero(neighbor)[1] == 1:\n                    neighbors.append"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            return goal\n        \n        def get_distance(board, goal):\n            distance = 0\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        distance += 1\n            return distance\n        \n        def solve(board):\n            if board == get_goal(board):\n                return 0\n            neighbors = get_neighbors(board)\n            min_distance = float('inf')\n            for neighbor in neighbors:\n                distance = solve(neighbor)\n                if distance < min_distance:\n                    min_distance = distance\n            return min_distance + 1\n        \n        return solve(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_neighbors_str(board):\n            neighbors = []\n            for neighbor in get_neighbors(board):\n                neighbors.append(''.join(map(str, neighbor)))\n            return neighbors\n        \n        def get_neighbors_str_set(board):\n            neighbors = set()\n            for neighbor in get_neighbors_str(board):\n                neighbors.add(neighbor)\n            return neighbors\n        \n        def get_neighbors_str_set_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list_list_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list_list_list_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list_list_list_list_list_list(board):\n                neighbors.append(list(neighbor))\n            return neighbors\n        \n        def get_neighbors_str_set_list_list_list_list_list_list_list(board):\n            neighbors = []\n            for neighbor in get_neighbors_str_set_list_list_list_list_list_list_list_list(board):\n                neighbors.append("}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = t[i]\n            else:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            \n            if t[i] not in t_dict:\n                t_dict[t[i]] = s[i]\n            else:\n                if t_dict[t[i]] != s[i]:\n                    return False\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        def find_pivot(nums):\n            left, right = 0, len(nums) - 1\n            while left < right:\n                mid = (left + right) // 2\n                if nums[mid] > nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n        \n        pivot = find_pivot(nums)\n        if binary_search(nums[:pivot], target):\n            return True\n        if binary_search(nums[pivot:], target):\n            return True\n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        def find_pivot(nums):\n            left, right = 0, len(nums) - 1\n            while left < right:\n                mid = (left + right) // 2\n                if nums[mid] > nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n        \n        pivot = find_pivot(nums)\n        if binary_search(nums[:pivot], target):\n            return True\n        if binary_search(nums[pivot:], target):\n            return True\n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return nums[0] == target\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i == 0 and j == 0:\n                        dp[i][j] = 1\n                    elif i == 0:\n                        dp[i][j] = dp[i][j-1]\n                    elif j == 0:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        \n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n                \n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root == None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n        \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return [root.val] + dfs(root.left) + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            count = {}\n            for num in nums:\n                if num not in count:\n                    count[num] = 0\n                count[num] += 1\n            return [(v, k) for k, v in count.items()]\n        \n        nums = dfs(root)\n        counts = count(nums)\n        counts.sort(key=lambda x: -x[0])\n        max_count = counts[0][0]\n        return [c[1] for c in counts if c[0] == max_count]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        def find_max(lst):\n            if not lst:\n                return None\n            max_count = 0\n            max_val = None\n            count = {}\n            for i in lst:\n                if i not in count:\n                    count[i] = 1\n                else:\n                    count[i] += 1\n                if count[i] > max_count:\n                    max_count = count[i]\n                    max_val = i\n            return max_val\n        \n        return find_max(dfs(root))"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return [root.val] + dfs(root.left) + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            c = collections.Counter(nums)\n            return [k for k, v in c.items() if v == max(c.values())]\n        \n        return count(dfs(root))"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return [root.val] + dfs(root.left) + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            c = collections.Counter(nums)\n            return [k for k, v in c.items() if v == max(c.values())]\n        \n        return count(dfs(root))"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return dfs(root.left) + [root.val] + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            max_count = 0\n            max_num = nums[0]\n            count_dict = {}\n            for num in nums:\n                if num in count_dict:\n                    count_dict[num] += 1\n                else:\n                    count_dict[num] = 1\n                if count_dict[num] > max_count:\n                    max_count = count_dict[num]\n                    max_num = num\n            return [max_num] if max_count == 1 else [num for num in count_dict if count_dict[num] == max_count]\n        \n        return count(dfs(root))"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the length of password\n        # 3. check the length of password\n        # 4. check the length of password\n        # 5. check the length of password\n        # 6. check the length of password\n        # 7. check the length of password\n        # 8. check the length of password\n        # 9. check the length of password\n        # 10. check the length of password\n        # 11. check the length of password\n        # 12. check the length of password\n        # 13. check the length of password\n        # 14. check the length of password\n        # 15. check the length of password\n        # 16. check the length of password\n        # 17. check the length of password\n        # 18. check the length of password\n        # 19. check the length of password\n        # 20. check the length of password\n        # 21. check the length of password\n        # 22. check the length of password\n        # 23. check the length of password\n        # 24. check the length of password\n        # 25. check the length of password\n        # 26. check the length of password\n        # 27. check the length of password\n        # 28. check the length of password\n        # 29. check the length of password\n        # 30. check the length of password\n        # 31. check the length of password\n        # 32. check the length of password\n        # 33. check the length of password\n        # 34. check the length of password\n        # 35. check the length of password\n        # 36. check the length of password\n        # 37. check the length of password\n        # 38. check the length of password\n        # 39. check the length of password\n        # 40. check the length of password\n        # 41. check the length of password\n        # 42. check the length of password\n        # 43. check the length of password\n        # 44. check the length of password\n        # 45. check the length of password\n        # 46. check the length of password\n        # 47. check the length of password\n        # 48. check the length of password\n        # 49. check the length of password\n        # 50. check the length of password\n        # 51. check the length of password\n        # 52. check the length of password\n        # 53. check the length of password\n        # 54. check the length of password\n        # 55. check the length of password\n        # 56. check the length of password\n        # 57. check the length of password\n        # 58. check the length of password\n        # 59. check the length of password\n        # 60. check the length of password\n        # 61. check the length of password\n        # 62. check the length of password\n        # 63. check the length of password\n        # 64. check the length of password\n        # 65. check the length of password\n        # 66. check the length of password\n        # 67. check the length of password\n        # 68. check the length of password\n        # 69. check the length of password\n        # 70. check the length of password\n        # 71. check the length of password\n        # 72. check the length of password\n        # 73. check the length of password\n        # 74. check the length of password\n        # 75. check the length of password\n        # 76. check the length of password\n        # 77. check the length of password\n        # 78. check the length of password\n        # 79. check the length of password\n        # 80. check the length of password\n        # 81. check the length of password\n        # 82. check the length of password\n        # 83. check the length of password\n        # 84. check the length of password\n        # 85. check the length of password\n        # 86. check the length of password"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curr_row = 0\n        going_down = False\n        \n        for c in s:\n            res[curr_row] += c\n            if curr_row == 0 or curr_row == numRows - 1:\n                going_down = not going_down\n            curr_row += 1 if going_down else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        currRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[currRow] += c\n            if currRow == 0 or currRow == numRows - 1:\n                goingDown = not goingDown\n            currRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curr_row = 0\n        going_down = False\n        \n        for c in s:\n            res[curr_row] += c\n            if curr_row == 0 or curr_row == numRows - 1:\n                going_down = not going_down\n            curr_row += 1 if going_down else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the index of max height\n        max_height_index = height.index(max_height)\n        \n        # 3. find the left and right max height\n        left_max_height = max(height[:max_height_index])\n        right_max_height = max(height[max_height_index:])\n        \n        # 4. find the water\n        water = 0\n        for i in range(max_height_index):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        for i in range(len(height)-1, max_height_index, -1):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-04-25\n        ## 100%\n        \n        ## 2022-04-25\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-05-20\n        ## 1. Find the max height of left and right\n        ## 2. Find the area of water\n        ## 3. Repeat until all the bars are covered\n        \n        ## 2022-05-21\n        ## 1. Find the max height of left and right\n        ## 2. Find the area of water\n        ## 3. Repeat until all the bars are covered\n        ## 4. Find the max height of left and right\n        ## 5. Find the area of water\n        ## 6. Repeat until all the bars are covered\n        ## 7. Find the max height of left and right\n        ## 8. Find the area of water\n        ## 9. Repeat until all the bars are covered\n        ## 10. Find the max height of left and right\n        ## 11. Find the area of water\n        ## 12. Repeat until all the bars are covered\n        ## 13. Find the max height of left and right\n        ## 14. Find the area of water\n        ## 15. Repeat until all the bars are covered\n        ## 16. Find the max height of left and right\n        ## 17. Find the area of water\n        ## 18. Repeat until all the bars are covered\n        ## 19. Find the max height of left and right\n        ## 20. Find the area of water\n        ## 21. Repeat until all the bars are covered\n        ## 22. Find the max height of left and right\n        ## 23. Find the area of water\n        ## 24. Repeat until all the bars are covered\n        ## 25. Find the max height of left and right\n        ## 26. Find the area of water\n        ## 27. Repeat until all the bars are covered\n        ## 28. Find the max height of left and right\n        ## 29. Find the area of water\n        ## 30. Repeat until all the bars are covered\n        ## 31. Find the max height of left and right\n        ## 32. Find the area of water\n        ## 33. Repeat until all the bars are covered\n        ## 34. Find the max height of left and right\n        ## 35. Find the area of water\n        ## 36. Repeat until all the bars are covered\n        ## 37. Find the max height of left and right\n        ## 38. Find the area of water\n        ## 39. Repeat until all the bars are covered\n        ## 40. Find the max height of left and right\n        ## 41. Find the area of water\n        ## 42. Repeat until all the bars are covered\n        ## 43. Find the max height of left and right\n        ## 44. Find the area of water\n        ## 45. Repeat until all the bars are covered\n        ## 46. Find the max height of left and right\n        ## 47. Find the area of water\n        ## 48. Repeat until all the bars are covered\n        ## 49. Find the max height of left and right\n        ## 50. Find the area of water\n        ## 51. Repeat until all the bars are covered\n        ## 52. Find the max height of left and right\n        ## 53. Find the area of water\n        ## 54. Repeat until all the bars are covered\n        ## 55. Find the max height of left and right\n        ## 56. Find the area of water\n        ## 57. Repeat until all the bars are covered\n        ## 58. Find the max height of left and right\n        ## 59. Find the area of water\n        ## 60. Repeat until all the bars are covered\n        ## 61. Find the max height of left and right\n        ## 62"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the index of max height\n        max_height_index = height.index(max_height)\n        \n        # 3. find the left and right max height\n        left_max_height = max(height[:max_height_index])\n        right_max_height = max(height[max_height_index:])\n        \n        # 4. find the water\n        water = 0\n        for i in range(max_height_index):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        for i in range(len(height)-1, max_height_index, -1):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-03-20\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        #"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1 <= n <= 10\u2075\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <="}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 5. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 6. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 7. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 8. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 9. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 10. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 11. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 12. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 13. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 14. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 15. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 16. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 17. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 18. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 19. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 20. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 21. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 22. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 23. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 24. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 25. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 26. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 27. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 28. Using Set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 29. Using Set\n        ## Time Complexity: O(n"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1 <= n <= 10\u2075\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <="}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of size n with all zeros\n        ## 2. iterate through the list and mark the index of the number as negative\n        ## 3. iterate through the list again and add the index to the list\n        ## 4. iterate through the list again and add the index to the list\n        ## 5. iterate through the list again and add the index to the list\n        ## 6. iterate through the list again and add the index to the list\n        ## 7. iterate through the list again and add the index to the list\n        ## 8. iterate through the list again and add the index to the list\n        ## 9. iterate through the list again and add the index to the list\n        ## 10. iterate through the list again and add the index to the list\n        ## 11. iterate through the list again and add the index to the list\n        ## 12. iterate through the list again and add the index to the list\n        ## 13. iterate through the list again and add the index to the list\n        ## 14. iterate through the list again and add the index to the list\n        ## 15. iterate through the list again and add the index to the list\n        ## 16. iterate through the list again and add the index to the list\n        ## 17. iterate through the list again and add the index to the list\n        ## 18. iterate through the list again and add the index to the list\n        ## 19. iterate through the list again and add the index to the list\n        ## 20. iterate through the list again and add the index to the list\n        ## 21. iterate through the list again and add the index to the list\n        ## 22. iterate through the list again and add the index to the list\n        ## 23. iterate through the list again and add the index to the list\n        ## 24. iterate through the list again and add the index to the list\n        ## 25. iterate through the list again and add the index to the list\n        ## 26. iterate through the list again and add the index to the list\n        ## 27. iterate through the list again and add the index to the list\n        ## 28. iterate through the list again and add the index to the list\n        ## 29. iterate through the list again and add the index to the list\n        ## 30. iterate through the list again and add the index to the list\n        ## 31. iterate through the list again and add the index to the list\n        ## 32. iterate through the list again and add the index to the list\n        ## 33. iterate through the list again and add the index to the list\n        ## 34. iterate through the list again and add the index to the list\n        ## 35. iterate through the list again and add the index to the list\n        ## 36. iterate through the list again and add the index to the list\n        ## 37. iterate through the list again and add the index to the list\n        ## 38. iterate through the list again and add the index to the list\n        ## 39. iterate through the list again and add the index to the list\n        ## 40. iterate through the list again and add the index to the list\n        ## 41. iterate through the list again and add the index to the list\n        ## 42. iterate through the list again and add the index to the list\n        ## 43. iterate through the list again and add the index to the list\n        ## 44. iterate through the list again and add the index to the list\n        ## 45. iterate through the list again and add the index to the list\n        ## 46. iterate through the list again and add the index to the list\n        ## 47. iterate through the list again and add the index to the list\n        ## 48. iterate through the list again and add the index to the list\n        ## 49. iterate through the list"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        return [len(mergeSort(nums[i:])) for i in range(len(nums))]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in en.umerate(nums)])]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in en.umerate(nums)])]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n                    \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n                \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n                \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in enumerate(nums)])]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n                continue\n            if intervals[i][0] > intervals[i-1][1]:\n                ans += 2\n            else:\n                ans += 1\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max end\n        max_end = -1\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the current interval is not overlapping with the max end\n            if interval[0] > max_end:\n                # increment the result\n                res += 1\n                # update the max end\n                max_end = interval[1]\n            # if the current interval is overlapping with the max end\n            else:\n                # update the max end\n                max_end = min(max_end, interval[1])\n        \n        # return the result\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n                continue\n            if intervals[i][0] > intervals[i-1][1]:\n                ans += 2\n            else:\n                ans += 1\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max end\n        max_end = -1\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the current interval is not overlapping with the max end\n            if interval[0] > max_end:\n                # update the result\n                res += 2\n                # update the max end\n                max_end = interval[1]\n            # if the current interval is overlapping with the max end\n            else:\n                # update the result\n                res += 1\n                # update the max end\n                max_end = min(max_end, interval[1])\n        \n        # return the result\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the set\n        s = set()\n        \n        # iterate over the intervals\n        for i in range(len(intervals)):\n            # get the start and end of the interval\n            start, end = intervals[i]\n            \n            # iterate over the intervals\n            for j in range(i+1, len(intervals)):\n                # get the start and end of the interval\n                start2, end2 = intervals[j]\n                \n                # if the start of the second interval is greater than the end of the first interval\n                if start2 > end:\n                    # add the interval to the set\n                    s.add((start, end))\n                    \n                    # increment the result\n                    res += 1\n                    \n                    # break the loop\n                    break\n                    \n                # if the start of the second interval is greater than the end of the first interval\n                elif start2 > end:\n                    # add the interval to the set\n                    s.add((start, end))\n                    \n                    # increment the result\n                    res += 1\n                    \n                    # break the loop\n                    break\n                    \n                # if the start of the second interval is less than the end of the first interval\n                else:\n                    # add the interval to the set\n                    s.add((start, end))\n                    \n                    # increment the result\n                    res += 1\n                    \n                    # break the loop\n                    break\n                    \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(left, right, curr, res):\n            if left == right == n:\n                res.append(curr)\n                return\n            if left < n:\n                backtrack(left + 1, right, curr + '(', res)\n            if right < left:\n                backtrack(left, right + 1, curr + ')', res)\n        \n        res = []\n        backtrack(0, 0, '', res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # loop\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                n = n + nums[i]\n                count += 1\n                \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                count += 1\n                n = n * 2\n                \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # loop\n        while i < len(nums):\n            if nums[i] <= n:\n                n += nums[i]\n                i += 1\n            else:\n                patches += 1\n                n += n\n        \n        return patches"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # loop\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                n = n + nums[i]\n                count += 1\n        \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                n = n + nums[i]\n                count += 1\n                \n        return count"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 0\uc744 \ubc18\ud658\n        \n        stack = []\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    if not stack:\n                        max_len = max(max_len, i + 1)\n                    else:\n                        max_len = max(max_len, i - stack[-1])\n                else:\n                    stack.append(i)\n        \n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_part = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            decimal_part += str(quotient)\n            \n            if remainder in remainder_dict:\n                decimal_part = decimal_part[:remainder_dict[remainder]] + \"(\" + decimal_part[remainder_dict[remainder]:] + \")\"\n                break\n            remainder_dict[remainder] = len(decimal_part)\n        \n        return str(sign * quotient) + \".\" + decimal_part"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        quotient_str = str(sign * quotient)\n        remainder_str = \"\"\n        \n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            \n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            \n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return quotient_str + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return sign + str(quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return sign + str(quotient) + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_string = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            \n            if remainder in remainder_dict:\n                decimal_string = \"(\" + decimal_string + \")\"\n                break\n            \n            remainder_dict[remainder] = len(remainder_dict)\n            decimal_string += str(quotient)\n        \n        return str(sign * quotient) + \".\" + decimal_string"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_string = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                decimal_string = decimal_string[:remainder_dict[remainder]] + \"(\" + decimal_string[remainder_dict[remainder]:] + \")\"\n                break\n            else:\n                remainder_dict[remainder] = len(remainder_dict)\n                decimal_string += str(quotient)\n        \n        return str(sign * quotient) + \".\" + decimal_string"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        elif right:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        dp = [1] * len(envelopes)\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array by width\n        envelopes.sort(key=lambda x: x[0])\n        \n        # create a list to store the height of the envelope\n        height = [envelopes[0][1]]\n        \n        # iterate through the array\n        for i in range(1, len(envelopes)):\n            # if the height of the envelope is greater than the last element in the list, append it to the list\n            if envelopes[i][1] > height[-1]:\n                height.append(envelopes[i][1])\n            # otherwise, find the index of the element in the list that is closest to the height of the envelope\n            else:\n                left = 0\n                right = len(height) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if height[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                height[left] = envelopes[i][1]\n        \n        # return the length of the list\n        return len(height)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find the longest increasing subsequence of heights\n        heights = [envelope[1] for envelope in envelopes]\n        return self.longestIncreasingSubsequence(heights)\n    \n    def longestIncreasingSubsequence(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        # initialize dp array with 1 for each element\n        dp = [1] * len(nums)\n        \n        # iterate over the nums array\n        for i in range(len(nums)):\n            # iterate over the previous elements\n            for j in range(i):\n                # if the current element is greater than the previous element\n                if nums[i] > nums[j]:\n                    # update the dp array\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        # return the maximum value in the dp array\n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Initialize a list to store the maximum number of envelopes\n        max_envelopes = []\n        \n        # Iterate over the envelopes\n        for envelope in envelopes:\n            # If the envelope is larger than the last envelope in the list, add it to the list\n            if not max_envelopes or envelope[1] > max_envelopes[-1][1]:\n                max_envelopes.append(envelope)\n            # Otherwise, update the envelope with the largest height in the list\n            else:\n                left, right = 0, len(max_envelopes) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if max_envelopes[mid][1] < envelope[1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                max_envelopes[left] = envelope\n        \n        # Return the length of the list\n        return len(max_envelopes)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        col_zero = False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        row_zero = True\n                    if j == 0:\n                        col_zero = True\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        if col_zero:\n            for i in range(m):\n                matrix[i][0] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row and col are set to 0 if the element is 0\n        ## we iterate through the matrix and set the row and col to 0 if the element is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = [0] * m\n        col = [0] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = 1\n                    col[j] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if row[i] == 1 or col[j] == 1:\n                    matrix[i][j] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row and col are set to 0 if the element is 0\n        ## we iterate through the matrix and set the row and col to 0 if the element is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the element to 0 if the row or col is 0\n        ## we iterate through the"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row = [0]*m\n        ## col = [0]*n\n        ## for i in range(m):\n        ##     for j in range(n):\n        ##         if matrix[i][j] == 0:\n        ##             row[i] = 1\n        ##             col[j] = 1\n        ## for i in range(m):\n        ##     for j in range(n):\n        ##         if row[i] == 1 or col[j] == 1:\n        ##             matrix[i][j] = 0\n        \n        ## O(1) space\n        m = len(matrix)\n        n = len(matrix[0])\n        row = [0]*m\n        col = [0]*n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = 1\n                    col[j] = 1\n        for i in range(m):\n            for j in range(n):\n                if row[i] == 1 or col[j] == 1:\n                    matrix[i][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        ## 2. Find the nth node from the end\n        if length == n:\n            return head.next\n        \n        ## 3. Find the nth node from the end\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        ## 4. Remove the nth node from the end\n        curr.next = curr.next.next\n        \n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. Delete the nth node from the end\n        ## 4. Return the head\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 99.44% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 14.4 MB, less than 99.44% of Python online submissions for Intersection of Two Arrays.\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 98.45% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 14.1 MB, less than 98.45% of Python online submissions for Intersection of Two Arrays.\n        ## 2022-04-20\n        ## 2022-04-21\n        ## 2022-04-22\n        ## 2022-04-23\n        ## 2022-04-24\n        ## 2022-04-25\n        ## 2022-04-26\n        ## 2022-04-27\n        ## 2022-04-28\n        ## 2022-04-29\n        ## 2022-04-30\n        ## 2022-05-01\n        ## 2022-05-02\n        ## 2022-05-03\n        ## 2022-05-04\n        ## 2022-05-05\n        ## 2022-05-06\n        ## 2022-05-07\n        ## 2022-05-08\n        ## 2022-05-09\n        ## 2022-05-10\n        ## 2022-05-11\n        ## 2022-05-12\n        ## 2022-05-13\n        ## 2022-05-14\n        ## 2022-05-15\n        ## 2022-05-16\n        ## 2022-05-17\n        ## 2022-05-18\n        ## 2022-05-19\n        ## 2022-05-20\n        ## 2022-05-21\n        ## 2022-05-22\n        ## 2022-05-23\n        ## 2022-05-24\n        ## 2022-05-25\n        ## 2022-05-26\n        ## 2022-05-27\n        ## 2022-05-28\n        ## 2022-05-29\n        ## 2022-05-30\n        ## 2022-05-31\n        ## 2022-06-01\n        ## 2022-06-02\n        ## 2022-06-03\n        ## 2022-06-04\n        ## 2022-06-05\n        ## 2022-06-06\n        ## 2022-06-07\n        ## 2022-06-08\n        ## 2022-06-09\n        ## 2022-06-10\n        ## 2022-06-11\n        ## 2022-06-12\n        ## 2022-06-13\n        ## 2022-06-14\n        ## 2022-06-15\n        ## 2022-06-16\n        ## 2022-06-17\n        ## 2022-06-18\n        ## 2022-06-19"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the sum of all the dresses\n        # 2. find the max dresses in a machine\n        # 3. find the min dresses in a machine\n        # 4. find the max dresses in a machine\n        # 5. find the min dresses in a machine\n        # 6. find the max dresses in a machine\n        # 7. find the min dresses in a machine\n        # 8. find the max dresses in a machine\n        # 9. find the min dresses in a machine\n        # 10. find the max dresses in a machine\n        # 11. find the min dresses in a machine\n        # 12. find the max dresses in a machine\n        # 13. find the min dresses in a machine\n        # 14. find the max dresses in a machine\n        # 15. find the min dresses in a machine\n        # 16. find the max dresses in a machine\n        # 17. find the min dresses in a machine\n        # 18. find the max dresses in a machine\n        # 19. find the min dresses in a machine\n        # 20. find the max dresses in a machine\n        # 21. find the min dresses in a machine\n        # 22. find the max dresses in a machine\n        # 23. find the min dresses in a machine\n        # 24. find the max dresses in a machine\n        # 25. find the min dresses in a machine\n        # 26. find the max dresses in a machine\n        # 27. find the min dresses in a machine\n        # 28. find the max dresses in a machine\n        # 29. find the min dresses in a machine\n        # 30. find the max dresses in a machine\n        # 31. find the min dresses in a machine\n        # 32. find the max dresses in a machine\n        # 33. find the min dresses in a machine\n        # 34. find the max dresses in a machine\n        # 35. find the min dresses in a machine\n        # 36. find the max dresses in a machine\n        # 37. find the min dresses in a machine\n        # 38. find the max dresses in a machine\n        # 39. find the min dresses in a machine\n        # 40. find the max dresses in a machine\n        # 41. find the min dresses in a machine\n        # 42. find the max dresses in a machine\n        # 43. find the min dresses in a machine\n        # 44. find the max dresses in a machine\n        # 45. find the min dresses in a machine\n        # 46. find the max dresses in a machine\n        # 47. find the min dresses in a machine\n        # 48. find the max dresses in a machine\n        # 49. find the min dresses in a machine\n        # 50. find the max dresses in a machine\n        # 51. find the min dresses in a machine\n        # 52. find the max dresses in a machine\n        # 53. find the min dresses in a machine\n        # 54. find the max dresses in a machine\n        # 55. find the min dresses in a machine\n        # 56. find the max dresses in a machine\n        # 57. find the min dresses in a machine\n        # 58. find the max dresses in a machine\n        # 59. find the min dresses in a machine\n        # 60. find the max dresses in a machine\n        # 61. find the min dresses in a machine\n        # 62. find the max dresses in a machine\n        # 63. find the min dresses in a machine\n        # 64. find the max dresses in a machine\n        # 65. find the min dresses in a machine\n        # 66. find the max dresses in a machine\n        # 67. find the min dresses in a machine\n        # 68. find the max dresses in a machine\n        # 69. find the min dresses in a machine\n        # 70. find the max dresses in a machine\n        # 71. find the min dresses in a machine\n        # 72. find the max dresses in a machine\n        # 73. find the min dresses in a machine\n        # 74. find the max dresses in"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total / n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i]\n            right = max(right, curr)\n            curr -= avg\n            ans = max(ans, right - avg * i)\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the sum of all the dresses\n        # 2. find the max dresses in a machine\n        # 3. find the min dresses in a machine\n        # 4. find the max dresses in a machine\n        # 5. find the min dresses in a machine\n        # 6. find the max dresses in a machine\n        # 7. find the min dresses in a machine\n        # 8. find the max dresses in a machine\n        # 9. find the min dresses in a machine\n        # 10. find the max dresses in a machine\n        # 11. find the min dresses in a machine\n        # 12. find the max dresses in a machine\n        # 13. find the min dresses in a machine\n        # 14. find the max dresses in a machine\n        # 15. find the min dresses in a machine\n        # 16. find the max dresses in a machine\n        # 17. find the min dresses in a machine\n        # 18. find the max dresses in a machine\n        # 19. find the min dresses in a machine\n        # 20. find the max dresses in a machine\n        # 21. find the min dresses in a machine\n        # 22. find the max dresses in a machine\n        # 23. find the min dresses in a machine\n        # 24. find the max dresses in a machine\n        # 25. find the min dresses in a machine\n        # 26. find the max dresses in a machine\n        # 27. find the min dresses in a machine\n        # 28. find the max dresses in a machine\n        # 29. find the min dresses in a machine\n        # 30. find the max dresses in a machine\n        # 31. find the min dresses in a machine\n        # 32. find the max dresses in a machine\n        # 33. find the min dresses in a machine\n        # 34. find the max dresses in a machine\n        # 35. find the min dresses in a machine\n        # 36. find the max dresses in a machine\n        # 37. find the min dresses in a machine\n        # 38. find the max dresses in a machine\n        # 39. find the min dresses in a machine\n        # 40. find the max dresses in a machine\n        # 41. find the min dresses in a machine\n        # 42. find the max dresses in a machine\n        # 43. find the min dresses in a machine\n        # 44. find the max dresses in a machine\n        # 45. find the min dresses in a machine\n        # 46. find the max dresses in a machine\n        # 47. find the min dresses in a machine\n        # 48. find the max dresses in a machine\n        # 49. find the min dresses in a machine\n        # 50. find the max dresses in a machine\n        # 51. find the min dresses in a machine\n        # 52. find the max dresses in a machine\n        # 53. find the min dresses in a machine\n        # 54. find the max dresses in a machine\n        # 55. find the min dresses in a machine\n        # 56. find the max dresses in a machine\n        # 57. find the min dresses in a machine\n        # 58. find the max dresses in a machine\n        # 59. find the min dresses in a machine\n        # 60. find the max dresses in a machine\n        # 61. find the min dresses in a machine\n        # 62. find the max dresses in a machine\n        # 63. find the min dresses in a machine\n        # 64. find the max dresses in a machine\n        # 65. find the min dresses in a machine\n        # 66. find the max dresses in a machine\n        # 67. find the min dresses in a machine\n        # 68. find the max dresses in a machine\n        # 69. find the min dresses in a machine\n        # 70. find the max dresses in a machine\n        # 71. find the min dresses in a machine\n        # 72. find the max dresses in a machine\n        # 73. find the min dresses in a machine\n        # 74. find the max dresses in"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        sum_machines = sum(machines)\n        if sum_machines % n != 0:\n            return -1\n        avg = sum_machines // n\n        \n        left_sum = 0\n        right_sum = sum_machines\n        left_max = 0\n        right_min = 0\n        for i in range(n):\n            left_sum += machines[i]\n            right_sum -= machines[i]\n            left_max = max(left_max, left_sum)\n            right_min = min(right_min, right_sum)\n            if left_sum == right_sum:\n                return left_max - right_min\n        \n        return -1"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total / n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i]\n            right = max(right, curr)\n            curr -= avg\n            ans = max(ans, right - avg * i)\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        \n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i, h in enumerate(heights):\n            while stack and h < heights[stack[-1]]:\n                top = stack.pop()\n                max_area = max(max_area, (i - stack[-1] - 1) * heights[top])\n            stack.append(i)\n        \n        while stack:\n            top = stack.pop()\n            max_area = max(max_area, (len(heights) - stack[-1] - 1) * heights[top])\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        \n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            cur_max_area = 0\n            cur_height = [0] * m\n            for j in range(m):\n                if matrix[j][i] == '1':\n                    cur_height[j] += 1\n                else:\n                    cur_height[j] = 0\n            cur_max_area = self.largestRectangleArea(cur_height)\n            max_area = max(max_area, cur_max_area)\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                cur_height = heights[stack.pop()]\n                cur_width = i - stack[-1] - 1 if stack else i\n                max_area = max(max_area, cur_height * cur_width)\n            stack.append(i)\n        \n        while stack:\n            cur_height = heights[stack.pop()]\n            cur_width = len(heights) - stack[-1] - 1 if stack else len(heights)\n            max_area = max(max_area, cur_height * cur_width)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[0]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[0]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[0]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == '.' and s[1].isdigit():\n            return False\n        \n        # 5. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[1].isdigit():\n            return False\n        \n        # 6. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[1].isdigit():\n            return False\n        \n        # 7. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] in ('+', '-') and s[2] != '.' and s[2].isdigit():\n            return False\n        \n        # 8. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] in ('+', '-') and s[2] != '.' and s[2].isdigit():\n            return False\n        \n        # 9. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[2].isdigit():\n            return False\n        \n        # 10. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] == '.' and s[2].isdigit():\n            return False\n        \n        # 11. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[3] in ('+', '-') and s[3] != '.' and s[3].isdigit():\n            return False\n        \n        # 12. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] == '.' and s[3] in ('+', '-') and s[3] != '.' and s[3].isdigit():\n            return False\n        \n        # 13. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[3] == '.' and s[3].isdigit():\n            return False\n        \n        # 14. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] == '.' and s[3] == '.' and s[3].isdigit():\n            return False\n        \n        # 15. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[3] == '.' and s[4] in ('+', '-') and s[4] != '.' and s[4].isdigit():\n            return False\n        \n        # 16. check if it is a valid exponential\n        if s[0] in ('"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789' or len(s) == 1):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and (s[1] not in '0123456789' or len(s) == 2):\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] not in '+-' and (s[1] not in '0123456789' or len(s) == 2):\n            return False\n        \n        # 5. check if it is a valid exponential\n        if s[0] not in '+-' and s[1] == 'e' and (s[2] not in '0123456789' or len(s) == 3):\n            return False\n        \n        # 6. check if it is a valid integer\n        if s[0] not in '+-' and s[1] not in '0123456789' and (s[2] not in '0123456789' or len(s) == 3):\n            return False\n        \n        # 7. check if it is a valid decimal\n        if s[0] not in '+-' and s[1] not in '0123456789' and s[2] == '.' and (s[3] not in '0123456789' or len(s) == 4):\n            return False\n        \n        # 8. check if it is a valid exponential\n        if s[0] not in '+-' and s[1] not in '0123456789' and s[2] not in '0123456789' and s[3] == 'e' and (s[4] not in '0123456789' or len(s) == 5):\n            return False\n        \n        # 9. check if it is a valid integer\n        if s[0] not in '+-' and s[1] not in '0123456789' and s[2] not in '0123456789' and s[3] not in '0123456789' and (s[4] not in '0123456789' or len(s) == 5):\n            return False\n        \n        # 10. check if it is a valid decimal\n        if s[0] not in '+-' and s[1] not in '0123456789' and s[2] not in '0123456789' and s[3] not in '0123456789' and s[4] == '.' and (s[5] not in '0123456789' or len(s) == 6):\n            return False\n        \n        # 11. check if it is a valid exponential\n        if s[0] not in '+-' and s[1] not in '0123456789' and s[2] not in '0123456789' and s[3] not in '0123456789' and s[4] not in '0123456789' and s[5] == 'e' and (s[6] not in '0123456789' or len(s) == 7):\n            return False\n        \n        # 12. check if it is a valid integer\n        if s[0] not in '+-' and s[1] not in '0123456789' and s[2] not in '0123456789' and s[3] not in '0123456789' and s[4] not in '0"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or len(s) == 0:\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] == '-' or s[0] == '+':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == '.' and s[1].isdigit():\n            return False\n        \n        # 5. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[1].isdigit():\n            return False\n        \n        # 6. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[1].isdigit():\n            return False\n        \n        # 7. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] in ('+', '-') and s[2] != '.' and s[2].isdigit():\n            return False\n        \n        # 8. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] in ('+', '-') and s[2] != '.' and s[2].isdigit():\n            return False\n        \n        # 9. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[2].isdigit():\n            return False\n        \n        # 10. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] == '.' and s[2].isdigit():\n            return False\n        \n        # 11. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[3] in ('+', '-') and s[3] != '.' and s[3].isdigit():\n            return False\n        \n        # 12. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] == '.' and s[3] in ('+', '-') and s[3] != '.' and s[3].isdigit():\n            return False\n        \n        # 13. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[3] == '.' and s[3].isdigit():\n            return False\n        \n        # 14. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'E' and s[2] == '.' and s[3] == '.' and s[3].isdigit():\n            return False\n        \n        # 15. check if it is a valid exponential\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] == 'e' and s[2] == '.' and s[3] == '.' and s[4] in ('+', '-') and s[4] != '.' and s[4].isdigit():\n            return False\n        \n        # 16. check if it is a valid exponential\n        if s[0] in ('"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789'):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n        \n        # 4. check if it is a valid decimal\n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        # 5. check if it is a valid float\n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        # 6. check if it is a valid integer\n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in sorted(roman_dict.keys(), reverse=True):\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n                \n        return roman_num"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap to store the characters in s and t\n        ## 2. Iterate through the characters in t and check if the character is present in the hashmap\n        ## 3. If the character is not present in the hashmap, return the character\n        ## 4. If the character is present in the hashmap, decrement the count of the character\n        ## 5. If the count of the character becomes 0, return the character\n        \n        ## Code:\n        \n        hashmap = {}\n        \n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        for char in t:\n            if char not in hashmap:\n                return char\n            else:\n                hashmap[char] -= 1\n                if hashmap[char] == 0:\n                    return char"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 2nd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 3rd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 4th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 5th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 6th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 7th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 8th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 9th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 10th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 11th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 12th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 13th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 14th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 15th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 16th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 17th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 18th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 19th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 20th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 21th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 22th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 23th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 24th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 25th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 26th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 27th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 28th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 29th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 30th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 31th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 32th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 33th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 34th method"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 2nd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 3rd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 4th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 5th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 6th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 7th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 8th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 9th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 10th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 11th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 12th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 13th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 14th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 15th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 16th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 17th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 18th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 19th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 20th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 21th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 22th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 23th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 24th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 25th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 26th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 27th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 28th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 29th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 30th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 31th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 32th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 33th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 34th method"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2nd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3rd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 4th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 5th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 6th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 7th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 8th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 9th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 10th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 11th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 12th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 13th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 14th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 15th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 16th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 17th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 18th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 19th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 20th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 21th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 22th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 23th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 24th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 25th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 26th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 27th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 28th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 29th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 30th method\n        ## Time Complexity: O"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row - row%3,col - col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## In"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        if num < 1:\n            return False\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        if i * i == num:\n            return True\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        if i * i == num:\n            return True\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        \n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        \n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        \n        ans = [0,1,1]\n        for i in range(3,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, word, visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or word[0] != board[i][j] or (i, j) in visited:\n                return False\n            visited.add((i, j))\n            res = dfs(i + 1, j, word[1:], visited) or dfs(i - 1, j, word[1:], visited) or dfs(i, j + 1, word[1:], visited) or dfs(i, j - 1, word[1:], visited)\n            visited.remove((i, j))\n            return res\n        \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i, j, word, set()):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] != word[0]:\n                return\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, board, word[1:], visited, res)\n            dfs(i - 1, j, board, word[1:], visited, res)\n            dfs(i, j + 1, board, word[1:], visited, res)\n            dfs(i, j - 1, board, word[1:], visited, res)\n            visited.remove((i, j))\n            \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, set(), res)\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, word, visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or word[0] != board[i][j] or (i, j) in visited:\n                return False\n            visited.add((i, j))\n            res = dfs(i + 1, j, word[1:], visited) or dfs(i - 1, j, word[1:], visited) or dfs(i, j + 1, word[1:], visited) or dfs(i, j - 1, word[1:], visited)\n            visited.remove((i, j))\n            return res\n        \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i, j, word, set()):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node, path):\n            if len(path) > 2:\n                return\n            if node.isWord:\n                res.append(path)\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] not in node.children:\n                return\n            tmp = board[i][j]\n            board[i][j] = '#'\n            dfs(i + 1, j, node.children[tmp], path + tmp)\n            dfs(i - 1, j, node.children[tmp], path + tmp)\n            dfs(i, j + 1, node.children[tmp], path + tmp)\n            dfs(i, j - 1, node.children[tmp], path + tmp)\n            board[i][j] = tmp\n        \n        res = []\n        root = Trie()\n        for word in words:\n            root.insert(word)\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, root, '')\n        return list(set(res))"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return\n            visited[i][j] = True\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if board[x][y] == word[0]:\n                    dfs(x, y, board, word[1:], visited, res)\n            visited[i][j] = False\n        \n        res = []\n        visited = [[False] * len(board[0]) for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, visited, res)\n        return list(set(res))"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n            \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n            \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n            \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n            \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for i in range(9):\n            col = [row[i] for row in board]\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [row[j:j+3] for row in board[i:i+3]]\n                if len(set([item for sublist in box for item in sublist])) != len(box):\n                    return False\n        \n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0,9,3):\n                for j in range(0,9,3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0,9,3):\n                for j in range(0,9,3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != 9:\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != 9:\n                return False\n        \n        # check 3x3 boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if len(set(box)) != 9:\n                    return False\n        \n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        s = s.split()\n        s.reverse()\n        return ' '.join(s)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert the string to a list of characters\n        ## 2. reverse the list\n        ## 3. iterate through the list\n        ## 4. convert each character to a number\n        ## 5. add the number to the total\n        ## 6. return the total\n        \n        ## 1. convert the string to a list of characters\n        columnTitle_list = list(columnTitle)\n        \n        ## 2. reverse the list\n        columnTitle_list.reverse()\n        \n        ## 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle_list)):\n            \n            ## 4. convert each character to a number\n            columnTitle_list[i] = ord(columnTitle_list[i]) - 64\n            \n            ## 5. add the number to the total\n            total += columnTitle_list[i] * (26 ** i)\n            \n        ## 6. return the total\n        return total"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. convert each character to its corresponding number\n        # 4. add the numbers together\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. convert each character to its corresponding number\n        # 3.1. create a dictionary to map each character to its corresponding number\n        # 3.2. create a variable to store the sum\n        # 3.3. iterate through the list of characters\n        # 3.4. for each character, add the corresponding number to the sum\n        # 3.5. return the sum\n        \n        # 3.1. create a dictionary to map each character to its corresponding number\n        char_to_num = {\n            'A': 1,\n            'B': 2,\n            'C': 3,\n            'D': 4,\n            'E': 5,\n            'F': 6,\n            'G': 7,\n            'H': 8,\n            'I': 9,\n            'J': 10,\n            'K': 11,\n            'L': 12,\n            'M': 13,\n            'N': 14,\n            'O': 15,\n            'P': 16,\n            'Q': 17,\n            'R': 18,\n            'S': 19,\n            'T': 20,\n            'U': 21,\n            'V': 22,\n            'W': 23,\n            'X': 24,\n            'Y': 25,\n            'Z': 26\n        }\n        \n        # 3.2. create a variable to store the sum\n        sum = 0\n        \n        # 3.3. iterate through the list of characters\n        for i in range(len(columnTitle)):\n            # 3.4. for each character, add the corresponding number to the sum\n            sum += char_to_num[columnTitle[i]] * (26 ** i)\n            \n        # 3.5. return the sum\n        return sum"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. multiply the current number by 26^(index)\n        # 5. add the current number to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            # 4. multiply the current number by 26^(index)\n            total += (26**i) * (ord(columnTitle[i]) - 64)\n            \n        # 5. return the total\n        return total"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert the string to a list of characters\n        ## 2. reverse the list\n        ## 3. convert each character to its corresponding number\n        ## 4. add the numbers together\n        \n        ## 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        ## 2. reverse the list\n        columnTitle.reverse()\n        \n        ## 3. convert each character to its corresponding number\n        ## 3.1. create a dictionary to map each character to its corresponding number\n        ## 3.2. create a variable to store the sum\n        ## 3.3. loop through the list of characters\n        ## 3.4. for each character, add the corresponding number to the sum\n        ## 3.5. return the sum\n        \n        ## 3.1. create a dictionary to map each character to its corresponding number\n        char_to_num = {\n            'A': 1,\n            'B': 2,\n            'C': 3,\n            'D': 4,\n            'E': 5,\n            'F': 6,\n            'G': 7,\n            'H': 8,\n            'I': 9,\n            'J': 10,\n            'K': 11,\n            'L': 12,\n            'M': 13,\n            'N': 14,\n            'O': 15,\n            'P': 16,\n            'Q': 17,\n            'R': 18,\n            'S': 19,\n            'T': 20,\n            'U': 21,\n            'V': 22,\n            'W': 23,\n            'X': 24,\n            'Y': 25,\n            'Z': 26\n        }\n        \n        ## 3.2. create a variable to store the sum\n        sum = 0\n        \n        ## 3.3. loop through the list of characters\n        for i in range(len(columnTitle)):\n            ## 3.4. for each character, add the corresponding number to the sum\n            sum += char_to_num[columnTitle[i]] * (26 ** i)\n            \n        ## 3.5. return the sum\n        return sum"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. for each character, multiply the character by 26^(index)\n        # 5. add the result to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            # 4. for each character, multiply the character by 26^(index)\n            total += (26**i) * (ord(columnTitle[i]) - 64)\n            \n        # 5. return the total\n        return total"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle node\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the dictionary, check if the word is the same as the previous word\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it to the dictionary with the word as the value\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(s) != len(pattern):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if s[i] not in d.values():\n                    d[pattern[i]] = s[i]\n                else:\n                    return False\n            else:\n                if d[pattern[i]] != s[i]:\n                    return False\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # check if the pattern and word are already in the mapping\n            if pattern[i] in mapping:\n                # check if the pattern and word are mapped to the same word\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            # check if the pattern and word are not in the mapping\n            else:\n                # add the pattern and word to the mapping\n                mapping[pattern[i]] = words[i]\n        \n        # return True if the pattern and words are mapped\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the dictionary, check if the word is the same as the previous word\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it to the dictionary with the word as the value\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # check if the pattern and word are already mapped\n            if pattern[i] in mapping:\n                # check if the pattern and word are mapped to the same word\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            # check if the pattern and word are not already mapped\n            else:\n                # check if the word is already mapped to a different pattern\n                if words[i] in mapping.values():\n                    return False\n                # map the pattern and word\n                mapping[pattern[i]] = words[i]\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if matrix[i][j] == target:\n                        return True\n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if matrix[i][j] == target:\n                        return True\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a carry variable\n        carry = 0\n        # create a while loop to iterate through the linked lists\n        while l1 or l2 or carry:\n            # create a variable to store the value of the current node\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            # create a variable to store the sum of the current node\n            val = val1 + val2 + carry\n            # create a variable to store the remainder of the sum\n            carry = val // 10\n            # create a variable to store the remainder of the sum\n            val = val % 10\n            # create a new node with the value of the sum\n            curr.next = ListNode(val)\n            # move the pointer to the next node\n            curr = curr.next\n            # move the pointers to the next node\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        # return the dummy node\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a new list node\n        head = ListNode()\n        # create a pointer to the head of the list\n        ptr = head\n        # create a variable to store the carry over\n        carry = 0\n        # loop until both lists are empty\n        while l1 or l2:\n            # if l1 is empty, add 0 to the sum\n            if l1 is None:\n                sum = l2.val + carry\n                # if the sum is greater than 10, set the carry over to 1\n                if sum > 9:\n                    carry = 1\n                else:\n                    carry = 0\n                # create a new list node with the sum\n                ptr.next = ListNode(sum % 10)\n                # move to the next node\n                ptr = ptr.next\n                # move to the next node in l2\n                l2 = l2.next\n            # if l2 is empty, add 0 to the sum\n            elif l2 is None:\n                sum = l1.val + carry\n                # if the sum is greater than 10, set the carry over to 1\n                if sum > 9:\n                    carry = 1\n                else:\n                    carry = 0\n                # create a new list node with the sum\n                ptr.next = ListNode(sum % 10)\n                # move to the next node\n                ptr = ptr.next\n                # move to the next node in l1\n                l1 = l1.next\n            # if both lists are not empty, add the values of the nodes\n            else:\n                sum = l1.val + l2.val + carry\n                # if the sum is greater than 10, set the carry over to 1\n                if sum > 9:\n                    carry = 1\n                else:\n                    carry = 0\n                # create a new list node with the sum\n                ptr.next = ListNode(sum % 10)\n                # move to the next node\n                ptr = ptr.next\n                # move to the next node in l1\n                l1 = l1.next\n                # move to the next node in l2\n                l2 = l2.next\n        # if the carry over is 1, create a new list node with the carry over\n        if carry == 1:\n            ptr.next = ListNode(1)\n        # return the head of the list\n        return head.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        head = ListNode()\n        # Initialize a pointer to the new linked list\n        curr = head\n        # Initialize a variable to store the carry over\n        carry = 0\n        \n        # Loop until both linked lists are empty\n        while l1 and l2:\n            # Add the values of the two linked lists\n            sum = l1.val + l2.val + carry\n            # Set the value of the current node to the sum modulo 10\n            curr.val = sum % 10\n            # Set the carry over to the sum divided by 10\n            carry = sum // 10\n            # If the sum is greater than 9, set the value of the current node to 0\n            if sum > 9:\n                curr.val = 0\n            # If the sum is greater than 9, set the value of the current node to 0\n            if l1.next or l2.next or carry:\n                # Create a new node\n                curr.next = ListNode()\n                # Set the value of the current node to the next node\n                curr = curr.next\n            # Move to the next node in the linked list\n            l1 = l1.next\n            l2 = l2.next\n        # If the sum is greater than 9, set the value of the current node to 0\n        if carry:\n            curr.val = carry\n            curr.next = ListNode()\n            curr = curr.next\n        # Return the new linked list\n        return head"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            val1 = (l1.val if l1 else 0)\n            val2 = (l2.val if l2 else 0)\n            \n            sum = val1 + val2 + carry\n            \n            carry = sum // 10\n            curr.next = ListNode(sum % 10)\n            \n            curr = curr.next\n            l1 = (l1.next if l1 else None)\n            l2 = (l2.next if l2 else None)\n            \n        return head.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            val1 = (l1.val if l1 else 0)\n            val2 = (l2.val if l2 else 0)\n            \n            sum = val1 + val2 + carry\n            \n            carry = sum // 10\n            curr.next = ListNode(sum % 10)\n            \n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip bits\n        flip = \"\"\n        for i in binary:\n            if i == \"0\":\n                flip += \"1\"\n            else:\n                flip += \"0\"\n        \n        # convert to decimal\n        return int(flip, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        ## convert to list\n        binary_list = list(binary)\n        ## reverse the list\n        binary_list.reverse()\n        ## convert to string\n        binary_str = ''.join(binary_list)\n        ## convert to int\n        binary_int = int(binary_str, 2)\n        ## convert to binary\n        binary_str = bin(binary_int)[2:]\n        ## convert to list\n        binary_list = list(binary_str)\n        ## reverse the list\n        binary_list.reverse()\n        ## convert to string\n        binary_str = ''.join(binary_list)\n        ## convert to int\n        binary_int = int(binary_str, 2)\n        ## return the complement\n        return binary_int"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip bits\n        flip = \"\"\n        for i in binary:\n            if i == \"0\":\n                flip += \"1\"\n            else:\n                flip += \"0\"\n        \n        # convert to decimal\n        return int(flip, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        \n        ## convert to complement\n        complement = \"\"\n        for i in binary:\n            if i == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        ## convert to decimal\n        return int(complement, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        \n        ## convert to complement\n        complement = \"\"\n        for i in binary:\n            if i == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        ## convert to decimal\n        return int(complement, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Brute force\n        # Time complexity: O(n^2)\n        # Space complexity: O(1)\n        # max_area = 0\n        # for i in range(len(height)):\n        #     for j in range(i+1, len(height)):\n        #         area = min(height[i], height[j]) * (j-i)\n        #         max_area = max(max_area, area)\n        # return max_area\n        \n        # Two pointers\n        # Time complexity: O(n)\n        # Space complexity: O(1)\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Brute force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # 1. Iterate through the array\n        # 2. For each element, find the max area possible\n        # 3. Return the max area\n        \n        # 1. Iterate through the array\n        max_area = 0\n        for i in range(len(height)):\n            for j in range(i+1, len(height)):\n                # 2. For each element, find the max area possible\n                area = min(height[i], height[j]) * (j-i)\n                # 3. Return the max area\n                if area > max_area:\n                    max_area = area\n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Brute force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # \n        # max_area = 0\n        # for i in range(len(height)):\n        #     for j in range(i+1, len(height)):\n        #         area = min(height[i], height[j]) * (j-i)\n        #         max_area = max(max_area, area)\n        # return max_area\n        \n        # Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # max_area = 0\n        # left = 0\n        # right = len(height) - 1\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        \n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign * res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                self.count += 1\n                return\n            \n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n                    \n        self.count = 0\n        backtrack(0, set(), set(), set())\n        return self.count"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols + [col], diag1 + [row + col], diag2 + [row - col])\n            return count\n        \n        return backtrack(0, [], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1, j, word[1:]) or dfs(i-1, j, word[1:]) or dfs(i, j+1, word[1:]) or dfs(i, j-1, word[1:])\n            board[i][j] = word[0]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. return the third max\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. if the third max is not in the list, return the last element\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. if the third max is not in the list, return the last element\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. if the third max is not in the list, return the last max\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            nums.sort()\n            return nums[-3]"}]}