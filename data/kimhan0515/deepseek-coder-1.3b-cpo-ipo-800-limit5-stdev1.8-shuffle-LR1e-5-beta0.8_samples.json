{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = []\n        left = 0\n        right = n - 1\n        top = 0\n        bottom = m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j] + dp[i-1][j]\n        # dp[i][j] = dp[i][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i][j]\n        # dp[i][j] = dp[i][j] + dp[i"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Sort the array\n        ## 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        ## 3. If the current number is positive and less than the length of the array, then swap the current number with the index of the current number\n        ## 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        ## 5. If the current number is positive and less than the length of the array, then return the current number\n        ## 6. If the current number is positive and greater than the length of the array, then return the length of the array + 1\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Sort the array\n        nums.sort()\n        \n        ## 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                ## 3. If the current number is positive and less than the length of the array, then swap the current number with the index of the current number\n                temp = nums[i]\n                nums[i] = nums[temp - 1]\n                nums[temp - 1] = temp\n                \n        ## 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                ## 5. If the current number is positive and less than the length of the array, then return the current number\n                return nums[i]\n        \n        ## 6. If the current number is positive and greater than the length of the array, then return the length of the array + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9\n        # 2. 1,2,3,4,5,6,7,8,9\n        # 3. 1,2,3,4,5,6,7,8,9\n        # 4. 1,2,3,4,5,6,7,8,9\n        # 5. 1,2,3,4,5,6,7,8,9\n        # 6. 1,2,3,4,5,6,7,8,9\n        # 7. 1,2,3,4,5,6,7,8,9\n        # 8. 1,2,3,4,5,6,7,8,9\n        # 9. 1,2,3,4,5,6,7,8,9\n        # 10. 1,2,3,4,5,6,7,8,9\n        # 11. 1,2,3,4,5,6,7,8,9\n        # 12. 1,2,3,4,5,6,7,8,9\n        # 13. 1,2,3,4,5,6,7,8,9\n        # 14. 1,2,3,4,5,6,7,8,9\n        # 15. 1,2,3,4,5,6,7,8,9\n        # 16. 1,2,3,4,5,6,7,8,9\n        # 17. 1,2,3,4,5,6,7,8,9\n        # 18. 1,2,3,4,5,6,7,8,9\n        # 19. 1,2,3,4,5,6,7,8,9\n        # 20. 1,2,3,4,5,6,7,8,9\n        # 21. 1,2,3,4,5,6,7,8,9\n        # 22. 1,2,3,4,5,6,7,8,9\n        # 23. 1,2,3,4,5,6,7,8,9\n        # 24. 1,2,3,4,5,6,7,8,9\n        # 25. 1,2,3,4,5,6,7,8,9\n        # 26. 1,2,3,4,5,6,7,8,9\n        # 27. 1,2,3,4,5,6,7,8,9\n        # 28. 1,2,3,4,5,6,7,8,9\n        # 29. 1,2,3,4,5,6,7,8,9\n        # 30. 1,2,3,4,5,6,7,8,9\n        # 31. 1,2,3,4,5,6,7,8,9\n        # 32. 1,2,3,4,5,6,7,8,9\n        # 33. 1,2,3,4,5,6,7,8,9\n        # 34. 1,2,3,4,5,6,7,8,9\n        # 35. 1,2,3,4,5,6,7,8,9\n        # 36. 1,2,3,4,5,6,7,8,9\n        # 37. 1,2,3,4,5,6,7,8,9\n        # 38. 1,2,3,4,5,6,7,8,9\n        # 39. 1,2,3,4,5,6,7,8,9\n        # 40. 1,2,3,4,5,6,7,8,9\n        # 41. 1,2,3,4,5,6,7,8,9\n        # 42. 1"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # Hashmap\n        hashmap = {}\n        for i in range(len(numbers)):\n            if numbers[i] in hashmap:\n                return [hashmap[numbers[i]]+1, i+1]\n            hashmap[target-numbers[i]] = i\n        return [-1,-1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, curr, prev):\n            if not num:\n                if curr == target:\n                    res.append(op)\n                return\n            for i in range(1, len(num)+1):\n                if i == 1 or num[0] != '0':\n                    curr = int(num[:i])\n                    if not op:\n                        backtrack(num[i:], target, num[:i], res, curr, curr)\n                    else:\n                        backtrack(num[i:], target, op + '+' + num[:i], res, curr + prev, curr)\n                        backtrack(num[i:], target, op + '-' + num[:i], res, curr - prev, -curr)\n                        backtrack(num[i:], target, op + '*' + num[:i], res, curr * prev, curr)\n        \n        res = []\n        backtrack(num, target, '', res, 0, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        if len(s) <= k:\n            return s\n        \n        res = []\n        i = len(s) - 1\n        while i >= 0:\n            if len(res) % (k + 1) == 0:\n                res.append('-')\n            res.append(s[i])\n            i -= 1\n        return ''.join(res[::-1])"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## TLE\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the gas array and cost array\n        ## 2. If the gas[i] - cost[i] < 0, then reset the gas tank to 0 and start over\n        ## 3. If the gas[i] - cost[i] >= 0, then add the gas[i] - cost[i] to the gas tank\n        ## 4. If the gas tank is negative, then return -1\n        ## 5. If the gas tank is positive, then return the index of the starting station\n        \n        gas_tank = 0\n        start_index = 0\n        for i in range(len(gas)):\n            gas_tank += gas[i] - cost[i]\n            if gas_tank < 0:\n                gas_tank = 0\n                start_index = i + 1\n        if gas_tank < 0:\n            return -1\n        return start_index"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if len(s) < 1:\n                return False\n            return (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '.'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums\n            else:\n                return merge(merge_k(nums[:len(nums)//2]), merge_k(nums[len(nums)//2:]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            elif nums1[-1] > nums2[-1]:\n                return merge_k_helper(nums1[:-1], nums2)\n            else:\n                return merge_k_helper(nums1, nums2[:-1])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            elif nums1[-1] > nums2[-1]:\n                return merge_k_helper_2(nums1[:-1], nums2)\n            else:\n                return merge_k_helper_2(nums1, nums2[:-1])\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            elif nums1[-1] > nums2[-1]:\n                return merge_k_helper_3(nums1[:-1], nums2)\n            else:\n                return merge_k_helper_3(nums1, nums2[:-1])\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            elif nums1[-1] > nums2[-1]:\n                return merge_k_helper_4(nums1[:-1], nums2)\n            else:\n                return merge_k_helper_4(nums1, nums2[:-1])\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            elif nums1[-1] > nums2[-1]:\n                return merge_k_helper_5(nums1[:-1], nums2)\n            else:\n                return merge_k_helper_5(nums1, nums2[:-1])\n        \n        def merge_k_helper_6(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            elif nums1[-1] > nums2[-1]:\n                return merge_k_helper_6(nums1[:-1], nums2)\n            else:\n                return merge_k_helper_6(nums1, nums2[:-1])\n        \n        def merge_k"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j])-dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while nums[i] - nums[j] > mid:\n                    j += 1\n                count += i - j\n            if count >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## We can use the property of XOR to find the missing number.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with itself is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of a number with a number is 0.\n        ## XOR of a number with 0 is the number itself.\n        ## XOR of"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O(n*m)\n        ## Space Complexity: O(n)\n        \n        ## BFS\n        ## Time Complexity: O("}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                        carry = 1\n                elif a[i] == '1' or b[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n            else:\n                if a[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    if left:\n                        if mid == 0 or nums[mid - 1] < target:\n                            return mid\n                        high = mid - 1\n                    else:\n                        if mid == len(nums) - 1 or nums[mid + 1] > target:\n                            return mid\n                        low = mid + 1\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return -1\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[-1][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap with key as character and value as count\n        ## 2. Iterate through the string and increment the count for each character\n        ## 3. Iterate through the hashmap and return the index of the first character with count = 1\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return -1\n        ## 2. If the string has only one character, return 0\n        \n        ## Initialization\n        hashmap = {}\n        \n        ## Edge Cases\n        if len(s) == 0:\n            return -1\n        if len(s) == 1:\n            return 0\n        \n        ## Iterate through the string and increment the count for each character\n        for char in s:\n            if char in hashmap:\n                hashmap[char] += 1\n            else:\n                hashmap[char] = 1\n        \n        ## Iterate through the hashmap and return the index of the first character with count = 1\n        for i in range(len(s)):\n            if hashmap[s[i]] == 1:\n                return i\n        \n        ## Return -1 if no unique character is found\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(k)\n        \n        # Approach:\n        # 1. Sort the array\n        # 2. Iterate over the array and check if the difference between the current element and the next element is less than or equal to indexDiff\n        # 3. If the difference is less than or equal to indexDiff, check if the absolute difference between the current element and the next element is less than or equal to valueDiff\n        # 4. If the difference is less than or equal to indexDiff and the absolute difference between the current element and the next element is less than or equal to valueDiff, return True\n        # 5. If the difference is greater than indexDiff, return False\n        \n        if len(nums) <= 1:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums)-1):\n            if nums[i] + valueDiff >= nums[i+1] and nums[i] - valueDiff <= nums[i+1]:\n                return True\n            \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        \n        left = 0\n        right = len(nums) - 1\n        i = 0\n        \n        while i <= right:\n            if nums[i] == 0:\n                nums[left], nums[i] = nums[i], nums[left]\n                left += 1\n                i += 1\n            elif nums[i] == 2:\n                nums[right], nums[i] = nums[i], nums[right]\n                right -= 1\n            else:\n                i += 1\n                \n        return nums"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                val = int(num1[i]) + int(num2[i]) + carry\n            else:\n                val = int(num1[i]) + carry\n            \n            carry = val // 10\n            res.append(val % 10)\n        \n        if carry:\n            res.append(carry)\n        \n        return ''.join(map(str, res[::-1]))"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack[-1] = stack[-1]*num\n                elif sign == '/':\n                    stack[-1] = int(stack[-1]/num)\n                sign = s[i]\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if capital is less than or equal to w, add profit to w\n        # if k is greater than 0, subtract 1 from k\n        # else, return w\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        sorted_profits = sorted(zip(capital, profits))\n        \n        # loop through capital\n        for i in range(len(sorted_capital)):\n            # if capital is less than or equal to w, add profit to w\n            if sorted_capital[i][0] <= w:\n                w += sorted_capital[i][1]\n            # if k is greater than 0, subtract 1 from k\n            elif k > 0:\n                w += sorted_profits[i][1]\n                k -= 1\n            # else, return w\n            else:\n                return w\n        \n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is larger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # Find the number that is larger than the number to its right\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the numbers to the right of the number that was swapped\n        left, right = 0, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is not in the dictionary, return False\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the list and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        prev.next = None\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            count += 1\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        # 2. reverse the string\n        # 3. add the reverse string to the front of the original string\n        \n        # 1. find the longest palindrome substring\n        #"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_dict = {}\n        for char in t:\n            if char not in t_dict:\n                t_dict[char] = 1\n            else:\n                t_dict[char] += 1\n        \n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_window = \"\"\n        min_window_len = len(s) + 1\n        \n        while right < len(s):\n            if s[right] in t_dict:\n                if s[right] in s_dict:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] = 1\n                if s_dict[s[right]] <= t_dict[s[right]]:\n                    if right - left + 1 < min_window_len:\n                        min_window = s[left:right+1]\n                        min_window_len = right - left + 1\n                right += 1\n            else:\n                if right - left + 1 < min_window_len:\n                    min_window = s[left:right+1]\n                    min_window_len = right - left + 1\n                left += 1\n                right += 1\n        \n        return min_window"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i+4] >= distance[i+2] and distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i+4] <= distance[i+2] and distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i+4] >= distance[i+2] and distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i+4] <= distance[i+2] and distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i+4] >= distance[i+2] and distance[i+5] <= distance[i+3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Count the frequency of each character in the string\n        # 2. If the frequency is odd, add 1 to the count\n        # 3. If the frequency is even, add it to the count\n        # 4. If the count is greater than 1, add 1 to the count\n        # 5. Return the count\n        \n        count = 0\n        for i in set(s):\n            if s.count(i) % 2 == 0:\n                count += s.count(i)\n            else:\n                count += s.count(i) - 1\n        if count > 1:\n            count += 1\n        return count"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < len(forest) and 0 <= ny < len(forest[0]) and forest[nx][ny] and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if not start:\n            return -1\n        steps = bfs(start, (len(forest) - 1, len(forest[0]) - 1))\n        if steps == -1:\n            return -1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return self.minDepth(root.right) + 1\n        \n        if root.right is None:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the prefix sum\n        # 3. find the range sum\n        # 4. count the range sum\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the prefix sum\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        # 3. find the range sum\n        range_sum = {}\n        for i in range(len(prefix_sum)):\n            for j in range(i):\n                range_sum[prefix_sum[i] - prefix_sum[j]] = range_sum.get(prefix_sum[i] - prefix_sum[j], 0) + 1\n        \n        # 4. count the range sum\n        count = 0\n        for i in range(len(prefix_sum)):\n            for j in range(i):\n                range_sum[prefix_sum[i] - prefix_sum[j]] -= 1\n                if lower <= prefix_sum[i] - prefix_sum[j] <= upper:\n                    count += range_sum[prefix_sum[i] - prefix_sum[j]]\n        \n        return count"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Approach 1:\n        # return int((2 * n + 0.25) ** 0.5 - 0.5)\n        \n        # Approach 2:\n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(temp)\n            queue = queue[len(temp):]\n        \n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 1:\n            return [0,1]\n        \n        if n == 2:\n            return [0,1,3,2]\n        \n        if n == 3:\n            return [0,1,3,2,6,7,5,4]\n        \n        if n == 4:\n            return [0,1,3,2,6,7,5,4,12,13,15,14,10,9,8]\n        \n        if n == 5:\n            return [0,1,3,2,6,7,5,4,12,13,15,14,10,9,8,16,17,19,18,22,23,25,24,20,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words."}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root,min_val,max_val):\n            if root is None:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return inorder(root.left,min_val,root.val) and inorder(root.right,root.val,max_val)\n        \n        return inorder(root,float('-inf'),float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original intervals\n        if not newInterval:\n            return intervals\n        \n        # if the original intervals is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first interval in the original intervals, insert the new interval at the beginning\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last interval in the original intervals, insert the new interval at the end\n        if newInterval[0] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first interval in the original intervals, merge the new interval with the first interval\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last interval in the original intervals, merge the new interval with the last interval\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle interval in the original intervals, merge the new interval with the middle interval\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval in the original intervals, insert the new interval at the appropriate position\n        for i in range(len(intervals)):"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, i, j = heapq.heappop(q)\n            if i == n - 1 and j == n - 1:\n                return curr\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), x, y))\n                    visited.add((x, y))\n        return -1"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Dynamic Programming\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 2. Recursion\n        ## Time Complexity: O(2^(m+n))\n        ## Space Complexity: O(m+n)\n        \n        ## 3. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 4. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 5. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 6. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 7. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 8. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 9. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 10. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 11. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 12. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 13. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 14. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 15. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 16. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 17. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 18. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 19. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 20. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 21. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 22. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## 23. Bottom Up Approach\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return \"\".join(map(str, res))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can buy and sell the stock at most 2 times.\n        ## 2. We can buy and sell the stock at most 1 time.\n        ## 3. We can buy and sell the stock at most 1 time.\n        ## 4. We can buy and sell the stock at most 1 time.\n        ## 5. We can buy and sell the stock at most 1 time.\n        ## 6. We can buy and sell the stock at most 1 time.\n        ## 7. We can buy and sell the stock at most 1 time.\n        ## 8. We can buy and sell the stock at most 1 time.\n        ## 9. We can buy and sell the stock at most 1 time.\n        ## 10. We can buy and sell the stock at most 1 time.\n        ## 11. We can buy and sell the stock at most 1 time.\n        ## 12. We can buy and sell the stock at most 1 time.\n        ## 13. We can buy and sell the stock at most 1 time.\n        ## 14. We can buy and sell the stock at most 1 time.\n        ## 15. We can buy and sell the stock at most 1 time.\n        ## 16. We can buy and sell the stock at most 1 time.\n        ## 17. We can buy and sell the stock at most 1 time.\n        ## 18. We can buy and sell the stock at most 1 time.\n        ## 19. We can buy and sell the stock at most 1 time.\n        ## 20. We can buy and sell the stock at most 1 time.\n        ## 21. We can buy and sell the stock at most 1 time.\n        ## 22. We can buy and sell the stock at most 1 time.\n        ## 23. We can buy and sell the stock at most 1 time.\n        ## 24. We can buy and sell the stock at most 1 time.\n        ## 25. We can buy and sell the stock at most 1 time.\n        ## 26. We can buy and sell the stock at most 1 time.\n        ## 27. We can buy and sell the stock at most 1 time.\n        ## 28. We can buy and sell the stock at most 1 time.\n        ## 29. We can buy and sell the stock at most 1 time.\n        ## 30. We can buy and sell the stock at most 1 time.\n        ## 31. We can buy and sell the stock at most 1 time.\n        ## 32. We can buy and sell the stock at most 1 time.\n        ## 33. We can buy and sell the stock at most 1 time.\n        ## 34. We can buy and sell the stock at most 1 time.\n        ## 35. We can buy and sell the stock at most 1 time.\n        ## 36. We can buy and sell the stock at most 1 time.\n        ## 37. We can buy and sell the stock at most 1 time.\n        ## 38. We can buy and sell the stock at most 1 time.\n        ## 39. We can buy and sell the stock at most 1 time.\n        ## 40. We can buy and sell the stock at most 1 time.\n        ## 41. We can buy and sell the stock at most 1 time.\n        ## 42. We can buy and sell the stock at most 1 time.\n        ## 43. We can buy and sell the stock at most 1 time.\n        ## 44. We can buy and sell the stock at most 1 time.\n        ## 45. We can buy and sell the stock at most 1 time.\n        ## 46. We can buy and sell the stock at most 1 time.\n        ## 47. We can buy and sell the stock at most 1 time.\n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target - candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper():\n            return False\n        else:\n            return True"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root == None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr != None or len(stack) != 0:\n            if curr != None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, res):\n            if left == 0 and right == 0:\n                if isValid(s):\n                    res.append(s)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left - 1, right, res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right - 1, res)\n        \n        res = []\n        dfs(s, s.count('('), s.count(')'), res)\n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n            \n        if l1:\n            curr.next = l1\n        elif l2:\n            curr.next = l2\n            \n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeros(n):\n            count = 0\n            while n:\n                count += n // 5\n                n //= 5\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeros(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        def getPairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if isPalindrome(word[i:]):\n                    pairs.append(len(word)-i-1)\n                if i and isPalindrome(word[:i]):\n                    pairs.append(i-1)\n            return pairs\n        \n        return [pairs for word in words for pairs in getPairs(word)]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def infect(i,j):\n            if i<0 or i>=len(isInfected) or j<0 or j>=len(isInfected[0]) or isInfected[i][j]==1:\n                return\n            isInfected[i][j]=1\n            for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\n                infect(x,y)\n        \n        def walls():\n            count=0\n            while True:\n                infected=[]\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j]==1:\n                            infect(i,j)\n                            infected.append((i,j))\n                if not infected:\n                    break\n                count+=1\n                for i,j in infected:\n                    isInfected[i][j]=0\n            return count\n        \n        return walls()"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            max_len = 1\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    max_len = max(max_len, 1 + dfs(x, y))\n            \n            dp[i][j] = max_len\n            return max_len\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Dynamic Programming\n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = False if s[:i] is not a valid word\n        # dp[0] = True\n        # dp[i] = True if dp[j] == True and s[j:i] in wordDict\n        # dp[i] = False if dp[j] == False and s[j:i] in wordDict\n        \n        # Base Case\n        if not s:\n            return []\n        \n        # Initialize dp array\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        # Iterate through s\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        # If dp[len(s)] is True, then s is a valid word\n        if dp[len(s)]:\n            # Initialize result\n            result = []\n            # Initialize current word\n            current_word = \"\"\n            # Iterate through s\n            for i in range(len(s)):\n                # If dp[i] is True, then s[:i] is a valid word\n                if dp[i]:\n                    # If current_word is not empty, then add it to result\n                    if current_word:\n                        result.append(current_word)\n                    # Add s[:i] to current_word\n                    current_word = s[:i]\n            # If current_word is not empty, then add it to result\n            if current_word:\n                result.append(current_word)\n            # Return result\n            return result\n        # If dp[len(s)] is False, then s is not a valid word\n        else:\n            # Return empty list\n            return []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level += 1\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes[::-1])\n            else:\n                result.append(level_nodes)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_hour(h):\n            if h < 12:\n                return str(h)\n            else:\n                return \"\"\n        \n        def get_minute(m):\n            if m < 60:\n                return str(m)\n            else:\n                return \"\"\n        \n        def get_time_list(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m)]\n            else:\n                return []\n        \n        def get_time_list_with_pm(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_one(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"01\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_two(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"02\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_three(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"03\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_four(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"04\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_five(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"05\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_six(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"06\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_seven(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"07\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_eight(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"08\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_nine(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m), \"PM\", \"00\", \"09\"]\n            else:\n                return []\n        \n        def get_time_list_with_pm_and_zero_and_ten(h, m):\n            if h < 12 and m < 60:\n                return [get_hour(h), get_minute(m"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n            \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = curr_i + di, curr_j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and not visited[new_i][new_j]:\n                    visited[new_i][new_j] = True\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # sliding window\n        # 1. sort the array\n        # 2. find the median\n        # 3. return the median\n        \n        # sort the array\n        nums.sort()\n        \n        # find the median\n        # if the length of the array is odd\n        if len(nums) % 2 == 1:\n            # return the middle element\n            return nums[len(nums) // 2]\n        else:\n            # return the average of the middle two elements\n            return (nums[len(nums) // 2] + nums[len(nums) // 2 - 1]) / 2"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate by k % length\n        k = k % length\n        \n        # if k is 0, we don't need to rotate\n        if k == 0:\n            return head\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut the old linked list off\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray(sums, k))\n        return max_sum\n    \n    def max_subarray(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i,j]\n        \n        ## Hashmap\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [hashmap[complement], i]\n            hashmap[nums[i]] = i\n        return []"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        new_cards = [a, b] + [x for x in cards if x not in [a, b]]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards.append(a + b)\n                            elif op == '-':\n                                new_cards.append(a - b)\n                            elif op == '*':\n                                new_cards.append(a * b)\n                            else:\n                                if b == 0:\n                                    continue\n                                new_cards.append(a / b)\n                        if dfs(new_cards, target):\n                            return True\n            return False\n        \n        return dfs(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p["}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        def dfs(node):\n            while graph[node]:\n                next_node = graph[node].pop(0)\n                dfs(next_node)\n            itinerary.append(node)\n        \n        itinerary = []\n        dfs(\"JFK\")\n        return itinerary[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l<r:\n                    if nums[i]+nums[j]+nums[l]+nums[r]==target:\n                        res.append([nums[i],nums[j],nums[l],nums[r]])\n                        l+=1\n                        r-=1\n                        while l<r and nums[l]==nums[l-1]:\n                            l+=1\n                        while l<r and nums[r]==nums[r+1]:\n                            r-=1\n                    elif nums[i]+nums[j]+nums[l]+nums[r]<target:\n                        l+=1\n                    else:\n                        r-=1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize result\n        result = []\n        \n        # initialize max height\n        max_height = 0\n        \n        # initialize current building\n        current_building = None\n        \n        # initialize current height\n        current_height = 0\n        \n        # initialize current edge\n        current_edge = None\n        \n        # initialize current edge index\n        current_edge_index = 0\n        \n        # loop through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as current building\n            if current_building != building[2]:\n                # set current building\n                current_building = building[2]\n                \n                # set current height\n                current_height = building[2]\n                \n                # set current edge\n                current_edge = building[0]\n                \n                # set current edge index\n                current_edge_index = 0\n                \n                # loop through buildings\n                for i in range(current_edge_index, len(buildings)):\n                    # if current edge is greater than current edge index\n                    if current_edge > buildings[i][0]:\n                        # set current edge index\n                        current_edge_index = i\n                        \n                        # set current edge\n                        current_edge = buildings[i][0]\n                        \n                        # set current height\n                        current_height = max(current_height, buildings[i][2])\n                        \n                        # if current height is greater than max height\n                        if current_height > max_height:\n                            # set max height\n                            max_height = current_height\n                            \n                            # append current edge and max height to result\n                            result.append([current_edge, max_height])\n                            \n                            # set current edge\n                            current_edge = buildings[i][0]\n                            \n                            # set current height\n                            current_height = buildings[i][2]\n                            \n                            # set current edge index\n                            current_edge_index = i\n                            \n                            # if current edge is greater than current edge index\n                            if current_edge > buildings[i][0]:\n                                # set current edge index\n                                current_edge_index = i\n                                \n                                # set current edge\n                                current_edge = buildings[i][0]\n                                \n                                # set current height\n                                current_height = max(current_height, buildings[i][2])\n                                \n                                # if current height is greater than max height\n                                if current_height > max_height:\n                                    # set max height\n                                    max_height = current_height\n                                    \n                                    # append current edge and max height to result\n                                    result.append([current_edge, max_height])\n                                    \n                                    # set current edge\n                                    current_edge = buildings[i][0]\n                                    \n                                    # set current height\n                                    current_height = buildings[i][2]\n                                    \n                                    # set current edge index\n                                    current_edge_index = i\n                    \n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # We can use DP to solve this problem.\n        # We can use a 2D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n            if num < 1000000000000000:\n                return helper(num // 1000000000000) + \" Trillion \" + helper(num % 1000000000000)\n            if num < 1000000000000000000:\n                return helper(num // 1000000000000000) + \" Quadrillion \" + helper(num % 1000000000000000)\n            if num < 1000000000000000000000:\n                return helper(num // 1000000000000000000) + \" Quintillion \" + helper(num % 1000000000000000000)\n            if num < 10000000000000000000000000:\n                return helper(num // 1000000000000000000000) + \" Sextillion \" + helper(num % 1000000000000000000000)\n            if num < 100000000000000000000000000000:\n                return helper(num // 1000000000000000000000000) + \" Septillion \" + helper(num % 1000000000000000000000000)\n            if num < 1000000000000000000000000000000000:\n                return helper(num // 1000000000000000000000000000) + \" Octillion \" + helper(num % 1000000000000000000000000000)\n            if num < 100000000000000000000000000000000000"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if i == 1:\n                        dp[i][j] = 1\n                    else:\n                        if j >= i:\n                            dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod\n                        else:\n                            dp[i][j] = (dp[i][j-1] - dp[i-1][j-i] + mod) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return root.val == targetSum\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the value is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the value is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Find the node with two parents\n        # 2. Find the edge that has the node with two parents\n        # 3. Find the node that has the edge with two parents\n        # 4. Return the edge that has the node with two parents\n        \n        # 1. Find the node with two parents\n        parent_map = {}\n        for edge in edges:\n            if edge[0] in parent_map:\n                parent_map[edge[0]].append(edge[1])\n            else:\n                parent_map[edge[0]] = [edge[1]]\n        \n        # 2. Find the edge that has the node with two parents\n        for edge in edges:\n            if edge[1] in parent_map:\n                if len(parent_map[edge[1]]) == 2:\n                    return edge\n            else:\n                parent_map[edge[1]] = [edge[0]]\n        \n        # 3. Find the node that has the edge with two parents\n        for edge in edges:\n            if edge[0] in parent_map:\n                if len(parent_map[edge[0]]) == 2:\n                    return edge\n            else:\n                parent_map[edge[0]] = [edge[1]]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n                \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        \n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the array and keep track of the number of times each number appears.\n        ## 2. If the number appears twice, then it will be the answer.\n        ## 3. If the number appears once, then it will be the answer.\n        ## 4. If the number appears zero times, then it will be the answer.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Iterate through the array and keep track of the number of times each number appears.\n        ## 2. If the number appears twice, then it will be the answer.\n        ## 3. If the number appears once, then it will be the answer.\n        ## 4. If the number appears zero times, then it will be the answer.\n        ## 5. If the number appears zero times, then it will be the answer.\n        ## 6. If the number appears zero times, then it will be the answer.\n        ## 7. If the number appears zero times, then it will be the answer.\n        ## 8. If the number appears zero times, then it will be the answer.\n        ## 9. If the number appears zero times, then it will be the answer.\n        ## 10. If the number appears zero times, then it will be the answer.\n        ## 11. If the number appears zero times, then it will be the answer.\n        ## 12. If the number appears zero times, then it will be the answer.\n        ## 13. If the number appears zero times, then it will be the answer.\n        ## 14. If the number appears zero times, then it will be the answer.\n        ## 15. If the number appears zero times, then it will be the answer.\n        ## 16. If the number appears zero times, then it will be the answer.\n        ## 17. If the number appears zero times, then it will be the answer.\n        ## 18. If the number appears zero times, then it will be the answer.\n        ## 19. If the number appears zero times, then it will be the answer.\n        ## 20. If the number appears zero times, then it will be the answer.\n        ## 21. If the number appears zero times, then it will be the answer.\n        ## 22. If the number appears zero times, then it will be the answer.\n        ## 23. If the number appears zero times, then it will be the answer.\n        ## 24. If the number appears zero times, then it will be the answer.\n        ## 25. If the number appears zero times, then it will be the answer.\n        ## 26. If the number appears zero times, then it will be the answer.\n        ## 27. If the number appears zero times, then it will be the answer.\n        ## 28. If the number appears zero times, then it will be the answer.\n        ## 29. If the number appears zero times, then it will be the answer.\n        ## 30. If the number appears zero times, then it will be the answer.\n        ## 31. If the number appears zero times, then it will be the answer.\n        ## 32. If the number appears zero times, then it will be the answer.\n        ## 33. If the number appears zero times, then it will be the answer.\n        ## 34. If the number appears zero times, then it will be the answer.\n        ## 35. If the number appears zero times, then it will be the answer.\n        ## 36. If the number appears zero times, then it will be the answer.\n        ## 37. If the number appears zero times, then it will be the answer.\n        ## 38. If the number appears zero times, then it will be the answer.\n        ## 39. If the number appears zero times, then it will be the answer.\n        ##"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + grid[i][j]\n                    if j > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + grid[i][j])\n                    if k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + grid[i][j])\n                    if j > 0 and k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + grid[i][j])\n        return max(dp[n - 1][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0]*3 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % mod\n            dp[i][1] = dp[i-1][0]\n            dp[i][2] = dp[i-1][1]\n        return (dp[n][0] + dp[n][1] + dp[n][2]) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return index of target\n        # if target is not in nums, return index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in num"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 4. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 5. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 6. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 7. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 8. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 9. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 10. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 11. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 12. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 13. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 14. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 15. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 16. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 17. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 18. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 19. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 20. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 21. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 22. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 23. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 24. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 25. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 26. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 27. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 28. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 29. \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 30. \n        ## Time Complexity: O"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"13211321321123113122112131211131221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211213213211231131221\"\n        \n        if n == 15:\n            return \"311311222123113213211231131221121312111322211213213211231131221\"\n        \n        if n == 16:\n            return \"1321132132112311322211213121113122122112132132112311322211213213211231131221\"\n        \n        if n == 17:\n            return \"111312211312132112311322211213121113122122112132132112311322211213213211231131221\"\n        \n        if n == 18:\n            return \"3113112221231132132112311322211213121113122122112132132112311322211213213211231131221\"\n        \n        if n == 19:\n            return \"1321132132112311322211213121113122122112132132112311322211213213211231131221\"\n        \n        if n == 20:\n            return \"111312211312132112311322211213121113122122112132132112311322211213213211231131221\"\n        \n        if n == 21:\n            return \"311311222123113213211231132221121312111312212211213213"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(target):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > target:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(i, curr):\n            if len(curr) == len(digits):\n                res.append(curr)\n                return\n            \n            for j in range(i, len(digits)):\n                for c in phone[digits[j]]:\n                    backtrack(j+1, curr+c)\n        \n        backtrack(0, \"\")\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            if i >= len(candidates) or target < 0:\n                return\n            dfs(i, curr, target - candidates[i])\n            curr.append(candidates[i])\n            dfs(i, curr, target)\n            curr.pop()\n            dfs(i + 1, curr, target)\n        dfs(0, [], target)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as n, return the smaller palindrome\n        # 3. If the nearest palindrome is 0, return 10\n        # 4. If the nearest palindrome is 9, return 9\n        # 5. If the nearest palindrome is 10, return 11\n        # 6. If the nearest palindrome is 99, return 100\n        # 7. If the nearest palindrome is 100, return 101\n        # 8. If the nearest palindrome is 999, return 1000\n        # 9. If the nearest palindrome is 1000, return 1001\n        # 10. If the nearest palindrome is 9999, return 10000\n        # 11. If the nearest palindrome is 10000, return 10001\n        # 12. If the nearest palindrome is 99999, return 100000\n        # 13. If the nearest palindrome is 100000, return 100001\n        # 14. If the nearest palindrome is 999999, return 1000000\n        # 15. If the nearest palindrome is 1000000, return 1000001\n        # 16. If the nearest palindrome is 9999999, return 10000000\n        # 17. If the nearest palindrome is 10000000, return 10000001\n        # 18. If the nearest palindrome is 99999999, return 100000000\n        # 19. If the nearest palindrome is 100000000, return 100000001\n        # 20. If the nearest palindrome is 999999999, return 1000000000\n        # 21. If the nearest palindrome is 1000000000, return 1000000001\n        # 22. If the nearest palindrome is 9999999999, return 10000000000\n        # 23. If the nearest palindrome is 10000000000, return 10000000001\n        # 24. If the nearest palindrome is 99999999999, return 100000000000\n        # 25. If the nearest palindrome is 100000000000, return 100000000001\n        # 26. If the nearest palindrome is 999999999999, return 1000000000000\n        # 27. If the nearest palindrome is 1000000000000, return 1000000000001\n        # 28. If the nearest palindrome is 9999999999999, return 10000000000000\n        # 29. If the nearest palindrome is 10000000000000, return 10000000000001\n        # 30. If the nearest palindrome is 99999999999999, return 100000000000000\n        # 31. If the nearest palindrome is 100000000000000, return 100000000000001\n        # 32. If the nearest"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        i,j = 0,0\n        count = 1\n        while count <= n*n:\n            for j in range(i,n-i):\n                matrix[i][j] = count\n                count += 1\n            for i in range(i+1,n-i):\n                matrix[i][n-i-1] = count\n                count += 1\n            for j in range(n-i-2,i-1,-1):\n                matrix[n-i-1][j] = count\n                count += 1\n            for i in range(n-i-2,i,-1):\n                matrix[i][i] = count\n                count += 1\n            i += 1\n            n -= 2\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            x = -x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        max_prod_so_far = nums[0]\n        \n        for i in range(1, len(nums)):\n            temp = max_prod\n            max_prod = max(nums[i], max(max_prod * nums[i], min_prod * nums[i]))\n            min_prod = min(nums[i], min(temp * nums[i], min_prod * nums[i]))\n            max_prod_so_far = max(max_prod_so_far, max_prod)\n            \n        return max_prod_so_far"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        \n        stone_map = {}\n        for stone in stones:\n            stone_map[stone] = stone_set\n        \n        queue = deque([(0,0)])\n        while queue:\n            stone, jump = queue.popleft()\n            if stone == stones[-1]:\n                return True\n            for next_stone in stone_map[stone]:\n                if next_stone - stone <= jump + 1:\n                    queue.append((next_stone, jump + 1))\n        return False"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank = {}\n        \n        # loop through the array\n        for i in range(len(score)):\n            # add the value to the dictionary\n            rank[score[i]] = i + 1\n        \n        # loop through the array\n        for i in range(len(score)):\n            # if the value is in the dictionary\n            if score[i] in rank:\n                # set the value to the key\n                score[i] = rank[score[i]]\n        \n        # loop through the array\n        for i in range(len(score)):\n            # if the value is 1\n            if score[i] == 1:\n                # set the value to \"Gold Medal\"\n                score[i] = \"Gold Medal\"\n            # if the value is 2\n            elif score[i] == 2:\n                # set the value to \"Silver Medal\"\n                score[i] = \"Silver Medal\"\n            # if the value is 3\n            elif score[i] == 3:\n                # set the value to \"Bronze Medal\"\n                score[i] = \"Bronze Medal\"\n        \n        # return the array\n        return score"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        curr_len = 0\n        seen = {}\n        for i in range(len(s)):\n            if s[i] in seen:\n                curr_len = i - seen[s[i]]\n            else:\n                curr_len += 1\n            max_len = max(max_len, curr_len)\n            seen[s[i]] = i\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n                else:\n                    break\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = max(arr)\n        max_index = arr.index(max_val)\n        count = 0\n        for i in range(max_index):\n            if arr[i] <= max_val:\n                count += 1\n                max_val = max(arr[i:max_index+1])\n        return count"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid)\n            count += mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        if len(v1) > len(v2):\n            v2.extend(['0'] * (len(v1) - len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend(['0'] * (len(v2) - len(v1)))\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j]-prices[i])\n        return max_profit\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            max_profit = max(max_profit, prices[i]-min_price)\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # loop through courses\n        for duration, lastDay in courses:\n            \n            # add course to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            \n            # add duration to total time\n            total += duration\n            \n            # if total time exceeds last day\n            if total > lastDay:\n                \n                # pop from priority queue\n                total -= heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp[i-4]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp[i-4]*2 + ... + dp[i-4]*2 + dp[i-5]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp[i-4]*2 + ... + dp[i-4]*2 + dp[i-5]*2 + ... + dp[i-5]*2 + dp[i-6]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp[i-4]*2 + ... + dp[i-4]*2 + dp[i-5]*2 + ... + dp[i-5]*2 + dp[i-6]*2 + ... + dp[i-6]*2 + dp[i-7]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp[i-4]*2 + ... + dp[i-4]*2 + dp[i-5]*2 + ... + dp[i-5]*2 + dp[i-6]*2 + ... + dp[i-6]*2 + dp[i-7]*2 + ... + dp[i-7]*2 + dp[i-8]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp[i-4]*2 + ... + dp[i-4]*2 + dp[i-5]*2 + ... + dp[i-5]*2 + dp[i-6]*2 + ... + dp[i-6]*2 + dp[i-7]*2 + ... + dp[i-7]*2 + dp[i-8]*2 + ... + dp[i-8]*2 + dp[i-9]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-2]*2 + dp[i-3]*2 + ... + dp[i-3]*2 + dp"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each element\n        ## 2. Iterate through the array and increment the frequency of each element\n        ## 3. Return the element with frequency 1\n        \n        ## Edge Cases:\n        ## 1. If the array is empty, return 0\n        ## 2. If the array has only one element, return that element\n        \n        ## Algorithm:\n        ## 1. Create a hashmap to store the frequency of each element\n        ## 2. Iterate through the array and increment the frequency of each element\n        ## 3. Return the element with frequency 1\n        \n        ## Code:\n        hashmap = {}\n        for i in nums:\n            if i not in hashmap:\n                hashmap[i] = 1\n            else:\n                hashmap[i] += 1\n        \n        for i in hashmap:\n            if hashmap[i] == 1:\n                return i\n        \n        return 0"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if target == \"\":\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target)"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        sum = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                sum -= roman_dict[s[i]]\n            else:\n                sum += roman_dict[s[i]]\n        return sum"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # 1. Create a set\n        # 2. Iterate through the array\n        # 3. If the element is already in the set, return True\n        # 4. Otherwise, add the element to the set\n        # 5. Return False\n        \n        # Edge Cases:\n        # 1. If the array is empty, return False\n        # 2. If the array has only one element, return False\n        \n        if len(nums) <= 1:\n            return False\n        \n        nums_set = set()\n        \n        for num in nums:\n            if num in nums_set:\n                return True\n            else:\n                nums_set.add(num)\n        \n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # 1. create a queue\n        # 2. iterate through the array\n        # 3. if the queue is full, pop the leftmost element\n        # 4. add the rightmost element\n        # 5. return the queue\n        \n        # edge case\n        if len(nums) == 0:\n            return []\n        \n        # create a queue\n        queue = []\n        \n        # iterate through the array\n        for i in range(len(nums)):\n            \n            # if the queue is full, pop the leftmost element\n            if len(queue) == k:\n                queue.pop(0)\n            \n            # add the rightmost element\n            queue.append(nums[i])\n            \n            # return the queue\n            if i >= k - 1:\n                res.append(max(queue))\n                \n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        # return nums[left]\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n            \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub204\uace0, \ub098\uba38\uc9c0\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub204\uc5b4\uc11c \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 4. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2d0 \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 6. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2d0 \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 7. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 8. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2d0 \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 9. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 10. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2d0 \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 11. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 12. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2d0 \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 13. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 14. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uac00 \uc544\ub2d0 \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 15. \uc81c\uacf1\uadfc\uc774 \uc815\uc218\uc77c \uacbd\uc6b0, \uc81c\uacf1\uadfc\uc744 \ubc18\ud658\ud55c\ub2e4."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        visited = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord(\"a\") + j) + word[i+1:]\n                    if neighbor in graph:\n                        if neighbor in visited:\n                            continue\n                        visited[neighbor] = visited[word] + 1\n                        queue.append(neighbor)\n                        if neighbor == endWord:\n                            break\n        else:\n            return []\n        \n        # Build the result\n        result = []\n        while queue:\n            word = queue.popleft()\n            if word == endWord:\n                result.append([word])\n            else:\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord(\"a\") + j) + word[i+1:]\n                        if neighbor in graph and neighbor in visited:\n                            if visited[neighbor] == visited[word] + 1:\n                                result.append([word] + [neighbor] + result[-1][1:])\n                            else:\n                                queue.append([word] + [neighbor] + result[-1][1:])\n        return result"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if root is None:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        if n == 1:\n            return True\n        else:\n            return False"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [ [nums[i]] + r for r in res]\n            else:\n                res += [ r[:i] + [nums[i]] + r[i:] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \uc5c6\uc73c\uba74 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \uc5c6\uc73c\uba74 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min == x_max and y_min == y_max:\n            return True\n        if x_min == x_max or y_min == y_max:\n            return False\n        if x_min < x_max and y_min < y_max:\n            return True\n        if x_min < x_max and y_min > y_max:\n            return False\n        if x_min > x_max and y_min < y_max:\n            return False\n        if x_min > x_max and y_min > y_max:\n            return True\n        return False"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert board to a string\n        # 2. convert board to a number\n        # 3. convert number to a string\n        # 4. convert string to a number\n        # 5. convert number to a string\n        # 6. convert string to a number\n        # 7. convert number to a string\n        # 8. convert string to a number\n        # 9. convert number to a string\n        # 10. convert string to a number\n        # 11. convert number to a string\n        # 12. convert string to a number\n        # 13. convert number to a string\n        # 14. convert string to a number\n        # 15. convert number to a string\n        # 16. convert string to a number\n        # 17. convert number to a string\n        # 18. convert string to a number\n        # 19. convert number to a string\n        # 20. convert string to a number\n        # 21. convert number to a string\n        # 22. convert string to a number\n        # 23. convert number to a string\n        # 24. convert string to a number\n        # 25. convert number to a string\n        # 26. convert string to a number\n        # 27. convert number to a string\n        # 28. convert string to a number\n        # 29. convert number to a string\n        # 30. convert string to a number\n        # 31. convert number to a string\n        # 32. convert string to a number\n        # 33. convert number to a string\n        # 34. convert string to a number\n        # 35. convert number to a string\n        # 36. convert string to a number\n        # 37. convert number to a string\n        # 38. convert string to a number\n        # 39. convert number to a string\n        # 40. convert string to a number\n        # 41. convert number to a string\n        # 42. convert string to a number\n        # 43. convert number to a string\n        # 44. convert string to a number\n        # 45. convert number to a string\n        # 46. convert string to a number\n        # 47. convert number to a string\n        # 48. convert string to a number\n        # 49. convert number to a string\n        # 50. convert string to a number\n        # 51. convert number to a string\n        # 52. convert string to a number\n        # 53. convert number to a string\n        # 54. convert string to a number\n        # 55. convert number to a string\n        # 56. convert string to a number\n        # 57. convert number to a string\n        # 58. convert string to a number\n        # 59. convert number to a string\n        # 60. convert string to a number\n        # 61. convert number to a string\n        # 62. convert string to a number\n        # 63. convert number to a string\n        # 64. convert string to a number\n        # 65. convert number to a string\n        # 66. convert string to a number\n        # 67. convert number to a string\n        # 68. convert string to a number\n        # 69. convert number to a string\n        # 70. convert string to a number\n        # 71. convert number to a string\n        # 72. convert string to a number\n        # 73. convert number to a string\n        # 74. convert string to a number\n        # 75. convert number to a string\n        # 76. convert string to a number\n        # 77. convert number to a string\n        # 78. convert string to a number\n        # 79. convert number to a string\n        # 80. convert string to a number\n        # 81. convert number to a string\n        # 82. convert string to a number\n        # 83. convert number to a string\n        # 84. convert string to a number\n        # 85. convert number to a string\n        # 86. convert string to a number"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n                \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # edge cases\n        if len(nums) == 0:\n            return False\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1,m):\n            if obstacleGrid[i][0] == 1:\n                obstacleGrid[i][0] = 0\n            else:\n                obstacleGrid[i][0] = obstacleGrid[i-1][0]\n                \n        for i in range(1,n):\n            if obstacleGrid[0][i] == 1:\n                obstacleGrid[0][i] = 0\n            else:\n                obstacleGrid[0][i] = obstacleGrid[0][i-1]\n                \n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j] == 1:\n                    obstacleGrid[i][j] = 0\n                else:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                    \n        return obstacleGrid[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root,min_diff,prev):\n            if root is None:\n                return\n            inorder(root.left,min_diff,prev)\n            min_diff = min(min_diff,root.val-prev)\n            prev = root.val\n            inorder(root.right,min_diff,prev)\n            return min_diff\n        \n        return inorder(root,float('inf'),float('-inf'))"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        max_count = 0\n        max_val = None\n        count = 0\n        prev = None\n        for val in inorder_list:\n            if prev is None:\n                prev = val\n                count = 1\n            elif val == prev:\n                count += 1\n            else:\n                if count > max_count:\n                    max_count = count\n                    max_val = prev\n                prev = val\n                count = 1\n            if val == inorder_list[-1]:\n                if count > max_count:\n                    max_count = count\n                    max_val = prev\n        return [max_val] if max_count == 1 else [max_val] if max_count == 2 else [max_val, inorder_list[inorder_list.index(max_val) + 1]]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is at least 6 characters long\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        \n        # 2. Check if password is at most 20 characters long\n        if len(password) > 20:\n            return max(20 - len(password), 0)\n        \n        # 3. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 3\n        \n        # 4. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 5. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 6. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 7. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 8. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 9. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 10. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 11. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 12. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 13. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 14. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 15. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 16. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 17. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 18. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = True\n        \n        for c in s:\n            res[i] += c\n            if i == 0:\n                flag = True\n            elif i == numRows - 1:\n                flag = False\n            if flag:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # TLE\n        # if len(height) < 3:\n        #     return 0\n        # res = 0\n        # for i in range(len(height)):\n        #     left_max = max(height[:i])\n        #     right_max = max(height[i:])\n        #     res += min(left_max, right_max) - height[i]\n        # return res\n        \n        # Approach 2: Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Accepted\n        # Use two pointers, left and right, to keep track of the maximum height on the left and right\n        # If the height of the left pointer is less than the height of the right pointer, move the left pointer\n        # If the height of the left pointer is greater than the height of the right pointer, move the right pointer\n        # If the height of the left pointer is equal to the height of the right pointer, move the left pointer\n        # Keep track of the maximum height on the left and right\n        # Calculate the amount of water that can be trapped\n        # Return the amount of water that can be trapped\n        if len(height) < 3:\n            return 0\n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Approach 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the list, add it to the list\n        ## Return the list\n        \n        ## Approach 1:\n        ## Create a set of nums\n        ## Iterate through the range of 1 to n\n        ## If the number is not in the set, add it to the list\n        ## Return the list\n        \n        ## Approach 2:\n        ## Create a list of n+1 elements\n        ## Iterate through the range of 1 to n\n        ##"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(nums[i], 0) for i in range(len(nums))])]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        prev = -1\n        for interval in intervals:\n            if interval[0] > prev:\n                res += 2\n                prev = interval[1] - 1\n            else:\n                prev = interval[1] - 1\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None:\n                return False\n            if root1.val != root2.val:\n                return False\n            return isMirror(root1.left, root2.right) and isMirror(root1.right, root2.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(open_count, close_count, curr_str, res):\n            if open_count == close_count == n:\n                res.append(curr_str)\n                return\n            if open_count < n:\n                backtrack(open_count + 1, close_count, curr_str + \"(\", res)\n            if close_count < open_count:\n                backtrack(open_count, close_count + 1, curr_str + \")\", res)\n        \n        res = []\n        backtrack(0, 0, \"\", res)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \ucd94\uac00\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud55c\ub2e4.\n        \n        stack = []\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    if not stack:\n                        max_len = max(max_len, i + 1)\n                    else:\n                        max_len = max(max_len, i - stack[-1])\n                else:\n                    stack.append(i)\n        \n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return sign + str(quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        fraction = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                fraction = fraction[:remainder_dict[remainder]] + \"(\" + fraction[remainder_dict[remainder]:] + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            fraction += str(quotient)\n        \n        return sign + str(quotient) + \".\" + fraction"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        print(envelopes)\n        dp = [1] * len(envelopes)\n        max_val = 1\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_val = max(max_val, dp[i])\n        return max_val"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row = [0]*len(matrix)\n        ## col = [0]*len(matrix[0])\n        ## for i in range(len(matrix)):\n        ##     for j in range(len(matrix[0])):\n        ##         if matrix[i][j] == 0:\n        ##             row[i] = 1\n        ##             col[j] = 1\n        ## for i in range(len(matrix)):\n        ##     for j in range(len(matrix[0])):\n        ##         if row[i] == 1 or col[j] == 1:\n        ##             matrix[i][j] = 0\n        ## return matrix\n        \n        ## O(1) space\n        row = False\n        col = False\n        for i in range(len(matrix)):\n            if matrix[i][0] == 0:\n                col = True\n            for j in range(1,len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(len(matrix)):\n            for j in range(1,len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if col:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n        if row:\n            for j in range(len(matrix[0])):\n                matrix[0][j] = 0\n        return matrix"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node at the nth position from the end\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2."}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        \n        return list(nums1 & nums2)"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum(machines)\n        # res = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     res = max(res, abs(left_sum - right_sum))\n        #     if left_sum < right_sum:\n        #         res = max(res, machines[i])\n        # return res\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        \n        sum_machines = sum(machines)\n        avg = sum_machines // n\n        \n        if avg * n != sum_machines:\n            return -1\n        \n        left_sum = 0\n        right_sum = sum(machines)\n        res = 0\n        \n        for i in range(n):\n            left_sum += machines[i]\n            right_sum -= machines[i]\n            res = max(res, abs(left_sum - right_sum))\n            if left_sum < right_sum:\n                res = max(res, machines[i])\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            temp = list1\n            list1 = list1.next\n            temp.next = self.mergeTwoLists(list1, list2)\n            return temp\n        else:\n            temp = list2\n            list2 = list2.next\n            temp.next = self.mergeTwoLists(list1, list2)\n            return temp"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_area = 0\n        heights = [0] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                backtrack(i + 1, path + [nums[i]])\n        backtrack(0, [])\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        # if nums[0] == nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n        roman_num = ''\n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap of the string s\n        ## 2. Iterate through the string t\n        ## 3. If the character is not in the hashmap, add it to the hashmap\n        ## 4. If the character is in the hashmap, decrement the count\n        ## 5. Return the character that has a count of 1\n        \n        hashmap = {}\n        \n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        for char in t:\n            if char not in hashmap:\n                return char\n            else:\n                hashmap[char] -= 1\n        \n        for key, value in hashmap.items():\n            if value == 1:\n                return key\n        \n        \n        ## Solution 2\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap of the string s\n        ## 2. Iterate through the string t\n        ## 3. If the character is not in the hashmap, add it to the hashmap\n        ## 4. If the character is in the hashmap, decrement the count\n        ## 5. Return the character that has a count of 1\n        \n        hashmap = {}\n        \n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        for char in t:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] -= 1\n        \n        for key, value in hashmap.items():\n            if value == 1:\n                return key"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_space(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        return (i,j)\n            return None\n        \n        def is_valid(board, num, pos):\n            # check row\n            for i in range(9):\n                if board[pos[0]][i] == num and pos[1] != i:\n                    return False\n            \n            # check column\n            for i in range(9):\n                if board[i][pos[1]] == num and pos[0] != i:\n                    return False\n            \n            # check box\n            box_x = pos[0] // 3\n            box_y = pos[1] // 3\n            \n            for i in range(box_x * 3, box_x * 3 + 3):\n                for j in range(box_y * 3, box_y * 3 + 3):\n                    if board[i][j] == num and (i,j) != pos:\n                        return False\n            \n            return True\n        \n        def solve(board):\n            empty = find_empty_space(board)\n            if empty is None:\n                return True\n            \n            for i in range(1,10):\n                if is_valid(board, str(i), empty):\n                    board[empty[0]][empty[1]] = str(i)\n                    \n                    if solve(board):\n                        return True\n                    \n                    board[empty[0]][empty[1]] = '.'\n            \n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        if i * i == num:\n            return True\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        \n        arr = [0,1,1]\n        for i in range(3,n+1):\n            if i%2 == 0:\n                arr.append(arr[i//2])\n            else:\n                arr.append(arr[i//2]+1)\n        return arr"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        # while head.val == val:\n        #     head = head.next\n        #     if head is None:\n        #         return None\n        # curr = head\n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        if head is None:\n            return None\n        head.next = self.removeElements(head.next, val)\n        return head.next if head.val == val else head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i == '' or i == '.':\n                continue\n            else:\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = 1\n            else:\n                s_dict[s[i]] += 1\n            \n            if t[i] not in t_dict:\n                t_dict[t[i]] = 1\n            else:\n                t_dict[t[i]] += 1\n        \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            else:\n                if s_dict[key] != t_dict[key]:\n                    return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. check rows\n        for row in board:\n            if len(set(row)) != 9:\n                return False\n        \n        # 2. check columns\n        for col in range(9):\n            if len(set([board[row][col] for row in range(9)])) != 9:\n                return False\n        \n        # 3. check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if len(set([board[i+k][j+l] for k in range(3) for l in range(3)])) != 9:\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            temp1, temp2 = first.next, second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping of pattern to words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the mapping, add it\n            if pattern[i] not in mapping:\n                mapping[pattern[i]] = words[i]\n            # if the pattern is in the mapping, check if the word is not the same as the word in the mapping\n            elif mapping[pattern[i]] != words[i]:\n                return False\n        \n        # if all the words are mapped, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result list\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop until both lists are empty\n        while l1 or l2:\n            # If both lists are empty, set the value to 0\n            if not l1 and not l2:\n                current.next = ListNode(0)\n                break\n            # If only l1 is empty, set the value to 0\n            elif not l1:\n                current.next = ListNode(0)\n                break\n            # If only l2 is empty, set the value to 0\n            elif not l2:\n                current.next = ListNode(0)\n                break\n            # Add the values of the two lists\n            else:\n                value = l1.val + l2.val + carry\n                # If the value is greater than 10, set the carry to 1\n                if value > 9:\n                    carry = 1\n                    value = value - 10\n                # If the value is less than 10, set the carry to 0\n                else:\n                    carry = 0\n                # Set the value of the current node to the value\n                current.next = ListNode(value)\n                # Move to the next node\n                current = current.next\n                # Move to the next node\n                l1 = l1.next\n                l2 = l2.next\n        # Return the result list\n        return result.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Convert the number to binary\n        binary_num = bin(num)[2:]\n        \n        ## 2. Reverse the binary number\n        binary_num = binary_num[::-1]\n        \n        ## 3. Convert the binary number to decimal\n        decimal_num = int(binary_num, 2)\n        \n        ## 4. Return the complement\n        return decimal_num"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums)-2:\n            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            line = []\n            line_len = 0\n            while i < len(words) and line_len + len(words[i]) + len(line) <= maxWidth:\n                line.append(words[i])\n                line_len += len(words[i])\n                i += 1\n            if i == len(words):\n                res.append(' '.join(line) + ' ' * (maxWidth - len(line) - len(line) + 1))\n            else:\n                if len(line) == 1:\n                    res.append(line[0] + ' ' * (maxWidth - len(line[0])))\n                else:\n                    num_spaces = maxWidth - len(line) - len(line) + 1\n                    num_spaces_per_word = num_spaces // (len(line) - 1)\n                    num_extra_spaces = num_spaces % (len(line) - 1)\n                    res.append(' '.join(line[0:num_extra_spaces + 1] + [' ' * num_spaces_per_word] * (len(line) - 1)))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def isConcatenated(word, wordDict):\n            if word in wordDict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in wordDict and right in wordDict:\n                    return True\n            return False\n        \n        wordDict = set(words)\n        res = []\n        for word in words:\n            if isConcatenated(word, wordDict):\n                res.append(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    count += backtrack(board, row + 1)\n                    board[row][col] = '.'\n            return count\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        return backtrack(board, 0)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max1 = max2 = max3 = float('-inf')\n        \n        for num in nums:\n            if num > max1:\n                max3 = max2\n                max2 = max1\n                max1 = num\n            elif num > max2:\n                max3 = max2\n                max2 = num\n            elif num > max3:\n                max3 = num\n                \n        return max3 if max3 != float('-inf') else max1"}]}