{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left = 0\n        right = n - 1\n        top = 0\n        bottom = m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = d"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left = 0\n        right = len(numbers) - 1\n\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n\n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, curr, prev):\n            if not num:\n                if curr == target:\n                    res.append(op)\n                return\n            for i in range(1, len(num)+1):\n                if i == 1 or (num[0] != '0' and i != 1):\n                    curr = int(num[:i])\n                    if not op:\n                        backtrack(num[i:], target, num[:i], res, curr, curr)\n                    else:\n                        backtrack(num[i:], target, op + '+' + num[:i], res, curr, curr + prev)\n                        backtrack(num[i:], target, op + '-' + num[:i], res, -curr, curr - prev)\n                        backtrack(num[i:], target, op + '*' + num[:i], res, prev * curr, curr * prev)\n        \n        res = []\n        backtrack(num, target, '', res, 0, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        res = ''\n        i = n - k\n        while i >= 0:\n            res = s[i:i-k:-k] + '-' + res\n            i -= k\n        return res[:-1]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        if total_gas < total_cost:\n            return -1\n        \n        start = 0\n        curr_gas = 0\n        for i in range(len(gas)):\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                start = i + 1\n                curr_gas = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j] for k in range(i+1, j))\n\n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we need to add 1 to the next digit\n        # if the last digit is 9, then we"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace(\"*\",\"\"):\n            return not s\n        \n        i = 0\n        j = 0\n        star = -1\n        m = len(s)\n        n = len(p)\n        \n        while i < m:\n            if j < n and (s[i] == p[j] or p[j] == \".\"):\n                i += 1\n                j += 1\n            elif p[j] == \"*\":\n                star = j\n                j += 1\n            elif star != -1:\n                j = star + 1\n                i -= 1\n                i += 1\n            else:\n                return False\n        \n        while j < n and p[j] == \"*\":\n            j += 1\n        \n        return j == n"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def find_max_subarray(nums, k):\n            stack = []\n            for num in nums:\n                while stack and stack[-1] < num and len(stack) + len(nums) - len(stack) > k:\n                    stack.pop()\n                if stack and stack[-1] == num:\n                    continue\n                stack.append(num)\n            return stack\n        \n        if len(nums1) < k:\n            return nums2[:k]\n        if len(nums2) < k:\n            return nums1[:k]\n        \n        max_subarray1 = find_max_subarray(nums1, k)\n        max_subarray2 = find_max_subarray(nums2, k)\n        \n        res = []\n        i, j = 0, 0\n        while i < len(max_subarray1) and j < len(max_subarray2):\n            if max_subarray1[i] > max_subarray2[j]:\n                res.append(max_subarray1[i])\n                i += 1\n            else:\n                res.append(max_subarray2[j])\n                j += 1\n        \n        res += max_subarray1[i:]\n        res += max_subarray2[j:]\n        \n        return res"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                sum += i + num // i\n            i += 1\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count, left_ptr = 0, 0\n            for right_ptr in range(len(nums)):\n                while nums[right_ptr] - nums[left_ptr] > mid:\n                    left_ptr += 1\n                count += right_ptr - left_ptr\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a','e','i','o','u','A','E','I','O','U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list)-1\n        while left < right:\n            if s_list[left] in vowels:\n                while s_list[right] not in vowels and right > left:\n                    right -= 1\n                if s_list[right] in vowels:\n                    s_list[left], s_list[right] = s_list[right], s_list[left]\n                    left += 1\n                    right -= 1\n            else:\n                left += 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        longest_streak = 0\n\n        for num in nums:\n            if (num - 1) not in nums_set:\n                current_num = num\n                current_streak = 1\n\n                while (current_num + 1) in nums_set:\n                    current_num += 1\n                    current_streak += 1\n\n                longest_streak = max(longest_streak, current_streak)\n\n        return longest_streak"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR\n        # 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 ^ 24 ^ 25 ^ 26 ^ 27 ^ 28 ^ 29 ^ 30 ^ 31 ^ 32 ^ 33 ^ 34 ^ 35 ^ 36 ^ 37 ^ 38 ^ 39 ^ 40 ^ 41 ^ 42 ^ 43 ^ 44 ^ 45 ^ 46 ^ 47 ^ 48 ^ 49 ^ 50 ^ 51 ^ 52 ^ 53 ^ 54 ^ 55 ^ 56 ^ 57 ^ 58 ^ 59 ^ 60 ^ 61 ^ 62 ^ 63 ^ 64 ^ 65 ^ 66 ^ 67 ^ 68 ^ 69 ^ 70 ^ 71 ^ 72 ^ 73 ^ 74 ^ 75 ^ 76 ^ 77 ^ 78 ^ 79 ^ 80 ^ 81 ^ 82 ^ 83 ^ 84 ^ 85 ^ 86 ^ 87 ^ 88 ^ 89 ^ 90 ^ 91 ^ 92 ^ 93 ^ 94 ^ 95 ^ 96 ^ 97 ^ 98 ^ 99\n        \n        # XOR\n        # 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 ^ 24 ^ 25 ^ 26 ^ 27 ^ 28 ^ 29 ^ 30 ^ 31 ^ 32 ^ 33 ^ 34 ^ 35 ^ 36 ^ 37 ^ 38 ^ 39 ^ 40 ^ 41 ^ 42 ^ 43 ^ 44 ^ 45 ^ 46 ^ 47 ^ 48 ^ 49 ^ 50 ^ 51 ^ 52 ^ 53 ^ 54 ^ 55 ^ 56 ^ 57 ^ 58 ^ 59 ^ 60 ^ 61 ^ 62 ^ 63 ^ 64 ^ 65 ^ 66 ^ 67 ^ 68 ^ 69 ^ 70 ^ 71 ^ 72 ^ 73 ^ 74 ^ 75 ^ 76 ^ 77 ^ 78 ^ 79 ^ 80 ^ 81 ^ 82 ^ 83 ^ 84 ^ 85 ^ 86 ^ 87 ^ 88 ^ 89 ^ 90 ^ 91 ^ 92 ^ 93 ^ 94 ^ 95 ^ 96 ^ 97 ^ 98 ^ 99\n        \n        # XOR\n        # 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 ^ 24 ^ 25 ^ 26 ^ 27 ^ 28 ^ 29 ^ 30 ^ 31 ^ 32 ^ 33 ^ 34 ^ 35 ^ 36 ^ 37 ^ 38 ^ 39 ^ 40 ^ 41 ^ 42 ^ 43 ^ 44 ^ 45 ^ 46 ^ 47 ^ 48 ^ 49 ^ 50 ^ 51 ^ 52 ^ 53 ^ 54 ^ 55 ^ 56 ^"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # Create a set of words from the wordList\n        wordSet = set(wordList)\n        \n        # Check if endWord is in the wordSet\n        if endWord not in wordSet:\n            return 0\n        \n        # Create a queue to store the words to be checked\n        queue = collections.deque([beginWord])\n        \n        # Create a set to store the words that have already been checked\n        visited = set()\n        \n        # Create a variable to store the number of steps\n        steps = 1\n        \n        # Loop until the queue is empty\n        while queue:\n            # Loop through the number of words in the queue\n            for _ in range(len(queue)):\n                # Pop the first word from the queue\n                word = queue.popleft()\n                \n                # Check if the word is the endWord\n                if word == endWord:\n                    return steps\n                \n                # Loop through the letters in the word\n                for i in range(len(word)):\n                    # Loop through the letters in the alphabet\n                    for letter in string.ascii_lowercase:\n                        # Check if the letter is the same as the current letter\n                        if word[i] == letter:\n                            continue\n                        \n                        # Create a new word with the letter replaced\n                        newWord = word[:i] + letter + word[i+1:]\n                        \n                        # Check if the new word is in the wordSet\n                        if newWord in wordSet:\n                            # Check if the new word has already been visited\n                            if newWord not in visited:\n                                # Add the new word to the queue\n                                queue.append(newWord)\n                                # Add the new word to the set of visited words\n                                visited.add(newWord)\n            \n            # Increment the number of steps\n            steps += 1\n        \n        # Return 0 if the endWord is not in the wordSet\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = \"\"\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        \n        if carry == 1:\n            res += \"1\"\n        \n        return res[::-1]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return [-1,-1]\n        \n        left = 0\n        right = len(nums)-1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        if nums[left] != target:\n            return [-1,-1]\n        \n        left = 0\n        right = len(nums)-1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        \n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n            j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return 0\n        \n        # if nums[0] == 0:\n        #     return -1\n        \n        # if nums[0] >= len(nums) - 1:\n        #     return 1\n        \n        # max_reach = nums[0]\n        # jumps = 1\n        # curr_reach = 0\n        \n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return -1\n            \n        #     max_reach = max(max_reach, i + nums[i])\n            \n        #     if i == curr_reach:\n        #         jumps += 1\n        #         curr_reach = max_reach\n        \n        # return jumps\n        \n        # # if len(nums) == 1:\n        # #     return 0\n        \n        # # if nums[0] == 0:\n        # #     return -1\n        \n        # # if nums[0] >= len(nums) - 1:\n        # #     return 1\n        \n        # # max_reach = nums[0]\n        # # jumps = 1\n        # # curr_reach = 0\n        \n        # # for i in range(1, len(nums)):\n        # #     if i > max_reach:\n        # #         return -1\n            \n        # #     max_reach = max(max_reach, i + nums[i])\n            \n        # #     if i == curr_reach:\n        # #         jumps += 1\n        # #         curr_reach = max_reach\n        \n        # # return jumps\n        \n        # if len(nums) == 1:\n        #     return 0\n        \n        # if nums[0] == 0:\n        #     return -1\n        \n        # max_reach = nums[0]\n        # jumps = 1\n        # curr_reach = 0\n        \n        # for i in range(1, len(nums)):\n            # if i > max_reach:\n            #     return -1\n            \n            # max_reach = max(max_reach, i + nums[i])\n            \n            # if i == curr_reach:\n            #     jumps += 1\n            #     curr_reach = max_reach\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(map(lambda x: x[1]-x[0], zip(prices, prices[1:])))\n        \n        dp = [0]*k\n        for price in prices:\n            for i in range(k-1, 0, -1):\n                dp[i] = max(dp[i], dp[i-1]+price)\n            dp[0] = max(dp[0], -price)\n        return dp[k-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_str = \"\"\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_str = str(remainder) + hex_str\n            else:\n                hex_str = hex_dict[remainder] + hex_str\n            num = num // 16\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to store the index of each character in the string\n        # iterate through the string and update the hashmap\n        # if the character is not in the hashmap, add it\n        # if the character is in the hashmap, update the frequency and set the index to -1\n        # iterate through the hashmap and return the index of the first non-repeating character\n        # if there is no non-repeating character, return -1\n        \n        # create a hashmap to store the frequency of each character in the string\n        # create a hashmap to"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0 or valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff != 0:\n        #     return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0 or valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff != 0:\n        #     return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0 or valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff != 0:\n        #     return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0 or valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff != 0:\n        #     return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0 or valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff != 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff != 0 and valueDiff != 0:\n        #     return False\n        \n        # if len(nums) < 2:\n        #"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        if left == right:\n            return (1 << left) + right\n        else:\n            return (1 << right) + left"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = ''\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                res += sign*num\n                if s[i] == '+':\n                    sign = 1\n                elif s[i] == '-':\n                    sign = -1\n                num = 0\n            if s[i] == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            if s[i] == ')':\n                res = stack.pop()*res + stack.pop()\n        return res"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] <= 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we can do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0, then we cannot do this project\n        # if profits[i] - capital[i] = 0,"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        d = {\n            '(': ')',\n            '{': '}',\n            '[': ']',\n        }\n\n        for c in s:\n            if c in d:\n                stack.append(c)\n            elif not stack or d[stack.pop()] != c:\n                return False\n\n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it and return it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater than the number found\n        # swap the two numbers\n        # reverse the numbers after the index\n        # return the array\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number, then the array is in descending order, so reverse it\n        # if no such number, then the array is in ascending order, so return it\n        # if the number is found, then find the index of the number that is just greater"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n\n        # Create a dictionary to store the number and its index\n        # If the number is already in the dictionary, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the dictionary\n        # If the dictionary is empty, return False\n\n        # Create a dictionary to store the number and its index\n        nums_dict = {}\n\n        # Iterate through the list of numbers\n        for i, num in enumerate(nums):\n            # If the number is already in the dictionary, check if the index is within the range of k\n            if num in nums_dict and i - nums_dict[num] <= k:\n                return True\n            # If it is not, add the number to the dictionary\n            nums_dict[num] = i\n\n        # If the dictionary is empty, return False\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n            queue = queue[len(level):]\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        # 1. \u5efa\u7acb\u6620\u5c04\u5173\u7cfb\n        # 2. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u4eba\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 3. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5ea7\u4f4d\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 4. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5ea7\u4f4d\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 5. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 6. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 7. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 8. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 9. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 10. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 11. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 12. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 13. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 14. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 15. \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5ea7\u4f4d\n        # 16. \u904d\u5386\u6620\u5c04\u5173\u7cfb\uff0c\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9\u5e94\u7684\u5bf9"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if s1 == s3 or s2 == s3:\n            return True\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        res = []\n        for word in words:\n            if word[0].lower() in row1:\n                if set(word.lower()) <= row1:\n                    res.append(word)\n            elif word[0].lower() in row2:\n                if set(word.lower()) <= row2:\n                    res.append(word)\n            else:\n                if set(word.lower()) <= row3:\n                    res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next or left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        for _ in range(left - 1):\n            prev = curr\n            curr = curr.next\n        \n        prev.next = None\n        tail = curr\n        \n        while right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            right -= 1\n        \n        tail.next = curr\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed string to the end of the original string\n        # return the reversed string\n        \n        # find the longest palindrome that is a prefix of the reversed string\n        # find the longest palindrome that is a suffix of the reversed string\n        # add the reversed"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        # create a hashmap to store the frequency of each character in t\n        # and a hashmap to store the frequency of each character in s\n        # if the character is not in t, then it is not in s\n        # if the character is in t, then it is in s\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is in t\n        # if the character is in s, then it is"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            if i >= 4 and distance[i] == distance[i-4] and distance[i-1] == distance[i-3]:\n                return True\n            if i >= 5 and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] == distance[i-3]:\n                return True\n            if i >= 6 and distance[i] + distance[i-4] >= distance[i-2] and distance[i-1] + distance[i-5] >= distance[i-3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a hashmap to store the frequency of each character in the string\n        hashmap = {}\n        for char in s:\n            if char in hashmap:\n                hashmap[char] += 1\n            else:\n                hashmap[char] = 1\n        \n        # Initialize the length of the longest palindrome to 0\n        longest_palindrome = 0\n        \n        # Iterate through the hashmap and check if the frequency is odd\n        for char, frequency in hashmap.items():\n            if frequency % 2 == 0:\n                longest_palindrome += frequency\n            else:\n                longest_palindrome += frequency - 1\n        \n        # If the length of the string is odd, add 1 to the longest palindrome\n        if len(s) % 2 == 1:\n            longest_palindrome += 1\n        \n        return longest_palindrome"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find all the trees in the forest\n        # 2. Sort the trees by height\n        # 3. Start from the top left corner and walk to the next tree\n        # 4. Keep track of the number of steps taken\n        # 5. If the tree is not reachable, return -1\n        \n        # 1. Find all the trees in the forest\n        trees = []\n        for row in forest:\n            for tree in row:\n                if tree > 1:\n                    trees.append((tree, row.index(tree), row.index(tree)))\n        \n        # 2. Sort the trees by height\n        trees.sort()\n        \n        # 3. Start from the top left corner and walk to the next tree\n        # 4. Keep track of the number of steps taken\n        # 5. If the tree is not reachable, return -1\n        steps = 0\n        current_position = (0, 0)\n        for tree, x, y in trees:\n            steps += self.bfs(forest, current_position, (x, y))\n            if steps == -1:\n                return -1\n            current_position = (x, y)\n        \n        return steps\n        \n    def bfs(self, forest, start, end):\n        # Breadth-first search\n        # Use a queue to keep track of the positions to visit\n        # Use a set to keep track of visited positions\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        # Use a set to keep track of positions that have already been visited\n        #"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc811\ub450\uc0ac \ud569 \uacc4\uc0b0\n        # 2. \uc811\ub450\uc0ac \ud569\uc744 \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 3. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 4. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 5. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 6. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 7. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 8. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 9. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 10. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 11. \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uc774\uc6a9\ud574 \uc815\ub82c\ub41c \ubc30\uc5f4\uc5d0\uc11c \uc811\ub450\uc0ac \ud569\uc758 \uac1c\uc218\ub97c \uad6c\ud55c"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((-1 + sqrt(1 + 8 * n)) / 2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n            result.append(temp)\n        \n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        temp = x\n        rev = 0\n        while temp:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        return rev == x"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2^n - 1\n        # 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for word in wordDict:\n                if s[i - len(word):i] == word:\n                    dp[i] = dp[i - len(word)]\n                if dp[i]:\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not overlapping with any interval\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval is overlapping with last interval\n        if newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # if newInterval is overlapping with first interval\n        if newInterval[0] <= intervals[0][0]:\n            intervals[0][0] = newInterval[0]\n            return intervals\n        \n        # if newInterval is overlapping with any interval\n        i = 0\n        while i < len(intervals):\n            if newInterval[0] <= intervals[i][1]:\n                intervals[i][1] = max(intervals[i][1], newInterval[1])\n                return intervals\n            i += 1\n        \n        # if newInterval is not overlapping with any interval\n        intervals.append(newInterval)\n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            \n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    backtrack(s, i+1, path + [s[start:i+1]], res)\n            \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 1000 / 15 = 62.5\n        # 62.5 buckets, 15 minutes to die, 30 minutes to test\n        # 62.5 / 15 = 4.166666666666667\n        # 4.166666666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 4.166666666666667 / 15 = 2.5833333333333335\n        # 2.5833333333333335 buckets, 15 minutes to die, 30 minutes to test\n        # 2.5833333333333335 / 15 = 1.7916666666666667\n        # 1.7916666666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 1.7916666666666667 / 15 = 1.4166666666666667\n        # 1.4166666666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 1.4166666666666667 / 15 = 1.2583333333333334\n        # 1.2583333333333334 buckets, 15 minutes to die, 30 minutes to test\n        # 1.2583333333333334 / 15 = 1.1791666666666667\n        # 1.1791666666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 1.1791666666666667 / 15 = 1.1416666666666667\n        # 1.1416666666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 1.1416666666666667 / 15 = 1.1258333333333334\n        # 1.1258333333333334 buckets, 15 minutes to die, 30 minutes to test\n        # 1.1258333333333334 / 15 = 1.1179166666666667\n        # 1.1179166666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 1.1179166666666667 / 15 = 1.1141666666666667\n        # 1.1141666666666667 buckets, 15 minutes to die, 30 minutes to test\n        # 1.1141666666666667 / 15 = 1.1125833333333334\n        # 1.1125833333333334 buckets, 15 minutes to die, 30 minutes to test\n        # 1.1125833333333334 / 15 = 1.1117916666666667\n        # 1.1117916666666"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # Binary search for the minimum time\n        left, right = 0, n * n - 1\n        while left < right:\n            mid = (left + right) // 2\n            if self.is_possible(grid, mid, n):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n        \n    def is_possible(self, grid, time, n):\n        # BFS to check if it is possible to swim in time\n        visited = set()\n        q = [(0, 0)]\n        visited.add((0, 0))\n        while q:\n            r, c = q.pop(0)\n            if r == n - 1 and c == n - 1:\n                return True\n            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nr, nc = r + dr, c + dc\n                if nr < 0 or nr >= n or nc < 0 or nc >= n or (nr, nc) in visited:\n                    continue\n                if grid[nr][nc] <= time:\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n        return False"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                res[i+j+1] += res[i+j] // 10\n                res[i+j] = res[i+j] % 10\n        \n        res = res[::-1]\n        res = [str(x) for x in res if x != 0]\n        return \"\".join(res)"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # left = 0\n        # right = 1\n        # max_profit = 0\n        # while right < len(prices):\n        #     if prices[left] < prices[right]:\n        #         max_profit = max(max_profit, prices[right] - prices[left])\n        #     else:\n        #         left = right\n        #         right += 1\n        # return max_profit\n\n        # if len(prices) < 2:\n        #     return 0\n\n        # left = 0\n        # right = 1\n        # max_profit = 0\n        # while right < len(prices):\n        #     if prices[left] < prices[right]:\n        #         max_profit += prices[right] - prices[left]\n        #         left = right\n        #     right += 1\n        # return max_profit\n\n        # if len(prices) < 2:\n        #     return 0\n\n        # left = 0\n        # right = 1\n        # max_profit = 0\n        # while right < len(prices):\n        #     if prices[left] < prices[right]:\n        #         max_profit += prices[right] - prices[left]\n        #         left = right\n        #     right += 1\n        # return max_profit\n\n        if len(prices) < 2:\n            return 0\n\n        left = 0\n        right = 1\n        max_profit = 0\n        while right < len(prices):\n            if prices[left] < prices[right]:\n                max_profit += prices[right] - prices[left]\n                left = right\n            right += 1\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, index, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(index, len(candidates)):\n            if i > index and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # We use a stack to keep track of the nodes we have visited\n        # We start by pushing the root node to the stack\n        # We then keep popping the stack until it is empty\n        # We then push the left child of the popped node to the stack\n        # We then push the right child of the popped node to the stack\n        # We then repeat this process until the stack is empty\n        # We return the list of values\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            result.append(node.val)\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        inorder_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:inorder_index+1], inorder[:inorder_index])\n        root.right = self.buildTree(preorder[inorder_index+1:], inorder[inorder_index+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6700\u5c11\u7684\u5220\u9664\u6b21\u6570\n        # 2. \u627e\u5230\u6240\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u4e32\n        # 3. \u8fd4\u56de\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        # 5. \u8fd4\u56de\u7ed3\u679c\n        # 6. \u8fd4\u56de\u7ed3\u679c\n        # 7. \u8fd4\u56de\u7ed3\u679c\n        # 8. \u8fd4\u56de\u7ed3\u679c\n        # 9. \u8fd4\u56de\u7ed3\u679c\n        # 10. \u8fd4\u56de\u7ed3\u679c\n        # 11. \u8fd4\u56de\u7ed3\u679c\n        # 12. \u8fd4\u56de\u7ed3\u679c\n        # 13. \u8fd4\u56de\u7ed3\u679c\n        # 14. \u8fd4\u56de\u7ed3\u679c\n        # 15. \u8fd4\u56de\u7ed3\u679c\n        # 16. \u8fd4\u56de\u7ed3\u679c\n        # 17. \u8fd4\u56de\u7ed3\u679c\n        # 18. \u8fd4\u56de\u7ed3\u679c\n        # 19. \u8fd4\u56de\u7ed3\u679c\n        # 20. \u8fd4\u56de\u7ed3\u679c\n        # 21. \u8fd4\u56de\u7ed3\u679c\n        # 22. \u8fd4\u56de\u7ed3\u679c\n        # 23. \u8fd4\u56de\u7ed3\u679c\n        # 24. \u8fd4\u56de\u7ed3\u679c\n        # 25. \u8fd4\u56de\u7ed3\u679c\n        # 26. \u8fd4\u56de\u7ed3\u679c\n        # 27. \u8fd4\u56de\u7ed3\u679c\n        # 28. \u8fd4\u56de\u7ed3\u679c\n        # 29. \u8fd4\u56de\u7ed3\u679c\n        # 30. \u8fd4\u56de\u7ed3\u679c\n        # 31. \u8fd4\u56de\u7ed3\u679c\n        # 32. \u8fd4\u56de\u7ed3\u679c\n        # 33. \u8fd4\u56de\u7ed3\u679c\n        # 34. \u8fd4\u56de\u7ed3\u679c\n        # 35. \u8fd4\u56de\u7ed3\u679c\n        # 36. \u8fd4\u56de\u7ed3\u679c\n        # 37. \u8fd4\u56de\u7ed3\u679c\n        # 38. \u8fd4\u56de\u7ed3\u679c\n        # 39. \u8fd4\u56de\u7ed3\u679c\n        # 40. \u8fd4\u56de\u7ed3\u679c\n        # 41. \u8fd4\u56de\u7ed3\u679c\n        # 42. \u8fd4\u56de\u7ed3\u679c\n        # 43. \u8fd4\u56de\u7ed3\u679c\n        # 44. \u8fd4\u56de\u7ed3\u679c\n        # 45. \u8fd4\u56de\u7ed3\u679c\n        # 46. \u8fd4\u56de\u7ed3\u679c\n        # 47. \u8fd4\u56de\u7ed3\u679c\n        # 48. \u8fd4\u56de\u7ed3\u679c\n        # 49. \u8fd4\u56de\u7ed3\u679c\n        # 50. \u8fd4\u56de\u7ed3\u679c\n        # 51. \u8fd4\u56de\u7ed3\u679c\n        # 52. \u8fd4\u56de\u7ed3\u679c\n        # 53. \u8fd4\u56de\u7ed3\u679c\n        # 54. \u8fd4\u56de\u7ed3\u679c\n        # 55. \u8fd4\u56de\u7ed3\u679c\n        # 56. \u8fd4\u56de\u7ed3\u679c\n        # 57. \u8fd4\u56de\u7ed3\u679c\n        # 58. \u8fd4\u56de\u7ed3\u679c\n        # 59. \u8fd4\u56de\u7ed3\u679c\n        # 60. \u8fd4\u56de\u7ed3\u679c\n        # 61. \u8fd4\u56de\u7ed3\u679c\n        # 62. \u8fd4\u56de\u7ed3\u679c\n        # 63. \u8fd4\u56de\u7ed3\u679c\n        # 64. \u8fd4\u56de\u7ed3\u679c\n        # 65. \u8fd4\u56de\u7ed3\u679c\n        # 66. \u8fd4\u56de\u7ed3\u679c\n        # 67. \u8fd4\u56de\u7ed3\u679c\n        # 68. \u8fd4\u56de\u7ed3\u679c\n        # 69. \u8fd4\u56de\u7ed3\u679c\n        # 70. \u8fd4\u56de\u7ed3\u679c\n        # 71. \u8fd4\u56de\u7ed3\u679c\n        # 72. \u8fd4\u56de\u7ed3\u679c\n        # 73. \u8fd4\u56de\u7ed3\u679c\n        # 74. \u8fd4\u56de\u7ed3\u679c\n        # 75. \u8fd4\u56de\u7ed3\u679c\n        # 76. \u8fd4\u56de\u7ed3\u679c\n        # 77. \u8fd4\u56de\u7ed3\u679c\n        # 78. \u8fd4\u56de\u7ed3\u679c\n        # 79. \u8fd4\u56de\u7ed3\u679c\n        # 80. \u8fd4\u56de\u7ed3\u679c\n        # 81. \u8fd4\u56de\u7ed3\u679c\n        # 82. \u8fd4\u56de\u7ed3\u679c\n        # 83. \u8fd4\u56de\u7ed3\u679c\n        # 84. \u8fd4\u56de\u7ed3\u679c\n        # 85. \u8fd4\u56de\u7ed3\u679c\n        # 86. \u8fd4\u56de\u7ed3\u679c\n        # 87. \u8fd4\u56de\u7ed3\u679c\n        # 88. \u8fd4\u56de\u7ed3\u679c\n        # 89. \u8fd4\u56de\u7ed3\u679c\n        # 90. \u8fd4\u56de\u7ed3\u679c\n        # 91. \u8fd4\u56de\u7ed3\u679c\n        # 92. \u8fd4\u56de\u7ed3\u679c\n        # 93. \u8fd4\u56de\u7ed3\u679c\n        #"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        return self.mergeTwoLists(left, right)"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) if s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 1) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] != s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j] == s[i-1]\n        # dp[i] = min(dp[j] + 1, dp[j] + 2) if s[j:i] is palindrome and s[j"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 10^18 = 10^9 * 10^9\n        # 10^9 = 10^18 * 10^9\n        # 1"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n\n        # Create a hashmap to store the reverse of each word\n        # and its index\n        reverse_map = {}\n        for i, word in enumerate(words):\n            reverse_map[word[::-1]] = i\n\n        # Create a list to store the result\n        result = []\n\n        # Iterate over the words\n        for i, word in enumerate(words):\n            # If the word is empty, add it to the result\n            if not word:\n                result.append([i, i])\n                continue\n\n            # Check if the reverse of the word is in the hashmap\n            # If it is, check if the reverse of the word is the same as the word\n            # If it is, add the index of the word to the result\n            # If it is not, add the index of the reverse of the word to the result\n            if word[::-1] in reverse_map:\n                if word[::-1] == word:\n                    result.append([i, reverse_map[word[::-1]]])\n                else:\n                    result.append([i, reverse_map[word[::-1]]])\n                    result.append([reverse_map[word[::-1]], i])\n\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            node = TreeNode(nums[mid])\n            node.left = helper(left, mid - 1)\n            node.right = helper(mid + 1, right)\n            return node\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\""}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            \n            if i > 0 and matrix[i][j] < matrix[i - 1][j]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(i - 1, j))\n            \n            if i < m - 1 and matrix[i][j] < matrix[i + 1][j]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(i + 1, j))\n            \n            if j > 0 and matrix[i][j] < matrix[i][j - 1]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(i, j - 1))\n            \n            if j < n - 1 and matrix[i][j] < matrix[i][j + 1]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(i, j + 1))\n            \n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += n // i * i + max(0, n % i - i + 1)\n            i *= 10\n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        leftToRight = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not leftToRight:\n                level.reverse()\n            result.append(level)\n            leftToRight = not leftToRight\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hours(n):\n            if n == 0:\n                return []\n            if n == 1:\n                return [\"1:00\"]\n            if n == 2:\n                return [\"2:00\",\"4:00\",\"8:00\"]\n            if n == 3:\n                return [\"5:00\",\"10:00\",\"16:00\",\"32:00\"]\n            if n == 4:\n                return [\"6:00\",\"12:00\",\"18:00\",\"36:00\"]\n            if n == 5:\n                return [\"10:01\",\"10:02\",\"10:04\",\"10:08\",\"10:16\",\"10:32\",\"10:48\",\"10:64\",\"10:80\",\"10:96\",\"10:112\",\"10:128\",\"10:144\",\"10:160\",\"10:176\",\"10:192\",\"10:208\",\"10:224\",\"10:240\",\"10:256\",\"10:272\",\"10:288\",\"10:304\",\"10:320\",\"10:336\",\"10:352\",\"10:368\",\"10:384\",\"10:400\",\"10:416\",\"10:432\",\"10:448\",\"10:464\",\"10:480\",\"10:496\",\"10:512\",\"10:528\",\"10:544\",\"10:560\",\"10:576\",\"10:592\",\"11:008\",\"11:024\",\"11:040\",\"11:056\",\"11:072\",\"11:088\",\"11:104\",\"11:120\",\"11:136\",\"11:152\",\"11:168\",\"11:184\",\"11:200\",\"11:216\",\"11:232\",\"11:248\",\"11:264\",\"11:280\",\"11:296\",\"11:312\",\"11:328\",\"11:344\",\"11:360\",\"11:376\",\"11:392\",\"11:408\",\"11:424\",\"11:440\",\"11:456\",\"11:472\",\"11:488\",\"11:504\",\"11:520\",\"11:536\",\"11:552\",\"11:568\",\"11:584\",\"11:600\",\"11:616\",\"11:632\",\"11:648\",\"11:664\",\"11:680\",\"11:696\",\"11:712\",\"11:728\",\"11:744\",\"11:760\",\"11:776\",\"11:792\",\"11:808\",\"11:824\",\"11:840\",\"11:856\",\"11:872\",\"11:888\",\"11:904\",\"11:920\",\"11:936\",\"11:952\",\"11:968\",\"11:984\",\"11:1000\",\"11:1016\",\"11:1032\",\"11:1048\",\"11:1064\",\"11:1080\",\"11:1096\",\"11:1112\",\"11:1128\",\"11:1144\",\"11:1160\",\"11:1176\",\"11:1192\",\"11:1208\",\"11:1224\",\"11:1240\",\"11:1256\",\"11:1272\",\"11:1288\",\"11:1304\",\"11:1320\",\"11:13"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n < 0:\n            return False\n        if n % 3 != 0:\n            return False\n        return self.isPowerOfThree(n//3)"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left_gain + right_gain + node.val)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            heapq.heappush(heap, (heightMap[i][0], i, 0))\n            heapq.heappush(heap, (heightMap[i][n-1], i, n-1))\n            visited.add((i, 0))\n            visited.add((i, n-1))\n        \n        for j in range(1, n-1):\n            heapq.heappush(heap, (heightMap[0][j], 0, j))\n            heapq.heappush(heap, (heightMap[m-1][j], m-1, j))\n            visited.add((0, j))\n            visited.add((m-1, j))\n        \n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    res += max(h-heightMap[ni][nj], 0)\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n                    visited.add((ni, nj))\n        \n        return res"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n\n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n\n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \uc800\uc7a5\ud558\uae30\n        # 4. \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud558\uae30\n        # 5. \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc911\uac04\uac12 \uc81c\uac70\ud55c \ufffd"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head and new tail\n        new_head = head\n        new_tail = head\n        k = k % length\n        if k == 0:\n            return head\n        \n        # find the new tail\n        for i in range(1, length - k):\n            new_tail = new_tail.next\n        \n        # reconnect the list\n        new_tail.next = head\n        new_head = new_tail.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            curr_sum = 0\n            prefix_sum = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    prefix_sum[i] += matrix[i][r]\n                curr_sum = max(curr_sum, self.max_subarray_sum(prefix_sum, k))\n                max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        if dividend == -2**31 and divisor == 1:\n            return -2**31\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend/divisor)\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend)/divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend)/abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i,j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(m):\n            dfs(i,0)\n            dfs(i,n-1)\n        \n        for j in range(n):\n            dfs(0,j)\n            dfs(m-1,j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n        \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Create a dictionary to store the complement of each number\n        complement_dict = {}\n\n        # Iterate through the list of numbers\n        for i, num in enumerate(nums):\n            # Check if the complement of the current number is already in the dictionary\n            if num in complement_dict:\n                # Return the indices of the complement and the current number\n                return [complement_dict[num], i]\n            # Add the complement of the current number to the dictionary\n            complement_dict[target - num] = i\n        \n        # If no complement is found, return an empty list\n        return []"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, n):\n            if n == 1:\n                return [cards[0]]\n            res = []\n            for i in range(n):\n                for j in dfs(cards, n-1):\n                    if j[0] != cards[i]:\n                        res.append([j[0]+cards[i], j[1]+i])\n                        res.append([j[0]-cards[i], j[1]+i])\n                        res.append([j[0]*cards[i], j[1]+i])\n                        if cards[i] != 0:\n                            res.append([j[0]/cards[i], j[1]+i])\n            return res\n        \n        return any(24 in j for j in dfs(cards, len(cards)))"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return False\n        \n        # if p is a single character, then s must also be a single character\n        if len(p) == 1:\n            return s == p or p == '*'\n        \n        # if p is a double character, then s must be a double character\n        if p[1] == '*':\n            return self.isMatch(s, p[2:])\n        \n        # if p is a single character, then s must be a single character\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s must be a single character\n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s must be a single character\n        if s[0] == p[0]:\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is a single character, then s must be a single character\n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n\n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = defaultdict(list)\n        for fromi, toi in tickets:\n            graph[fromi].append(toi)\n        \n        # Sort the graph by alphabetical order\n        for fromi in graph:\n            graph[fromi].sort(reverse=True)\n        \n        # DFS to find the itinerary\n        res = []\n        def dfs(fromi):\n            # Base case: if there are no more tickets, return the itinerary\n            if len(graph[fromi]) == 0:\n                return True\n            \n            # DFS to find the next ticket\n            for i in range(len(graph[fromi])-1, -1, -1):\n                toi = graph[fromi][i]\n                graph[fromi].pop(i)\n                if dfs(toi):\n                    res.append(toi)\n                    return True\n            \n            # If no ticket is found, return False\n            return False\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize heap\n        heap = []\n\n        # iterate through buildings\n        for building in buildings:\n            # if building is ending, remove from heap\n            if building[1] < 0:\n                heapq.heappush(heap, (-building[1], building[2]))\n            # if building is starting, add to heap\n            else:\n                heapq.heappush(heap, (building[1], -building[2]))\n\n        # initialize current height\n        current_height = 0\n\n        # iterate through heap\n        while heap:\n            # get next building\n            next_building = heapq.heappop(heap)\n\n            # if next building is ending, add to result\n            if next_building[0] < 0:\n                if -next_building[0] > current_height:\n                    result.append([-next_building[0], next_building[1]])\n                    current_height = -next_building[0]\n            # if next building is starting, add to result\n            else:\n                if next_building[1] > current_height:\n                    result.append([next_building[0], next_building[1]])\n                    current_height = next_building[1]\n\n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            triangle[i][0] += triangle[i-1][0]\n            for j in range(1, len(triangle[i])-1):\n                triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n            triangle[i][-1] += triangle[i-1][-1]\n        \n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Quintillion\", \"Sextillion\", \"Septillion\", \"Octillion\", \"Nonillion\", \"Dekadillion\", \"Undecillion\", \"Duodecillion\", \"Tredecillion\", \"Quattuordecillion\", \"Quindecillion\", \"Sexdecillion\", \"Septendecillion\", \"Octodecillion\", \"Novemdecillion\", \"Vigintillion\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n            if num < 1000000000000000:\n                return helper(num // 1000000000000) + \" Trillion \" + helper(num % 1000000000000)\n            if num < 1000000000000000000:\n                return helper(num // 1000000000000000) + \" Quadrillion \" + helper(num % 1000000000000000)\n            if num < 1000000000000000000000:\n                return helper(num // 1000000000000000000) + \" Quintillion \" + helper(num % 1000000000000000000)\n            if num < 1000000000000000000000000:\n                return helper(num // 1000000000000000000000) + \" Sextillion \" + helper(num % 1000000000000000000000)\n            if num < 1000000000000000000000000000:\n                return helper(num // 100000000000000000000000) + \" Septillion \" + helper(num % 100000000000000000000000)\n            if num < 1000000000000000000000000000000:\n                return helper(num //"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j < i:\n                    dp[i][j] = 0\n                elif j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            next_node = curr.next\n            curr.next = next_node.next\n            next_node.next = curr\n            prev.next = next_node\n            prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        left = ListNode(0)\n        right = ListNode(0)\n        left_head = left\n        right_head = right\n        \n        while head:\n            if head.val < x:\n                left.next = head\n                left = left.next\n            else:\n                right.next = head\n                right = right.next\n            head = head.next\n        \n        left.next = right_head.next\n        right.next = None\n        \n        return left_head.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Find the node with two parents\n        # 2. Find the node with the most edges\n        # 3. Find the edge with the most edges\n        # 4. Return the edge\n        \n        # 1. Find the node with two parents\n        parent = {}\n        child = {}\n        for edge in edges:\n            if edge[0] in parent:\n                child[edge[0]] = edge[1]\n            else:\n                parent[edge[0]] = edge[1]\n        \n        # 2. Find the node with the most edges\n        max_edges = 0\n        most_edges_node = None\n        for node in parent:\n            if parent[node] in child:\n                if max_edges < child[parent[node]]:\n                    most_edges_node = node\n                    max_edges = child[parent[node]]\n            else:\n                if max_edges < parent[node]:\n                    most_edges_node = node\n                    max_edges = parent[node]\n        \n        # 3. Find the edge with the most edges\n        if most_edges_node in parent:\n            return [most_edges_node, parent[most_edges_node]]\n        else:\n            return [most_edges_node, child[most_edges_node]]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        self.backtrack(nums, visited, [], res)\n        return res\n        \n    def backtrack(self, nums, visited, path, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\n                continue\n            visited[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, visited, path, res)\n            visited[i] = False\n            path.pop()"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR\n        # 0 ^ 0 = 0\n        # 0 ^ 1 = 1\n        # 1 ^ 0 = 1\n        # 1 ^ 1 = 0\n        # 2 ^ 2 = 0\n        # 2 ^ 1 = 3\n        # 3 ^ 2 = 1\n        # 3 ^ 1 = 2\n        # 4 ^ 4 = 0\n        # 4 ^ 3 = 1\n        # 5 ^ 5 = 0\n        # 5 ^ 4 = 3\n        # 6 ^ 6 = 0\n        # 6 ^ 5 = 3\n        # 7 ^ 7 = 0\n        # 7 ^ 6 = 3\n        # 8 ^ 8 = 0\n        # 8 ^ 7 = 3\n        # 9 ^ 9 = 0\n        # 9 ^ 8 = 3\n        # 10 ^ 10 = 0\n        # 10 ^ 9 = 3\n        # 11 ^ 11 = 0\n        # 11 ^ 10 = 3\n        # 12 ^ 12 = 0\n        # 12 ^ 11 = 3\n        # 13 ^ 13 = 0\n        # 13 ^ 12 = 3\n        # 14 ^ 14 = 0\n        # 14 ^ 13 = 3\n        # 15 ^ 15 = 0\n        # 15 ^ 14 = 3\n        # 16 ^ 16 = 0\n        # 16 ^ 15 = 3\n        # 17 ^ 17 = 0\n        # 17 ^ 16 = 3\n        # 18 ^ 18 = 0\n        # 18 ^ 17 = 3\n        # 19 ^ 19 = 0\n        # 19 ^ 18 = 3\n        # 20 ^ 20 = 0\n        # 20 ^ 19 = 3\n        # 21 ^ 21 = 0\n        # 21 ^ 20 = 3\n        # 22 ^ 22 = 0\n        # 22 ^ 21 = 3\n        # 23 ^ 23 = 0\n        # 23 ^ 22 = 3\n        # 24 ^ 24 = 0\n        # 24 ^ 23 = 3\n        # 25 ^ 25 = 0\n        # 25 ^ 24 = 3\n        # 26 ^ 26 = 0\n        # 26 ^ 25 = 3\n        # 27 ^ 27 = 0\n        # 27 ^ 26 = 3\n        # 28 ^ 28 = 0\n        # 28 ^ 27 = 3\n        # 29 ^ 29 = 0\n        # 29 ^ 28 = 3\n        # 30 ^ 30 = 0\n        # 30 ^ 29 = 3\n        # 31 ^ 31 = 0\n        # 31 ^ 30 = 3\n        # 32 ^ 32 = 0\n        # 32 ^ 31 = 3\n        # 33 ^ 33 = 0\n        # 33 ^ 32 = 3\n        # 34 ^ 34 = 0\n        # 34 ^ 33 = 3\n        # 35 ^ 35 = 0\n        # 35 ^ 34 = 3\n        # 36 ^ 36 = 0\n        # 36 ^ 35 = 3\n        # 37 ^ 37 = 0\n        # 37 ^ 36 = 3\n        # 38 ^ 38 = 0\n        # 38 ^ 37 = 3\n        # 39 ^ 39 = 0\n        # 39 ^ 38 = 3\n        # 40 ^ 40 = 0\n        # 40 ^ 39 = 3\n        # 41 ^ 41 = 0\n        # 41 ^ 40 = 3\n        # 42 ^ 42 = 0\n        # 42 ^ 41 = 3\n        # 43 ^ 43 = 0\n        # 43 ^ 42 = 3\n        # 4"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n            dp[0][i] = dp[0][i - 1] + grid[0][i]\n\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n                if i + j != n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + dp[i - 1][j])\n                if i + j != 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + dp[i][j])\n\n        return dp[n - 1][n - 1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [1, 2, 4]\n        for i in range(3, n+1):\n            dp.append((dp[i-1] + dp[i-2] + dp[i-3]) % mod)\n        return (dp[n] * 2 + dp[n-1] * 2) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums)-1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if nums[0] == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump < i:\n        #         return False\n        #     max_jump = max(max_jump, i + nums[i])\n        # return True\n\n        # if nums[0] == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump < i:\n        #         return False\n        #     max_jump = max(max_jump, i + nums[i])\n        #     if max_jump >= len(nums) - 1:\n        #         return True\n        # return False\n\n        # if nums[0] == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump < i:\n        #         return False\n        #     max_jump = max(max_jump, i + nums[i])\n        #     if max_jump >= len(nums) - 1:\n        #         return True\n        # return False\n\n        # if nums[0] == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump < i:\n        #         return False\n        #     max_jump = max(max_jump, i + nums[i])\n        #     if max_jump >= len(nums) - 1:\n        #         return True\n        # return False\n\n        # if nums[0] == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump < i:\n        #         return False\n        #     max_jump = max(max_jump, i + nums[i])\n        #     if max_jump >= len(nums) - 1:\n        #         return True\n        # return False\n\n        if nums[0] == 0:\n            return False\n        if len(nums) == 1:\n            return True\n        max_jump = nums[0]\n        for i in range(1, len(nums)):\n            if max_jump < i:\n                return False\n            max_jump = max(max_jump, i + nums[i])\n            if max_jump >= len(nums) - 1:\n                return True\n        return False"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        res = \"1\"\n        for i in range(2, n+1):\n            res = self.say(res)\n        return res\n        \n    def say(self, s):\n        res = \"\"\n        count = 1\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                count += 1\n            else:\n                res += str(count) + s[i]\n                count = 1\n        res += str(count) + s[len(s)-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target and nums[right] >= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and nums[mid] > target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = []\n        def backtrack(i, curr):\n            if i == len(digits):\n                res.append(curr)\n                return\n            \n            for c in phone[digits[i]]:\n                backtrack(i+1, curr+c)\n        \n        backtrack(0, '')\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the number\n        # 2. if the number is 1, return 0\n        # 3. if the number is 2, return 1\n        # 4. if the number is 3, return 2\n        # 5. if the number is 4, return 3\n        # 6. if the number is 5, return 4\n        # 7. if the number is 6, return 5\n        # 8. if the number is 7, return 6\n        # 9. if the number is 8, return 7\n        # 10. if the number is 9, return 8\n        # 11. if the number is 10, return 9\n        # 12. if the number is 11, return 10\n        # 13. if the number is 12, return 11\n        # 14. if the number is 13, return 12\n        # 15. if the number is 14, return 13\n        # 16. if the number is 15, return 14\n        # 17. if the number is 16, return 15\n        # 18. if the number is 17, return 16\n        # 19. if the number is 18, return 17\n        # 20. if the number is 19, return 18\n        # 21. if the number is 20, return 19\n        # 22. if the number is 21, return 20\n        # 23. if the number is 22, return 21\n        # 24. if the number is 23, return 22\n        # 25. if the number is 24, return 23\n        # 26. if the number is 25, return 24\n        # 27. if the number is 26, return 25\n        # 28. if the number is 27, return 26\n        # 29. if the number is 28, return 27\n        # 30. if the number is 29, return 28\n        # 31. if the number is 30, return 29\n        # 32. if the number is 31, return 30\n        # 33. if the number is 32, return 31\n        # 34. if the number is 33, return 32\n        # 35. if the number is 34, return 33\n        # 36. if the number is 35, return 34\n        # 37. if the number is 36, return 35\n        # 38. if the number is 37, return 36\n        # 39. if the number is 38, return 37\n        # 40. if the number is 39, return 38\n        # 41. if the number is 40, return 39\n        # 42. if the number is 41, return 40\n        # 43. if the number is 42, return 41\n        # 44. if the number is 43, return 42\n        # 45. if the number is 44, return 43\n        # 46. if the number is 45, return 44\n        # 47. if the number is 46, return 45\n        # 48. if the number is 47, return 46\n        # 49. if the number is 48, return 47\n        # 50. if the number is 49, return 48\n        # 51. if the number is 50, return 49\n        # 52. if the number is 51, return 50\n        # 53. if the number is 52, return 51\n        # 54. if the number is 53, return 52\n        # 55. if the number is 54, return 53\n        # 56. if the number is 55"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        # transpose\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            temp_max = max_prod * nums[i]\n            temp_min = min_prod * nums[i]\n            max_prod = max(nums[i], temp_max, temp_min)\n            min_prod = min(nums[i], temp_max, temp_min)\n            result = max(result, max_prod)\n\n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_map = {stone:set() for stone in stone_set}\n        stone_map[stones[0]].add(1)\n\n        for stone in stones:\n            for jump in stone_map[stone]:\n                if stone + jump in stone_set:\n                    stone_map[stone + jump].add(jump + 1)\n                    stone_map[stone + jump].add(jump)\n                    stone_map[stone + jump].add(jump - 1)\n\n        return stone_map[stones[-1]] != set()"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        \n        # assign the rank to each score\n        for i, score in enumerate(score):\n            rank_dict[score] = i + 1\n        \n        # assign the rank to each score\n        for i, score in enumerate(score):\n            if rank_dict[score] == 1:\n                score_rank = \"Gold Medal\"\n            elif rank_dict[score] == 2:\n                score_rank = \"Silver Medal\"\n            elif rank_dict[score] == 3:\n                score_rank = \"Bronze Medal\"\n            else:\n                score_rank = str(rank_dict[score])\n            \n            # assign the rank to the score\n            score_rank = str(score_rank)\n            \n            # assign the rank to the score\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list\n            score_rank = score_rank\n            \n            # add the rank to the list"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if char in set, remove left pointer\n        # 5. else, add char to set\n        # 6. update max\n        # 7. return max\n        \n        # 1. left pointer\n        #"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = word_dict.copy()\n            j = i\n            while j < len(s):\n                word = s[j:j+word_len]\n                if word in temp_dict:\n                    temp_dict[word] -= 1\n                    if temp_dict[word] == 0:\n                        del temp_dict[word]\n                j += word_len\n                if len(temp_dict) == 0:\n                    res.append(i)\n                    break\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = arr[0]\n        chunks = 1\n\n        for i in range(1, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n            if max_num == i:\n                chunks += 1\n\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and curr.val > prev.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        \n        for i in range(1,m+1):\n            dp[i][0] = i\n        for j in range(1,n+1):\n            dp[0][j] = j\n        \n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += xor & 1\n            xor = xor >> 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            nums[left:right+1] = temp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid)\n            count += mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return (sx == tx and sy <= ty) or (sy == ty and sx <= tx)"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        l1 = len(v1)\n        l2 = len(v2)\n        if l1 > l2:\n            v2.extend([0]*(l1-l2))\n        elif l2 > l1:\n            v1.extend([0]*(l2-l1))\n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        min_price = float('inf')\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # priority queue\n        pq = []\n        # total time\n        total = 0\n        # iterate over courses\n        for duration, lastDay in courses:\n            # add course to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            # update total time\n            total += duration\n            # if total time exceeds last day, remove course from priority queue\n            if total > lastDay:\n                # remove course from priority queue\n                total += heapq.heappop(pq)[0]\n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return tail"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        # if s in s*2[1:len(s)//2]:\n        #     return True\n        # return False\n\n        return s in s*2[1:len(s)//2]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2*dp[i-2]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 14\n        # dp[5] = 42\n        # dp[6] = 132\n        # dp[7] = 429\n        # dp[8] = 1430\n        # dp[9] = 4862\n        # dp[10] = 16796\n        # dp[11] = 58786\n        # dp[12] = 208012\n        # dp[13] = 742900\n        # dp[14] = 2674440\n        # dp[15] = 9694845\n        # dp[16] = 35357670\n        # dp[17] = 129644790\n        # dp[18] = 477638700\n        # dp[19] = 1767263190\n        # dp[20] = 6564120420\n        # dp[21] = 24466265020\n        # dp[22] = 86204111524\n        # dp[23] = 313452632440\n        # dp[24] = 1030367836884\n        # dp[25] = 3719933264080\n        # dp[26] = 12507277216120\n        # dp[27] = 42681670048260\n        # dp[28] = 155112100432440\n        # dp[29] = 510909425045200\n        # dp[30] = 183631110408840\n        # dp[31] = 630451750837680\n        # dp[32] = 230679118480720\n        # dp[33] = 772631851460480\n        # dp[34] = 282581953324720\n        # dp[35] = 960971890948080\n        # dp[36] = 353576708830080\n        # dp[37] = 129644790041640\n        # dp[38] = 47763870048260\n        # dp[39] = 176726319044840\n        # dp[40] = 65641204202240\n        # dp[41] = 24466265020220\n        # dp[42] = 8620411152444\n        # dp[43] = 3134526324408\n        # dp[44] = 1030367836884\n        # dp[45] = 371993326408\n        # dp[46] = 125072772161\n        # dp[47] = 426816700482\n        # dp[48] = 155112100432\n        # dp[49] = 51090942504\n        # dp[50] = 183"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        # XOR of a number with itself is 0\n        # XOR of a number with 0 is the number\n        # XOR of a number with a number is 0\n        # So we can use XOR to find the single number\n        # Time Complexity: O("}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\""}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                    for k in range(i,j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                total += roman_dict[s[i]]\n                i += 1\n        return total"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_num = max(nums[0:k])\n        # res = [max_num]\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_num:\n        #         max_num = nums[i]\n        #     if i >= k:\n        #         if nums[i-k] == max_num:\n        #             max_num = max(nums[i-k+1:i+1])\n        #     res.append(max_num)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_num = max(nums[0:k])\n        # res = [max_num]\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_num:\n        #         max_num = nums[i]\n        #     if i >= k:\n        #         if nums[i-k] == max_num:\n        #             max_num = max(nums[i-k+1:i+1])\n        #     res.append(max_num)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_num = max(nums[0:k])\n        # res = [max_num]\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_num:\n        #         max_num = nums[i]\n        #     if i >= k:\n        #         if nums[i-k] == max_num:\n        #             max_num = max(nums[i-k+1:i+1])\n        #     res.append(max_num)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_num = max(nums[0:k])\n        # res = [max_num]\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_num:\n        #         max_num = nums[i]\n        #     if i >= k:\n        #         if nums[i-k] == max_num:\n        #             max_num = max(nums[i-k+1:i+1])\n        #     res.append(max_num)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_num = max(nums[0:k])\n        # res = [max_num]\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_num:\n        #         max_num = nums[i]\n        #     if i >= k:\n        #         if nums[i-k] == max_num:\n        #             max_num = max(nums[i-k+1:i+1])\n        #     res.append(max_num)\n        # return res\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_num = max(nums[0:k])\n        # res = [max_num]\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_num:\n        #         max_num = nums[i]\n        #     if i >= k:\n        #         if nums[i-k] == max_num:\n        #             max_num = max(num"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and root.val == targetSum:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * L = area\n        # 2. L * L = area\n        # 3. L * L > area\n        # 4. L > area / L\n        # 5. L > area / L\n        # 6. L > area / L\n        # 7. L > area / L\n        # 8. L > area / L\n        # 9. L > area / L\n        # 10. L > area / L\n        # 11. L > area / L\n        # 12. L > area / L\n        # 13. L > area / L\n        # 14. L > area / L\n        # 15. L > area / L\n        # 16. L > area / L\n        # 17. L > area / L\n        # 18. L > area / L\n        # 19. L > area / L\n        # 20. L > area / L\n        # 21. L > area / L\n        # 22. L > area / L\n        # 23. L > area / L\n        # 24. L > area / L\n        # 25. L > area / L\n        # 26. L > area / L\n        # 27. L > area / L\n        # 28. L > area / L\n        # 29. L > area / L\n        # 30. L > area / L\n        # 31. L > area / L\n        # 32. L > area / L\n        # 33. L > area / L\n        # 34. L > area / L\n        # 35. L > area / L\n        # 36. L > area / L\n        # 37. L > area / L\n        # 38. L > area / L\n        # 39. L > area / L\n        # 40. L > area / L\n        # 41. L > area / L\n        # 42. L > area / L\n        # 43. L > area / L\n        # 44. L > area / L\n        # 45. L > area / L\n        # 46. L > area / L\n        # 47. L > area / L\n        # 48. L > area / L\n        # 49. L > area / L\n        # 50. L > area / L\n        # 51. L > area / L\n        # 52. L > area / L\n        # 53. L > area / L\n        # 54. L > area / L\n        # 55. L > area / L\n        # 56. L > area / L\n        # 57. L > area / L\n        # 58. L > area / L\n        # 59. L > area / L\n        # 60. L > area / L\n        # 61. L > area / L\n        # 62. L > area / L\n        # 63. L > area / L\n        # 64. L > area / L\n        # 65. L > area / L\n        # 66. L > area / L\n        # 67. L > area / L\n        # 68. L > area / L\n        # 69. L > area / L\n        # 70. L > area / L\n        # 71. L > area / L\n        # 72. L > area / L\n        # 73. L > area / L\n        # 74. L > area / L\n        # 75. L > area / L\n        # 76. L > area / L\n        # 77. L > area / L\n        # 78. L > area / L\n        # 79. L > area / L\n        # 80. L > area / L\n        # 81. L > area / L\n        # 82. L > area / L\n        # 83. L > area / L\n        # 84. L > area / L\n        # 85. L > area / L\n        # 86. L > area / L"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\""}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 != 0:\n            return False\n        \n        return self.isPowerOfTwo(n // 2)"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        while i < len(nums):\n            j = i\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            n = len(res)\n            for k in range(n):\n                res.append(res[k] + [nums[i]])\n            i = j\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            width = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(first / second))\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        seen = set()\n\n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n            seen.add((x1, y1))\n            seen.add((x1, y2))\n            seen.add((x2, y1))\n            seen.add((x2, y2))\n\n        if (x_min, y_min) not in seen or (x_min, y_max) not in seen or (x_max, y_min) not in seen or (x_max, y_max) not in seen:\n            return False\n\n        return area == (x_max - x_min) * (y_max - y_min)"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n\n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 6\n        # 7 8 9 10 11 12\n        # 13 14 15 16 17 18\n        # 19 20 21 22 23 24\n        # 25 26 27 28 29 30\n        # 31 32 33 34 35 36\n        # 37 38 39 40 41 42\n        # 43 44 45 46 47 48\n        # 49 50 51 52 53 54\n        # 55 56 57 58 59 60\n        # 61 62 63 64 65 66\n        # 67 68 69 70 71 72\n        # 73 74 75 76 77 78\n        # 79 80 81 82 83 84\n        # 85 86 87 88 89 90\n        # 91 92 93 94 95 96\n        # 97 98 99 100 101 102\n        # 103 104 105 106 107 108\n        # 109 110 111 112 113 114\n        # 115 116 117 118 119 120\n        # 121 122 123 124 125 126\n        # 127 128 129 130 131 132\n        # 133 134 135 136 137 138\n        # 139 140 141 142 143 144\n        # 145 146 147 148 149 150\n        # 151 152 153 154 155 156\n        # 157 158 159 160 161 162\n        # 163 164 165 166 167 168\n        # 169 170 171 172 173 174\n        # 175 176 177 178 179 180\n        # 181 182 183 184 185 186\n        # 187 188 189 190 191 192\n        # 193 194 195 196 197 198\n        # 199 200 201 202 203 204\n        # 205 206 207 208 209 210\n        # 211 212 213 214 215 216\n        # 217 218 219 220 221 222\n        # 223 224 225 226 227 228\n        # 229 230 231 232 233 234\n        # 235 236 237 238 239 240\n        # 241 242 243 244 245 246\n        # 247 248"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        left = 0\n        right = len(nums)-1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        dp[m-1][n-1] = 1\n        \n        for i in range(m-2,-1,-1):\n            if obstacleGrid[i][n-1] == 1:\n                dp[i][n-1] = 0\n            else:\n                dp[i][n-1] = dp[i+1][n-1]\n        \n        for j in range(n-2,-1,-1):\n            if obstacleGrid[m-1][j] == 1:\n                dp[m-1][j] = 0\n            else:\n                dp[m-1][j] = dp[m-1][j+1]\n        \n        for i in range(m-2,-1,-1):\n            for j in range(n-2,-1,-1):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1]\n        \n        return dp[0][0]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = float('inf')\n        res = 0\n        for i in range(len(nums)-2):\n            left = i+1\n            right = len(nums)-1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum > target:\n                    right -= 1\n                elif sum < target:\n                    left += 1\n                else:\n                    return target\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        res = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, prev, ans):\n            if root is None:\n                return\n            inorder(root.left, prev, ans)\n            if prev is not None:\n                ans = min(ans, root.val - prev)\n            prev = root.val\n            inorder(root.right, prev, ans)\n        \n        ans = float('inf')\n        inorder(root, None, ans)\n        return ans"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0, 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] == right[0]:\n                return left[0] + 1, left[1]\n            elif left[0] > right[0]:\n                return left[0] + 1, left[1]\n            else:\n                return right[0] + 1, right[1]\n        \n        count, max_count = dfs(root)\n        res = []\n        if max_count == 1:\n            res.append(root.val)\n        elif max_count > 1:\n            res.append(root.val)\n        return res"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uae38\uc774 \uccb4\ud06c\n        # 2. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 3. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 4. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 7. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 9. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 11. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 13. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 15. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 16. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 17. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 18. \uc704 \uc870\uac74\uc744 \ufffd"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = -1\n        \n        for c in s:\n            if i == 0 or i == numRows - 1:\n                flag = -flag\n            \n            res[i] += c\n            i += flag\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height)-1\n        left_max, right_max = 0, 0\n        res = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    res += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    res += right_max - height[right]\n                right -= 1\n        \n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. We can use the array as a hash table\n        ## 2. We can use the array as a set\n        ## 3. We can use the array as a bitmap\n        ## 4. We can use the array as a bitmap\n        ## 5. We can use the array as a bitmap\n        ## 6. We can use the array as a bitmap\n        ## 7. We can use the array as a bitmap\n        ## 8. We can use the array as a bitmap\n        ## 9. We can use the array as a bitmap\n        ## 10. We can use the array as a bitmap\n        ## 11. We can use the array as a bitmap\n        ## 12. We can use the array as a bitmap\n        ## 13. We can use the array as a bitmap\n        ## 14. We can use the array as a bitmap\n        ## 15. We can use the array as a bitmap\n        ## 16. We can use the array as a bitmap\n        ## 17. We can use the array as a bitmap\n        ## 18. We can use the array as a bitmap\n        ## 19. We can use the array as a bitmap\n        ## 20. We can use the array as a bitmap\n        ## 21. We can use the array as a bitmap\n        ## 22. We can use the array as a bitmap\n        ## 23. We can use the array as a bitmap\n        ## 24. We can use the array as a bitmap\n        ## 25. We can use the array as a bitmap\n        ## 26. We can use the array as a bitmap\n        ## 27. We can use the array as a bitmap\n        ## 28. We can use the array as a bitmap\n        ## 29. We can use the array as a bitmap\n        ## 30. We can use the array as a bitmap\n        ## 31. We can use the array as a bitmap\n        ## 32. We can use the array as a bitmap\n        ## 33. We can use the array as a bitmap\n        ## 34. We can use the array as a bitmap\n        ## 35. We can use the array as a bitmap\n        ## 36. We can use the array as a bitmap\n        ## 37. We can use the array as a bitmap\n        ## 38. We can use the array as a bitmap\n        ## 39. We can use the array as a bitmap\n        ## 40. We can use the array as a bitmap\n        ## 41. We can use the array as a bitmap\n        ## 42. We can use the array as a bitmap\n        ## 43. We can use the array as a bitmap\n        ## 44. We can use the array as a bitmap\n        ## 45. We can use the array as a bitmap\n        ## 46. We can use the array as a bitmap\n        ## 47. We can use the array as a bitmap\n        ## 48. We can use the array as a bitmap\n        ## 49. We can use the array as a bitmap\n        ## 50. We can use the array as a bitmap\n        ## 51. We can use the array as a bitmap\n        ## 52. We can use the array as a bitmap\n        ## 53. We can use the array as a bitmap\n        ## 54. We can use the array as a bitmap\n        ## 55. We can use the array as a bitmap\n        ## 56. We can use the array as a bitmap\n        ## 57. We can use the array as a bitmap\n        ## 58. We can use the array as a bitmap\n        ## 59. We can use the array as a bitmap\n        ## 60. We can use the array as a bitmap"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = [intervals[0][1]-1]\n        for i in intervals[1:]:\n            if i[0] > res[-1]:\n                res.append(i[1]-1)\n            else:\n                res.append(res[-1]-1)\n        return sum(res)+1"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(0)\n                i += 1\n            elif formula[i] == ')':\n                num = 0\n                while stack and isinstance(stack[-1], int):\n                    num = stack.pop() + num\n                if stack:\n                    if isinstance(stack[-1], str):\n                        stack[-1] = stack[-1] * num\n                    else:\n                        stack[-1] = stack[-1] + num\n                else:\n                    stack.append(1)\n                i += 1\n            else:\n                j = i + 1\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                num = int(formula[i:j])\n                if stack:\n                    if isinstance(stack[-1], str):\n                        stack[-1] = stack[-1] * num\n                    else:\n                        stack[-1] = stack[-1] + num\n                else:\n                    stack.append(1)\n                i = j\n        stack.reverse()\n        res = {}\n        for s in stack:\n            if isinstance(s, int):\n                if res:\n                    for k, v in res.items():\n                        res[k] += s\n                else:\n                    res['1'] = s\n            else:\n                res[s] = res.get(s, 0) + 1\n        res = sorted(res.items())\n        res = [k + (v if v > 1 else '') for k, v in res]\n        return ''.join(res)"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 4 != 0:\n            return False\n        \n        return self.isPowerOfFour(n/4)"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        if n == 1:\n            return ['()']\n        \n        res = []\n        self.helper(n, n, '', res)\n        return res\n        \n    def helper(self, left, right, curr, res):\n        if left == 0 and right == 0:\n            res.append(curr)\n            return\n        \n        if left > 0:\n            self.helper(left - 1, right, curr + '(', res)\n        \n        if right > left:\n            self.helper(left, right - 1, curr + ')', res)"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # loop through nums\n        while i < len(nums):\n            # if nums[i] is greater than n, then we need to add a patch\n            if nums[i] > n:\n                patches += 1\n                # if we have a patch, then we can add another patch\n                # and continue\n                if patches:\n                    patches += 1\n                # if we have no patches, then we can add a patch\n                # and continue\n                else:\n                    patches += 1\n            # if nums[i] is less than n, then we can add nums[i] to n\n            else:\n                n += nums[i]\n                i += 1\n        \n        # return the number of patches\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. stack\n        # 6. dp\n        # 7. greedy\n        # 8. stack\n        # 9. dp\n        # 10. greedy\n        # 11. stack\n        # 12. dp\n        # 13. greedy\n        # 14. stack\n        # 15. dp\n        # 16. greedy\n        # 17. stack\n        # 18. dp\n        # 19. greedy\n        # 20. stack\n        # 21. dp\n        # 22. greedy\n        # 23. stack\n        # 24. dp\n        # 25. greedy\n        # 26. stack\n        # 27. dp\n        # 28. greedy\n        # 29. stack\n        # 30. dp\n        # 31. greedy\n        # 32. stack\n        # 33. dp\n        # 34. greedy\n        # 35. stack\n        # 36. dp\n        # 37. greedy\n        # 38. stack\n        # 39. dp\n        # 40. greedy\n        # 41. stack\n        # 42. dp\n        # 43. greedy\n        # 44. stack\n        # 45. dp\n        # 46. greedy\n        # 47. stack\n        # 48. dp\n        # 49. greedy\n        # 50. stack\n        # 51. dp\n        # 52. greedy\n        # 53. stack\n        # 54. dp\n        # 55. greedy\n        # 56. stack\n        # 57. dp\n        # 58. greedy\n        # 59. stack\n        # 60. dp\n        # 61. greedy\n        # 62. stack\n        # 63. dp\n        # 64. greedy\n        # 65. stack\n        # 66. dp\n        # 67. greedy\n        # 68. stack\n        # 69. dp\n        # 70. greedy\n        # 71. stack\n        # 72. dp\n        # 73. greedy\n        # 74. stack\n        # 75. dp\n        # 76. greedy\n        # 77. stack\n        # 78. dp\n        # 79. greedy\n        # 80. stack\n        # 81. dp\n        # 82. greedy\n        # 83. stack\n        # 84. dp\n        # 85. greedy\n        # 86. stack\n        # 87. dp\n        # 88. greedy\n        # 89. stack\n        # 90. dp\n        # 91. greedy\n        # 92. stack\n        # 93. dp\n        # 94. greedy\n        # 95. stack\n        # 96. dp\n        # 97. greedy\n        # 98. stack\n        # 99. dp\n        # 100. greedy\n        # 101. stack\n        # 102. dp\n        # 103. greedy\n        # 104. stack\n        # 105. dp\n        # 106. greedy\n        # 107. stack\n        # 108. dp\n        # 109. greedy\n        # 110. stack\n        # 111. dp\n        # 112. greedy\n        # 113. stack\n        # 114. dp\n        # 115. greedy\n        # 116. stack\n        # 117. d"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_str = \"\"\n        i = 0\n        \n        while remainder != 0:\n            if remainder in remainder_dict:\n                remainder_str = remainder_str[:remainder_dict[remainder]] + \"(\" + remainder_str[remainder_dict[remainder]:] + \")\"\n                break\n            remainder_dict[remainder] = i\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            remainder_str += str(quotient)\n            i += 1\n        \n        return sign + str(quotient) + \".\" + remainder_str if remainder_str else str(quotient)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the left and right halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # merge the remaining nodes\n        if left:\n            curr.next = left\n        elif right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for w, h in envelopes:\n            if not dp or dp[-1] < h:\n                dp.append(h)\n            else:\n                left, right = 0, len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < h:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = h\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = set()\n        cols = set()\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0\n\n        return matrix"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if the list is empty\n        if not head:\n            return None\n        \n        # if the list has only one node\n        if not head.next:\n            return None\n        \n        # if the list has two nodes\n        if not head.next.next:\n            head = None\n            return head\n        \n        # if the list has more than two nodes\n        # set the slow pointer to the head\n        slow = head\n        # set the fast pointer to the head\n        fast = head\n        \n        # move the fast pointer n nodes ahead\n        for i in range(n):\n            fast = fast.next\n        \n        # if the fast pointer is None, it means that the nth node from the end is the head\n        if not fast:\n            head = head.next\n            return head\n        \n        # move the slow pointer and fast pointer until the fast pointer is None\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # set the next node of the slow pointer to the next node of the slow pointer\n        slow.next = slow.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        return list(nums1 & nums2)"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        curr = 0\n        max_move = 0\n        for i in machines:\n            curr += i - avg\n            max_move = max(max_move, abs(curr))\n        return max_move"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1:\n            curr.next = list1\n        elif list2:\n            curr.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n        \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                height = heights[stack.pop()]\n                if not stack:\n                    left = -1\n                else:\n                    left = stack[-1]\n                max_area = max(max_area, (i - left - 1) * height)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            if not stack:\n                left = -1\n            else:\n                left = stack[-1]\n            max_area = max(max_area, (len(heights) - left - 1) * height)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [item + [num] for item in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        if s[0] in ['+','-']:\n            s = s[1:]\n        \n        if s[0] == '.':\n            s = s[1:]\n            if not s or s[0] in ['+','-']:\n                return False\n            if s[0] == '.':\n                return False\n        \n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        \n        if s[-1] == '.':\n            s = s[:-1]\n            if not s or s[-1] in ['+','-']:\n                return False\n            if s[-1] == '.':\n                return False\n        \n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            if not s[0].isdigit() or not s[1].isdigit():\n                return False\n            if s[0] == '0' or s[1] == '0':\n                return False\n            if s[1][0] == '-':\n                return False\n            return True\n        \n        if s.isdigit():\n            return True\n        return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n\n        roman_num = ''\n\n        for key in roman_dict.keys():\n            roman_num += (num // key) * roman_dict[key]\n            num %= key\n\n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # 26 bit\n        # 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            # check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # check col\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # check 3x3 box\n            box_row = row // 3\n            box_col = col // 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row * 3 + i][box_col * 3 + j] == num:\n                        return False\n            return True\n\n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n\n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the smallest\n        # if the node is not swapped, then the node.val should be the largest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        # if the node is swapped, then the node.val should be the largest\n        # if the node is not swapped, then the node.val should be the smallest\n        #"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        left = 0\n        right = num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0]\n        curr = 1\n        for i in range(1, n+1):\n            if i == curr:\n                res.append(1)\n                curr *= 2\n            else:\n                res.append(res[i-curr] + 1)\n        return res"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        path = path.split('/')\n        for i in path:\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['$'] = True\n        \n        res = []\n        m = len(board)\n        n = len(board[0])\n        visited = set()\n        \n        def dfs(i, j, node):\n            if '$' in node:\n                res.append(node.pop('$'))\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, node.get(board[i][j], {}))\n            dfs(i - 1, j, node.get(board[i][j], {}))\n            dfs(i, j + 1, node.get(board[i][j], {}))\n            dfs(i, j - 1, node.get(board[i][j], {}))\n            visited.remove((i, j))\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, trie)\n        \n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 2. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 3. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 4. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 5. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 6. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 7. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 8. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 9. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 10. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 11. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 12. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 13. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 14. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 15. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 16. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 17. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 18. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 19. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 20. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 21. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 22. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 23. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 24. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 25. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 26. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 27. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 28. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 29. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 30. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 31. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 32. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 33. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 34. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 35. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 36. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 37. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 38. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 39. 3 sets of 9 rows, 9 columns, 9 3x3 boxes\n        # 40. 3 sets of 9 rows, 9 columns,"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                res.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                res.append(\"Fizz\")\n            elif i%5 == 0:\n                res.append(\"Buzz\")\n            else:\n                res.append(str(i))\n        return res"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res = res * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n\n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        \n        second = self.reverse(second)\n        first = head\n        \n        while second:\n            temp = first.next\n            first.next = second\n            second = second.next\n            first.next.next = temp\n            first = temp\n        \n        return head\n        \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] in d:\n                if d[pattern[i]] != s[i]:\n                    return False\n            else:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            temp = nums[i]\n            nums.pop(i)\n            res += [temp + x for x in self.permute(nums)]\n            nums.insert(i, temp)\n        \n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        low = 0\n        high = m*n-1\n        while low <= high:\n            mid = (low+high)//2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid+1\n            else:\n                high = mid-1\n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        head = ListNode()\n        # Initialize a pointer to the new linked list\n        curr = head\n        # Initialize a variable to keep track of the carry\n        carry = 0\n        # Loop until both linked lists are empty\n        while l1 and l2:\n            # Add the values of the two linked lists\n            sum = l1.val + l2.val + carry\n            # Set the value of the current node to the sum modulo 10\n            curr.val = sum % 10\n            # Set the carry to the sum divided by 10\n            carry = sum // 10\n            # Move the pointers to the next nodes\n            l1 = l1.next\n            l2 = l2.next\n            # If the current node is empty, create a new node\n            if l1 is None and l2 is None and carry == 0:\n                break\n            curr.next = ListNode()\n            curr = curr.next\n        # If the linked list is longer than the other, add the remaining nodes to the new linked list\n        while l1:\n            sum = l1.val + carry\n            curr.val = sum % 10\n            carry = sum // 10\n            l1 = l1.next\n            if l1 is None and carry == 0:\n                break\n            curr.next = ListNode()\n            curr = curr.next\n        while l2:\n            sum = l2.val + carry\n            curr.val = sum % 10\n            carry = sum // 10\n            l2 = l2.next\n            if l2 is None and carry == 0:\n                break\n            curr.next = ListNode()\n            curr = curr.next\n        # If the carry is still 1, add a new node to the new linked list\n        if carry == 1:\n            curr.next = ListNode(1)\n        # Return the new linked list\n        return head"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert num to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Convert the decimal to binary\n        # 5. Convert the binary to decimal\n        # 6. Return the decimal\n        \n        # 1. Convert num to binary\n        binary = bin(num)[2:]\n        \n        # 2. Reverse the binary\n        reversed_binary = binary[::-1]\n        \n        # 3. Convert the binary to decimal\n        decimal = int(reversed_binary, 2)\n        \n        # 4. Convert the decimal to binary\n        complement_binary = bin(decimal)[2:]\n        \n        # 5. Convert the binary to decimal\n        complement_decimal = int(complement_binary, 2)\n        \n        # 6. Return the decimal\n        return complement_decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n                count += count\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        curr_len = 0\n        curr_words = []\n        for word in words:\n            if curr_len + len(word) + len(curr_words) > maxWidth:\n                if len(curr_words) == 1:\n                    res.append(curr_words[0] + ' ' * (maxWidth - curr_len))\n                else:\n                    num_spaces = (maxWidth - curr_len) // (len(curr_words) - 1)\n                    extra_spaces = (maxWidth - curr_len) % (len(curr_words) - 1)\n                    res.append(''.join([curr_words[i] + ' ' * num_spaces + (' ' if i < extra_spaces else '') for i in range(len(curr_words))]))\n                curr_len = 0\n                curr_words = []\n            curr_len += len(word)\n            curr_words.append(word)\n        if curr_len:\n            res.append(' '.join(curr_words) + ' ' * (maxWidth - curr_len))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        word_set = set(words)\n        res = []\n        for word in words:\n            if self.dfs(word, word_set):\n                res.append(word)\n        return res\n\n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            left = word[:i]\n            right = word[i:]\n            if left in word_set and (right in word_set or self.dfs(right, word_set)):\n                return True\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col, cols):\n            return col not in cols and row + col not in cols and row - col not in cols\n        \n        def backtrack(row, cols, n):\n            if row == n:\n                self.count += 1\n                return\n            \n            for col in range(n):\n                if is_valid(row, col, cols):\n                    cols.add(col)\n                    backtrack(row + 1, cols, n)\n                    cols.remove(col)\n        \n        self.count = 0\n        backtrack(0, set(), n)\n        return self.count"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n\n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n\n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1.sort()\n        # return nums1\n\n        # nums1[m:m+n] = nums2[:n]\n        # nums1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            return sorted(nums)[-3]"}]}