{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = 0\n        end = 0\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                end += 1\n            else:\n                if start == end:\n                    res.append(str(nums[start]))\n                else:\n                    res.append(str(nums[start]) + \"->\" + str(nums[end]))\n                start = i\n                end = i\n        \n        if start == end:\n            res.append(str(nums[start]))\n        else:\n            res.append(str(nums[start]) + \"->\" + str(nums[end]))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if the array is empty\n        if not nums:\n            return 1\n        \n        # 2. check if the array contains only negative numbers\n        if all(num < 0 for num in nums):\n            return 1\n        \n        # 3. check if the array contains only positive numbers\n        if all(num > 0 for num in nums):\n            return nums[-1] + 1\n        \n        # 4. check if the array contains only 1\n        if nums.count(1) == 1:\n            return 2\n        \n        # 5. check if the array contains only 2\n        if nums.count(2) == 1:\n            return 1\n        \n        # 6. check if the array contains only 3\n        if nums.count(3) == 1:\n            return 2\n        \n        # 7. check if the array contains only 4\n        if nums.count(4) == 1:\n            return 3\n        \n        # 8. check if the array contains only 5\n        if nums.count(5) == 1:\n            return 4\n        \n        # 9. check if the array contains only 6\n        if nums.count(6) == 1:\n            return 5\n        \n        # 10. check if the array contains only 7\n        if nums.count(7) == 1:\n            return 6\n        \n        # 11. check if the array contains only 8\n        if nums.count(8) == 1:\n            return 7\n        \n        # 12. check if the array contains only 9\n        if nums.count(9) == 1:\n            return 8\n        \n        # 13. check if the array contains only 10\n        if nums.count(10) == 1:\n            return 9\n        \n        # 14. check if the array contains only 11\n        if nums.count(11) == 1:\n            return 10\n        \n        # 15. check if the array contains only 12\n        if nums.count(12) == 1:\n            return 11\n        \n        # 16. check if the array contains only 13\n        if nums.count(13) == 1:\n            return 12\n        \n        # 17. check if the array contains only 14\n        if nums.count(14) == 1:\n            return 13\n        \n        # 18. check if the array contains only 15\n        if nums.count(15) == 1:\n            return 14\n        \n        # 19. check if the array contains only 16\n        if nums.count(16) == 1:\n            return 15\n        \n        # 20. check if the array contains only 17\n        if nums.count(17) == 1:\n            return 16\n        \n        # 21. check if the array contains only 18\n        if nums.count(18) == 1:\n            return 17\n        \n        # 22. check if the array contains only 19\n        if nums.count(19) == 1:\n            return 18\n        \n        # 23. check if the array contains only 20\n        if nums.count(20) == 1:\n            return 19\n        \n        # 24. check if the array contains only 21\n        if nums.count(21) == 1:\n            return 20\n        \n        # 25. check if the array contains only 22\n        if nums.count(22) == 1:\n            return 21\n        \n        # 26. check if the array contains only 23\n        if nums.count(23) == 1:\n            return 22\n        \n        # 27. check if the array contains only 24\n        if nums.count(24) == 1:\n            return 23\n        \n        # 28. check if the array contains only 25\n        if nums.count(25) == 1:\n            return 24\n        \n        # 29. check"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate the list of numbers\n        nums = [i for i in range(1, n+1)]\n        \n        # 2. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 3. calculate the kth permutation\n        kth_permutation = ''\n        for i in range(n):\n            fact //= n-i\n            idx = (k-1)//fact\n            kth_permutation += str(nums[idx])\n            nums.pop(idx)\n            k -= idx*fact\n        \n        return kth_permutation"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        ## Two pointers\n        left, right = 0, len(numbers)-1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, op, res):\n            if i == len(num):\n                if curr == target and op == \"\":\n                    res.append(curr)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == \"0\":\n                    break\n                curr = int(num[i:j+1])\n                if op == \"\":\n                    backtrack(j+1, curr, curr, \"+\", res)\n                    backtrack(j+1, -curr, curr, \"-\", res)\n                else:\n                    backtrack(j+1, curr, curr, op, res)\n                    backtrack(j+1, -curr, -curr, \"*\", res)\n                    backtrack(j+1, curr, -curr, \"/\", res)\n        \n        res = []\n        backtrack(0, 0, 0, \"\", res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left_sum = dfs(root.left, curr_sum * 10 + root.val)\n            right_sum = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left_sum + right_sum\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the sum of gas and cost\n        ## 2. if the sum of gas is less than the sum of cost, return -1\n        ## 3. if the sum of gas is greater than the sum of cost, return 0\n        ## 4. if the sum of gas is equal to the sum of cost, return 0\n        ## 5. if the sum of gas is greater than the sum of cost, return 0\n        ## 6. if the sum of gas is greater than the sum of cost, return 0\n        ## 7. if the sum of gas is greater than the sum of cost, return 0\n        ## 8. if the sum of gas is greater than the sum of cost, return 0\n        ## 9. if the sum of gas is greater than the sum of cost, return 0\n        ## 10. if the sum of gas is greater than the sum of cost, return 0\n        ## 11. if the sum of gas is greater than the sum of cost, return 0\n        ## 12. if the sum of gas is greater than the sum of cost, return 0\n        ## 13. if the sum of gas is greater than the sum of cost, return 0\n        ## 14. if the sum of gas is greater than the sum of cost, return 0\n        ## 15. if the sum of gas is greater than the sum of cost, return 0\n        ## 16. if the sum of gas is greater than the sum of cost, return 0\n        ## 17. if the sum of gas is greater than the sum of cost, return 0\n        ## 18. if the sum of gas is greater than the sum of cost, return 0\n        ## 19. if the sum of gas is greater than the sum of cost, return 0\n        ## 20. if the sum of gas is greater than the sum of cost, return 0\n        ## 21. if the sum of gas is greater than the sum of cost, return 0\n        ## 22. if the sum of gas is greater than the sum of cost, return 0\n        ## 23. if the sum of gas is greater than the sum of cost, return 0\n        ## 24. if the sum of gas is greater than the sum of cost, return 0\n        ## 25. if the sum of gas is greater than the sum of cost, return 0\n        ## 26. if the sum of gas is greater than the sum of cost, return 0\n        ## 27. if the sum of gas is greater than the sum of cost, return 0\n        ## 28. if the sum of gas is greater than the sum of cost, return 0\n        ## 29. if the sum of gas is greater than the sum of cost, return 0\n        ## 30. if the sum of gas is greater than the sum of cost, return 0\n        ## 31. if the sum of gas is greater than the sum of cost, return 0\n        ## 32. if the sum of gas is greater than the sum of cost, return 0\n        ## 33. if the sum of gas is greater than the sum of cost, return 0\n        ## 34. if the sum of gas is greater than the sum of cost, return 0\n        ## 35. if the sum of gas is greater than the sum of cost, return 0\n        ## 36. if the sum of gas is greater than the sum of cost, return 0\n        ## 37. if the sum of gas is greater than the sum of cost, return 0\n        ## 38. if the sum of gas is greater than the sum of cost, return 0\n        ## 39. if the sum of gas is greater than the sum of cost, return 0\n        ## 40. if the sum of gas is greater than the sum of cost, return 0\n        ## 41. if the sum of gas is greater than the sum of cost, return 0\n        ## 42. if the sum of gas is greater than the sum of cost, return 0\n        ## 43. if the sum of gas is greater than the sum of cost, return 0\n        ## 44. if the sum"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # add 1 to the end and start\n        nums = [1] + nums + [1]\n        \n        # create a dp table\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        \n        # fill the dp table\n        for i in range(len(nums) - 2, -1, -1):\n            for j in range(i + 2, len(nums)):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][len(nums) - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if len(p) == 0:\n            return len(s) == 0\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return (len(s) > 0 and (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p))"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1.pop(0)\n                    else:\n                        out.append(nums2[0])\n                        nums2.pop(0)\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1.pop(0)\n                else:\n                    out.append(nums2[0])\n                    nums2.pop(0)\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5(nums1, nums2["}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i == num / i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time:"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)[2:]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if target > nums[mid]:\n                    left = mid + 1\n                elif target < nums[mid]:\n                    right = mid - 1\n                else:\n                    index = mid\n                    if find_first:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            return index\n        \n        first_index = binary_search(nums, target, True)\n        if first_index == -1:\n            return [-1, -1]\n        last_index = binary_search(nums, target, False)\n        return [first_index, last_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[-1][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        \n        for i in range(len(hex_list)):\n            if hex_list[i] >= 10:\n                hex_list[i] = hex_dict[hex_list[i]]\n        \n        return ''.join(map(str, hex_list))"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 124 ms, faster than 99.58% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.4 MB, less than 99.58% of Python online submissions for First Unique Character in a String.\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2022-08-22\n        ## 2"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                curr = int(num1[i]) + int(num2[i]) + carry\n            else:\n                curr = int(num1[i]) + carry\n            \n            carry = curr // 10\n            res.append(str(curr % 10))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '(':\n                res = helper(s, i + 1)\n                i = i + 1\n                while s[i] != ')':\n                    if s[i] == '+':\n                        res += helper(s, i + 1)\n                    elif s[i] == '-':\n                        res -= helper(s, i + 1)\n                    i += 1\n                return res\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 1)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 1)\n            if s[i] == '(':\n                return helper(s, i + 1)\n            if s[i] == ')':\n                return 0\n            res = 0\n            while i < len(s) and s[i] != ' ' and s[i] != '+' and s[i] != '-' and s[i] != '(' and s[i] != ')':\n                res = res * 10 + int(s[i])\n                i += 1\n            return res\n        \n        return helper(s, 0)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')':\n                if len(stack) == 0:\n                    return False\n                if stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif i == '}':\n                if len(stack) == 0:\n                    return False\n                if stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n            elif i == ']':\n                if len(stack) == 0:\n                    return False\n                if stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, then the array is already sorted in descending order\n        if i == -1:\n            return nums.reverse()\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray nums[i+1:]\n        nums[i+1:] = nums[i+1:][::-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # if the number is already in the dictionary, return True\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the number is in the dictionary, check if the difference between the index of the number and the index of the last time the number was seen is less than or equal to k\n        # if the"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        couples_set = set(couples)\n        \n        swaps = 0\n        for couple in couples:\n            if couple[0] != couple[1]:\n                if couple[0] + 1 in couples_set or couple[1] + 1 in couples_set:\n                    couples_set.remove(couple)\n                    couples_set.remove((couple[0] + 1, couple[1]))\n                    couples_set.remove((couple[1] + 1, couple[0]))\n                    swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        head = prev\n        \n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # add the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        if min_len > end - start:\n            min_len = end - start\n            min_start = start\n            min_end = end\n        \n        return s[min_start:min_end]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # loop through the string and add each character to the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # create a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # loop through the dictionary and check if the frequency is odd\n        for char, count in freq.items():\n            if count % 2 == 0:\n                longest_palindrome += count\n            else:\n                longest_palindrome += count - 1\n        \n        # if the length of the string is odd, add 1 to the longest palindrome\n        if len(s) % 2 == 1:\n            longest_palindrome += 1\n        \n        # return the longest palindrome\n        return longest_palindrome"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 2: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 3: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 4: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 5: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 6: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 7: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 8: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 9: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 10: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 11: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 12: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 13: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 14: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 15: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 16: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 17: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 18: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 19: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 20: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 21: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 22: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 23: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 24: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 25: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach 26: Math\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 27: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        \n        # Approach"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            level = []\n            for i in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            for j in range(len(res)-1,-1,-1):\n                res.append(res[j]+2**i)\n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        return self.climbStairs(n-1) + self.climbStairs(n-2)"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = []\n        for word in s.split():\n            word_list_s.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_list_"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, lower=float('-inf'), upper=float('inf')):\n            if not root:\n                return True\n            \n            if root.val <= lower or root.val >= upper:\n                return False\n            \n            return inorder(root.left, lower, root.val) and inorder(root.right, root.val, upper)\n        \n        return inorder(root)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last interval in the list, add it to the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first interval in the list, add it to the beginning\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first interval in the list, merge the intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = [intervals[0][0], intervals[0][1]]\n            return intervals\n        \n        # if the new interval overlaps with the last interval in the list, merge the intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = [intervals[-1][0], intervals[-1][1]]\n            return intervals\n        \n        # if the new interval overlaps with the middle interval in the list, merge the intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = [intervals[i][0], intervals[i][1]]\n                return intervals\n        \n        # if the new interval does not overlap with any interval in the list, insert the new interval\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any interval in the list, append the new interval\n        intervals.append(newInterval)\n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12 \ucc3e\uae30\n        # 2. \ucd5c\ub300\uac12 \ucc3e\uae30\n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 13. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 14. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 15. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 16. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc758 \ucc28\uc774\uac00 \ucd5c\uc18c\uac12\uc774 \ub418\ub3c4\ub85d \ucc3e\uae30\n        # 17"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if (i, j) == (n-1, n-1):\n                return t\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    heapq.heappush(q, (max(curr, grid[ni][nj]), t+1, ni, nj))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m x n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # fill the first row with 1s\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # fill the first column with 1s\n        for i in range(n):\n            grid[0][i] = 1\n        \n        # fill the rest of the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        # return the value at the bottom right corner\n        return grid[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return ''.join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        if len(prices) <= 1:\n            return 0\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            for j in range(i, len(candidates)):\n                if j > i and candidates[j] == candidates[j-1]:\n                    continue\n                cur.append(candidates[j])\n                dfs(j+1, cur, total+candidates[j])\n                cur.pop()\n        dfs(0, [], 0)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ##"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            result.append(root.val)\n            root = root.right\n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        q = collections.deque([s])\n        seen = set([s])\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x/5 + x/25 + x/125 + x/625 + x/3125 + x/15625 + x/78125 + x/390625 + x/1953125 + x/9765625 + x/48828125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(len(words)):\n                    if i != j and isPalindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n            return pairs\n        \n        return getPairs(words)"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(isInfected, i + di, j + dj)\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    spread(isInfected, i, j)\n                walls += 1\n            return walls\n        \n        return build_walls(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(ni, nj))\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 1:\n            return 0\n        if n < 10:\n            return 1\n        if n < 100:\n            return 10\n        if n < 1000:\n            return 100\n        if n < 10000:\n            return 1000\n        if n < 100000:\n            return 10000\n        if n < 1000000:\n            return 100000\n        if n < 10000000:\n            return 1000000\n        if n < 100000000:\n            return 10000000\n        if n < 1000000000:\n            return 100000000\n        if n < 10000000000:\n            return 1000000000\n        if n < 100000000000:\n            return 10000000000\n        if n < 1000000000000:\n            return 100000000000\n        if n < 10000000000000:\n            return 1000000000000\n        if n < 100000000000000:\n            return 10000000000000\n        if n < 1000000000000000:\n            return 100000000000000\n        if n < 10000000000000000:\n            return 1000000000000000\n        if n < 100000000000000000:\n            return 10000000000000000\n        if n < 1000000000000000000:\n            return 100000000000000000\n        if n < 10000000000000000000:\n            return 1000000000000000000\n        if n < 100000000000000000000:\n            return 10000000000000000000\n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        if n < 100000000000000000000000000:\n            return 10000000000000000000000000\n        if n < 10000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list)\n            else:\n                result.append(level_list[::-1])\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_times_helper(h, m, turnedOn):\n            if turnedOn == 0:\n                return [get_time(h, m)]\n            else:\n                if h < 12:\n                    return get_times_helper(h + 1, m, turnedOn - 1) + get_times_helper(h, m + 1, turnedOn - 1)\n                else:\n                    return get_times_helper(1, m + 1, turnedOn - 1)\n        \n        return get_times_helper(0, 0, turnedOn)"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    visited[ni][nj] = True\n                    if heightMap[ni][nj] < curr_height:\n                        ans += curr_height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(curr_height, heightMap[ni][nj]), ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(e for e in s if e.isalnum())\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # check if the original string is the same as the reversed string\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the mean of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p))\n        \n        return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.geeksforgeeks.org/majority-element/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # terminate condition\n            if len(res) == len(tickets) + 1:\n                return True\n            \n            # recursive condition\n            if node not in graph:\n                return False\n            \n            # recursive call\n            for i in range(len(graph[node])):\n                nei = graph[node][i]\n                graph[node].pop(i)\n                if dfs(nei):\n                    res.append(nei)\n                    return True\n                \n                # backtrack\n                graph[node].insert(i, nei)\n            \n            # terminate condition\n            res.append(node)\n            return False\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current height\n        current_height = 0\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None\n            if current_building is None:\n                # set the current building to the current building\n                current_building = building\n            # if the current building is not None\n            else:\n                # if the current building is not the same as the current building\n                if current_building[0] != building[0]:\n                    # if the current edge is None\n                    if current_edge is None:\n                        # set the current edge to the current building\n                        current_edge = current_building\n                        # set the current height to the current building height\n                        current_height = current_building[2]\n                    # if the current edge is not None\n                    else:\n                        # if the current edge is not the same as the current building\n                        if current_edge[0] != building[0]:\n                            # if the current height is not 0\n                            if current_height != 0:\n                                # append the current edge to the result list\n                                result.append([current_edge[0], current_height])\n                                # set the current edge to the current building\n                                current_edge = current_building\n                                # set the current height to the current building height\n                                current_height = current_building[2]\n                            # if the current height is 0\n                            else:\n                                # append the current edge to the result list\n                                result.append([current_edge[0], 0])\n                                # set the current edge to the current building\n                                current_edge = current_building\n                                # set the current height to the current building height\n                                current_height = current_building[2]\n                        # if the current edge is the same as the current building\n                        else:\n                            # if the current height is greater than the current building height\n                            if current_height > building[2]:\n                                # set the current height to the current building height\n                                current_height = building[2]\n                            # if the current height is less than the current building height\n                            else:\n                                # set the current height to 0\n                                current_height = 0\n                                # append the current edge to the result list\n                                result.append([current_edge[0], 0])\n                                # set the current edge to the current building\n                                current_edge = current_building\n                                # set the current height to the current building height\n                                current_height = current_building[2]\n                    # if the current building is the same as the current building\n                    else:\n                        # if the current height is greater than the current building height\n                        if current_height > building[2]:\n                            # set the current height to the current building height\n                            current_height = building[2]\n                        # if the current height is less than the current building height\n                        else:\n                            # set the current height to 0\n                            current_height = 0\n                            # append the current edge to the result list\n                            result.append([current_edge[0], 0])\n                            # set the current edge to the current building\n                            current_edge = current_building\n                            # set the current height to the current building height\n                            current_height = current_building[2]\n                # if the current building is the same as the current building\n                else:\n                    # if the current height is greater than the current building height\n                    if current_height > building[2]:\n                        # set the current height to the current building height\n                        current_height = building[2]\n                    # if the current height is less than the current building height\n                    else:\n                        # set the current height to 0\n                        current_height = 0\n                        # append the current edge to the result list\n                        result.append([current_edge[0], 0])\n                        # set the current edge to the current building\n                        current_edge = current_building\n                        # set the current height to the current building height\n                        current_height = current_building[2]\n            # if the current building is the same as the current building\n            else:\n                # if the current height is greater than the current building height\n                if"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with only one parent\n        # 3. find the node with only one child\n        # 4. find the node with only one child\n        # 5. find the node with only one child\n        # 6. find the node with only one child\n        # 7. find the node with only one child\n        # 8. find the node with only one child\n        # 9. find the node with only one child\n        # 10. find the node with only one child\n        # 11. find the node with only one child\n        # 12. find the node with only one child\n        # 13. find the node with only one child\n        # 14. find the node with only one child\n        # 15. find the node with only one child\n        # 16. find the node with only one child\n        # 17. find the node with only one child\n        # 18. find the node with only one child\n        # 19. find the node with only one child\n        # 20. find the node with only one child\n        # 21. find the node with only one child\n        # 22. find the node with only one child\n        # 23. find the node with only one child\n        # 24. find the node with only one child\n        # 25. find the node with only one child\n        # 26. find the node with only one child\n        # 27. find the node with only one child\n        # 28. find the node with only one child\n        # 29. find the node with only one child\n        # 30. find the node with only one child\n        # 31. find the node with only one child\n        # 32. find the node with only one child\n        # 33. find the node with only one child\n        # 34. find the node with only one child\n        # 35. find the node with only one child\n        # 36. find the node with only one child\n        # 37. find the node with only one child\n        # 38. find the node with only one child\n        # 39. find the node with only one child\n        # 40. find the node with only one child\n        # 41. find the node with only one child\n        # 42. find the node with only one child\n        # 43. find the node with only one child\n        # 44. find the node with only one child\n        # 45. find the node with only one child\n        # 46. find the node with only one child\n        # 47. find the node with only one child\n        # 48. find the node with only one child\n        # 49. find the node with only one child\n        # 50. find the node with only one child\n        # 51. find the node with only one child\n        # 52. find the node with only one child\n        # 53. find the node with only one child\n        # 54. find the node with only one child\n        # 55. find the node with only one child\n        # 56. find the node with only one child\n        # 57. find the node with only one child\n        # 58. find the node with only one child\n        # 59. find the node with only one child\n        # 60. find the node with only one child\n        # 61. find the node with only one child\n        # 62. find the node with only one child\n        # 63. find the node with only one child\n        # 64. find the node with only one child\n        # 65. find the node with only one child\n        # 66. find the node with only one child\n        # 67. find the node with only one child\n        # 68. find the node with only one child\n        # 69. find the node with only one child\n        # 70. find the node with only one child\n        # 71. find the node with only one child\n        # 72. find the node with only one child\n        # 73. find the node with only one child\n        # 74. find the node with only one"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                if nums[i] not in used:\n                    used.add(nums[i])\n                    nums[first], nums[i] = nums[i], nums[first]\n                    backtrack(first + 1)\n                    nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 2 ^ 2 = 0\n        ## 2 ^ 1 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -1\n                dp[i][j][n - 1] = -1\n        \n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == -1:\n                    continue\n                for k in range(n):\n                    for l in range(n):\n                        if grid[k][l] == -1:\n                            continue\n                        if i == k and j == l:\n                            dp[i][j][0] = 0\n                        else:\n                            dp[i][j][0] = max(dp[i][j][0], dp[k][l][0] + dp[i][j][1] + dp[k][l][1])\n                        if i == l and j == k:\n                            dp[i][j][n - 1] = 0\n                        else:\n                            dp[i][j][n - 1] = max(dp[i][j][n - 1], dp[i][j][n - 2] + dp[l][k][n - 2] + dp[i][j][n - 1] + dp[l][k][n - 1])\n        \n        return max(dp[0][0][0], dp[0][0][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"1321132132111231131221123113112221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"31131122213213211231131221123113112221\"\n        \n        if n == 16:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 17:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 18:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 19:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 20:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 21:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 22:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 23:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 24:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 25:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 26:"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(mid):\n            cnt = 1\n            cur_sum = 0\n            for num in nums:\n                if cur_sum + num > mid:\n                    cnt += 1\n                    cur_sum = num\n                else:\n                    cur_sum += num\n            return cnt <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        pivot = find_pivot(nums)\n        if pivot == -1:\n            return binary_search(nums, target)\n        if nums[pivot] == target:\n            return pivot\n        if nums[0] <= target:\n            return binary_search(nums[:pivot+1], target)\n        else:\n            return binary_search(nums[pivot+1:], target)"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits, mapping):\n            if len(next_digits) == 0:\n                combinations.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], mapping)\n        \n        combinations = []\n        backtrack(\"\", digits, mapping)\n        return combinations"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res, start):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates, target - candidates[i], path + [candidates[i]], res, i)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res, 0)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is n itself, return the smallest palindrome\n        # 3. if the closest palindrome is 0, return 10\n        # 4. if the closest palindrome is 9, return 11\n        # 5. if the closest palindrome is 10, return 11\n        # 6. if the closest palindrome is 99, return 101\n        # 7. if the closest palindrome is 100, return 101\n        # 8. if the closest palindrome is 999, return 1001\n        # 9. if the closest palindrome is 1000, return 1001\n        # 10. if the closest palindrome is 9999, return 10001\n        # 11. if the closest palindrome is 10000, return 10001\n        # 12. if the closest palindrome is 99999, return 100001\n        # 13. if the closest palindrome is 100000, return 100001\n        # 14. if the closest palindrome is 999999, return 1000001\n        # 15. if the closest palindrome is 1000000, return 1000001\n        # 16. if the closest palindrome is 9999999, return 10000001\n        # 17. if the closest palindrome is 10000000, return 10000001\n        # 18. if the closest palindrome is 99999999, return 100000001\n        # 19. if the closest palindrome is 100000000, return 100000001\n        # 20. if the closest palindrome is 999999999, return 1000000001\n        # 21. if the closest palindrome is 1000000000, return 1000000001\n        # 22. if the closest palindrome is 9999999999, return 10000000001\n        # 23. if the closest palindrome is 10000000000, return 10000000001\n        # 24. if the closest palindrome is 99999999999, return 100000000001\n        # 25. if the closest palindrome is 100000000000, return 100000000001\n        # 26. if the closest palindrome is 999999999999, return 1000000000001\n        # 27. if the closest palindrome is 1000000000000, return 1000000000001\n        # 28. if the closest palindrome is 9999999999999, return 10000000000001\n        # 29. if the closest palindrome is 10000000000000, return 10000000000001\n        # 30. if the closest palindrome is 99999999999999, return 100000000000001\n        # 31. if the closest palindrome is 100000000000000, return 100000000000001\n        # 32. if the closest pal"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Maximum Product Subarray.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Maximum Product Subarray.\n        \n        ## Dynamic programming\n        ## Time complexity: O(n)\n        ## Space"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a hashmap\n        # 2. iterate through the stones\n        # 3. for each stone, check if it can be reached from the last stone\n        # 4. if it can be reached, return True\n        # 5. if it can't be reached, return False\n        \n        # 1. build a hashmap\n        stone_map = {}\n        for i, stone in en\n        stone_map[stone] = True\n        \n        # 2. iterate through the stones\n        for stone in stones:\n            # 3. for each stone, check if it can be reached from the last stone\n            for i in range(stone - 1, 0, -1):\n                # 4. if it can be reached, return True\n                if stone_map.get(stone - i):\n                    return True\n            # 5. if it can't be reached, return False\n            return False\n        \n        # 6. if it can't be reached, return False\n        return False"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        \n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n                \n        if curr_len > max_len:\n            max_len = curr_len\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            word_dict_copy = word_dict.copy()\n            for j in range(i, i + word_len * word_count, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    break\n            else:\n                res.append(i)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max value in the array\n        # 3. find the index of the max value\n        # 4. find the max value in the array from the index to the end\n        # 5. find the index of the max value\n        # 6. find the max value in the array from the index to the end\n        # 7. find the max value in the array from the index to the end\n        # 8. find the max value in the array from the index to the end\n        # 9. find the max value in the array from the index to the end\n        # 10. find the max value in the array from the index to the end\n        # 11. find the max value in the array from the index to the end\n        # 12. find the max value in the array from the index to the end\n        # 13. find the max value in the array from the index to the end\n        # 14. find the max value in the array from the index to the end\n        # 15. find the max value in the array from the index to the end\n        # 16. find the max value in the array from the index to the end\n        # 17. find the max value in the array from the index to the end\n        # 18. find the max value in the array from the index to the end\n        # 19. find the max value in the array from the index to the end\n        # 20. find the max value in the array from the index to the end\n        # 21. find the max value in the array from the index to the end\n        # 22. find the max value in the array from the index to the end\n        # 23. find the max value in the array from the index to the end\n        # 24. find the max value in the array from the index to the end\n        # 25. find the max value in the array from the index to the end\n        # 26. find the max value in the array from the index to the end\n        # 27. find the max value in the array from the index to the end\n        # 28. find the max value in the array from the index to the end\n        # 29. find the max value in the array from the index to the end\n        # 30. find the max value in the array from the index to the end\n        # 31. find the max value in the array from the index to the end\n        # 32. find the max value in the array from the index to the end\n        # 33. find the max value in the array from the index to the end\n        # 34. find the max value in the array from the index to the end\n        # 35. find the max value in the array from the index to the end\n        # 36. find the max value in the array from the index to the end\n        # 37. find the max value in the array from the index to the end\n        # 38. find the max value in the array from the index to the end\n        # 39. find the max value in the array from the index to the end\n        # 40. find the max value in the array from the index to the end\n        # 41. find the max value in the array from the index to the end\n        # 42. find the max value in the array from the index to the end\n        # 43. find the max value in the array from the index to the end\n        # 44. find the max value in the array from the index to the end\n        # 45. find the max value in the array from the index to the end\n        # 46. find the max value in the array from the index to the end\n        # 47. find the max value in the array from the index to the end\n        # 48. find the max value in the array from the index to the end\n        # 49. find the max value in the array from the index to the end\n        # 50. find the max value in the array from the index to the end\n        # 51. find the max value in the array from the index to the end\n        # 52. find the max value in the array from the index to the end\n        # 53. find the max value in the array from the index to the end"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                if prices[j] > prices[i]:\n                    max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        if not prices:\n            return 0\n        dp = [0] * len(prices)\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            dp[i] = max(dp[i-1], prices[i] - min_price)\n        return dp[-1]\n        \n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            max_profit = max(max_profit, prices[i] - min_price)\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n                \n        # return number of courses\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(s[0]) != 0:\n        #     return False\n        # for i in range(len(s)//len(s[0])):\n        #     if s[i*len(s[0]):] == s[0:len(s[0])]:\n        #         return True\n        # return False\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 2 ^ 2 = 0\n        ## 2 ^ 3 = 3\n        ## 3 ^ 2 = 1\n        ## 3 ^ 3 = 0\n        ## 4 ^ 4 = 0\n        ## 4 ^ 5 = 5\n        ## 5 ^ 4 = 3\n        ## 5 ^ 5 = 0\n        ## 6 ^ 6 = 0\n        ## 6 ^ 7 = 7\n        ## 7 ^ 6 = 3\n        ## 7 ^ 7 = 0\n        ## 8 ^ 8 = 0\n        ## 8 ^ 9 = 9\n        ## 9 ^ 8 = 3\n        ## 9 ^ 9 = 0\n        ## 10 ^ 10 = 0\n        ## 10 ^ 11 = 11\n        ## 11 ^ 10 = 3\n        ## 11 ^ 11 = 0\n        ## 12 ^ 12 = 0\n        ## 12 ^ 13 = 13\n        ## 13 ^ 12 = 3\n        ## 13 ^ 13 = 0\n        ## 14 ^ 14 = 0\n        ## 14 ^ 15 = 15\n        ## 15 ^ 14 = 3\n        ## 15 ^ 15 = 0\n        ## 16 ^ 16 = 0\n        ## 16 ^ 17 = 17\n        ## 17 ^ 16 = 3\n        ## 17 ^ 17 = 0\n        ## 18 ^ 18 = 0\n        ## 18 ^ 19 = 19\n        ## 19 ^ 18 = 3\n        ## 19 ^ 19 = 0\n        ## 20 ^ 20 = 0\n        ## 20 ^ 21 = 21\n        ## 21 ^ 20 = 3\n        ## 21 ^ 21 = 0\n        ## 22 ^ 22 = 0\n        ## 22 ^ 23 = 23\n        ## 23 ^ 22 = 3\n        ## 23 ^ 23 = 0\n        ## 24 ^ 24 = 0\n        ## 24 ^ 25 = 25\n        ## 25 ^ 24 = 3\n        ## 25 ^ 25 = 0\n        ## 26 ^ 26 = 0\n        ## 26 ^ 27 = 27\n        ## 27 ^ 26 = 3\n        ## 27 ^ 27 = 0\n        ## 28 ^ 28 = 0\n        ## 28 ^ 29 = 29\n        ## 29 ^ 28 = 3\n        ## 29 ^ 29 = 0\n        ## 30 ^ 30 = 0\n        ## 30 ^ 31 = 31\n        ## 31 ^ 30 = 3\n        ## 31 ^ 31 = 0\n        ## 32 ^ 32 = 0\n        ## 32 ^ 33 = 33\n        ## 33 ^ 32 = 3\n        ## 33 ^ 33 = 0\n        ## 34 ^ 34 = 0\n        ## 34 ^ 35 = 35\n        ## 35 ^ 34 = 3\n        ## 35 ^ 35 = 0\n        ## 36 ^ 36 = 0\n        ## 36 ^ 37 = 37\n        ## 37 ^ 36 = 3\n        ## 37 ^ 37 = 0\n        ## 38 ^ 38 = 0\n        ## 38 ^ 39 = 39\n        ## 39 ^ 38 = 3"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not target.startswith(sticker):\n                    continue\n                res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[0]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1650,2435,2435,1650,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,441,1234,2400,3432,3432,2400,1234,441,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,495,1406,3042,4782,5788,5050,3432,1650,495,100,16,1]\n        if rowIndex == 17:\n            return [1,17,111,567,1780,4032,7082,9248,9248,7082,4032,1780,567,111,17,1]\n        if rowIndex == 18:\n            return [1,18,122,666,2280,5376,9248,12000,12000,9248,5376,2280,666,122,18,1]\n        if rowIndex == 19:\n            return [1,19,133,777,3030,7770,15540,25200,30240,25200,15540,7770,3030,777,133,19,1]\n        if rowIndex == 20:\n            return [1,20,144,888,3888,10388,20776,32256,36384,32256,20776,10388,3888,888,144,20,1]\n        if"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc \uad6c\ud558\uae30\n        # 2. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4\uc758 \uc57d\uc218 \uad6c\ud558\uae30\n        # 3. \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4 \uc911 \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 4. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 5. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 6. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 7. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 8. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 9. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 10. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 11. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 12. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 13. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 14. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 15. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 16. \uc81c\uacf1\uadfc \uad6c"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"_\" + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        \n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                        if neighbor in graph:\n                            for neighbor2 in graph[neighbor]:\n                                if neighbor2 == endWord:\n                                    res.append([beginWord, neighbor, neighbor2])\n                                else:\n                                    queue.append(neighbor2)\n                                    visited.add(neighbor2)\n            if endWord in visited:\n                break\n        \n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return max(height(root.left), height(root.right)) + 1\n        \n        if not root:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc624\ub978\ucabd \ub192\uc774\ub97c \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 2. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc624\ub978\ucabd \ub192\uc774\ub97c \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 3. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc624\ub978\ucabd \ub192\uc774\ub97c \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 4. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc624\ub978\ucabd \ub192\uc774\ub97c \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 5. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc624\ub978\ucabd \ub192\uc774\ub97c \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 6. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc624\ub978\ucabd \ub192\uc774\ub97c \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 7. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd \ub192\uc774\ubcf4\ub2e4 \uc791\uc740 \uacbd\uc6b0 \ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles:\n            return False\n        \n        if (x_max, y_min) not in rectangles:\n            return False\n        \n        if (x_min, y_max) not in rectangles:\n            return False\n        \n        if (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 3. 26\u8fdb\u5236\u8f6c\u6362\n        # 4. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 5. 26\u8fdb\u5236\u8f6c\u6362\n        # 6. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 7. 26\u8fdb\u5236\u8f6c\u6362\n        # 8. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 9. 26\u8fdb\u5236\u8f6c\u6362\n        # 10. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 11. 26\u8fdb\u5236\u8f6c\u6362\n        # 12. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 13. 26\u8fdb\u5236\u8f6c\u6362\n        # 14. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 15. 26\u8fdb\u5236\u8f6c\u6362\n        # 16. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 17. 26\u8fdb\u5236\u8f6c\u6362\n        # 18. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 19. 26\u8fdb\u5236\u8f6c\u6362\n        # 20. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 21. 26\u8fdb\u5236\u8f6c\u6362\n        # 22. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 23. 26\u8fdb\u5236\u8f6c\u6362\n        # 24. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 25. 26\u8fdb\u5236\u8f6c\u6362\n        # 26. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 27. 26\u8fdb\u5236\u8f6c\u6362\n        # 28. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 29. 26\u8fdb\u5236\u8f6c\u6362\n        # 30. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 31. 26\u8fdb\u5236\u8f6c\u6362\n        # 32. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 33. 26\u8fdb\u5236\u8f6c\u6362\n        # 34. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 35. 26\u8fdb\u5236\u8f6c\u6362\n        # 36. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 37. 26\u8fdb\u5236\u8f6c\u6362\n        # 38. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 39. 26\u8fdb\u5236\u8f6c\u6362\n        # 40. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 41. 26\u8fdb\u5236\u8f6c\u6362\n        # 42. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 43. 26\u8fdb\u5236\u8f6c\u6362\n        # 44. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 45. 26\u8fdb\u5236\u8f6c\u6362\n        # 46. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 47. 26\u8fdb\u5236\u8f6c\u6362\n        # 48. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 49. 26\u8fdb\u5236\u8f6c\u6362\n        # 50. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 51. 26\u8fdb\u5236\u8f6c\u6362\n        # 52. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 53. 26\u8fdb\u5236\u8f6c\u6362\n        # 54. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 55. 26\u8fdb\u5236\u8f6c\u6362\n        # 56. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 57. 26\u8fdb\u5236\u8f6c\u6362\n        # 58. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 59. 26\u8fdb\u5236\u8f6c\u6362\n        # 60. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 61. 26\u8fdb\u5236\u8f6c\u6362\n        # 62. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 63. 26\u8fdb\u5236\u8f6c\u6362\n        # 64. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 65. 26\u8fdb\u5236\u8f6c\u6362\n        # 66. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 67. 26\u8fdb\u5236\u8f6c\u6362\n        # 68. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 69. 26\u8fdb\u5236\u8f6c\u6362\n        # 70. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 71. 26\u8fdb\u5236\u8f6c\u6362\n        # 72. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 73. 26\u8fdb\u5236\u8f6c\u6362\n        # 74. \u4ece\u540e\u5f80\u524d"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        return False\n            return True\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if get_goal(board):\n                    return moves\n                for neighbor in get_neighbors(board):\n                    if neighbor not in visited:\n                        visited.add(tuple(neighbor))\n                        queue.append((neighbor, moves + 1))\n            return -1\n        \n        return bfs(tuple(board))"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n        \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        def find_mode(root):\n            if not root:\n                return []\n            left = find_mode(root.left)\n            right = find_mode(root.right)\n            if root.val in left:\n                return [root.val] + left\n            elif root.val in right:\n                return [root.val] + right\n            else:\n                return left + right\n        \n        return find_mode(root)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        currRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[currRow] += c\n            if currRow == 0 or currRow == numRows - 1:\n                goingDown = not goingDown\n            currRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-04-22\n        ## 1. Find the max height of left and right\n        ## 2. Find the min height of left and right\n        ## 3. Find the min height of left and right\n        ## 4. Find the min height of left and right\n        ## 5. Find the min height of left and right\n        ## 6. Find the min height of left and right\n        ## 7. Find the min height of left and right\n        ## 8. Find the min height of left and right\n        ## 9. Find the min height of left and right\n        ## 10. Find the min height of left and right\n        ## 11. Find the min height of left and right\n        ## 12. Find the min height of left and right\n        ## 13. Find the min height of left and right\n        ## 14. Find the min height of left and right\n        ## 15. Find the min height of left and right\n        ## 16. Find the min height of left and right\n        ## 17. Find the min height of left and right\n        ## 18. Find the min height of left and right\n        ## 19. Find the min height of left and right\n        ## 20. Find the min height of left and right\n        ## 21. Find the min height of left and right\n        ## 22. Find the min height of left and right\n        ## 23. Find the min height of left and right\n        ## 24. Find the min height of left and right\n        ## 25. Find the min height of left and right\n        ## 26. Find the min height of left and right\n        ## 27. Find the min height of left and right\n        ## 28. Find the min height of left and right\n        ## 29. Find the min height of left and right\n        ## 30. Find the min height of left and right\n        ## 31. Find the min height of left and right\n        ## 32. Find the min height of left and right\n        ## 33. Find the min height of left and right\n        ## 34. Find the min height of left and right\n        ## 35. Find the min height of left and right\n        ## 36. Find the min height of left and right\n        ## 37. Find the min height of left and right\n        ## 38. Find the min height of left and right\n        ## 39. Find the min height of left and right\n        ## 40. Find the min height of left and right\n        ## 41. Find the min height of left and right\n        ## 42. Find the min height of left and right\n        ## 43. Find the min height of left and right\n        ## 44. Find the min height of left and right\n        ## 45. Find the min height of left and right\n        ## 46. Find the min height of left and right\n        ## 47. Find the min height of left and right\n        ## 48. Find the min height of left and right\n        ## 49. Find the min height of left and right\n        ## 50. Find the min height of left and right\n        ## 51. Find the min height of left and right\n        ## 52. Find the min height of left and right\n        ## 53. Find the min height of left and right\n        ## 54. Find the min height of left and right\n        ## 55. Find the min height of left and right\n        ## 56. Find the min height of left and right\n        ## 57. Find the min height of left and right\n        ## 58. Find the min height of left and right\n        ## 59. Find the min height of left and right\n        ## 60. Find the min height of left and right\n        ## 61. Find the min height of left and right\n        ## 6"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1 <= n <= 10\u2075\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <="}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n                continue\n            if intervals[i][0] > intervals[i-1][1]:\n                ans += 2\n            else:\n                ans += 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(left, right, curr, res):\n            if left == right == n:\n                res.append(curr)\n                return\n            if left < n:\n                backtrack(left + 1, right, curr + '(', res)\n            if right < left:\n                backtrack(left, right + 1, curr + ')', res)\n        \n        res = []\n        backtrack(0, 0, '', res)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                count += 1\n                n = n * 2\n        \n        return count"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        result = str(sign * quotient) + \".\"\n        \n        remainder_dict = {}\n        \n        while remainder != 0:\n            if remainder in remainder_dict:\n                result += \"(\"\n                result += \"\".join(result[remainder_dict[remainder]:])\n                result += \")\"\n                break\n            remainder_dict[remainder] = len(result)\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            result += str(quotient)\n        \n        return result"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        max_len = 1\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_len = max(max_len, dp[i])\n        \n        return max_len"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move the slow pointer until the fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 99.95% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 14.5 MB, less than 99.95% of Python online submissions for Intersection of Two Arrays.\n        ## 2021.05.27\n        ## 2021.05.28\n        ## 2021.05.29\n        ## 2021.05.30\n        ## 2021.05.31\n        ## 2021.06.01\n        ## 2021.06.02\n        ## 2021.06.03\n        ## 2021.06.04\n        ## 2021.06.05\n        ## 2021.06.06\n        ## 2021.06.07\n        ## 2021.06.08\n        ## 2021.06.09\n        ## 2021.06.10\n        ## 2021.06.11\n        ## 2021.06.12\n        ## 2021.06.13\n        ## 2021.06.14\n        ## 2021.06.15\n        ## 2021.06.16\n        ## 2021.06.17\n        ## 2021.06.18\n        ## 2021.06.19\n        ## 2021.06.20\n        ## 2021.06.21\n        ## 2021.06.22\n        ## 2021.06.23\n        ## 2021.06.24\n        ## 2021.06.25\n        ## 2021.06.26\n        ## 2021.06.27\n        ## 2021.06.28\n        ## 2021.06.29\n        ## 2021.06.30\n        ## 2021.06.31\n        ## 2021.07.01\n        ## 2021.07.02\n        ## 2021.07.03\n        ## 2021.07.04\n        ## 2021.07.05\n        ## 2021.07.06\n        ## 2021.07.07\n        ## 2021.07.08\n        ## 2021.07.09\n        ## 2021.07.10\n        ## 2021.07.11\n        ## 2021.07.12\n        ## 2021.07.13\n        ## 2021.07.14\n        ## 2021.07.15\n        ## 2021.07.16\n        ## 2021.07.17\n        ## 2021.07.18\n        ## 2021.07.19\n        ## 2021.07.20\n        ## 2021.07.21\n        ## 2021.07.22\n        ## 2021.07.23\n        ## 2021.07.24\n        ## 2021.07.25"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total / n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i]\n            right = max(right, curr)\n            curr -= avg\n            ans = max(ans, right - avg * i)\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, n):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            subset = []\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 5. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 6. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 7. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 8. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 9. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 10. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 11. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 12. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 13. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 14. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.2 MB, less than 100."}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        if i * i == num:\n            return True\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, word, visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i + 1, j, word[1:], visited) or dfs(i - 1, j, word[1:], visited) or dfs(i, j + 1, word[1:], visited) or dfs(i, j - 1, word[1:], visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i, j, word, [[False] * len(board[0]) for _ in range(len(board))]):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0,9,3):\n                for j in range(0,9,3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        s = s.split()\n        s.reverse()\n        return ' '.join(s)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. convert each character to a number\n        # 4. add the numbers together\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. convert each character to a number\n        columnTitle = [ord(i) - 64 for i in columnTitle]\n        \n        # 4. add the numbers together\n        columnTitle = sum(columnTitle)\n        \n        return columnTitle"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(s) != len(pattern):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if s[i] not in d.values():\n                    d[pattern[i]] = s[i]\n                else:\n                    return False\n            else:\n                if d[pattern[i]] != s[i]:\n                    return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if matrix[i][j] == target:\n                        return True\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        ## reverse the binary string\n        binary = binary[::-1]\n        ## convert to integer\n        binary = int(binary, 2)\n        ## convert to binary\n        binary = bin(binary)[2:]\n        ## reverse the binary string\n        binary = binary[::-1]\n        ## convert to integer\n        binary = int(binary, 2)\n        return binary"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        \n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign * res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. return the third max\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}