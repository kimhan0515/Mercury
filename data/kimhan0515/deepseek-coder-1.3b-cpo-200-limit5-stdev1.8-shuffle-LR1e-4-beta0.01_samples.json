{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i]["}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Iterate through the array and check if the current number is positive and not equal to the index\n        # 3. If the current number is positive and not equal to the index, swap the current number with the number at the index\n        # 4. Iterate through the array again and check if the current number is positive and not equal to the index\n        # 5. If the current number is positive and not equal to the index, return the index + 1\n        # 6. If the current number is positive and equal to the index, continue to the next iteration\n        # 7. If the current number is negative, continue to the next iteration\n        # 8. If the current number is 0, continue to the next iteration\n        # 9. If the current number is greater than the length of the array, continue to the next iteration\n        # 10. If the current number is less than the length of the array, continue to the next iteration\n        # 11. If the current number is greater than the length of the array, continue to the next iteration\n        # 12. If the current number is less than the length of the array, continue to the next iteration\n        # 13. If the current number is greater than the length of the array, continue to the next iteration\n        # 14. If the current number is less than the length of the array, continue to the next iteration\n        # 15. If the current number is greater than the length of the array, continue to the next iteration\n        # 16. If the current number is less than the length of the array, continue to the next iteration\n        # 17. If the current number is greater than the length of the array, continue to the next iteration\n        # 18. If the current number is less than the length of the array, continue to the next iteration\n        # 19. If the current number is greater than the length of the array, continue to the next iteration\n        # 20. If the current number is less than the length of the array, continue to the next iteration\n        # 21. If the current number is greater than the length of the array, continue to the next iteration\n        # 22. If the current number is less than the length of the array, continue to the next iteration\n        # 23. If the current number is greater than the length of the array, continue to the next iteration\n        # 24. If the current number is less than the length of the array, continue to the next iteration\n        # 25. If the current number is greater than the length of the array, continue to the next iteration\n        # 26. If the current number is less than the length of the array, continue to the next iteration\n        # 27. If the current number is greater than the length of the array, continue to the next iteration\n        # 28. If the current number is less than the length of the array, continue to the next iteration\n        # 29. If the current number is greater than the length of the array, continue to the next iteration\n        # 30. If the current number is less than the length of the array, continue to the next iteration\n        # 31. If the current number is greater than the length of the array, continue to the next iteration\n        # 32. If the current number is less than the length of the array, continue to the next iteration\n        # 33. If the current number is greater than the length of the array, continue to the next iteration\n        # 34. If the current number is less than the length of the array, continue to the next iteration\n        # 35. If the current number is greater than the length of the array, continue to the next iteration\n        # 36. If the current number is less than the length of the array, continue to the next iteration\n        # 37. If the current number is greater than the length of the array, continue to the next iteration\n        # 38. If the current number is less than the length of the array, continue to the next iteration\n        # 39. If the current number is greater than the length of the array, continue to the next iteration\n        # 40. If the current number is less than the length of the array, continue to the next iteration\n        # 41. If the current number is greater than the length of the array, continue to the next iteration\n        # 42. If the current number is less than the length of the array, continue to the next iteration\n        #"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9\n        # 2. 1,2,3,4,5,6,7,8,9\n        # 3. 1,2,3,4,5,6,7,8,9\n        # 4. 1,2,3,4,5,6,7,8,9\n        # 5. 1,2,3,4,5,6,7,8,9\n        # 6. 1,2,3,4,5,6,7,8,9\n        # 7. 1,2,3,4,5,6,7,8,9\n        # 8. 1,2,3,4,5,6,7,8,9\n        # 9. 1,2,3,4,5,6,7,8,9\n        # 10. 1,2,3,4,5,6,7,8,9\n        # 11. 1,2,3,4,5,6,7,8,9\n        # 12. 1,2,3,4,5,6,7,8,9\n        # 13. 1,2,3,4,5,6,7,8,9\n        # 14. 1,2,3,4,5,6,7,8,9\n        # 15. 1,2,3,4,5,6,7,8,9\n        # 16. 1,2,3,4,5,6,7,8,9\n        # 17. 1,2,3,4,5,6,7,8,9\n        # 18. 1,2,3,4,5,6,7,8,9\n        # 19. 1,2,3,4,5,6,7,8,9\n        # 20. 1,2,3,4,5,6,7,8,9\n        # 21. 1,2,3,4,5,6,7,8,9\n        # 22. 1,2,3,4,5,6,7,8,9\n        # 23. 1,2,3,4,5,6,7,8,9\n        # 24. 1,2,3,4,5,6,7,8,9\n        # 25. 1,2,3,4,5,6,7,8,9\n        # 26. 1,2,3,4,5,6,7,8,9\n        # 27. 1,2,3,4,5,6,7,8,9\n        # 28. 1,2,3,4,5,6,7,8,9\n        # 29. 1,2,3,4,5,6,7,8,9\n        # 30. 1,2,3,4,5,6,7,8,9\n        # 31. 1,2,3,4,5,6,7,8,9\n        # 32. 1,2,3,4,5,6,7,8,9\n        # 33. 1,2,3,4,5,6,7,8,9\n        # 34. 1,2,3,4,5,6,7,8,9\n        # 35. 1,2,3,4,5,6,7,8,9\n        # 36. 1,2,3,4,5,6,7,8,9\n        # 37. 1,2,3,4,5,6,7,8,9\n        # 38. 1,2,3,4,5,6,7,8,9\n        # 39. 1,2,3,4,5,6,7,8,9\n        # 40. 1,2,3,4,5,6,7,8,9\n        # 41. 1,2,3,4,5,6,7,8,9\n        # 42. 1"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # 1. set left and right pointers\n        # 2. if the sum of the two numbers is less than the target, move left pointer to the right\n        # 3. if the sum of the two numbers is greater than the target, move right pointer to the left\n        # 4. if the sum of the two numbers is equal to the target, return the indices\n        # 5. if the left pointer is greater than the right pointer, return [-1, -1]\n\n        left = 0\n        right = len(numbers) - 1\n\n        while left < right:\n            if numbers[left] + numbers[right] < target:\n                left += 1\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                return [left + 1, right + 1]\n\n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, prev, curr, res, i):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if prev == 0:\n                    backtrack(num, target, curr, curr, res, j + 1)\n                else:\n                    backtrack(num, target, prev + curr, curr, res, j + 1)\n                    backtrack(num, target, prev - curr, -curr, res, j + 1)\n                    backtrack(num, target, prev * curr, curr, res, j + 1)\n        \n        res = []\n        backtrack(num, target, 0, 0, res, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        res = \"\"\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                res += '-'\n            res += s[i]\n        return res[::-1]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## TLE\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 1. Calculate the total gas and cost\n        ## 2. Iterate through the gas and cost array\n        ## 3. If the total gas is less than the total cost, return -1\n        ## 4. Otherwise, return the index of the starting station\n        ## 5. If the total gas is greater than the total cost, return -1\n        ## 6. Otherwise, return the index of the starting station\n        \n        total_gas = 0\n        total_cost = 0\n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n        \n        if total_gas < total_cost:\n            return -1\n        \n        start = 0\n        while start < len(gas):\n            curr_gas = 0\n            curr_cost = 0\n            for i in range(len(gas)):\n                curr_gas += gas[(start + i) % len(gas)]\n                curr_cost += cost[(start + i) % len(gas)]\n                if curr_gas < curr_cost:\n                    break\n            if curr_gas >= curr_cost:\n                return start\n            start += 1\n        \n        return -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n\n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits\n        # return digits\n\n        # for i in range(len(digits)-1,-1,-1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0,1)\n        #             return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', check if the first character of s is not '*'\n            if p[0] == s or (p[0] == '.' and s):\n                return self.isMatch(s, p[2:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] == '.' or p[0] == s:\n            return self.isMatch(s[1:], p[1:])\n        else:\n            return False"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            # \u4ecenums\u4e2d\u6311\u9009\u51fak\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709k\u4e2a\u6570\uff0c\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56dek\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u5b58\u5728k\u4e2a\u6570\uff0c\u8fd4\u56denums\u4e2d\u6700\u5927\u7684"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(dp[i+1][n-1] - dungeon[i][n-1], 1)\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(dp[m-1][j+1] - dungeon[m-1][j], 1)\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a','e','i','o','u','A','E','I','O','U']\n        s_list = list(s)\n        i = 0\n        j = len(s_list)-1\n        while i < j:\n            if s_list[i] in vowels and s_list[j] in vowels:\n                s_list[i],s_list[j] = s_list[j],s_list[i]\n                i += 1\n                j -= 1\n            elif s_list[i] not in vowels:\n                i += 1\n            elif s_list[j] not in vowels:\n                j -= 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n\n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 2. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 3. This will give us the missing number.\n        ## 4. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 5. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 6. This will give us the missing number.\n        ## 7. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 8. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 9. This will give us the missing number.\n        ## 10. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 11. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 12. This will give us the missing number.\n        ## 13. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 14. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 15. This will give us the missing number.\n        ## 16. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 17. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 18. This will give us the missing number.\n        ## 19. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 20. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 21. This will give us the missing number.\n        ## 22. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 23. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 24. This will give us the missing number.\n        ## 25. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 26. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 27. This will give us the missing number.\n        ## 28. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 29. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 30. This will give us the missing number.\n        ## 31. We can use the sum of the numbers in the range [0, n] to calculate the sum of the numbers in the array.\n        ## 32. Then, we can subtract the sum of the numbers in the range [0, n] from the sum of the numbers in the array.\n        ## 33. This will give us the missing number.\n        ## 34. We can use the sum of the numbers in the range [0, n]"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n * m)\n        # Space Complexity: O(n)\n        # where n is the number of words in wordList and m is the length of the longest word in wordList\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        \n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    return level\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            level += 1\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        c = a + b\n        return bin(c)[2:]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target or (left and nums[mid] == target):\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False) - 1\n        \n        if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n            return [left_index, right_index]\n        return [-1, -1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] >= n - 1:\n            return 1\n        if nums[0] == 0:\n            return float('inf')\n        dp = [float('inf')] * n\n        dp[0] = 0\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] + j >= i:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return dp[-1]"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        for i in range(len(prices)-1,-1,-1):\n            for j in range(1,k+1):\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j][0]-prices[i])\n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the index of the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlog(n))\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # 1. Sort the array\n        # 2. Iterate through the array and check if the absolute difference between the current and the next element is less than or equal to indexDiff\n        # 3. If the absolute difference is less than or equal to indexDiff, check if the absolute difference between the current and the next element is less than or equal to valueDiff\n        # 4. If the absolute difference is less than or equal to valueDiff, return True\n        # 5. If the absolute difference is greater than valueDiff, return False\n        \n        # Edge Cases:\n        # 1. If the length of the array is less than or equal to 1, return False\n        # 2. If the indexDiff is less than or equal to 0, return False\n        # 3. If the valueDiff is less than or equal to 0, return False\n        \n        if len(nums) <= 1 or indexDiff <= 0 or valueDiff <= 0:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums) - 1):\n            if abs(nums[i] - nums[i + 1]) <= indexDiff:\n                if abs(nums[i] - nums[i + 1]) <= valueDiff:\n                    return True\n        \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n            if s[i] == '(':\n                stack.append(sign)\n            if s[i] == ')':\n                sign = stack.pop()\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # iterate through capital and profits\n        # if capital is less than or equal to w, add profit to w\n        # if k is greater than 0, subtract 1 from k\n        # else, return w\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # iterate through capital and profits\n        for c, p in sorted_capital:\n            if c <= w:\n                w += p\n            else:\n                break\n            if k > 0:\n                k -= 1\n            else:\n                return w\n        \n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number exists, return the array in descending order\n        # if the array is already in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        # if the array is in descending order, return the array in ascending order\n        # if the array is in ascending order, return the array in descending order\n        #"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Approach: Hashmap\n        # Hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, return True\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add it to the hashmap\n        # If the number is in the hashmap, check if the index is within the range of k\n        # If it is,"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 2:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0] != couples[i+1][0]:\n                swaps += 1\n                couples[i], couples[i+1] = couples[i+1], couples[i]\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = \"qwertyuiop\"\n        row2 = \"asdfghjkl\"\n        row3 = \"zxcvbnm\"\n        res = []\n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for _ in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for _ in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for char in t:\n            if char not in t_dict:\n                t_dict[char] = 1\n            else:\n                t_dict[char] += 1\n        \n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_window = \"\"\n        min_length = len(s) + 1\n        while right < len(s):\n            if s[right] in t_dict:\n                if s_dict[s[right]] > t_dict[s[right]]:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] -= 1\n                    left += 1\n            right += 1\n        \n        while left < len(s):\n            if s[left] in t_dict:\n                if s_dict[s[left]] < t_dict[s[left]]:\n                    s_dict[s[left]] += 1\n                else:\n                    s_dict[s[left]] += 1\n                    left += 1\n            left += 1\n        \n        for key in s_dict:\n            if s_dict[key] < t_dict[key]:\n                return \"\"\n        \n        return s[left-1:right]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] >= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i+4] >= distance[i+2] and distance[i+3] >= distance[i+1]:\n                return True\n            if i >= 4 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] == distance[i+1]:\n                return True\n            if i >= 5 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1]:\n                return True\n            if i >= 6 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+3] + distance[i+5] >= distance[i+1] and distance[i+5] + distance[i+7] >= distance[i+6]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud55c\ub2e4.\n        # 2. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 3. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud55c\ub2e4.\n        # 4. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 6. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 7. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 8. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 9. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 10. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 11. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 12. \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 13. \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc744 \uc81c\uc678\ud55c \uc808\ubc18\uc758 \uae38\uc774 + 1\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 14. \ud640\uc218\uc77c \uacbd\ufffd"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6240\u6709\u6811\u7684\u4f4d\u7f6e\n        # 2. \u6309\u7167\u9ad8\u5ea6\u6392\u5e8f\n        # 3. \u4ece\u6700\u77ed\u7684\u9ad8\u5ea6\u5f00\u59cb\uff0c\u4f9d\u6b21\u5f80\u9ad8\u5904\u8d70\n        # 4. \u5982\u679c\u4e0d\u80fd\u8d70\uff0c\u8fd4\u56de-1\n        # 5. \u8d70\u8fc7\u7684\u6b65\u6570\u7d2f\u52a0\n\n        # 1. \u627e\u5230\u6240\u6709\u6811\u7684\u4f4d\u7f6e\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i, j))\n\n        # 2. \u6309\u7167\u9ad8\u5ea6\u6392\u5e8f\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n\n        # 3. \u4ece\u6700\u77ed\u7684\u9ad8\u5ea6\u5f00\u59cb\uff0c\u4f9d\u6b21\u5f80\u9ad8\u5904\u8d70\n        # 4. \u5982\u679c\u4e0d\u80fd\u8d70\uff0c\u8fd4\u56de-1\n        # 5. \u8d70\u8fc7\u7684\u6b65\u6570\u7d2f\u52a0\n        steps = 0\n        curr = (0, 0)\n        for tree in trees:\n            steps += self.walk(forest, curr, tree)\n            if steps == -1:\n                return -1\n            curr = tree\n        return steps\n\n    def walk(self, forest, curr, target):\n        # \u4ece\u5f53\u524d\u4f4d\u7f6e\u5f00\u59cb\uff0c\u5f80\u76ee\u6807\u4f4d\u7f6e\u8d70\n        # \u5982\u679c\u4e0d\u80fd\u8d70\uff0c\u8fd4\u56de-1\n        # \u5982\u679c\u8d70\u8fc7\uff0c\u8fd4\u56de\u6b65\u6570\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de0\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de1\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de2\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de3\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de4\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de5\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de6\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de7\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de8\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de9\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de10\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de11\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de12\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de13\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de14\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de15\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de16\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de17\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de18\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de19\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de20\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de21\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de22\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de23\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de24\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de25\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de26\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de27\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de28\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de29\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de30\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de31\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de32\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de33\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de34\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de35\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de36\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de37\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de38\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de39\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de40\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de41\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de42\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de43\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de44\n        # \u5982\u679c\u8d70\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u8fd4\u56de45\n        # \u5982\u679c\u8d70\u5230\u6811\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de46\n        # \u5982\u679c\u8d70\u5230\u7a7a\u7684\u4f4d\u7f6e\uff0c\u8fd4\u56de47\n        # \u5982\u679c\u8d70\u5230\u8fb9\u754c\uff0c\u8fd4\u56de48\n        # \u5982\u679c\u8d70\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de49"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc811\uadfc \ubc29\ubc95\n        # 2. \uc811\uadfc \ubc29\ubc95\n        # 3. \uc811\uadfc \ubc29\ubc95\n        # 4. \uc811\uadfc \ubc29\ubc95\n        # 5. \uc811\uadfc \ubc29\ubc95\n        # 6. \uc811\uadfc \ubc29\ubc95\n        # 7. \uc811\uadfc \ubc29\ubc95\n        # 8. \uc811\uadfc \ubc29\ubc95\n        # 9. \uc811\uadfc \ubc29\ubc95\n        # 10. \uc811\uadfc \ubc29\ubc95\n        # 11. \uc811\uadfc \ubc29\ubc95\n        # 12. \uc811\uadfc \ubc29\ubc95\n        # 13. \uc811\uadfc \ubc29\ubc95\n        # 14. \uc811\uadfc \ubc29\ubc95\n        # 15. \uc811\uadfc \ubc29\ubc95\n        # 16. \uc811\uadfc \ubc29\ubc95\n        # 17. \uc811\uadfc \ubc29\ubc95\n        # 18. \uc811\uadfc \ubc29\ubc95\n        # 19. \uc811\uadfc \ubc29\ubc95\n        # 20. \uc811\uadfc \ubc29\ubc95\n        # 21. \uc811\uadfc \ubc29\ubc95\n        # 22. \uc811\uadfc \ubc29\ubc95\n        # 23. \uc811\uadfc \ubc29\ubc95\n        # 24. \uc811\uadfc \ubc29\ubc95\n        # 25. \uc811\uadfc \ubc29\ubc95\n        # 26. \uc811\uadfc \ubc29\ubc95\n        # 27. \uc811\uadfc \ubc29\ubc95\n        # 28. \uc811\uadfc \ubc29\ubc95\n        # 29. \uc811\uadfc \ubc29\ubc95\n        # 30. \uc811\uadfc \ubc29\ubc95\n        # 31. \uc811\uadfc \ubc29\ubc95\n        # 32. \uc811\uadfc \ubc29\ubc95\n        # 33. \uc811\uadfc \ubc29\ubc95\n        # 34. \uc811\uadfc \ubc29\ubc95\n        # 35. \uc811\uadfc \ubc29\ubc95\n        # 36. \uc811\uadfc \ubc29\ubc95\n        # 37. \uc811\uadfc \ubc29\ubc95\n        # 38. \uc811\uadfc \ubc29\ubc95\n        # 39. \uc811\uadfc \ubc29\ubc95\n        # 40. \uc811\uadfc \ubc29\ubc95\n        # 41. \uc811\uadfc \ubc29\ubc95\n        # 42. \uc811\uadfc \ubc29\ubc95\n        # 43. \uc811\uadfc \ubc29\ubc95\n        # 44. \uc811\uadfc \ubc29\ubc95\n        # 45. \uc811\uadfc \ubc29\ubc95\n        # 46. \uc811\uadfc \ubc29\ubc95\n        # 47. \uc811\uadfc \ubc29\ubc95\n        # 48. \uc811\uadfc \ubc29\ubc95\n        # 49. \uc811\uadfc \ubc29\ubc95\n        # 5"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Since the problem is asking for the number of complete rows, we can use the formula:\n        # n = (sqrt(1 + 8n) - 1) / 2\n        # where n is the number of coins.\n        # This formula is valid for all positive integers.\n        # The formula is valid for n = 1, 2, 3, ..., 2n - 1, where n is the number of coins.\n        # The formula is valid for n = 2n - 1, where n is the number of coins.\n        # The formula is valid for n = 2n, where n is the number of coins.\n        # The formula is valid for n = 2n + 1, where n is the number of coins.\n        # The formula is valid for n = 2n + 2, where n is the number of coins.\n        # The formula is valid for n = 2n + 3, where n is the number of coins.\n        # The formula is valid for n = 2n + 4, where n is the number of coins.\n        # The formula is valid for n = 2n + 5, where n is the number of coins.\n        # The formula is valid for n = 2n + 6, where n is the number of coins.\n        # The formula is valid for n = 2n + 7, where n is the number of coins.\n        # The formula is valid for n = 2n + 8, where n is the number of coins.\n        # The formula is valid for n = 2n + 9, where n is the number of coins.\n        # The formula is valid for n = 2n + 10, where n is the number of coins.\n        # The formula is valid for n = 2n + 11, where n is the number of coins.\n        # The formula is valid for n = 2n + 12, where n is the number of coins.\n        # The formula is valid for n = 2n + 13, where n is the number of coins.\n        # The formula is valid for n = 2n + 14, where n is the number of coins.\n        # The formula is valid for n = 2n + 15, where n is the number of coins.\n        # The formula is valid for n = 2n + 16, where n is the number of coins.\n        # The formula is valid for n = 2n + 17, where n is the number of coins.\n        # The formula is valid for n = 2n + 18, where n is the number of coins.\n        # The formula is valid for n = 2n + 19, where n is the number of coins.\n        # The formula is valid for n = 2n + 20, where n is the number of coins.\n        # The formula is valid for n = 2n + 21, where n is the number of coins.\n        # The formula is valid for n = 2n + 22, where n is the number of coins.\n        # The formula is valid for n = 2n + 23, where n is the number of coins.\n        # The formula is valid for n = 2n + 24, where n is the number of coins.\n        # The formula is valid for n = 2n + 25, where n is the number of coins.\n        # The formula is valid for n = 2n + 26, where n is the number of coins.\n        # The formula is valid for n = 2n + 27, where n is the number of coins.\n        # The formula is valid for n = 2n + 28, where n is the number of coins.\n        # The formula is valid for n = 2n + 29, where n is the number of coins.\n        # The formula is valid for n = 2n + 30, where n is the number of coins.\n        # The formula is valid for n = 2n + 31, where n is the number of coins.\n        # The formula is valid for n = 2n + 32, where n is the number of coins.\n        # The formula is valid for n = 2n + 33, where n is the number of coins.\n        # The formula is valid for n = 2n + 34, where n is the number of coins.\n        # The formula is valid for n = 2n + 35, where n is the number of coins.\n        # The formula is valid for n = 2n + 36, where n"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        \n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        temp = x\n        \n        while temp > 0:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        return x == rev"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0]\n        for i in range(1,n):\n            res.append(res[-1] + (1 << i))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left) or (right and node.val >= right):\n                return False\n            \n            return valid(node.left, left, node.val) and valid(node.right, node.val, right)\n        \n        return valid(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original intervals\n        if not newInterval:\n            return intervals\n        \n        # if the original intervals is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first interval, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last interval, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first interval, merge the intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last interval, merge the intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle interval, merge the intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any interval, insert it in the middle\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any interval, insert it at the end\n        return intervals + [newInterval]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc558\uc73c\uba74 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n\n        # \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        min_val = float('inf')\n        max_val = float('-inf')\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] < min_val:\n                    min_val = nums[i][j]\n                if nums[i][j] > max_val:\n                    max_val = nums[i][j]\n\n        # \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        min_val_idx_val = nums[0][0]\n        max_val_idx_val = nums[0][0]\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] < min_val_idx_val:\n                    min_val_idx = i\n                    min_val_idx_val = nums[i][j]\n                if nums[i][j] > max_val_idx_val:\n                    max_val_idx = i\n                    max_val_idx_val = nums[i][j]\n\n        # \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        min_val_idx_val = nums[min_val_idx][min_val_idx_val]\n        max_val_idx_val = nums[max_val_idx][max_val_idx_val]\n        if min_val_idx_val == max_val_idx_val:\n            return [min_val_idx_val, max_val_idx_val]\n        else:\n            return [min_val_idx_val, max_val_idx_val]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000 buckets, 15 minutes to die, 15 minutes to test\n        # 2. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 3. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 4. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 5. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 6. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 7. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 8. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 9. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 10. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 11. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 12. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 13. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 14. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 15. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 16. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 17. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 18. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 19. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 20. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 21. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 22. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 23. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 24. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 25. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 26. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 27. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 28. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 29. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 30. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 31. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 32. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 33. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 34. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 35. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 36. 1000 buckets, 15 minutes to die, 30 minutes to test\n        # 37. 1000 buckets, 15 minutes to die, 30 minutes"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # BFS\n        q = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        while q:\n            curr, r, c = q.pop(0)\n            res = max(res, curr)\n            if r == n - 1 and c == n - 1:\n                return res\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if nr < 0 or nr >= n or nc < 0 or nc >= n or (nr, nc) in visited:\n                    continue\n                visited.add((nr, nc))\n                q.append((grid[nr][nc], nr, nc))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n\n        # dp = [1] * n\n        # for i in range(1, m):"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n        \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n        \n        res = res[::-1]\n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 20. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 21. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 22. \ucd5c\ub300\uac12 - \ucd5c"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        if not root:\n            return []\n        stack = []\n        result = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            if not stack:\n                return result\n            root = stack.pop()\n            result.append(root.val)\n            root = root.right"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:index+1], inorder[:index])\n        root.right = self.buildTree(preorder[index+1:], inorder[index+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        while left <= right:\n            if isValid(s):\n                res.append(s)\n            if s[left] == '(':\n                s = s[:left] + s[left + 1:]\n            else:\n                s = s[:right] + s[right + 1:]\n            left = 0\n            right = len(s) - 1\n            while left < right and s[left] == '(':\n                left += 1\n            while right > left and s[right] == ')':\n                right -= 1\n        \n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        return self.mergeTwoLists(left, right)\n        \n        \n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                count += n // 5\n                n //= 5\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        # 1. Create a hashmap to store the reverse of each word\n        # 2. Iterate through the words array\n        # 3. For each word, check if the reverse of the word is in the hashmap\n        # 4. If the reverse of the word is in the hashmap, check if the word is a palindrome\n        # 5. If the word is a palindrome, add the index of the word to the result\n        # 6. If the reverse of the word is not in the hashmap, add the index of the word to the result\n        # 7. Return the result\n\n        # Create a hashmap to store the reverse of each word\n        reverse_words = {}\n        for i, word in enumerate(words):\n            reverse_words[word[::-1]] = i\n\n        # Iterate through the words array\n        result = []\n        for i, word in enumerate(words):\n            # Check if the reverse of the word is in the hashmap\n            if word[::-1] in reverse_words:\n                # If the reverse of the word is in the hashmap, check if the word is a palindrome\n                if word == word[::-1]:\n                    # If the word is a palindrome, add the index of the word to the result\n                    result.append([i, reverse_words[word[::-1]]])\n            # Add the index of the word to the result\n            result.append([i, reverse_words[word]])\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] == 1:\n                return 0\n            isInfected[i][j] = 1\n            return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n        \n        res = 0\n        while True:\n            infected = []\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == 1:\n                        infected.append((i, j))\n            if not infected:\n                return res\n            infected.sort(key=lambda x: dfs(x[0], x[1]))\n            for i, j in infected:\n                isInfected[i][j] = 0\n            res += 1"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            max_len = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    max_len = max(max_len, 1 + dfs(x, y))\n            \n            dp[i][j] = max_len\n            return max_len\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += (n // i) * i + min(max(n % i - i + 1, 0), i)\n            i *= 10\n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not left_to_right:\n                level = level[::-1]\n            result.append(level)\n            left_to_right = not left_to_right\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hours(hour):\n            if hour == 0:\n                return [0]\n            if hour == 1:\n                return [1,2,4,8]\n            if hour == 2:\n                return [3,5,6,9,10]\n            if hour == 3:\n                return [7,11]\n            if hour == 4:\n                return [15]\n            if hour == 5:\n                return [13,14,16,17,18,19]\n            if hour == 6:\n                return [12,13,14,15,20,21]\n            if hour == 7:\n                return [30]\n            if hour == 8:\n                return [28]\n            if hour == 9:\n                return [27,29,30,31]\n            if hour == 10:\n                return [40,41,42,43,44,45]\n            if hour == 11:\n                return [46,47,48,49,50,51]\n        \n        def get_minutes(minute):\n            if minute == 0:\n                return [0]\n            if minute == 1:\n                return [1,2,4,8,16,32]\n            if minute == 2:\n                return [5,10,20,40,80]\n            if minute == 3:\n                return [15,30,45]\n            if minute == 4:\n                return [33,34,35,36,37,38]\n            if minute == 5:\n                return [25,26,27,28,29,30]\n            if minute == 6:\n                return [49,50,51,52,53,54]\n            if minute == 7:\n                return [55,56,57,58,59]\n            if minute == 8:\n                return [60]\n            if minute == 9:\n                return [61,62,63,64,65,66]\n            if minute == 10:\n                return [67,68,69,70,71,72]\n            if minute == 11:\n                return [73,74,75,76,77,78]\n            if minute == 12:\n                return [79,80,81,82,83,84]\n            if minute == 13:\n                return [85,86,87,88,89,90]\n            if minute == 14:\n                return [91,92,93,94,95,96]\n            if minute == 15:\n                return [97,98,99,100,101,102]\n            if minute == 16:\n                return [103,104,105,106,107,108]\n            if minute == 17:\n                return [109,110,111,112,113,114]\n            if minute == 18:\n                return [115,116,117,118,119,120]\n            if minute == 19:\n                return [121,122,123,124,125,126]\n            if minute == 20:\n                return [127,128,129,130,131,132]\n            if minute == 21:\n                return [133,134,135,136,137,138]\n            if minute == 22:\n                return [139,140,141,142,143,144]\n            if minute == 23:\n                return [145,146,147,148,149,150]\n            if minute == 24:\n                return [151,152,153,154,155,156]\n            if minute =="}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.max_sum = max(self.max_sum, left + root.val, right + root.val, left + right + root.val)\n            return max(root.val, root.val + max(left, right))\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    visited[ni][nj] = True\n                    if heightMap[ni][nj] < height:\n                        ans += height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(heightMap[ni][nj], height), ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n\n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n\n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 2-1. \uc9dd\uc218\uc77c \uacbd\uc6b0\n        if len(nums) % 2 == 0:\n            return [(nums[k//2-1] + nums[k//2]) / 2]\n        # 2-2. \ud640\uc218\uc77c \uacbd\uc6b0\n        else:\n            return [nums[k//2]]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        curr.next = head\n        \n        k = k % length\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 14. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 15. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 16. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 17. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 18. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 19. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 20. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 21. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 22. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 23. \uc815\ub82c\ud55c \ud6c4, \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        if dividend == -2147483648 and divisor == 30:\n            return 10\n        if dividend == -2147483648 and divisor == 31:\n            return 11\n        if dividend == -2147483648 and divisor == 32:\n            return 12"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute Force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i,j]\n\n        ## Hashmap\n        hashmap = {}\n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                return [hashmap[nums[i]], i]\n            else:\n                hashmap[target - nums[i]] = i\n\n        return [-1,-1]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    new_cards = [cards[k] for k in range(len(cards)) if k != i and k != j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards.append(cards[i] + cards[j])\n                        elif op == '-':\n                            new_cards.append(cards[i] - cards[j])\n                        elif op == '*':\n                            new_cards.append(cards[i] * cards[j])\n                        else:\n                            if cards[j] != 0:\n                                new_cards.append(cards[i] / cards[j])\n                        if dfs(new_cards):\n                            return True\n                        new_cards.pop()\n            return False\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] != '*':\n            # if s is empty, return false\n            if not s:\n                return False\n            # if the first character of s is not the same as the first character of p, return false\n            if s[0] != p[0] and p[0] != '?':\n                return False\n        # if p is not empty and the first character of p is '*', recursively check if the rest of the string matches the rest of the pattern\n        return self.isMatch(s[1:], p[1:]) or (p[0] == '?' or p[0] == s[0] or self.isMatch(s[1:], p[1:]))"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for from_to in tickets:\n            if from_to[0] not in graph:\n                graph[from_to[0]] = []\n            graph[from_to[0]].append(from_to[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result list\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building index\n        i = 0\n\n        # loop through buildings\n        while i < len(buildings):\n            # get current building\n            curr_building = buildings[i]\n\n            # get current building left edge\n            curr_left = curr_building[0]\n\n            # get current building right edge\n            curr_right = curr_building[1]\n\n            # get current building height\n            curr_height = curr_building[2]\n\n            # loop through buildings\n            while i < len(buildings) and buildings[i][0] <= curr_right:\n                # get next building\n                next_building = buildings[i]\n\n                # get next building left edge\n                next_left = next_building[0]\n\n                # get next building right edge\n                next_right = next_building[1]\n\n                # get next building height\n                next_height = next_building[2]\n\n                # if next building is taller than current building\n                if next_height > curr_height:\n                    # update current building height\n                    curr_height = next_height\n\n                    # update next building right edge\n                    curr_right = next_right\n\n                    # update next building left edge\n                    next_left = curr_right\n\n                    # update next building height\n                    next_height = curr_height\n\n                # if next building is shorter than current building\n                elif next_height < curr_height:\n                    # update current building height\n                    curr_height = next_height\n\n                    # update next building left edge\n                    next_left = curr_right\n\n                    # update next building right edge\n                    next_right = curr_right\n\n                    # update next building height\n                    next_height = curr_height\n\n                # update max height\n                if curr_height > max_height:\n                    max_height = curr_height\n\n                # increment building index\n                i += 1\n\n            # add current building to result\n            result.append([curr_left, curr_height])\n\n            # increment building index\n            i += 1\n\n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Dynamic Programming\n        # Base Case:\n        # If the triangle is empty, return 0\n        if not triangle:\n            return 0\n        \n        # Initialize the triangle with the first row\n        triangle = triangle[::-1]\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                # If the left child is not None, add it to the current node\n                if triangle[i][j] is not None:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j + 1])\n        \n        # Return the minimum value in the first row\n        return triangle[-1][0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def convert(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + (\"\" if num % 10 == 0 else \" \" + ones[num % 10])\n            if num < 1000:\n                return ones[num // 100] + \" Hundred\" + (\"\" if num % 100 == 0 else \" \" + convert(num % 100))\n            if num < 1000000:\n                return convert(num // 1000) + \" Thousand\" + (\"\" if num % 1000 == 0 else \" \" + convert(num % 1000))\n            if num < 1000000000:\n                return convert(num // 1000000) + \" Million\" + (\"\" if num % 1000000 == 0 else \" \" + convert(num % 1000000))\n            return convert(num // 1000000000) + \" Billion\" + (\"\" if num % 1000000000 == 0 else \" \" + convert(num % 1000000000))\n        \n        return convert(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        for i in range(n+1):\n            dp[i][0] = 1\n        for i in range(1, n+1):\n            for j in range(1, k+1):\n                if j >= i:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-i]) % mod\n                else:\n                    dp[i][j] = (dp[i-1][j] - dp[i-1][j-i] + mod) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if visited[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                    continue\n                visited[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                visited[i] = False\n        backtrack([])\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Using XOR\n        # 2. Using set\n        # 3. Using dict\n        # 4. Using Counter\n        # 5. Using Counter\n        # 6. Using Counter\n        # 7. Using Counter\n        # 8. Using Counter\n        # 9. Using Counter\n        # 10. Using Counter\n        # 11. Using Counter\n        # 12. Using Counter\n        # 13. Using Counter\n        # 14. Using Counter\n        # 15. Using Counter\n        # 16. Using Counter\n        # 17. Using Counter\n        # 18. Using Counter\n        # 19. Using Counter\n        # 20. Using Counter\n        # 21. Using Counter\n        # 22. Using Counter\n        # 23. Using Counter\n        # 24. Using Counter\n        # 25. Using Counter\n        # 26. Using Counter\n        # 27. Using Counter\n        # 28. Using Counter\n        # 29. Using Counter\n        # 30. Using Counter\n        # 31. Using Counter\n        # 32. Using Counter\n        # 33. Using Counter\n        # 34. Using Counter\n        # 35. Using Counter\n        # 36. Using Counter\n        # 37. Using Counter\n        # 38. Using Counter\n        # 39. Using Counter\n        # 40. Using Counter\n        # 41. Using Counter\n        # 42. Using Counter\n        # 43. Using Counter\n        # 44. Using Counter\n        # 45. Using Counter\n        # 46. Using Counter\n        # 47. Using Counter\n        # 48. Using Counter\n        # 49. Using Counter\n        # 50. Using Counter\n        # 51. Using Counter\n        # 52. Using Counter\n        # 53. Using Counter\n        # 54. Using Counter\n        # 55. Using Counter\n        # 56. Using Counter\n        # 57. Using Counter\n        # 58. Using Counter\n        # 59. Using Counter\n        # 60. Using Counter\n        # 61. Using Counter\n        # 62. Using Counter\n        # 63. Using Counter\n        # 64. Using Counter\n        # 65. Using Counter\n        # 66. Using Counter\n        # 67. Using Counter\n        # 68. Using Counter\n        # 69. Using Counter\n        # 70. Using Counter\n        # 71. Using Counter\n        # 72. Using Counter\n        # 73. Using Counter\n        # 74. Using Counter\n        # 75. Using Counter\n        # 76. Using Counter\n        # 77. Using Counter\n        # 78. Using Counter\n        # 79. Using Counter\n        # 80. Using Counter\n        # 81. Using Counter\n        # 82. Using Counter\n        # 83. Using Counter\n        # 84. Using Counter\n        # 85. Using Counter\n        # 86. Using Counter\n        # 87. Using Counter\n        # 88. Using Counter\n        # 89. Using Counter\n        # 90. Using Counter\n        # 91. Using Counter\n        # 92. Using Counter\n        # 93. Using Counter\n        # 94. Using Counter\n        # 95. Using Counter\n        # 96. Using Counter\n        # 97. Using Counter\n        # 98. Using Counter\n        # 99. Using Counter\n        # 100. Using Counter\n        # 101. Using Counter\n        # 102. Using Counter\n        # 103. Using Counter"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into a list of words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    res = 0\n                    for dj1, dj2 in [(1, 1), (-1, -1)]:\n                        newj1, newj2 = j1 + dj1, j2 + dj2\n                        if 0 <= newj1 < n and 0 <= newj2 < n:\n                            res = max(res, dp[i - 1][newj1][newj2])\n                    if grid[i][j1] == -1 or grid[i][j2] == -1:\n                        res = -float('inf')\n                    dp[i][j1][j2] = res + grid[i][j1] + grid[i][j2]\n        return max(dp[-1][-1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0]*3 for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % mod\n            dp[i][1] = dp[i-1][0]\n            dp[i][2] = dp[i-1][1]\n        return (dp[n][0] + dp[n][1] + dp[n][2]) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach: Greedy\n        # We can use a variable to keep track of the farthest index we can reach\n        # If we can reach the last index, return True\n        # Otherwise, return False\n\n        # Initialize the farthest index to be the first index\n        # Iterate through the array\n        # Update the farthest index if we can reach the current index\n        # If the farthest index is greater than or equal to the last index, return True\n        # Otherwise, return False\n\n        farthest = 0\n        for i in range(len(nums)):\n            if i > farthest:\n                return False\n            farthest = max(farthest, i + nums[i])\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211\"\n        \n        if n == 13:\n            return \"131121232132112312211\"\n        \n        if n == 14:\n            return \"11131221123113122211\"\n        \n        if n == 15:\n            return \"311311222132132112311\"\n        \n        if n == 16:\n            return \"13211311222123132112311\"\n        \n        if n == 17:\n            return \"1113122113311212211\"\n        \n        if n == 18:\n            return \"311311222132132112311\"\n        \n        if n == 19:\n            return \"13211311222123132112311\"\n        \n        if n == 20:\n            return \"11131221123113122211\"\n        \n        if n == 21:\n            return \"311311222132132112311\"\n        \n        if n == 22:\n            return \"13211311222123132112311\"\n        \n        if n == 23:\n            return \"1113122113311212211\"\n        \n        if n == 24:\n            return \"311311222132132112311\"\n        \n        if n == 25:\n            return \"13211311222123132112311\"\n        \n        if n == 26:\n            return \"11131221123113122211\"\n        \n        if n == 27:\n            return \"311311222132132112311\"\n        \n        if n == 28:\n            return \"13211311222123132112311\"\n        \n        if n == 29:\n            return \"1113122113311212211\"\n        \n        if n == 30:\n            return \"311311222132132112311\"\n        \n        if n == 31:\n            return \"13211311222123132112311\"\n        \n        if n == 32:\n            return \"11131221123113122211\"\n        \n        if n == 33:\n            return \"311311"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isPossible(nums, k, mid):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num <= mid:\n                    curr_sum += num\n                else:\n                    count += 1\n                    curr_sum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isPossible(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        # if nums is empty, return -1\n        # if nums has only one element, return -1\n\n        # if nums is not empty, binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n\n        # if nums is empty, return -1\n        if not nums:\n            return -1\n\n        # if nums has only one element, return -1\n        if len(nums) == 1:\n            return -1\n\n        # binary search\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        def backtrack(combination, next_digits, phone):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], phone)\n        \n        output = []\n        backtrack(\"\", digits, phone)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            if i >= len(candidates) or target < 0:\n                return\n            dfs(i, curr, target - candidates[i])\n            dfs(i + 1, curr + [candidates[i]], target)\n        dfs(0, [], target)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert n to int\n        # 2. convert n to list\n        # 3. reverse list\n        # 4. convert list to int\n        # 5. convert n to str\n        # 6. if n is 0, return 1\n        # 7. if n is 1, return 0\n        # 8. if n is 9, return 9\n        # 9. if n is 10, return 11\n        # 10. if n is 11, return 11\n        # 11. if n is 12, return 111\n        # 12. if n is 13, return 1111\n        # 13. if n is 14, return 11111\n        # 14. if n is 15, return 111111\n        # 15. if n is 16, return 1111111\n        # 16. if n is 17, return 11111111\n        # 17. if n is 18, return 111111111\n        # 18. if n is 19, return 1111111111\n        # 19. if n is 20, return 11111111111\n        # 20. if n is 21, return 111111111111\n        # 21. if n is 22, return 1111111111111\n        # 22. if n is 23, return 11111111111111\n        # 23. if n is 24, return 111111111111111\n        # 24. if n is 25, return 1111111111111111\n        # 25. if n is 26, return 11111111111111111\n        # 26. if n is 27, return 111111111111111111\n        # 27. if n is 28, return 1111111111111111111\n        # 28. if n is 29, return 11111111111111111111\n        # 29. if n is 30, return 111111111111111111111\n        # 30. if n is 31, return 1111111111111111111111\n        # 31. if n is 32, return 11111111111111111111111\n        # 32. if n is 33, return 111111111111111111111111\n        # 33. if n is 34, return 1111111111111111111111111\n        # 34. if n is 35, return 11111111111111111111111111\n        # 35. if n is 36, return 111111111111111111111111111\n        # 36. if n is 37, return 111111111111111111111111111\n        # 37. if n is 38, return 1111111111111111111111111111\n        # 38. if n is 39, return 1111111111111111111"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            x = -x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n\n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        dp = {}\n        for stone in stones:\n            dp[stone] = set()\n        dp[0].add(0)\n        for stone in stones:\n            for prev_jump in dp[stone]:\n                for jump in range(prev_jump - 1, prev_jump + 2):\n                    if jump > 0 and stone + jump in stone_set:\n                        dp[stone + jump].add(jump)\n        return len(dp[stones[-1]]) > 0"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score array in descending order\n        score.sort(reverse=True)\n\n        # create a dictionary to map the score to its rank\n        score_to_rank = {}\n        for i, score in enumerate(score):\n            score_to_rank[score] = i + 1\n\n        # map the score to its rank\n        for i, score in enumerate(score):\n            if i == 0:\n                score_to_rank[score] = \"Gold Medal\"\n            elif i == 1:\n                score_to_rank[score] = \"Silver Medal\"\n            elif i == 2:\n                score_to_rank[score] = \"Bronze Medal\"\n            else:\n                score_to_rank[score] = str(i + 1)\n\n        # create a list of the ranks\n        ranks = [score_to_rank[score] for score in score]\n\n        return ranks"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        start = 0\n        seen = {}\n        for i, c in enumerate(s):\n            if c in seen:\n                start = max(start, seen[c] + 1)\n            seen[c] = i\n            max_len = max(max_len, i - start + 1)\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n                else:\n                    break\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        chunks = 0\n        for i in range(len(arr)):\n            if arr[i] == max_num:\n                chunks += 1\n                max_num = max(arr[i+1:])\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            nums[left:right + 1] = temp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        # max_profit = 0\n        # min_price = prices[0]\n        # for i in range(1, len(prices)):\n        #     if prices[i] < min_price:\n        #         min_price = prices[i]\n        #     elif prices[i] - min_price > max_profit:\n        #         max_profit = prices[i] - min_price\n        # return max_profit\n        # if len(prices) < 2:\n        #     return 0\n        # max_profit = 0\n        # min_price = prices[0]\n        # for i in range(1, len(prices)):\n        #     if prices[i] < min_price:\n        #         min_price = prices[i]\n        #     elif prices[i] - min_price > max_profit:\n        #         max_profit = prices[i] - min_price\n        # return max_profit\n        if len(prices) < 2:\n            return 0\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            elif prices[i] - min_price > max_profit:\n                max_profit = prices[i] - min_price\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # priority queue\n        pq = []\n        # total time\n        total = 0\n        # loop through courses\n        for duration, lastDay in courses:\n            # add course to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            # add course to total time\n            total += duration\n            # if total time is greater than last day\n            if total > lastDay:\n                # pop from priority queue\n                total += heapq.heappop(pq)[0]\n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return tail"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        \n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 260ms\n        # 2. 36ms\n        # 3. 13ms\n        # 4. 13ms\n        # 5. 13ms\n        # 6. 13ms\n        # 7. 13ms\n        # 8. 13ms\n        # 9. 13ms\n        # 10. 13ms\n        # 11. 13ms\n        # 12. 13ms\n        # 13. 13ms\n        # 14. 13ms\n        # 15. 13ms\n        # 16. 13ms\n        # 17. 13ms\n        # 18. 13ms\n        # 19. 13ms\n        # 20. 13ms\n        # 21. 13ms\n        # 22. 13ms\n        # 23. 13ms\n        # 24. 13ms\n        # 25. 13ms\n        # 26. 13ms\n        # 27. 13ms\n        # 28. 13ms\n        # 29. 13ms\n        # 30. 13ms\n        # 31. 13ms\n        # 32. 13ms\n        # 33. 13ms\n        # 34. 13ms\n        # 35. 13ms\n        # 36. 13ms\n        # 37. 13ms\n        # 38. 13ms\n        # 39. 13ms\n        # 40. 13ms\n        # 41. 13ms\n        # 42. 13ms\n        # 43. 13ms\n        # 44. 13ms\n        # 45. 13ms\n        # 46. 13ms\n        # 47. 13ms\n        # 48. 13ms\n        # 49. 13ms\n        # 50. 13ms\n        # 51. 13ms\n        # 52. 13ms\n        # 53. 13ms\n        # 54. 13ms\n        # 55. 13ms\n        # 56. 13ms\n        # 57. 13ms\n        # 58. 13ms\n        # 59. 13ms\n        # 60. 13ms\n        # 61. 13ms\n        # 62. 13ms\n        # 63. 13ms\n        # 64. 13ms\n        # 65. 13ms\n        # 66. 13ms\n        # 67. 13ms\n        # 68. 13ms\n        # 69. 13ms\n        # 70. 13ms\n        # 71. 13ms\n        # 72. 13ms\n        # 73. 13ms\n        # 74. 13ms\n        # 75. 13ms\n        # 76. 13ms\n        # 77. 13ms\n        # 78. 13ms\n        # 79. 13ms\n        # 80. 13ms\n        # 81. 13ms\n        # 82. 13ms\n        # 83. 13ms\n        # 84. 13ms\n        # 85. 13ms\n        # 86. 13ms\n        # 87. 13ms\n        # 88. 13ms\n        # 89. 13ms\n        # 90. 13ms\n        # 91. 13ms\n        # 92. 13ms\n        # 93. 13ms\n        # 94. 13"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to spell out target[0:i]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of target[0:j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of target[0:j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[j]\n        # dp[i] = min("}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                    for k in range(i,j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                result += roman_dict[s[i]]\n                i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        nums.sort()\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\n        # 2. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 14. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \ufffd"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        # if nums[0] == nums[-1]:\n        #     return nums[0]\n\n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n\n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n            elif nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left += 1\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            path.append(root.val)\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 2 4 8 16 32 64 125 250 500 1000 2000 4000 8000 16000 32000 64000 125000 250000 500000 1000000\n        # 2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    res.append([])\n                for i in range(len(curr)):\n                    for neighbor in graph[curr[:i] + \"*\" + curr[i+1:]]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n                            res[-1].append(neighbor)\n        \n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            if path not in res:\n                res.append(path)\n            for i in range(start, len(nums)):\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc21c\ud68c\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud560 \ub54c \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc744 \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud560 \ub54c \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ub978\ucabd \uc6d0\uc18c\ub4e4\uc758 \uc624\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min == x_max and y_min == y_max:\n            return True\n        if x_min == x_max or y_min == y_max:\n            return False\n        if x_min < y_min or x_max > y_max:\n            return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n\n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the empty square\n        # 1,2,3,4,5 are the numbers\n        # 6 is the goal\n        # 7 is the number of moves\n        # 8 is the number of moves to the goal\n        # 9 is the number of moves to the goal with the empty square\n        # 10 is the number of moves to the goal with the empty square and the number 6\n        # 11 is the number of moves to the goal with the empty square and the number 6 and the number 1\n        # 12 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2\n        # 13 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3\n        # 14 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4\n        # 15 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5\n        # 16 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0\n        # 17 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7\n        # 18 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8\n        # 19 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number 9\n        # 20 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number 9 and the number 10\n        # 21 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number 9 and the number 10 and the number 11\n        # 22 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number 9 and the number 10 and the number 11 and the number 12\n        # 23 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number 9 and the number 10 and the number 11 and the number 12 and the number 13\n        # 24 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number 9 and the number 10 and the number 11 and the number 12 and the number 13 and the number 14\n        # 25 is the number of moves to the goal with the empty square and the number 6 and the number 1 and the number 2 and the number 3 and the number 4 and the number 5 and the number 0 and the number 7 and the number 8 and the number"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True\n        # else return False\n\n        # if target is in nums, return True"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            if s[0] == '0':\n                return 0\n            if int(s[0]) == 1 and int(s[1]) <= 6:\n                return 2\n            else:\n                return 1\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0':\n                if int(s[i - 2:i]) <= 26:\n                    dp[i] += dp[i - 2]\n        return dp[-1] % (10**9 + 7)"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest_sum = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum_ = nums[i] + nums[left] + nums[right]\n                if abs(sum_ - target) < abs(closest_sum - target):\n                    closest_sum = sum_\n                if sum_ < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest_sum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(inorder_list)):\n            min_diff = min(min_diff, abs(inorder_list[i] - inorder_list[i - 1]))\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        res = dfs(root)\n        count = {}\n        for i in res:\n            count[i] = count.get(i, 0) + 1\n        max_count = max(count.values())\n        return [k for k, v in count.items() if v == max_count]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 7. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 9. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 11. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 13. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 15. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 16. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        # 17. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\ub294 \uacbd\uc6b0 \ufffd"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n // 5\n            n = n // 5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = -1\n        \n        for c in s:\n            res[i] += c\n            if i == 0 or i == numRows - 1:\n                flag = -flag\n            i += flag\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \ubc18\ubcf5\n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 4. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 5. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 6. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 7. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 8. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 9. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 10. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 11. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 12. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 13. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ubb3c\uc744 \ucc44\uc6cc\ub123\uc74c\n        # 14. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ufffd"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Create a list of size n+1 with all zeros\n        ## 2. Iterate through the nums array and mark the index of the nums[i] as negative\n        ## 3. Iterate through the list and return the indices that are still positive\n        ## 4. Time complexity: O(n)\n        ## 5. Space complexity: O(1)\n        n = len(nums)\n        res = [0] * (n+1)\n        for i in range(n):\n            res[nums[i]] = -1\n        for i in range(1, n+1):\n            if res[i] == 0:\n                res[i] = i\n        return res[1:]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \ub4a4, \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 2. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 3. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 4. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 5. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 6. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 7. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 8. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 9. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 10. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 11. \uc815\ub82c\ub41c \uc21c\uc11c\ub300\ub85c \uc21c\ud68c\ud558\uba74\uc11c \uc790\uc2e0\ubcf4\ub2e4 \uc791\uc740 \uc218"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        prev = -1\n        for interval in intervals:\n            if interval[0] > prev:\n                res += 2\n                prev = interval[1] - 1\n            else:\n                res += 1\n                prev -= 1\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None:\n                return False\n            if root1.val != root2.val:\n                return False\n            return isMirror(root1.left, root2.right) and isMirror(root1.right, root2.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \uc815\uaddc\uc2dd\uc73c\ub85c \uc22b\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc5f4\uc744 \ucd94\ucd9c\ud55c\ub2e4.\n        # 2. \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c\ub2e4.\n        # 3. \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \uacb0\uacfc\ub97c \ub515\uc154\ub108\ub9ac\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # 4. \ub515\uc154\ub108\ub9ac\ub97c \uc815\ub82c\ud55c\ub2e4.\n        # 5. \ub515\uc154\ub108\ub9ac\ub97c \ubb38\uc790\uc5f4\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # 6. \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        # \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \uacb0\uacfc\ub97c \ub515\uc154\ub108\ub9ac\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\ub97c \uc815\ub82c\ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\ub97c \ubb38\uc790\uc5f4\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        # \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \uacb0\uacfc\ub97c \ub515\uc154\ub108\ub9ac\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\ub97c \uc815\ub82c\ud55c\ub2e4.\n        # \ub515\uc154\ub108\ub9ac\ub97c \ubb38\uc790\uc5f4\ub85c \ubcc0\ud658\ud55c\ub2e4.\n        # \ubb38\uc790\uc5f4\uc744 \ubc18\ud658\ud55c\ub2e4.\n        \n        # \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4\uc744 \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc73c\ub85c \ucd94\ucd9c\ud55c \ubb38\uc790\uc5f4"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return result"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n = n // 4\n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        nums.append(float('inf'))\n        \n        # loop\n        while i < len(nums):\n            if nums[i] <= n:\n                n += nums[i]\n                i += 1\n            else:\n                patches += 1\n                n += n\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \ucd94\uac00\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 0\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud55c\ub2e4.\n\n        stack = []\n        max_len = 0\n\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                else:\n                    stack.append(i)\n\n        if not stack:\n            return 0\n        else:\n            return max(max_len, max(stack) + 1)"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = \"\"\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res += str(numerator // denominator)\n        numerator %= denominator\n        \n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + \"(\" + res[seen[numerator]:] + \")\"\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # print(envelopes)\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        row_zero = False\n        col_zero = False\n\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        row_zero = True\n                    if j == 0:\n                        col_zero = True\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if row_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n\n        if col_zero:\n            for i in range(rows):\n                matrix[i][0] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the node to be removed\n        if length == n:\n            return head.next\n        \n        # 3. Find the node before the node to be removed\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        # 4. Remove the node\n        curr.next = curr.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        if sum(machines) % n != 0:\n            return -1\n        avg = sum(machines) // n\n        res = 0\n        curr = 0\n        for i in range(n):\n            curr += machines[i] - avg\n            res = max(res, abs(curr))\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        heights = [0] * cols\n        \n        for row in range(rows):\n            for col in range(cols):\n                if matrix[row][col] == '1':\n                    heights[col] += 1\n                else:\n                    heights[col] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i, height in enumerate(heights):\n            while stack and height < heights[stack[-1]]:\n                top = stack.pop()\n                if not stack:\n                    left = -1\n                else:\n                    left = stack[-1]\n                area = (i - left - 1) * heights[top]\n                max_area = max(max_area, area)\n            stack.append(i)\n        \n        while stack:\n            top = stack.pop()\n            if not stack:\n                left = -1\n            else:\n                left = stack[-1]\n            area = (len(heights) - left - 1) * heights[top]\n            max_area = max(max_area, area)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        for i in range(2**len(nums)):\n            temp = []\n            for j in range(len(nums)):\n                if i & (1<<j):\n                    temp.append(nums[j])\n            res.append(temp)\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 2. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 3. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 4. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 5. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 6. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 7. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 8. \uc815\ub82c\ub41c \ubc30\uc5f4\uc774 \uc544\ub2c8\ub77c\uba74 \uc911\uc559\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \ubd80\ubd84\uc744 \ub098\ub204\uc5b4 \uc815\ub82c\ub41c \ubc30\uc5f4\uc778\ufffd"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 2. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 3. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 4. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 5. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 6. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 7. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 8. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 9. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 10. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 11. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 12. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 13. \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc22b\uc790\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub294\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 14."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: \"M\",\n            900: \"CM\",\n            500: \"D\",\n            400: \"CD\",\n            100: \"C\",\n            90: \"XC\",\n            50: \"L\",\n            40: \"XL\",\n            10: \"X\",\n            9: \"IX\",\n            5: \"V\",\n            4: \"IV\",\n            1: \"I\",\n        }\n\n        roman_num = \"\"\n\n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n\n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and decrement the frequency of each character in the hashmap\n        ## 3. Return the character with a frequency of 1\n        ##\n        ## Note:\n        ## 1. We can use a hashmap to store the frequency of each character in s\n        ## 2. We can use a hashmap to store the frequency of each character in t\n        ## 3. We can use a hashmap to store the frequency of each character in s\n        ## 4. We can use a hashmap to store the frequency of each character in t\n        ## 5. We can use a hashmap to store the frequency of each character in s\n        ## 6. We can use a hashmap to store the frequency of each character in t\n        ## 7. We can use a hashmap to store the frequency of each character in s\n        ## 8. We can use a hashmap to store the frequency of each character in t\n        ## 9. We can use a hashmap to store the frequency of each character in s\n        ## 10. We can use a hashmap to store the frequency of each character in t\n        ## 11. We can use a hashmap to store the frequency of each character in s\n        ## 12. We can use a hashmap to store the frequency of each character in t\n        ## 13. We can use a hashmap to store the frequency of each character in s\n        ## 14. We can use a hashmap to store the frequency of each character in t\n        ## 15. We can use a hashmap to store the frequency of each character in s\n        ## 16. We can use a hashmap to store the frequency of each character in t\n        ## 17. We can use a hashmap to store the frequency of each character in s\n        ## 18. We can use a hashmap to store the frequency of each character in t\n        ## 19. We can use a hashmap to store the frequency of each character in s\n        ## 20. We can use a hashmap to store the frequency of each character in t\n        ## 21. We can use a hashmap to store the frequency of each character in s\n        ## 22. We can use a hashmap to store the frequency of each character in t\n        ## 23. We can use a hashmap to store the frequency of each character in s\n        ## 24. We can use a hashmap to store the frequency of each character in t\n        ## 25. We can use a hashmap to store the frequency of each character in s\n        ## 26. We can use a hashmap to store the frequency of each character in t\n        ## 27. We can use a hashmap to store the frequency of each character in s\n        ## 28. We can use a hashmap to store the frequency of each character in t\n        ## 29. We can use a hashmap to store the frequency of each character in s\n        ## 30. We can use a hashmap to store the frequency of each character in t\n        ## 31. We can use a hashmap to store the frequency of each character in s\n        ## 32. We can use a hashmap to store the frequency of each character in t\n        ## 33. We can use a hashmap to store the frequency of each character in s\n        ## 34. We can use a hashmap to store the frequency of each character in t\n        ## 35. We can use a hashmap to store the frequency of each character in s\n        ## 36. We can use a hashmap to store the frequency of each character in t\n        ## 37. We can use a hashmap to store the frequency of each character in s\n        ## 38. We can use a hashmap to store the frequency of each character in t\n        ## 39. We can use a hashmap to store the frequency of each character in s\n        ## 40. We can use a hashmap to store the frequency of each character in"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n            row_start = (row // 3) * 3\n            col_start = (col // 3) * 3\n            for i in range(row_start, row_start + 3):\n                for j in range(col_start, col_start + 3):\n                    if board[i][j] == num:\n                        return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder traversal again to restore the tree\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values of the two nodes\n        # inorder tra"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # Solution 1:\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 2:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 3:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 4:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 5:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 6:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 7:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 8:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Reverse the second half of the linked list\n        # 5. Return True if the first half and the second half are equal\n        \n        # Solution 9:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach:\n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half and the second half\n        # 4. Rever"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        if sorted(s1) != sorted(s2):\n            return False\n        if len(s1) == 1:\n            return True\n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 for loops\n        # 2. 3 for loops\n        # 3. 3 for loops\n        # 4. 3 for loops\n        # 5. 3 for loops\n        # 6. 3 for loops\n        # 7. 3 for loops\n        # 8. 3 for loops\n        # 9. 3 for loops\n        # 10. 3 for loops\n        # 11. 3 for loops\n        # 12. 3 for loops\n        # 13. 3 for loops\n        # 14. 3 for loops\n        # 15. 3 for loops\n        # 16. 3 for loops\n        # 17. 3 for loops\n        # 18. 3 for loops\n        # 19. 3 for loops\n        # 20. 3 for loops\n        # 21. 3 for loops\n        # 22. 3 for loops\n        # 23. 3 for loops\n        # 24. 3 for loops\n        # 25. 3 for loops\n        # 26. 3 for loops\n        # 27. 3 for loops\n        # 28. 3 for loops\n        # 29. 3 for loops\n        # 30. 3 for loops\n        # 31. 3 for loops\n        # 32. 3 for loops\n        # 33. 3 for loops\n        # 34. 3 for loops\n        # 35. 3 for loops\n        # 36. 3 for loops\n        # 37. 3 for loops\n        # 38. 3 for loops\n        # 39. 3 for loops\n        # 40. 3 for loops\n        # 41. 3 for loops\n        # 42. 3 for loops\n        # 43. 3 for loops\n        # 44. 3 for loops\n        # 45. 3 for loops\n        # 46. 3 for loops\n        # 47. 3 for loops\n        # 48. 3 for loops\n        # 49. 3 for loops\n        # 50. 3 for loops\n        # 51. 3 for loops\n        # 52. 3 for loops\n        # 53. 3 for loops\n        # 54. 3 for loops\n        # 55. 3 for loops\n        # 56. 3 for loops\n        # 57. 3 for loops\n        # 58. 3 for loops\n        # 59. 3 for loops\n        # 60. 3 for loops\n        # 61. 3 for loops\n        # 62. 3 for loops\n        # 63. 3 for loops\n        # 64. 3 for loops\n        # 65. 3 for loops\n        # 66. 3 for loops\n        # 67. 3 for loops\n        # 68. 3 for loops\n        # 69. 3 for loops\n        # 70. 3 for loops\n        # 71. 3 for loops\n        # 72. 3 for loops\n        # 73. 3 for loops\n        # 74. 3 for loops\n        # 75. 3 for loops\n        # 76. 3 for loops\n        # 77. 3 for loops\n        # 78. 3 for loops\n        # 79. 3 for loops\n        # 80. 3 for loops\n        # 81. 3 for loops\n        # 82. 3 for loops\n        # 83. 3 for loops\n        # 84. 3 for loops\n        # 85. 3 for loops\n        # 86. 3 for loops\n        # 87. 3 for loops\n        # 88. 3 for loops\n        # 89. 3 for loops\n        # 90. 3 for loops\n        # 91. 3 for loops\n        # 92. 3 for loops\n        # 93. 3 for loops\n        # 94. 3 for loops"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Reverse the order of the words\n        words.reverse()\n        \n        # Join the words back into a single string\n        return \" \".join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res += (ord(columnTitle[i]) - 64) * (26 ** (len(columnTitle) - i - 1))\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        \n        second = self.reverse(second)\n        \n        first = head\n        \n        while second:\n            temp1 = first.next\n            temp2 = second.next\n            \n            first.next = second\n            second.next = temp1\n            \n            first = temp1\n            second = temp2\n        \n        return head\n        \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the number of words is not equal to the number of letters in the pattern, return False\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the mapping, check if the word is the same as the previous word\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the mapping, add it to the mapping\n            else:\n                mapping[letter] = word\n        \n        # if all the letters are mapped to words, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n\n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new list node\n        # 2. Create a new list node\n        # 3. Create a new list node\n        # 4. Create a new list node\n        # 5. Create a new list node\n        # 6. Create a new list node\n        # 7. Create a new list node\n        # 8. Create a new list node\n        # 9. Create a new list node\n        # 10. Create a new list node\n        # 11. Create a new list node\n        # 12. Create a new list node\n        # 13. Create a new list node\n        # 14. Create a new list node\n        # 15. Create a new list node\n        # 16. Create a new list node\n        # 17. Create a new list node\n        # 18. Create a new list node\n        # 19. Create a new list node\n        # 20. Create a new list node\n        # 21. Create a new list node\n        # 22. Create a new list node\n        # 23. Create a new list node\n        # 24. Create a new list node\n        # 25. Create a new list node\n        # 26. Create a new list node\n        # 27. Create a new list node\n        # 28. Create a new list node\n        # 29. Create a new list node\n        # 30. Create a new list node\n        # 31. Create a new list node\n        # 32. Create a new list node\n        # 33. Create a new list node\n        # 34. Create a new list node\n        # 35. Create a new list node\n        # 36. Create a new list node\n        # 37. Create a new list node\n        # 38. Create a new list node\n        # 39. Create a new list node\n        # 40. Create a new list node\n        # 41. Create a new list node\n        # 42. Create a new list node\n        # 43. Create a new list node\n        # 44. Create a new list node\n        # 45. Create a new list node\n        # 46. Create a new list node\n        # 47. Create a new list node\n        # 48. Create a new list node\n        # 49. Create a new list node\n        # 50. Create a new list node\n        # 51. Create a new list node\n        # 52. Create a new list node\n        # 53. Create a new list node\n        # 54. Create a new list node\n        # 55. Create a new list node\n        # 56. Create a new list node\n        # 57. Create a new list node\n        # 58. Create a new list node\n        # 59. Create a new list node\n        # 60. Create a new list node\n        # 61. Create a new list node\n        # 62. Create a new list node\n        # 63. Create a new list node\n        # 64. Create a new list node\n        # 65. Create a new list node\n        # 66. Create a new list node\n        # 67. Create a new list node\n        # 68. Create a new list node\n        # 69. Create a new list node\n        # 70. Create a new list node\n        # 71. Create a new list node\n        # 72. Create a new list node\n        # 73. Create a new list node\n        # 74. Create a new list node\n        # 75. Create a new list node\n        # 76. Create a new list node\n        # 77. Create a new list node\n        # 78. Create a new list node\n        # 79. Create a new list node\n        # 80. Create a new list node\n        # 81. Create a new list node\n        # 82. Create a new list node\n        # 83. Create a new list node\n        # 84. Create a new list node\n        # 85. Create a new list node\n        # 86. Create a new list node"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums) - 2:\n            if nums[i+2] - nums[i] == nums[i+1] - nums[i]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            curr_len = len(words[i])\n            j = i + 1\n            while j < len(words) and curr_len + len(words[j]) + 1 <= maxWidth:\n                curr_len += len(words[j]) + 1\n                j += 1\n            if j == len(words):\n                res.append(' '.join(words[i:j]) + ' ' * (maxWidth - curr_len))\n            else:\n                num_words = j - i\n                num_spaces = maxWidth - curr_len\n                avg_spaces = num_spaces // (num_words - 1)\n                extra_spaces = num_spaces % (num_words - 1)\n                res.append(' '.join(words[i:j] + [' ' * avg_spaces] * extra_spaces + [' ' * avg_spaces + words[j - 1]] * (num_words - 1 - extra_spaces)))\n            i = j\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N^2)\n        # Space Complexity: O(N)\n        # Approach: Dynamic Programming\n        # 1. Create a set of words\n        # 2. Iterate through the words\n        # 3. If the word is in the set, return it\n        # 4. Otherwise, iterate through the word and check if the substring is in the set\n        # 5. If the substring is in the set, add the word to the set\n        # 6. Return the list of concatenated words\n        \n        word_set = set(words)\n        res = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                res.append(word)\n        \n        return res\n    \n    def dfs(self, word, word_set):\n        if word in word_set:\n            return True\n        \n        for i in range(1, len(word)):\n            left = word[:i]\n            right = word[i:]\n            \n            if left in word_set and right in word_set:\n                return True\n            elif left in word_set:\n                if self.dfs(right, word_set):\n                    return True\n        \n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col, n):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row):\n            if row == n:\n                self.count += 1\n                return\n            for col in range(n):\n                if is_valid(row, col, n):\n                    board[row][col] = 1\n                    backtrack(row + 1)\n                    board[row][col] = 0\n        \n        board = [[0 for _ in range(n)] for _ in range(n)]\n        self.count = 0\n        backtrack(0)\n        return self.count"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n\n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}