{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, n-1, 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) < len(t):\n            return 0\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(min(i, len(t)), 0, -1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and all numbers larger than n as 0\n        # 2. iterate through the array and mark the numbers as negative\n        # 3. iterate through the array again and return the first number that is not marked as negative\n        # 4. if all numbers are marked as negative, return n + 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        res = \"\"\n        nums = [i for i in range(1, n + 1)]\n        for i in range(n - 1, -1, -1):\n            # 2.1 calculate the index of the current digit\n            idx = k // fact\n            # 2.2 calculate the digit\n            res += str(nums[idx])\n            # 2.3 remove the digit from the nums\n            nums.remove(nums[idx])\n            # 2.4 update k\n            k %= fact\n            # 2.5 update the factorial\n            fact //= i\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Two pointers\n        # 2. O(n) time and O(1) space\n        # 3. O(n) time and O(1) space\n        # 4. O(n) time and O(1) space\n        # 5. O(n) time and O(1) space\n        # 6. O(n) time and O(1) space\n        # 7. O(n) time and O(1) space\n        # 8. O(n) time and O(1) space\n        # 9. O(n) time and O(1) space\n        # 10. O(n) time and O(1) space\n        # 11. O(n) time and O(1) space\n        # 12. O(n) time and O(1) space\n        # 13. O(n) time and O(1) space\n        # 14. O(n) time and O(1) space\n        # 15. O(n) time and O(1) space\n        # 16. O(n) time and O(1) space\n        # 17. O(n) time and O(1) space\n        # 18. O(n) time and O(1) space\n        # 19. O(n) time and O(1) space\n        # 20. O(n) time and O(1) space\n        # 21. O(n) time and O(1) space\n        # 22. O(n) time and O(1) space\n        # 23. O(n) time and O(1) space\n        # 24. O(n) time and O(1) space\n        # 25. O(n) time and O(1) space\n        # 26. O(n) time and O(1) space\n        # 27. O(n) time and O(1) space\n        # 28. O(n) time and O(1) space\n        # 29. O(n) time and O(1) space\n        # 30. O(n) time and O(1) space\n        # 31. O(n) time and O(1) space\n        # 32. O(n) time and O(1) space\n        # 33. O(n) time and O(1) space\n        # 34. O(n) time and O(1) space\n        # 35. O(n) time and O(1) space\n        # 36. O(n) time and O(1) space\n        # 37. O(n) time and O(1) space\n        # 38. O(n) time and O(1) space\n        # 39. O(n) time and O(1) space\n        # 40. O(n) time and O(1) space\n        # 41. O(n) time and O(1) space\n        # 42. O(n) time and O(1) space\n        # 43. O(n) time and O(1) space\n        # 44. O(n) time and O(1) space\n        # 45. O(n) time and O(1) space\n        # 46. O(n) time and O(1) space\n        # 47. O(n) time and O(1) space\n        # 48. O(n) time and O(1) space\n        # 49. O(n) time and O(1) space\n        # 50. O(n) time and O(1) space\n        # 51. O(n) time and O(1) space\n        # 52. O(n) time and O(1) space\n        # 53. O(n) time and O(1) space\n        # 54. O(n) time and O(1) space\n        # 55. O(n) time and O(1) space\n        # 56. O(n) time and O(1) space\n        # 57. O(n) time and O(1) space\n        # 58. O(n) time and O("}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, path, idx):\n            if not num:\n                if target == 0 and op == '+':\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i == 1 or (num[0] != '0' and op != '+'):\n                    backtrack(num[i:], target - int(num[:i]), '+', res, path + num[:i], i)\n                if i > 1 or (num[0] != '0' and op != '-'):\n                    backtrack(num[i:], target + int(num[:i]), '-', res, path + '-' + num[:i], i)\n                if i > 1:\n                    backtrack(num[i:], target - int(num[:i]), '*', res, path + '*' + num[:i], i)\n        \n        res = []\n        backtrack(num, target, '+', res, '', 1)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr * 10 + root.val\n            return dfs(root.left, curr * 10 + root.val) + dfs(root.right, curr * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    (first_match and self.isMatch(s[1:], p)))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for num in nums:\n                while out and k > 0 and out[-1] < num:\n                    out.pop()\n                    k -= 1\n                out.append(num)\n            return out\n        \n        m, n = len(nums1), len(nums2)\n        return max(pick(nums1[:m-k], k), pick(nums2[:n-k], k))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1 - dungeon[i][j], 1)\n                elif i == m - 1:\n                    dp[i][j] = max(dp[i][j + 1] - dungeon[i][j], 1)\n                elif j == n - 1:\n                    dp[i][j] = max(dp[i + 1][j] - dungeon[i][j], 1)\n                else:\n                    dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and s[l] not in vowels:\n                l += 1\n            while l < r and s[r] not in vowels:\n                r -= 1\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 = 0\n        ## 0 ^ 1 ^ 2 ^ 1 ^ 2 ^ 3 ^ 1 ^ 2 ^ 3 ^ 4 ^ 1 ^ 2 ^ 5 ^ 1 ^ 2 ^ 6 ^ 1 ^ 2 ^ 7 ^ 1 ^ 2 ^ 8 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            for i in range(len(word)):\n                for j in range(ord('a'), ord('z') + 1):\n                    next_word = word[:i] + chr(j) + word[i+1:]\n                    if next_word == endWord:\n                        return length + 1\n                    if next_word in wordList:\n                        queue.append((next_word, length + 1))\n                        wordList.remove(next_word)\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        i = len(a) - 1\n        j = len(b) - 1\n        res = []\n        \n        while i >= 0:\n            if j >= 0:\n                carry += int(a[i]) + int(b[j])\n            else:\n                carry += int(a[i])\n            res.append(carry % 2)\n            carry //= 2\n            i -= 1\n            j -= 1\n        \n        if carry:\n            res.append(carry)\n        \n        return ''.join(map(str, res[::-1]))"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left if lower else right\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(1, n):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for i in range(0, len(prices) - 1, 2) if prices[i] < prices[i+1])\n        \n        dp = [[0] * 2 for _ in range(k + 1)]\n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[j][0] = max(dp[j][0], dp[j - 1][1] + prices[i])\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i])\n        return dp[-1][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists, otherwise return -1\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string and update the hashmap and the list\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is not in the list, add it to the list\n        # return the first element of the list if it exists"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        if valueDiff < 0:\n            return False\n        \n        if indexDiff < 0:\n            indexDiff = len(nums) + indexDiff\n        \n        if indexDiff > len(nums):\n            return False\n        \n        if indexDiff == 0:\n            return False\n        \n        if indexDiff == 1:\n            return True\n        \n        if valueDiff == 0:\n            return False\n        \n        if valueDiff == 1:\n            return True\n        \n        if valueDiff > len(nums):\n            return False\n        \n        if valueDiff > len(nums) * 2:\n            return False\n        \n        if valueDiff > len(nums) * 3:\n            return False\n        \n        if valueDiff > len(nums) * 4:\n            return False\n        \n        if valueDiff > len(nums) * 5:\n            return False\n        \n        if valueDiff > len(nums) * 6:\n            return False\n        \n        if valueDiff > len(nums) * 7:\n            return False\n        \n        if valueDiff > len(nums) * 8:\n            return False\n        \n        if valueDiff > len(nums) * 9:\n            return False\n        \n        if valueDiff > len(nums) * 10:\n            return False\n        \n        if valueDiff > len(nums) * 11:\n            return False\n        \n        if valueDiff > len(nums) * 12:\n            return False\n        \n        if valueDiff > len(nums) * 13:\n            return False\n        \n        if valueDiff > len(nums) * 14:\n            return False\n        \n        if valueDiff > len(nums) * 15:\n            return False\n        \n        if valueDiff > len(nums) * 16:\n            return False\n        \n        if valueDiff > len(nums) * 17:\n            return False\n        \n        if valueDiff > len(nums) * 18:\n            return False\n        \n        if valueDiff > len(nums) * 19:\n            return False\n        \n        if valueDiff > len(nums) * 20:\n            return False\n        \n        if valueDiff > len(nums) * 21:\n            return False\n        \n        if valueDiff > len(nums) * 22:\n            return False\n        \n        if valueDiff > len(nums) * 23:\n            return False\n        \n        if valueDiff > len(nums) * 24:\n            return False\n        \n        if valueDiff > len(nums) * 25:\n            return False\n        \n        if valueDiff > len(nums) * 26:\n            return False\n        \n        if valueDiff > len(nums) * 27:\n            return False\n        \n        if valueDiff > len(nums) * 28:\n            return False\n        \n        if valueDiff > len(nums) * 29:\n            return False\n        \n        if valueDiff > len(nums) * 30:\n            return False\n        \n        if valueDiff > len(nums) * 31:\n            return False\n        \n        if valueDiff > len(nums) * 32:\n            return False\n        \n        if valueDiff > len(nums) * 33:\n            return False\n        \n        if valueDiff > len(nums) * 34:\n            return False\n        \n        if valueDiff > len(nums) * 35:\n            return False\n        \n        if valueDiff > len(nums) * 36:\n            return False\n        \n        if valueDiff > len(nums) * 37:\n            return False\n        \n        if valueDiff > len(nums) * 38:\n            return False\n        \n        if valueDiff > len(nums) * 39:\n            return False\n        \n        if valueDiff > len(nums) * 40:\n            return False\n        \n        if valueDiff > len(nums) * 41:\n            return False\n        \n        if valueDiff > len(num"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0: red, 1: white, 2: blue\n        red, white, blue = 0, 0, len(nums) - 1\n        \n        while white <= blue:\n            if nums[white] == 0:\n                nums[red], nums[white] = nums[white], nums[red]\n                red += 1\n                white += 1\n            elif nums[white] == 2:\n                nums[blue], nums[white] = nums[white], nums[blue]\n                blue -= 1\n            else:\n                white += 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for num in nums:\n            if num == 1:\n                curr_count += 1\n            else:\n                max_count = max(max_count, curr_count)\n                curr_count = 0\n                \n        return max(max_count, curr_count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = list(num1), list(num2)\n        \n        carry = 0\n        for i in range(len(num1)):\n            sum = int(num1[-i - 1]) + int(num2[-i - 1]) + carry\n            carry = sum // 10\n            num1[-i - 1] = str(sum % 10)\n        \n        for i in range(len(num1) - 1, -1, -1):\n            sum = int(num1[i]) + carry\n            carry = sum // 10\n            num1[i] = str(sum % 10)\n        \n        if carry:\n            num1.insert(0, str(carry))\n        \n        return ''.join(num1)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res, num = 0, 0\n            while i < len(s):\n                if s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                elif s[i] == '+':\n                    res += sign * num\n                    sign = 1\n                    num = 0\n                elif s[i] == '-':\n                    res += sign * num\n                    sign = -1\n                    num = 0\n                elif s[i] == '(':\n                    num, i = helper(s, i + 1, sign)\n                elif s[i] == ')':\n                    return res + sign * num, i + 1\n            return res + sign * num, i\n        \n        return helper(s, 0, 1)[0]"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # greedy\n        # O(nlogn)\n        # O(1)\n        # 1. sort capital and profits\n        # 2. greedy\n        # 3. iterate over capital\n        # 4. if k > 0, add profit to w\n        # 5. else, add capital to w\n        # 6. if capital > w, return w\n        # 7. else, k--\n        # 8. else, add capital to w\n        # 9. if k == 0, return w\n        # 10. else, k--\n        # 11. else, add capital to w\n        # 12. if k == 0, return w\n        # 13. else, k--\n        # 14. else, add capital to w\n        # 15. if k == 0, return w\n        # 16. else, k--\n        # 17. else, add capital to w\n        # 18. if k == 0, return w\n        # 19. else, k--\n        # 20. else, add capital to w\n        # 21. if k == 0, return w\n        # 22. else, k--\n        # 23. else, add capital to w\n        # 24. if k == 0, return w\n        # 25. else, k--\n        # 26. else, add capital to w\n        # 27. if k == 0, return w\n        # 28. else, k--\n        # 29. else, add capital to w\n        # 30. if k == 0, return w\n        # 31. else, k--\n        # 32. else, add capital to w\n        # 33. if k == 0, return w\n        # 34. else, k--\n        # 35. else, add capital to w\n        # 36. if k == 0, return w\n        # 37. else, k--\n        # 38. else, add capital to w\n        # 39. if k == 0, return w\n        # 40. else, k--\n        # 41. else, add capital to w\n        # 42. if k == 0, return w\n        # 43. else, k--\n        # 44. else, add capital to w\n        # 45. if k == 0, return w\n        # 46. else, k--\n        # 47. else, add capital to w\n        # 48. if k == 0, return w\n        # 49. else, k--\n        # 50. else, add capital to w\n        # 51. if k == 0, return w\n        # 52. else, k--\n        # 53. else, add capital to w\n        # 54. if k == 0, return w\n        # 55. else, k--\n        # 56. else, add capital to w\n        # 57. if k == 0, return w\n        # 58. else, k--\n        # 59. else, add capital to w\n        # 60. if k == 0, return w\n        # 61. else, k--\n        # 62. else, add capital to w\n        # 63. if k == 0, return w\n        # 64. else, k--\n        # 65. else, add capital to w\n        # 66. if k == 0, return w\n        # 67. else, k--\n        # 68. else, add capital to w\n        # 69. if k == 0, return w\n        # 70. else, k--\n        # 71. else, add capital to w\n        # 72. if k == 0, return w\n        # 73. else, k--\n        # 74. else, add capital to w\n        # 75. if k == 0, return w\n        # 76. else, k--\n        # 77. else, add capital to w\n        # 78. if k == 0, return w\n        # 79. else, k--\n        # 80. else,"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and stack[-1] == i:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the number to its right\n        # find the first number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the first number\n        \n        # find the first number that is smaller than the number to its right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # find the first number that is larger than the number to its right\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers to the right of the first number\n        nums[i + 1:] = nums[len(nums) - 1: i:-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        d = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in d:\n                if i - d[nums[i]] <= k:\n                    return True\n            d[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        res = 0\n        for i in range(0, n, 2):\n            if couples[i][0] / 2 != couples[i][1] / 2:\n                res += 1\n                couples[i], couples[i+1] = couples[i+1], couples[i]\n        return res"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if s1 == s3 or s2 == s3:\n            return True\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        firstRow = set('qwertyuiop')\n        secondRow = set('asdfghjkl')\n        thirdRow = set('zxcvbnm')\n        \n        res = []\n        for word in words:\n            if word[0] in firstRow:\n                row = firstRow\n            elif word[0] in secondRow:\n                row = secondRow\n            else:\n                row = thirdRow\n            for c in word:\n                if c not in row:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            tmp = curr.next\n            curr.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # then add the rest of the string to the beginning\n        # O(n) time and O(1) space\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O(n)-solution-with-explanation\n        # https://leetcode.com/problems/shortest-palindrome/discuss/100823/Python-O"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        count = collections.Counter(t)\n        required = len(count)\n        left = 0\n        right = 0\n        window = {}\n        window_count = 0\n        res = float('inf'), None, None\n        \n        for right in range(len(s)):\n            char = s[right]\n            if char in count:\n                window[char] = window.get(char, 0) + 1\n                if window[char] == count[char]:\n                    window_count += 1\n            \n            while window_count == required:\n                if right - left + 1 < res[0]:\n                    res = (right - left + 1, left, right)\n                \n                char = s[left]\n                if char in count:\n                    window[char] -= 1\n                    if window[char] < count[char]:\n                        window_count -= 1\n                \n                left += 1\n        \n        return \"\" if res[0] == float('inf') else s[res[1]:res[2] + 1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 2] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of each letter\n        # 2. if the number is odd, add 1 to the result\n        # 3. if the number is even, add it to the result\n        # 4. return the result\n        \n        count = {}\n        for c in s:\n            if c not in count:\n                count[c] = 1\n            else:\n                count[c] += 1\n        \n        result = 0\n        for c in count:\n            if count[c] % 2 == 0:\n                result += count[c]\n            else:\n                result += count[c] - 1\n        \n        return result if result < len(s) else result + 1"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                q = [(node[0], node[1], steps) for node in q]\n                for _ in range(len(q)):\n                    x, y, steps = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0 and (nx, ny) not in visited:\n                            q.append((nx, ny, steps + 1))\n                            visited.add((nx, ny))\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\n        trees.sort(key=lambda x: x[0])\n        start = (0, 0)\n        for tree in trees:\n            steps = bfs(start, tree)\n            if steps < 0:\n                return -1\n            start = tree\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = (sqrt(1 + 8n) - 1) / 2\n        # return int(n)\n        \n        return int((sqrt(1 + 8 * n) - 1) / 2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2^n - 1 is the max number we can generate\n        # 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (node.val < right and node.val > left):\n                return False\n            return valid(node.left, left, node.val) and valid(node.right, node.val, right)\n        \n        return valid(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list,\n        # insert the new interval at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list,\n        # insert the new interval at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list,\n        # merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            newInterval = intervals[0]\n        \n        # if the new interval overlaps with the last element in the list,\n        # merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            newInterval = intervals[-1]\n        \n        # if the new interval overlaps with any element in the list,\n        # merge the new interval with the element before it\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                newInterval = intervals[i]\n                break\n        \n        # if the new interval overlaps with any element in the list,\n        # merge the new interval with the element after it\n        for i in range(len(intervals)-1, -1, -1):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                newInterval = intervals[i]\n                break\n        \n        # remove the merged interval from the list\n        intervals.remove(newInterval)\n        \n        # insert the merged interval back into the list\n        intervals.insert(i, newInterval)\n        \n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. use min heap to store the max of each list\n        # 3. use max heap to store the min of each list\n        # 4. compare the max of the min heap with the min of the max heap\n        # 5. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 6. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 7. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 8. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 9. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 10. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 11. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 12. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 13. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 14. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 15. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 16. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 17. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 18. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 19. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 20. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 21. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 22. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 23. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 24. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 25. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 26. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 27. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 28. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 29. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 30. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 31. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 32. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 33. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 34. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 35. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 36. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 37. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 38."}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000 buckets, 15 minutes, 15 minutes\n        # 2. 1000 buckets, 15 minutes, 30 minutes\n        # 3. 1000 buckets, 15 minutes, 60 minutes\n        # 4. 1000 buckets, 15 minutes, 120 minutes\n        # 5. 1000 buckets, 15 minutes, 240 minutes\n        # 6. 1000 buckets, 15 minutes, 480 minutes\n        # 7. 1000 buckets, 15 minutes, 960 minutes\n        # 8. 1000 buckets, 15 minutes, 1920 minutes\n        # 9. 1000 buckets, 15 minutes, 3840 minutes\n        # 10. 1000 buckets, 15 minutes, 7680 minutes\n        # 11. 1000 buckets, 15 minutes, 15360 minutes\n        # 12. 1000 buckets, 15 minutes, 30720 minutes\n        # 13. 1000 buckets, 15 minutes, 61440 minutes\n        # 14. 1000 buckets, 15 minutes, 122880 minutes\n        # 15. 1000 buckets, 15 minutes, 245760 minutes\n        # 16. 1000 buckets, 15 minutes, 491520 minutes\n        # 17. 1000 buckets, 15 minutes, 983040 minutes\n        # 18. 1000 buckets, 15 minutes, 1966080 minutes\n        # 19. 1000 buckets, 15 minutes, 3932160 minutes\n        # 20. 1000 buckets, 15 minutes, 7864320 minutes\n        # 21. 1000 buckets, 15 minutes, 15728640 minutes\n        # 22. 1000 buckets, 15 minutes, 31457280 minutes\n        # 23. 1000 buckets, 15 minutes, 62914560 minutes\n        # 24. 1000 buckets, 15 minutes, 125829120 minutes\n        # 25. 1000 buckets, 15 minutes, 251658240 minutes\n        # 26. 1000 buckets, 15 minutes, 503316480 minutes\n        # 27. 1000 buckets, 15 minutes, 1006632960 minutes\n        # 28. 1000 buckets, 15 minutes, 2013265920 minutes\n        # 29. 1000 buckets, 15 minutes, 4026531840 minutes\n        # 30. 1000 buckets, 15 minutes, 8053063680 minutes\n        # 31. 1000 buckets, 15 minutes, 16106127360 minutes\n        # 32. 1000 buckets, 15 minutes, 32212254720 minutes\n        # 33. 1000 buckets, 15 minutes, 64424509440 minutes\n        # 34. 1000 buckets, 15 minutes, 128849018880 minutes\n        # 35. 1000 buckets, 15 minutes, 257698037760 minutes\n        # 36. 1000 buckets, 15 minutes, 51539"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        heap = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        \n        while heap:\n            curr_time, x, y = heapq.heappop(heap)\n            res = max(res, curr_time)\n            if x == n - 1 and y == n - 1:\n                return res\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                    heapq.heappush(heap, (grid[nx][ny], nx, ny))\n                    visited.add((nx, ny))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[-1][-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = '0'\n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res = self.add(res, self.multiply(num1[len(num1) - i - 1], num2[len(num2) - j - 1]))\n        return res\n    \n    def add(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        carry = 0\n        for i in range(len(num1)):\n            sum = carry + int(num1[i]) + int(num2[i])\n            carry = sum // 10\n            res = str(sum % 10) + res\n        if carry > 0:\n            res = str(carry) + res\n        return res\n    \n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = '0'\n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res = self.add(res, self.multiply(num1[len(num1) - i - 1], num2[len(num2) - j - 1]))\n        return res\n    \n    def add(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        carry = 0\n        for i in range(len(num1)):\n            sum = carry + int(num1[i]) + int(num2[i])\n            carry = sum // 10\n            res = str(sum % 10) + res\n        if carry > 0:\n            res = str(carry) + res\n        return res"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP\n        \n        ## 1. 2 pointer approach\n        ## 2. 1 pointer approach\n        ## 3. DP"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] != '(' and s[i] != ')':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [n] * (n + 1)\n        dp[0] = -1\n        \n        for i in range(n):\n            for j in range(i + 1):\n                if s[j:i + 1] == s[j:i + 1][::-1]:\n                    dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n        \n        return dp[n]"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^5 = 10^4 * 5 + 1\n        # 2. 10^6 = 10^5 * 6 + 1\n        # 3. 10^7 = 10^6 * 7 + 1\n        # 4. 10^8 = 10^7 * 8 + 1\n        # 5. 10^9 = 10^8 * 9 + 1\n        # 6. 10^10 = 10^9 * 10 + 1\n        # 7. 10^11 = 10^10 * 11 + 1\n        # 8. 10^12 = 10^11 * 12 + 1\n        # 9. 10^13 = 10^12 * 13 + 1\n        # 10. 10^14 = 10^13 * 14 + 1\n        # 11. 10^15 = 10^14 * 15 + 1\n        # 12. 10^16 = 10^15 * 16 + 1\n        # 13. 10^17 = 10^16 * 17 + 1\n        # 14. 10^18 = 10^17 * 18 + 1\n        # 15. 10^19 = 10^18 * 19 + 1\n        # 16. 10^20 = 10^19 * 20 + 1\n        # 17. 10^21 = 10^20 * 21 + 1\n        # 18. 10^22 = 10^21 * 22 + 1\n        # 19. 10^23 = 10^22 * 23 + 1\n        # 20. 10^24 = 10^23 * 24 + 1\n        # 21. 10^25 = 10^24 * 25 + 1\n        # 22. 10^26 = 10^25 * 26 + 1\n        # 23. 10^27 = 10^26 * 27 + 1\n        # 24. 10^28 = 10^27 * 28 + 1\n        # 25. 10^29 = 10^28 * 29 + 1\n        # 26. 10^30 = 10^29 * 30 + 1\n        # 27. 10^31 = 10^30 * 31 + 1\n        # 28. 10^32 = 10^31 * 32 + 1\n        # 29. 10^33 = 10^32 * 33 + 1\n        # 30. 10^34 = 10^33 * 34 + 1\n        # 31. 10^35 = 10^34 * 35 + 1\n        # 32. 10^36 = 10^35 * 36 + 1\n        # 33. 10^37 = 10^36 * 37 + 1\n        # 34. 10^38 = 10^37 * 38 + 1\n        # 35. 10^39 = 10^38 * 39 + 1\n        # 36. 10^40 = 10^39 * 40 + 1\n        # 37. 10^41 = 10^40 * 41 + 1\n        # 38. 10^42 = 10^41 * 42 + 1\n        # 39. 10^43 = 10^42 * 43 + 1\n        # 40. 10^44 = 10^43 * 44 + 1\n        # 41. 10^45 = 10^44 * 45 + 1\n        # 42. 10^46 = 10^45 * 46 + 1"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a reverse lookup table\n        reverse_lookup = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # build a result list\n        result = []\n        \n        # iterate over all words\n        for i, word in enumerate(words):\n            # check if the current word is a palindrome\n            if word in reverse_lookup:\n                # if it is, check if the reverse lookup table contains the reversed word\n                if i != reverse_lookup[word]:\n                    result.append([i, reverse_lookup[word]])\n            # check if the reversed word is a palindrome\n            for j in range(len(word) + 1):\n                # if it is, check if the reverse lookup table contains the reversed word\n                if word[j:] in reverse_lookup:\n                    result.append([reverse_lookup[word[j:]], i])\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            res += 1\n                            self.spread(isInfected, i, j)\n            return res\n        \n        def spread(isInfected, i, j):\n            m, n = len(isInfected), len(isInfected[0])\n            dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                    isInfected[ni][nj] = 2\n                    self.spread(isInfected, ni, nj)\n        \n        return spread(isInfected) + spread(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, dp, i, j))\n        \n        return res\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, x, y))\n        \n        return dp[i][j] + 1"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10\n        \n        if n < 1000:\n            return 100\n        \n        if n < 10000:\n            return 1000\n        \n        if n < 100000:\n            return 10000\n        \n        if n < 1000000:\n            return 100000\n        \n        if n < 10000000:\n            return 1000000\n        \n        if n < 100000000:\n            return 10000000\n        \n        if n < 1000000000:\n            return 100000000\n        \n        if n < 10000000000:\n            return 1000000000\n        \n        if n < 100000000000:\n            return 10000000000\n        \n        if n < 1000000000000:\n            return 100000000000\n        \n        if n < 10000000000000:\n            return 1000000000000\n        \n        if n < 100000000000000:\n            return 10000000000000\n        \n        if n < 1000000000000000:\n            return 100000000000000\n        \n        if n < 10000000000000000:\n            return 1000000000000000\n        \n        if n < 100000000000000000:\n            return 10000000000000000\n        \n        if n < 1000000000000000000:\n            return 100000000000000000\n        \n        if n < 10000000000000000000:\n            return 1000000000000000000\n        \n        if n < 100000000000000000000:\n            return 10000000000000000000\n        \n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        \n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        \n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        \n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        \n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        \n        if n < 100000000000000000000000000:\n            return"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n        \n        if dp[-1]:\n            res = []\n            i = len(s)\n            while i > 0:\n                if dp[i]:\n                    res.append(s[i - dp[i]:i + 1])\n                    i -= dp[i]\n                else:\n                    i -= 1\n            return res[::-1]\n        else:\n            return []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level += 1\n            level_list = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                result.append(level_list[::-1])\n            else:\n                result.append(level_list)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(n):\n            if n == 0:\n                return []\n            if n == 1:\n                return ['0:01','0:02','0:04','0:08','0:16','0:32','0:64','1:00','2:00','4:00','8:00']\n            if n == 2:\n                return ['0:03','0:05','0:06','0:09','0:15','0:30','0:60','1:01','2:01','4:01','8:01']\n            if n == 3:\n                return ['0:04','0:07','0:08','0:11','0:17','0:33','0:64','1:02','2:02','4:02','8:02']\n            if n == 4:\n                return ['0:05','0:06','0:09','0:17','0:34','0:65','1:03','2:03','4:03','8:03']\n            if n == 5:\n                return ['0:06','0:07','0:08','0:12','0:18','0:35','0:66','1:04','2:04','4:04','8:04']\n            if n == 6:\n                return ['0:07','0:08','0:13','0:19','0:36','0:67','1:05','2:05','4:05','8:05']\n            if n == 7:\n                return ['0:08','0:09','0:14','0:19','0:37','0:68','1:06','2:06','4:06','8:06']\n            if n == 8:\n                return ['0:09','0:10','0:15','0:19','0:38','0:69','1:07','2:07','4:07','8:07']\n            if n == 9:\n                return ['0:10','0:11','0:16','0:19','0:39','0:70','1:08','2:08','4:08','8:08']\n            if n == 10:\n                return ['0:11','0:12','0:17','0:19','0:40','0:71','1:09','2:09','4:09','8:09']\n            if n == 11:\n                return ['0:12','0:13','0:18','0:19','0:41','0:72','1:10','2:10','4:10','8:10']\n            if n == 12:\n                return ['0:13','0:14','0:19','0:20','0:42','0:73','1:11','2:11','4:11','8:11']\n            if n == 13:\n                return ['0:14','0:15','0:19','0:21','0:43','0:74','1:12','2:12','4:12','8:12']\n            if n == 14:\n                return ['0:15','0:16','0:19','0:22','0:44','0:75','1:13','2:13','4:13','8:13']\n            if n == 15:\n                return ['0:16','0:17','0:19','0:23','0:45','0:76','1:14','2:14','4:14','8:14']\n            if n == 16:\n                return ['0:17','0:18','0:19','0:24','0:46','0:77','1:15','2:15','4:15','8:15']"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, len(res[-1])):\n                temp.append(res[-1][j] + res[-1][j-1])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set((0, 0))\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(0, h - heightMap[ni][nj])\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n                    seen.add((ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the median\n        # 3. return the median\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the median\n        if len(nums) % 2 == 1:\n            return float(nums[len(nums) // 2])\n        else:\n            return (nums[len(nums) // 2] + nums[len(nums) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for _ in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                res = max(res, self.maxSubArray(sums, k))\n                if res == k:\n                    return k\n        return res\n        \n    def maxSubArray(self, sums, k):\n        s = set([0])\n        res = float('-inf')\n        for sum in sums:\n            res = max(res, sum - k)\n            res = max(res, sum - res)\n            if res in s:\n                return res\n            s.add(sum)\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend/divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend)/abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the number and its index\n        num_dict = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            \n            # check if the complement is in the dictionary\n            if target - num in num_dict:\n                \n                # return the index of the complement and the current index\n                return [num_dict[target - num], i]\n            \n            # add the number to the dictionary\n            num_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_a, new_b = a + b, a - b\n                        elif op == '-':\n                            new_a, new_b = a - b, b - a\n                        elif op == '*':\n                            new_a, new_b = a * b, a / b\n                        else:\n                            new_a, new_b = b / a, a / b\n                        if new_b > 0 and backtrack([new_a] + cards[1:], target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if p[0] != '*':\n            if len(s) > 0 and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '?'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/100998/Python-O(n)-time-O"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # if there is no more edges, add to the result\n            if len(graph[node]) == 0:\n                res.append(node)\n                return\n            # otherwise, iterate through all the edges\n            for neighbor in graph[node]:\n                graph[node].remove(neighbor)\n                dfs(neighbor)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = [[0, 0]]\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the building is ending\n            if building[1] < 0:\n                # add the building to the result\n                result.append([building[0], -building[1]])\n            else:\n                # find the index of the building in the result\n                i = 0\n                while i < len(result) and result[i][0] < building[0]:\n                    i += 1\n                # if the building is ending\n                if building[1] < 0:\n                    # remove the building from the result\n                    result.pop(i)\n                else:\n                    # update the height of the building in the result\n                    result[i][1] = max(result[i][1], -building[1])\n        \n        # sort the result by height\n        result.sort(key=lambda x: x[1])\n        \n        # return the result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + (\" \" + helper(num % 10))\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k] - dp[i-1-2k][j-k] + dp[i-1-2k][j-k-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k] - dp[i-1-2k][j-k] + dp[i-1-2k][j-k-1] + dp[i-1-2k][j-k-2] + ... + dp[i-1-2k][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k] - dp[i-1-2k][j-k] + dp[i-1-2k][j-k-1] + dp[i-1-2k][j-k-2] + ... + dp[i-1-2k][j-k] + dp[i-1-2k][j-k-3] + ... + dp[i-1-2k][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k] - dp[i-1-2k][j-k] + dp[i-1-2k][j-k-1] + dp[i-1-2k][j-k-2] + ... + dp[i-1-2k][j-k] + dp[i-1-2k][j-k-3] + ... + dp[i-1-2k][j-k] - dp[i-1-3k][j-k] + dp[i-1-3k][j-k-1] + dp[i-1-3k][j-k-2] + ... + dp[i-1-3k][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k] - dp[i-1-2k][j-k] + dp[i-1-2k][j-k-1] + dp[i-1-2k][j-k-2] + ... + dp[i-1-2k][j-k] + dp[i-1-2k][j-k-3] + ... + dp[i-1-2k][j-k] - dp[i-1-3k][j-k] + dp[i-1-3k][j-k-1] + dp[i-1-3k][j-k-2] + ... + dp[i-1-3k][j-k] + dp[i-1-3k][j-k-3] + ... + dp[i-1-3k][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1-k][j] + dp[i-1-k][j-k] - dp"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with only one parent\n        # 3. find the edge that connects the two nodes\n        # 4. return the edge\n        \n        # 1. find the node with two parents\n        parent_1 = None\n        parent_2 = None\n        for edge in edges:\n            if parent_1 and parent_2:\n                break\n            if edge[1] not in parent_1:\n                parent_1 = edge[1]\n            else:\n                parent_2 = edge[1]\n        \n        # 2. find the node with only one parent\n        parent_1_child = None\n        for edge in edges:\n            if edge[0] == parent_1:\n                parent_1_child = edge[1]\n            elif edge[0] == parent_2:\n                parent_2_child = edge[1]\n            if parent_1_child and parent_2_child:\n                break\n        \n        # 3. find the edge that connects the two nodes\n        if parent_1_child == parent_2:\n            return [parent_2, parent_1]\n        else:\n            return [parent_1_child, parent_2]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res, used):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\n                    continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(nums, path, res, used)\n                used[i] = False\n                path.pop()\n        \n        nums.sort()\n        used = [False] * len(nums)\n        res = []\n        backtrack(nums, [], res, used)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 = 1\n        ## 0 ^ 1 ^ 1 ^ 0 = 1\n        ## 0 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 0 ^ 1 = 1\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 1 ^ 0 = 0\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 = 1\n        ## 0 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 0 ^ 0 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 1 = 1\n        ## 1 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 0 ^ 0 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 1 ^ 0 = 0\n        ## 0 ^ 0 ^ 0 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 1 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 0 ^ 1 ^ 1 = 1\n        ## 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 0 ^ 1 ^ 1 = 1"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Solution 1:\n        # return len(s.split()[-1])\n        \n        # Solution 2:\n        # return len(s.split()[-1])\n        \n        # Solution 3:\n        # return len(s.split()[-1])\n        \n        # Solution 4:\n        # return len(s.split()[-1])\n        \n        # Solution 5:\n        # return len(s.split()[-1])\n        \n        # Solution 6:\n        # return len(s.split()[-1])\n        \n        # Solution 7:\n        # return len(s.split()[-1])\n        \n        # Solution 8:\n        # return len(s.split()[-1])\n        \n        # Solution 9:\n        # return len(s.split()[-1])\n        \n        # Solution 10:\n        # return len(s.split()[-1])\n        \n        # Solution 11:\n        # return len(s.split()[-1])\n        \n        # Solution 12:\n        # return len(s.split()[-1])\n        \n        # Solution 13:\n        # return len(s.split()[-1])\n        \n        # Solution 14:\n        # return len(s.split()[-1])\n        \n        # Solution 15:\n        # return len(s.split()[-1])\n        \n        # Solution 16:\n        # return len(s.split()[-1])\n        \n        # Solution 17:\n        # return len(s.split()[-1])\n        \n        # Solution 18:\n        # return len(s.split()[-1])\n        \n        # Solution 19:\n        # return len(s.split()[-1])\n        \n        # Solution 20:\n        # return len(s.split()[-1])\n        \n        # Solution 21:\n        # return len(s.split()[-1])\n        \n        # Solution 22:\n        # return len(s.split()[-1])\n        \n        # Solution 23:\n        # return len(s.split()[-1])\n        \n        # Solution 24:\n        # return len(s.split()[-1])\n        \n        # Solution 25:\n        # return len(s.split()[-1])\n        \n        # Solution 26:\n        # return len(s.split()[-1])\n        \n        # Solution 27:\n        # return len(s.split()[-1])\n        \n        # Solution 28:\n        # return len(s.split()[-1])\n        \n        # Solution 29:\n        # return len(s.split()[-1])\n        \n        # Solution 30:\n        # return len(s.split()[-1])\n        \n        # Solution 31:\n        # return len(s.split()[-1])\n        \n        # Solution 32:\n        # return len(s.split()[-1])\n        \n        # Solution 33:\n        # return len(s.split()[-1])\n        \n        # Solution 34:\n        # return len(s.split()[-1])\n        \n        # Solution 35:\n        # return len(s.split()[-1])\n        \n        # Solution 36:\n        # return len(s.split()[-1])\n        \n        # Solution 37:\n        # return len(s.split()[-1])\n        \n        # Solution 38:\n        # return len(s.split()[-1])\n        \n        # Solution 39:\n        # return len(s.split()[-1])\n        \n        # Solution 40:\n        # return len(s.split()[-1])\n        \n        # Solution 41:\n        # return len(s.split()[-1])\n        \n        # Solution 42:\n        # return len(s.split()[-1])\n        \n        # Solution 43:\n        # return len(s.split()[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + grid[i][j2]\n                    if j1 > 0:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1 - 1][j2] + grid[i][j1] + grid[i][j2])\n                    if j2 > 0:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1][j2 - 1] + grid[i][j1] + grid[i][j2])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if grid[n - 1][j1] * 2 + grid[n - 1][j2] * 2 == n * 2)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def getNext(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = getNext(n)\n        while fast != 1 and slow != fast:\n            slow = getNext(slow)\n            fast = getNext(getNext(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # binary search\n        # O(log n) runtime\n        #"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j-1]\n                elif j == 0:\n                    grid[i][j] += grid[i-1][j]\n                else:\n                    grid[i][j] += min(grid[i][j-1], grid[i-1][j])\n                    \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = '1'\n        for i in range(2, n+1):\n            curr = ''\n            count = 1\n            for j in range(1, len(prev)):\n                if prev[j] == prev[j-1]:\n                    count += 1\n                else:\n                    curr += str(count) + prev[j-1]\n                    count = 1\n            curr += str(count) + prev[-1]\n            prev = curr\n        return prev"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is too large, increase the max sum\n        # if the sum is too small, decrease the max sum\n        # binary search the max sum\n        \n        # find the max sum of the subarray\n        def getMaxSum(nums, k, maxSum):\n            curSum = 0\n            cnt = 1\n            for num in nums:\n                if curSum + num > maxSum:\n                    curSum = num\n                    cnt += 1\n                else:\n                    curSum += num\n            return cnt <= k\n        \n        # binary search\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if getMaxSum(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            # base case: no more digits to check\n            if not next_digits:\n                # completed combination\n                output.append(combination)\n                return\n            \n            # get the digit at the beginning of the next_digits\n            first_digit = next_digits[0]\n            \n            # recurse on the remaining digits with the first_digit\n            for letter in digit_to_letters[first_digit]:\n                backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n        dfs(0, [], 0)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if n[0] == '0':\n            return '0'\n        \n        if n[0] == '1':\n            if len(n) == 1:\n                return '9'\n            else:\n                return n[1:]\n        \n        if n[-1] == '0':\n            return n[:-1]\n        \n        if n[-1] == '9':\n            return n[:-1] + '1'\n        \n        if n[-1] == '1':\n            return n[:-1] + '0'\n        \n        if n[-1] == '9':\n            return n[:-1] + '8'\n        \n        if n[-1] == '5':\n            return n[:-1] + '4'\n        \n        if n[-1] == '4':\n            return n[:-1] + '3'\n        \n        if n[-1] == '6':\n            return n[:-1] + '7'\n        \n        if n[-1] == '7':\n            return n[:-1] + '8'\n        \n        if n[-1] == '8':\n            return n[:-1] + '9'\n        \n        if n[-1] == '9':\n            return n[:-1] + '9'\n        \n        return n[:-1] + '9'"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n // 2):\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum product and the current maximum product\n        max_product = nums[0]\n        curr_max = nums[0]\n        curr_min = nums[0]\n        \n        # Iterate through the array from the second element\n        for i in range(1, len(nums)):\n            # Calculate the current maximum product\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            \n            # Update the maximum product if necessary\n            max_product = max(max_product, curr_max)\n            \n        return max_product"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        stone_set = set(stones)\n        \n        dp = {0: set()}\n        \n        for stone in stones:\n            for prev in dp.get(stone - 1, set()):\n                for jump in [prev - 1, prev, prev + 1]:\n                    if jump > 0 and jump + stone in stone_set:\n                        if jump + stone == stones[-1]:\n                            return True\n                        dp.setdefault(jump + stone, set()).add(jump)\n        return False"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score = sorted(score, reverse=True)\n        \n        # create a hashmap to store the score and its corresponding rank\n        score_rank = {}\n        for i, s in enumerate(score):\n            score_rank[s] = i + 1\n        \n        # update the score and rank\n        for i, s in enumerate(score):\n            if i == 0:\n                score[i] = \"Gold Medal\"\n            elif i == 1:\n                score[i] = \"Silver Medal\"\n            elif i == 2:\n                score[i] = \"Bronze Medal\"\n            else:\n                score[i] = str(i + 1)\n        \n        # update the rank\n        for i, s in enumerate(score):\n            score[i] = score_rank[s]\n        \n        return score"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # 1. use a hashmap to store the last index of each char\n        # 2. use a variable to store the max length\n        # 3. use a variable to store the current length\n        # 4. iterate through the string\n        # 5. if the char is not in the hashmap, add it to the hashmap\n        # 6. if the char is in the hashmap, update the max length if needed\n        # 7. update the current length\n        # 8. return the max length\n        \n        if not s:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        last_index = {}\n        \n        for i in range(len(s)):\n            if s[i] in last_index:\n                curr_len = min(i - last_index[s[i]], curr_len + 1)\n            else:\n                curr_len += 1\n            max_len = max(max_len, curr_len)\n            last_index[s[i]] = i\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    left = j + word_len\n                    word_dict_copy = word_dict.copy()\n                if not word_dict_copy:\n                    res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        res = 1\n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                res += 1\n        return res"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr.next, curr\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid:\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n                i += 1\n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n            else:\n                if v2[i] > 0:\n                    return 1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end time\n        courses.sort(key=lambda x: x[1])\n        \n        # greedy\n        # max heap\n        # max heap of duration\n        # if duration > end time, remove max\n        # else add duration to max heap\n        # return len of max heap\n        \n        heap = []\n        time = 0\n        \n        for duration, end in courses:\n            heapq.heappush(heap, (-duration, end))\n            time += duration\n            if time > end:\n                time += heapq.heappop(heap)[0]\n        \n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            tail = prev\n            for i in range(k):\n                if not tail:\n                    return dummy.next\n                tail = tail.next\n            head = prev.next\n            tail = head\n            for i in range(k):\n                temp = head.next\n                head.next = head.next.next\n                tail.next = head\n                tail = head\n                head = temp\n            prev.next = tail\n            prev = head\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers\n        # 2. XOR all the numbers again\n        # 3. The remaining number is the answer\n        \n        a = 0\n        for num in nums:\n            a ^= num\n            \n        return a"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to form target[0:i]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be formed from target[0:j]\n        # dp[i] = min(dp[j] + 1) for j in stickers if target[j:i] can be"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        q = collections.deque()\n        res = []\n        \n        for i in range(len(nums)):\n            while q and q[0] <= i - k:\n                q.popleft()\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                res.append(nums[q[0]])\n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        left, right = 0, m\n        while left < right:\n            i = (left + right) // 2\n            j = (m + n + 1) // 2 - i\n            if nums1[i] < nums2[j]:\n                left = i + 1\n            else:\n                right = i\n        \n        i = left\n        j = (m + n + 1) // 2 - i\n        nums1_left = nums1[i] if i > 0 else float('-inf')\n        nums1_right = nums1[i - 1] if i < m else float('inf')\n        nums2_left = nums2[j] if j > 0 else float('-inf')\n        nums2_right = nums2[j - 1] if j < n else float('inf')\n        \n        if (m + n) % 2 == 1:\n            return max(nums1_left, nums2_left)\n        else:\n            return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[right]:\n                right = mid - 1\n            else:\n                left = mid + 1"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area / 2) = area\n        # 2. 2 * (area // 2) = area\n        # 3. 2 * (area // 2) = area\n        # 4. 2 * (area // 2) = area\n        # 5. 2 * (area // 2) = area\n        # 6. 2 * (area // 2) = area\n        # 7. 2 * (area // 2) = area\n        # 8. 2 * (area // 2) = area\n        # 9. 2 * (area // 2) = area\n        # 10. 2 * (area // 2) = area\n        # 11. 2 * (area // 2) = area\n        # 12. 2 * (area // 2) = area\n        # 13. 2 * (area // 2) = area\n        # 14. 2 * (area // 2) = area\n        # 15. 2 * (area // 2) = area\n        # 16. 2 * (area // 2) = area\n        # 17. 2 * (area // 2) = area\n        # 18. 2 * (area // 2) = area\n        # 19. 2 * (area // 2) = area\n        # 20. 2 * (area // 2) = area\n        # 21. 2 * (area // 2) = area\n        # 22. 2 * (area // 2) = area\n        # 23. 2 * (area // 2) = area\n        # 24. 2 * (area // 2) = area\n        # 25. 2 * (area // 2) = area\n        # 26. 2 * (area // 2) = area\n        # 27. 2 * (area // 2) = area\n        # 28. 2 * (area // 2) = area\n        # 29. 2 * (area // 2) = area\n        # 30. 2 * (area // 2) = area\n        # 31. 2 * (area // 2) = area\n        # 32. 2 * (area // 2) = area\n        # 33. 2 * (area // 2) = area\n        # 34. 2 * (area // 2) = area\n        # 35. 2 * (area // 2) = area\n        # 36. 2 * (area // 2) = area\n        # 37. 2 * (area // 2) = area\n        # 38. 2 * (area // 2) = area\n        # 39. 2 * (area // 2) = area\n        # 40. 2 * (area // 2) = area\n        # 41. 2 * (area // 2) = area\n        # 42. 2 * (area // 2) = area\n        # 43. 2 * (area // 2) = area\n        # 44. 2 * (area // 2) = area\n        # 45. 2 * (area // 2) = area\n        # 46. 2 * (area // 2) = area\n        # 47. 2 * (area // 2) = area\n        # 48. 2 * (area // 2) = area\n        # 49. 2 * (area // 2) = area\n        # 50. 2 * (area // 2) = area\n        # 51. 2 * (area // 2) = area\n        # 52. 2 * (area // 2) = area\n        # 53. 2 * (area // 2) = area\n        # 54. 2 * (area // 2) = area\n        # 55. 2 * (area // 2) = area\n        # 56. 2 * (area // 2) = area\n        # 57. 2 * (area // 2) = area\n        # 58."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m^2)\n        # Space: O(n * m^2)\n        # n: number of words in wordList\n        # m: length of each word\n        # m^2: number of possible transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList\n        # m: number of transformations\n        # m: number of words in wordList"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n            else:\n                res += [nums[i]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        return area == (x_max - x_min) * (y_max - y_min)"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber, rem = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + rem) + res\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [board[0][0]*10 + board[0][1]*1 + board[0][2],\n                    board[1][0]*10 + board[1][1]*1 + board[1][2]]\n        \n        # convert board_1d to a set\n        board_1d_set = set(board_1d)\n        \n        # convert board_1d to a string\n        board_1d_str = str(board_1d)\n        \n        # convert board_1d_str to a set\n        board_1d_str_set = set(board_1d_str)\n        \n        # if board_1d_str_set is the same as board_1d_set, return 0\n        if board_1d_str_set == board_1d_set:\n            return 0\n        \n        # create a queue\n        queue = collections.deque([board_1d_str])\n        \n        # create a set to store visited states\n        visited = set([board_1d_str])\n        \n        # create a dictionary to store the number of moves\n        moves = {board_1d_str: 0}\n        \n        # create a list of possible moves\n        possible_moves = [[1,3],[0,2,4],[1,5],[0,4],[1,3,5],[4,2]]\n        \n        # while queue is not empty\n        while queue:\n            # pop the first element from the queue\n            board_1d_str = queue.popleft()\n            \n            # if board_1d_str is the same as the target, return moves[board_1d_str]\n            if board_1d_str == '123450':\n                return moves[board_1d_str]\n            \n            # split board_1d_str into two parts\n            zero_index = board_1d_str.index('0')\n            board_1d_str_left = board_1d_str[:zero_index]\n            board_1d_str_right = board_1d_str[zero_index+1:]\n            \n            # for each possible move\n            for move in possible_moves:\n                # create a new board_1d_str_left\n                board_1d_str_left_new = board_1d_str_left[:move[0]] + board_1d_str_right[move[1]] + board_1d_str_left[move[0]+move[2]:]\n                \n                # if board_1d_str_left_new is not in visited, add it to visited\n                if board_1d_str_left_new not in visited:\n                    visited.add(board_1d_str_left_new)\n                    \n                    # add board_1d_str_left_new to queue\n                    queue.append(board_1d_str_left_new)\n                    \n                    # add board_1d_str_left_new to moves with moves[board_1d_str] + 1\n                    moves[board_1d_str_left_new] = moves[board_1d_str] + 1\n        \n        # return -1 if no solution is found\n        return -1"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] == nums[l]:\n                l += 1\n            elif nums[mid] > nums[l]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return s\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return res"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        ans = float('inf')\n        for n in inorder(root):\n            if prev:\n                ans = min(ans, n - prev)\n            prev = n\n        return ans"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return [0, float('-inf')]\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] == right[0]:\n                return [left[0] + 1, root.val]\n            elif left[0] > right[0]:\n                return [left[0] + 1, left[1]]\n            else:\n                return [right[0] + 1, right[1]]\n        \n        return dfs(root)[1:]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the number of repeating characters\n        # 3. check the number of special characters\n        # 4. check the number of digits\n        # 5. check the number of lowercase characters\n        # 6. check the number of uppercase characters\n        # 7. check the number of vowels\n        # 8. check the number of consonants\n        # 9. check the number of digits\n        # 10. check the number of special characters\n        # 11. check the number of digits\n        # 12. check the number of special characters\n        # 13. check the number of digits\n        # 14. check the number of special characters\n        # 15. check the number of digits\n        # 16. check the number of special characters\n        # 17. check the number of digits\n        # 18. check the number of special characters\n        # 19. check the number of digits\n        # 20. check the number of special characters\n        # 21. check the number of digits\n        # 22. check the number of special characters\n        # 23. check the number of digits\n        # 24. check the number of special characters\n        # 25. check the number of digits\n        # 26. check the number of special characters\n        # 27. check the number of digits\n        # 28. check the number of special characters\n        # 29. check the number of digits\n        # 30. check the number of special characters\n        # 31. check the number of digits\n        # 32. check the number of special characters\n        # 33. check the number of digits\n        # 34. check the number of special characters\n        # 35. check the number of digits\n        # 36. check the number of special characters\n        # 37. check the number of digits\n        # 38. check the number of special characters\n        # 39. check the number of digits\n        # 40. check the number of special characters\n        # 41. check the number of digits\n        # 42. check the number of special characters\n        # 43. check the number of digits\n        # 44. check the number of special characters\n        # 45. check the number of digits\n        # 46. check the number of special characters\n        # 47. check the number of digits\n        # 48. check the number of special characters\n        # 49. check the number of digits\n        # 50. check the number of special characters\n        # 51. check the number of digits\n        # 52. check the number of special characters\n        # 53. check the number of digits\n        # 54. check the number of special characters\n        # 55. check the number of digits\n        # 56. check the number of special characters\n        # 57. check the number of digits\n        # 58. check the number of special characters\n        # 59. check the number of digits\n        # 60. check the number of special characters\n        # 61. check the number of digits\n        # 62. check the number of special characters\n        # 63. check the number of digits\n        # 64. check the number of special characters\n        # 65. check the number of digits\n        # 66. check the number of special characters\n        # 67. check the number of digits\n        # 68. check the number of special characters\n        # 69. check the number of digits\n        # 70. check the number of special characters\n        # 71. check the number of digits\n        # 72. check the number of special characters\n        # 73. check the number of digits\n        # 74. check the number of special characters\n        # 75. check the number of digits\n        # 76. check the number of special characters\n        # 77. check the number of digits\n        # 78. check the number of special characters\n        # 79. check the number of digits\n        # 8"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n                \n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use a dict to store the number of smaller elements to the left\n        # 5. use a dict to store the number of smaller elements to the right\n        # 6. use a dict to store the number of smaller elements to the left\n        # 7. use a dict to store the number of smaller elements to the right\n        # 8. use a dict to store the number of smaller elements to the left\n        # 9. use a dict to store the number of smaller elements to the right\n        # 10. use a dict to store the number of smaller elements to the left\n        # 11. use a dict to store the number of smaller elements to the right\n        # 12. use a dict to store the number of smaller elements to the left\n        # 13. use a dict to store the number of smaller elements to the right\n        # 14. use a dict to store the number of smaller elements to the left\n        # 15. use a dict to store the number of smaller elements to the right\n        # 16. use a dict to store the number of smaller elements to the left\n        # 17. use a dict to store the number of smaller elements to the right\n        # 18. use a dict to store the number of smaller elements to the left\n        # 19. use a dict to store the number of smaller elements to the right\n        # 20. use a dict to store the number of smaller elements to the left\n        # 21. use a dict to store the number of smaller elements to the right\n        # 22. use a dict to store the number of smaller elements to the left\n        # 23. use a dict to store the number of smaller elements to the right\n        # 24. use a dict to store the number of smaller elements to the left\n        # 25. use a dict to store the number of smaller elements to the right\n        # 26. use a dict to store the number of smaller elements to the left\n        # 27. use a dict to store the number of smaller elements to the right\n        # 28. use a dict to store the number of smaller elements to the left\n        # 29. use a dict to store the number of smaller elements to the right\n        # 30. use a dict to store the number of smaller elements to the left\n        # 31. use a dict to store the number of smaller elements to the right\n        # 32. use a dict to store the number of smaller elements to the left\n        # 33. use a dict to store the number of smaller elements to the right\n        # 34. use a dict to store the number of smaller elements to the left\n        # 35. use a dict to store the number of smaller elements to the right\n        # 36. use a dict to store the number of smaller elements to the left\n        # 37. use a dict to store the number of smaller elements to the right\n        # 38. use a dict to store the number of smaller elements to the left\n        # 39. use a dict to store the number of smaller elements to the right\n        # 40. use a dict to store the number of smaller elements to the left\n        # 41. use a dict to store the number of smaller elements to the right\n        # 42. use a dict to store the number of smaller elements to the left\n        # 43. use a dict to store the number of smaller elements to the right\n        # 44. use a dict to store the number of smaller elements to the left\n        # 45. use a dict to store the number of smaller elements to the right\n        # 46. use a dict to store the number of smaller elements to the left\n        # 47. use a dict to store the number of smaller elements to the right\n        # 48. use a dict to store the number of smaller elements to the left\n        # 49. use a dict to store the number of smaller elements to the right\n        # 50. use a dict to store the number of smaller elements to the left\n        # 51. use a dict to store the number of smaller elements to the right\n        # 52. use a dict to store the number of smaller elements to the left\n        #"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = cur = 2\n        for s, e in intervals:\n            if s <= cur:\n                cur = e\n            else:\n                cur = e - 1\n                ans += 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                if node.right:\n                    stack.append(node.right)\n                if node.left:\n                    stack.append(node.left)\n                res.append(node.val)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n - i - 1)\n            for l in left:\n                for r in right:\n                    res.append('({}){}'.format(l, r))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n += nums[i]\n                i += 1\n            else:\n                patches += 1\n                if n < nums[i]:\n                    break\n                n += n\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. stack\n        # 6. dp\n        # 7. greedy\n        # 8. dp\n        # 9. greedy\n        # 10. dp\n        # 11. greedy\n        # 12. dp\n        # 13. greedy\n        # 14. dp\n        # 15. greedy\n        # 16. dp\n        # 17. greedy\n        # 18. dp\n        # 19. greedy\n        # 20. dp\n        # 21. greedy\n        # 22. dp\n        # 23. greedy\n        # 24. dp\n        # 25. greedy\n        # 26. dp\n        # 27. greedy\n        # 28. dp\n        # 29. greedy\n        # 30. dp\n        # 31. greedy\n        # 32. dp\n        # 33. greedy\n        # 34. dp\n        # 35. greedy\n        # 36. dp\n        # 37. greedy\n        # 38. dp\n        # 39. greedy\n        # 40. dp\n        # 41. greedy\n        # 42. dp\n        # 43. greedy\n        # 44. dp\n        # 45. greedy\n        # 46. dp\n        # 47. greedy\n        # 48. dp\n        # 49. greedy\n        # 50. dp\n        # 51. greedy\n        # 52. dp\n        # 53. greedy\n        # 54. dp\n        # 55. greedy\n        # 56. dp\n        # 57. greedy\n        # 58. dp\n        # 59. greedy\n        # 60. dp\n        # 61. greedy\n        # 62. dp\n        # 63. greedy\n        # 64. dp\n        # 65. greedy\n        # 66. dp\n        # 67. greedy\n        # 68. dp\n        # 69. greedy\n        # 70. dp\n        # 71. greedy\n        # 72. dp\n        # 73. greedy\n        # 74. dp\n        # 75. greedy\n        # 76. dp\n        # 77. greedy\n        # 78. dp\n        # 79. greedy\n        # 80. dp\n        # 81. greedy\n        # 82. dp\n        # 83. greedy\n        # 84. dp\n        # 85. greedy\n        # 86. dp\n        # 87. greedy\n        # 88. dp\n        # 89. greedy\n        # 90. dp\n        # 91. greedy\n        # 92. dp\n        # 93. greedy\n        # 94. dp\n        # 95. greedy\n        # 96. dp\n        # 97. greedy\n        # 98. dp\n        # 99. greedy\n        # 100. dp\n        # 101. greedy\n        # 102. dp\n        # 103. greedy\n        # 104. dp\n        # 105. greedy\n        # 106. dp\n        # 107. greedy\n        # 108. dp\n        # 109. greedy\n        # 110. dp\n        # 111. greedy\n        # 112. dp\n        # 113. greedy"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        res = ''\n        if (numerator < 0) ^ (denominator < 0):\n            res += '-'\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        numerator %= denominator\n        if numerator == 0:\n            return res\n        res += '.'\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + '(' + res[seen[numerator]:] + ')'\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        \n        for e in envelopes:\n            left, right = 0, len(dp) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if dp[mid] < e[1]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            if left == len(dp):\n                dp.append(e[1])\n            else:\n                dp[left] = e[1]\n        \n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ## O(m*n) time\n        \n        ## O(1) space\n        ##"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the node to remove\n        if length == n:\n            return head.next\n        \n        # 3. Find the node to remove\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        curr.next = curr.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) // len(machines)\n        ans = 0\n        curr = 0\n        for m in machines:\n            curr += m - avg\n            ans = max(ans, abs(curr), m - avg)\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(n, x // i)\n            return cnt\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list1.next, list2\n        \n        head = list1\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                list1 = list1.next\n            else:\n                list1.next, list2 = list2, list1\n                list1 = list1.next\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [curr + [num] for curr in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # 0 ^ 1 = 1\n        # 1 ^ 1 = 0\n        # 0 ^ 0 = 0\n        # 1 ^ 0 = 1\n        # 0 ^ 1 ^ 1 = 0\n        # 1 ^ 0 ^ 1 = 0\n        # 0 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 0 = 1\n        # 0 ^ 1 ^ 1 ^ 1 = 0\n        # 1 ^ 0 ^ 1 ^ 1 = 0\n        # 0 ^ 1 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 0 ^ 0 = 1\n        # 1 ^ 0 ^ 0 ^ 0 = 1\n        # 0 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 1 ^ 0 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 1 ^ 0 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 1 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 1 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 0 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 0 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 1 ^ 0 ^ 0 = 1\n        # 1 ^ 0 ^ 1 ^ 0 ^ 0 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 0 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        # 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 1 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 1 ^ 0 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 1 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 1 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 0 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 1 ^ 1 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 0 ^ 1 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 1 ^ 0 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 0 ^"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, row, col, num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1, 10):\n                if is_valid(board, row, col, str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first, second, prev = None, None, None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        first.val, second.val = second.val, first.val"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left, right = 0, num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        ans = [0]\n        for i in range(1, n + 1):\n            ans.append(ans[i >> 1] + (i & 1))\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node):\n            if board[i][j] not in node:\n                return False\n            \n            node = node[board[i][j]]\n            if '*' in node:\n                return True\n            \n            temp = board[i][j]\n            board[i][j] = '#'\n            res = any([dfs(i+1, j, node)\n                      ,dfs(i-1, j, node)\n                      ,dfs(i, j+1, node)\n                      ,dfs(i, j-1, node)])\n            board[i][j] = temp\n            return res\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['*'] = True\n        \n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, trie):\n                    res.append(word)\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for c in s_dict:\n            if s_dict[c] != t_dict.get(c, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                sub = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(sub)) != len(sub):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                res.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                res.append(\"Fizz\")\n            elif i % 5 == 0:\n                res.append(\"Buzz\")\n            else:\n                res.append(str(i))\n        return res"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res += (ord(columnTitle[i]) - ord('A') + 1) * (26 ** (len(columnTitle) - i - 1))\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            tmp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = tmp\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first.next, first.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i, j in zip(pattern, s):\n            if i not in d:\n                if j in d.values():\n                    return False\n                d[i] = j\n            elif d[i] != j:\n                return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        binary = ''.join('1' if bit == '0' else '0' for bit in binary)\n        \n        # 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        ans = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n            ans += dp[i]\n        \n        return ans"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur = []\n        cur_len = 0\n        for word in words:\n            if cur_len + len(word) + len(cur) > maxWidth:\n                if len(cur) == 1:\n                    res.append(cur[0] + ' ' * (maxWidth - cur_len))\n                else:\n                    num_spaces = (maxWidth - cur_len) // (len(cur) - 1)\n                    extra_spaces = (maxWidth - cur_len) % (len(cur) - 1)\n                    res.append(''.join(cur[i] + ' ' * num_spaces + (' ' if i < extra_spaces else '') for i in range(len(cur))))\n                cur = [word]\n                cur_len = len(word)\n            else:\n                cur.append(word)\n                cur_len += len(word)\n        if cur:\n            res.append(' '.join(cur) + ' ' * (maxWidth - len(' '.join(cur))))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                if node.left:\n                    stack.append(node.left)\n                if node.right:\n                    stack.append(node.right)\n                res.append(node.val)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area ="}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time: O(N^2)\n        # Space: O(N)\n        # 1. build a set of words\n        # 2. for each word, check if it can be built from other words in the set\n        # 3. if it can, add it to the result\n        # 4. if it can't, add it to the set\n        \n        word_set = set(words)\n        result = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                result.append(word)\n            word_set.add(word)\n            \n        return result\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and (suffix in word_set or self.dfs(suffix, word_set)):\n                return True\n        return len(word) > 0 and word not in word_set"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res if sign == 1 else \"-\" + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.'] * n for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, word, i, j):\n                    return True\n        \n        return False\n    \n    def dfs(self, board, word, i, j):\n        if len(word) == 0:\n            return True\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n            return False\n        \n        tmp = board[i][j]\n        board[i][j] = '#'\n        \n        res = self.dfs(board, word[1:], i + 1, j) or self.dfs(board, word[1:], i - 1, j) or self.dfs(board, word[1:], i, j + 1) or self.dfs(board, word[1:], i, j - 1)\n        \n        board[i][j] = tmp\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:n] = nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] ="}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max1 = max2 = max3 = float('-inf')\n        \n        for num in nums:\n            if num > max1:\n                max3 = max2\n                max2 = max1\n                max1 = num\n            elif num > max2:\n                max3 = max2\n                max2 = num\n            elif num > max3:\n                max3 = num\n                \n        return max3 if max3 != float('-inf') else max1"}]}