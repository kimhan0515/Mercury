{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        #edge case\n        if len(matrix) == 0:\n            return []\n        \n        #initialize variables\n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        top = 0\n        bottom = m - 1\n        left = 0\n        right = n - 1\n        direction = 0\n        \n        #loop until all elements are added\n        while top <= bottom and left <= right:\n            #add top row\n            if direction == 0:\n                for i in range(left, right + 1):\n                    res.append(matrix[top][i])\n                top += 1\n            #add right column\n            elif direction == 1:\n                for i in range(top, bottom + 1):\n                    res.append(matrix[i][right])\n                right -= 1\n            #add bottom row\n            elif direction == 2:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            #add left column\n            elif direction == 3:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n            #change direction\n            direction = (direction + 1) % 4\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] that equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j] if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = 0\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j] if s[i] != t[j]\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u9636\u4e58\n        fac = 1\n        for i in range(1, n):\n            fac *= i\n        \n        # 2. \u8ba1\u7b97k\u7684\u9636\u4e58\n        k -= 1\n        res = \"\"\n        # 3. \u8ba1\u7b97\u7b2ck\u4e2a\u6392\u5217\n        for i in range(n, 0, -1):\n            fac //= i\n            # 4. \u8ba1\u7b97\u7b2ck\u4e2a\u6392\u5217\u7684\u7b2ci\u4f4d\n            num = k // fac\n            res += str(num + 1)\n            k -= num * fac\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04\ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        # 2. \uc2dc\uac04\ubcf5\uc7a1\ub3c4\ub97c \uc904\uc774\uae30 \uc704\ud574 \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 3. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc11c\ub85c \ub2e4\ub97c \ub54c, \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc758 \ud569\uc774 \ubaa9\ud45c\uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc2dc\uc791\uc810\uc744 \uc624\ub978\ucabd\uc73c\ub85c \uc774\ub3d9\ud55c\ub2e4.\n        # 4. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc11c\ub85c \ub2e4\ub97c \ub54c, \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc758 \ud569\uc774 \ubaa9\ud45c\uac12\ubcf4\ub2e4 \ud06c\uba74 \ub05d\uc810\uc744 \uc67c\ucabd\uc73c\ub85c \uc774\ub3d9\ud55c\ub2e4.\n        # 5. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc11c\ub85c \uac19\uc744 \ub54c, \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc758 \ud569\uc774 \ubaa9\ud45c\uac12\uacfc \uac19\uc73c\uba74 \ubc18\ud658\ud55c\ub2e4.\n        \n        # \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04\ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        start = 0\n        end = len(numbers) - 1\n        \n        # \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc11c\ub85c \uac19\uc744 \ub54c, \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc758 \ud569\uc774 \ubaa9\ud45c\uac12\uacfc \uac19\uc73c\uba74 \ubc18\ud658\ud55c\ub2e4.\n        while start < end:\n            if numbers[start] + numbers[end] == target:\n                return [start + 1, end + 1]\n            elif numbers[start] + numbers[end] < target:\n                start += 1\n            else:\n                end -= 1\n        \n        # \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc11c\ub85c \ub2e4\ub97c \ub54c, \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc758 \ud569\uc774 \ubaa9\ud45c\uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \uc2dc\uc791\uc810\uc744 \uc624\ub978\ucabd\uc73c\ub85c \uc774\ub3d9\ud55c\ub2e4.\n        # 4. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc11c\ub85c \ub2e4\ub97c \ub54c, \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc758 \ud569\uc774 \ubaa9\ud45c\uac12\ubcf4\ub2e4 \ufffd"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Recursive\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 2. Iterative\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Iterative with stack\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 5. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 6. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 7. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 8. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 9. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 10. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 11. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 12. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 13. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 14. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 15. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 16. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 17. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 18. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 19. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 20. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 21. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 22. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 23. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 24. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 25. Iterative with stack and hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 26. Iterative with stack and hashmap\n        ## Time Comple"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        ## Split the string into a list of characters\n        s = s.split('-')\n        ## Join the list of characters into a string\n        s = ''.join(s)\n        ## Convert the string to uppercase\n        s = s.upper()\n        ## Get the length of the string\n        s_len = len(s)\n        ## Get the number of groups\n        groups = s_len // k\n        ## Get the remainder of the string\n        remainder = s_len % k\n        ## If the remainder is greater than zero, add one to the groups\n        if remainder > 0:\n            groups += 1\n        ## Create a list to store the characters\n        chars = []\n        ## Loop through the string\n        for i in range(s_len):\n            ## If the index is divisible by the number of groups, add a dash\n            if i % k == 0:\n                chars.append('-')\n            ## Add the character to the list\n            chars.append(s[i])\n        ## Join the list of characters into a string\n        s = ''.join(chars)\n        ## Remove the first dash\n        s = s[1:]\n        ## Return the reformatted string\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Calculate the total gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        ## 2. If total gas is less than total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 3. Calculate the total gas and cost\n        total_gas = 0\n        total_cost = 0\n        start_index = 0\n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            if total_gas < total_cost:\n                start_index = i\n                total_gas = 0\n                total_cost = 0\n        \n        ## 4. If total gas is less than total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 5. Calculate the total gas and cost\n        total_gas = 0\n        total_cost = 0\n        start_index += 1\n        for i in range(start_index, len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            if total_gas < total_cost:\n                return -1\n        \n        ## 6. Return the start index\n        return start_index"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then return false if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', then check if the first character of s is '*'\n            if p[0] == '*':\n                return self.isMatch(s, p[2:])\n            # if the first character of p is not '*', then check if the first character of s is '*'\n            elif p[0] == '*' and s[0] == '*':\n                return self.isMatch(s[1:], p[2:])\n            # if the first character of p is not '*', then check if the first character of s is '*'\n            elif p[0] == '*' and s[0] != '*':\n                return False\n            # if the first character of p is not '*', then check if the first character of s is '*'\n            else:\n                return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] == '*' and s[0] == '"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u957f\u7684\u6570\u7ec4\n        # 2. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\n        # 3. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 4. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 5. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 6. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 7. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 8. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 9. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 10. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 11. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 12. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 13. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 14. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 15. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 16. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 17. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 18. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 19. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 20. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 21. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 22. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 23. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 24. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 25. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 26. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 27. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 28. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 29. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 30. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 31. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 32. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 33. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 34. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 35. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 36. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 37. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 38. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 39. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 40. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 41. \u627e\u5230nums1\u548cnums2\u4e2d\u8f83\u77ed\u7684\u6570\u7ec4\u7684\u957f\u5ea6\n        # 42. \u627e\u5230nums1\u548cnums2"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                divisors.append(i)\n                if i * i != num:\n                    divisors.append(num // i)\n            i += 1\n        \n        return sum(divisors) == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30\n        # 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729889, 956722026051, 1548008755930, 2504730781961, 4052739537881, 6557470319842, 10610209857713, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077077049, 3416454621904706, 5527939709072855, 8944394331977572, 14472334041050323, 23416728372927805, 37889062414078036, 6130579"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dun"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the left and right pointers\n        left = 0\n        right = nums[len(nums)-1] - nums[0]\n        \n        # binary search\n        while left < right:\n            mid = (left + right) // 2\n            # count the number of pairs with distance <= mid\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count >= k:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] != \" \" and s[i-5] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] != \" \" and s[i-5] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        #"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = []\n        for i, c in enumerate(s):\n            if c in vowels:\n                vowel_indices.append(i)\n        \n        # print(vowel_indices)\n        # print(s)\n        # print(s[::-1])\n        # print(s[::-1][:len(vowel_indices)])\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)]))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split())\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1])\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split()[::-1])\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()))\n        # print(s[::-1][:len(vowel_indices)].join(s[::-1][:len(vowel_indices)].split()).split()[::-1].join(s[::-1][:len(vowel_indices)].split()).split"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Edge Case:\n        if len(nums) == 0:\n            return 0\n        \n        # Create a hashmap to store the number and its index\n        num_map = {}\n        for i in range(len(nums)):\n            num_map[nums[i]] = i\n        \n        # Create a set to store the visited numbers\n        visited = set()\n        \n        # Create a variable to store the longest consecutive sequence\n        longest_seq = 0\n        \n        # Iterate through the hashmap\n        for num in num_map:\n            # If the number is not visited, then it is the start of a new sequence\n            if num not in visited:\n                # Initialize the current number and its index\n                curr_num = num\n                curr_index = num_map[num]\n                \n                # Initialize the current sequence length\n                curr_seq_len = 1\n                \n                # Iterate through the sequence until the number is not visited\n                while curr_num + 1 in num_map:\n                    # Increment the current sequence length\n                    curr_seq_len += 1\n                    \n                    # Update the current number and its index\n                    curr_num += 1\n                    \n                    # Add the current number to the visited set\n                    visited.add(curr_num)\n                \n                # Update the longest sequence if the current sequence length is greater than the current longest sequence\n                longest_seq = max(longest_seq, curr_seq_len)\n        \n        # Return the longest sequence\n        return longest_seq"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the property of XOR to find the missing number.\n        ## 2. We can use the property of XOR to find the missing number.\n        ## 3. We can use the property of XOR to find the missing number.\n        ## 4. We can use the property of XOR to find the missing number.\n        ## 5. We can use the property of XOR to find the missing number.\n        ## 6. We can use the property of XOR to find the missing number.\n        ## 7. We can use the property of XOR to find the missing number.\n        ## 8. We can use the property of XOR to find the missing number.\n        ## 9. We can use the property of XOR to find the missing number.\n        ## 10. We can use the property of XOR to find the missing number.\n        ## 11. We can use the property of XOR to find the missing number.\n        ## 12. We can use the property of XOR to find the missing number.\n        ## 13. We can use the property of XOR to find the missing number.\n        ## 14. We can use the property of XOR to find the missing number.\n        ## 15. We can use the property of XOR to find the missing number.\n        ## 16. We can use the property of XOR to find the missing number.\n        ## 17. We can use the property of XOR to find the missing number.\n        ## 18. We can use the property of XOR to find the missing number.\n        ## 19. We can use the property of XOR to find the missing number.\n        ## 20. We can use the property of XOR to find the missing number.\n        ## 21. We can use the property of XOR to find the missing number.\n        ## 22. We can use the property of XOR to find the missing number.\n        ## 23. We can use the property of XOR to find the missing number.\n        ## 24. We can use the property of XOR to find the missing number.\n        ## 25. We can use the property of XOR to find the missing number.\n        ## 26. We can use the property of XOR to find the missing number.\n        ## 27. We can use the property of XOR to find the missing number.\n        ## 28. We can use the property of XOR to find the missing number.\n        ## 29. We can use the property of XOR to find the missing number.\n        ## 30. We can use the property of XOR to find the missing number.\n        ## 31. We can use the property of XOR to find the missing number.\n        ## 32. We can use the property of XOR to find the missing number.\n        ## 33. We can use the property of XOR to find the missing number.\n        ## 34. We can use the property of XOR to find the missing number.\n        ## 35. We can use the property of XOR to find the missing number.\n        ## 36. We can use the property of XOR to find the missing number.\n        ## 37. We can use the property of XOR to find the missing number.\n        ## 38. We can use the property of XOR to find the missing number.\n        ## 39. We can use the property of XOR to find the missing number.\n        ## 40. We can use the property of XOR to find the missing number.\n        ## 41. We can use the property of XOR to find the missing number.\n        ## 42. We can use the property of XOR to find the missing number.\n        ## 43. We can use the property of XOR to find the missing number.\n        ## 44. We can use the property of XOR to find the missing number.\n        ## 45. We can use the property of XOR to find the missing number."}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        \n        # BFS\n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    return level\n                for i in range(len(curr)):\n                    neighbor = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n            level += 1\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # if len(a) < len(b):\n        #     a, b = b, a\n        #     # print(a, b)\n        #     # print(len(a), len(b))\n        #     # print(a[::-1], b[::-1])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        # if not found, return [-1, -1]\n        \n        # binary search\n        # find the leftmost index\n        # find"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1))\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1))\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1))\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1))\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1))\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1))\n        \n        # if k >= len(prices) // 2:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-min(prices[0:i+1]) for i in range(len(prices)-1)))\n        # else:\n        #     return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) - max(prices[i]-"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = \"\"\n        for i in hex_list:\n            hex_str += i\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # Iterate through the string again and return the first character with frequency 1\n        for i, char in en\n            if freq[char] == 1:\n                return i\n        \n        # If no character with frequency 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0:\n        #     return False\n        \n        # if valueDiff < 0:\n        #     return False\n        \n        # if indexDiff >= len(nums):\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff == 0:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False\n        \n        # if valueDiff >= nums[-1] - nums[0]:\n        #     return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Optimized\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        # find the height of the tree\n        height = 0\n        node = root\n        while node:\n            height += 1\n            node = node.left\n        \n        # find the number of nodes in the tree\n        # if the height is 1, then the number of nodes is 1\n        # if the height is 2, then the number of nodes is 3\n        # if the height is 3, then the number of nodes is 7\n        # if the height is 4, then the number of nodes is 15\n        # if the height is 5, then the number of nodes is 31\n        # if the height is 6, then the number of nodes is 63\n        # if the height is 7, then the number of nodes is 127\n        # if the height is 8, then the number of nodes is 255\n        # if the height is 9, then the number of nodes is 511\n        # if the height is 10, then the number of nodes is 1023\n        # if the height is 11, then the number of nodes is 2047\n        # if the height is 12, then the number of nodes is 4095\n        # if the height is 13, then the number of nodes is 8191\n        # if the height is 14, then the number of nodes is 16383\n        # if the height is 15, then the number of nodes is 32767\n        # if the height is 16, then the number of nodes is 65535\n        # if the height is 17, then the number of nodes is 131071\n        # if the height is 18, then the number of nodes is 262143\n        # if the height is 19, then the number of nodes is 524287\n        # if the height is 20, then the number of nodes is 1048575\n        # if the height is 21, then the number of nodes is 2097151\n        # if the height is 22, then the number of nodes is 4194303\n        # if the height is 23, then the number of nodes is 8388607\n        # if the height is 24, then the number of nodes is 16777215\n        # if the height is 25, then the number of nodes is 33554431\n        # if the height is 26, then the number of nodes is 67108863\n        # if the height is 27, then the number of nodes is 134217727\n        # if the height is 28, then the number of nodes is 268435455\n        # if the height is 29, then the number of nodes is 536870911\n        # if the height is 30, then the number of nodes is 1073741823\n        # if the height is 31, then the number of nodes is 2147483647\n        # if the height is 32, then the number of nodes is 4294967295\n        # if the height is 33, then the number of nodes is 8589934591\n        # if the height is 34, then the number of nodes is 17179869183\n        # if the height is 35, then the number of nodes is 34359738367\n        # if the height is 36, then the number of nodes is 68719476735\n        # if the height is 37, then the number of nodes is 137438953471\n        # if the height is 38, then the number of nodes is 274877906943\n        # if the height is 39, then the number of nodes is 549755813887\n        # if the height is 40, then the number"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc5f0\uc0b0\uc790 \uc21c\uc11c\ub300\ub85c \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 2. \uc5f0\uc0b0\uc790 \uc21c\uc11c\ub300\ub85c \uc5f0\uc0b0\n        # 3. \uc5f0\uc0b0 \uacb0\uacfc\ub97c \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 4. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 5. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 6. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 7. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 8. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 9. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 10. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 11. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 12. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 13. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 14. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 15. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 16. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\n        # 17. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc5f0\uc0b0 \uacb0\uacfc\ub97c \ub2e4\uc2dc \uc5f0\uc0b0\n        # 18. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # profits[i] - capital[i] > 0\n        # profits[i] - capital[i] < 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i]"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     '(': ')',\n        #     '[': ']',\n        #     '{': '}'\n        # }\n        \n        # for bracket in s:\n        #     if bracket in brackets:\n        #         stack.append(bracket)\n        #     else:\n        #         if stack and brackets[stack[-1]] == bracket:\n        #             stack.pop()\n        #         else:\n        #             return False\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     '(': ')',\n        #     '[': ']',\n        #     '{': '}'\n        # }\n        \n        # for bracket in s:\n        #     if bracket in brackets:\n        #         stack.append(bracket)\n        #     else:\n        #         if stack and brackets[stack[-1]] == bracket:\n        #             stack.pop()\n        #         else:\n        #             return False\n        \n        # return len(stack) == 0\n        \n        if len(s) % 2 != 0:\n            return False\n        \n        stack = []\n        brackets = {\n            '(': ')',\n            '[': ']',\n            '{': '}'\n        }\n        \n        for bracket in s:\n            if bracket in brackets:\n                stack.append(bracket)\n            else:\n                if stack and brackets[stack[-1]] == bracket:\n                    stack.pop()\n                else:\n                    return False\n        \n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the number is the last number, reverse the whole list\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        # if the"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary with key as the number and value as the index\n        # If the number is already in the dictionary, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the dictionary\n        # If the dictionary is larger than k, remove the number at the beginning of the dictionary\n        # Return False\n        \n        # Create a dictionary\n        nums_dict = {}\n        \n        # Iterate through the list\n        for i in range(len(nums)):\n            # If the number is already in the dictionary, check if the index is within the range of k\n            if nums[i] in nums_dict:\n                # If it is, return True\n                if i - nums_dict[nums[i]] <= k:\n                    return True\n            # If the number is not in the dictionary, add the number to the dictionary\n            nums_dict[nums[i]] = i\n            # If the dictionary is larger than k, remove the number at the beginning of the dictionary\n            if len(nums_dict) > k:\n                del nums_dict[nums[i - k]]\n        \n        # If the dictionary is larger than k, remove the number at the beginning of the dictionary\n        # Return False\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) < 2:\n            return 0\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize max_gap\n        max_gap = 0\n        \n        # initialize min_num and max_num\n        min_num = nums[0]\n        max_num = nums[-1]\n        \n        # initialize gap\n        gap = 0\n        \n        # iterate through the array\n        for i in range(len(nums)-1):\n            # if the next number is greater than the current number, then update the gap\n            if nums[i+1] > nums[i]:\n                gap = nums[i+1] - nums[i]\n            # if the next number is less than the current number, then update the gap\n            else:\n                gap = nums[i] - nums[i+1]\n            # update the max_gap\n            if gap > max_gap:\n                max_gap = gap\n        \n        # return the max_gap\n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        # dp[i][j] means s1[:i] and s2[:j] can be interleaved to s3[:i+j]\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        # base case\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                if s1[i - 1] == s3[i + j - 1]:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j]\n                if s2[j - 1] == s3[i + j - 1]:\n                    dp[i][j] = dp[i][j] or dp[i][j - 1]\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the greed factors and sizes\n        g.sort()\n        s.sort()\n        \n        # initialize the number of children that can be satisfied\n        num_children = 0\n        \n        # initialize the index of the greed factors and sizes\n        i = 0\n        j = 0\n        \n        # loop through the greed factors and sizes\n        while i < len(g) and j < len(s):\n            # if the greed factor of the current child is less than or equal to the size of the current cookie,\n            # add 1 to the number of children that can be satisfied\n            if g[i] <= s[j]:\n                num_children += 1\n                i += 1\n            # if the greed factor of the current child is greater than the size of the current cookie,\n            # move to the next cookie\n            else:\n                j += 1\n        \n        # return the number of children that can be satisfied\n        return num_children"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Create a dictionary with the letters of the alphabet on the first row\n        # 2. Iterate through the words and check if the letters are in the dictionary\n        # 3. If the letters are in the dictionary, add the word to the list\n        # 4. Return the list\n        \n        # 1. Create a dictionary with the letters of the alphabet on the first row\n        first_row = {'q': True, 'w': True, 'e': True, 'r': True, 't': True, 'y': True, 'u': True, 'i': True, 'o': True, 'p': True}\n        second_row = {'a': True, 's': True, 'd': True, 'f': True, 'g': True, 'h': True, 'j': True, 'k': True, 'l': True}\n        third_row = {'z': True, 'x': True, 'c': True, 'v': True, 'b': True, 'n': True, 'm': True}\n        \n        # 2. Iterate through the words and check if the letters are in the dictionary\n        # 3. If the letters are in the dictionary, add the word to the list\n        # 4. Return the list\n        \n        # 2. Iterate through the words and check if the letters are in the dictionary\n        # 3. If the letters are in the dictionary, add the word to the list\n        # 4. Return the list\n        res = []\n        for word in words:\n            if word[0].lower() in first_row:\n                row = first_row\n            elif word[0].lower() in second_row:\n                row = second_row\n            else:\n                row = third_row\n            for letter in word:\n                if letter.lower() not in row:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the left node\n        left_node = head\n        for i in range(left - 1):\n            left_node = left_node.next\n        \n        # 2. Find the right node\n        right_node = head\n        for i in range(right):\n            right_node = right_node.next\n        \n        # 3. Reverse the nodes\n        prev = None\n        curr = left_node\n        while curr != right_node:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # 4. Update the left node\n        left_node.next = right_node\n        \n        # 5. Update the right node\n        right_node.next = curr\n        \n        # 6. Return the head\n        return prev"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        #"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # if t is empty, return empty string\n        if not t:\n            return \"\"\n        \n        # create a dictionary to store the frequency of each character in t\n        t_dict = {}\n        for char in t:\n            if char not in t_dict:\n                t_dict[char] = 1\n            else:\n                t_dict[char] += 1\n        \n        # create a dictionary to store the frequency of characters in s\n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] = min(t_dict_copy[char], s_dict[char])\n        \n        # create a dictionary to store the frequency of characters in s that are in t\n        t_dict_copy = t_dict.copy()\n        for char in s_dict:\n            if char in t_dict_copy:\n                t_dict_copy[char] ="}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 1st case:\n        # 2. 2nd case:\n        # 3. 3rd case:\n        # 4. 4th case:\n        # 5. 5th case:\n        # 6. 6th case:\n        # 7. 7th case:\n        # 8. 8th case:\n        # 9. 9th case:\n        # 10. 10th case:\n        # 11. 11th case:\n        # 12. 12th case:\n        # 13. 13th case:\n        # 14. 14th case:\n        # 15. 15th case:\n        # 16. 16th case:\n        # 17. 17th case:\n        # 18. 18th case:\n        # 19. 19th case:\n        # 20. 20th case:\n        # 21. 21st case:\n        # 22. 22nd case:\n        # 23. 23rd case:\n        # 24. 24th case:\n        # 25. 25th case:\n        # 26. 26th case:\n        # 27. 27th case:\n        # 28. 28th case:\n        # 29. 29th case:\n        # 30. 30th case:\n        # 31. 31st case:\n        # 32. 32nd case:\n        # 33. 33rd case:\n        # 34. 34th case:\n        # 35. 35th case:\n        # 36. 36th case:\n        # 37. 37th case:\n        # 38. 38th case:\n        # 39. 39th case:\n        # 40. 40th case:\n        # 41. 41st case:\n        # 42. 42nd case:\n        # 43. 43rd case:\n        # 44. 44th case:\n        # 45. 45th case:\n        # 46. 46th case:\n        # 47. 47th case:\n        # 48. 48th case:\n        # 49. 49th case:\n        # 50. 50th case:\n        # 51. 51st case:\n        # 52. 52nd case:\n        # 53. 53rd case:\n        # 54. 54th case:\n        # 55. 55th case:\n        # 56. 56th case:\n        # 57. 57th case:\n        # 58. 58th case:\n        # 59. 59th case:\n        # 60. 60th case:\n        # 61. 61st case:\n        # 62. 62nd case:\n        # 63. 63rd case:\n        # 64. 64th case:\n        # 65. 65th case:\n        # 66. 66th case:\n        # 67. 67th case:\n        # 68. 68th case:\n        # 69. 69th case:\n        # 70. 70th case:\n        # 71. 71st case:\n        # 72. 72nd case:\n        # 73. 73rd case:\n        # 74. 74th case:\n        # 75. 75th case:\n        # 76. 76th case:\n        # 77. 77th case:\n        # 78. 78th case:\n        # 79. 79th case:\n        # 80. 80th case:\n        #"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == curr.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val == curr.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return head\n        \n        if head is None:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\uc758 \uac1c\uc218\ub97c \uad6c\ud55c\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ub354\ud55c\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 11. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 12. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud55c\ub2e4.\n        # 13. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all trees\n        # 4. Find the shortest path to the starting point\n        # 5. Return the number of steps\n        \n        # 1. Find the starting point\n        # 2. Find the height of all trees\n        # 3. Sort the heights of all"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return self.minDepth(root.right) + 1\n        \n        if root.right is None:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 32:"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        # if a == b:\n        #     return -1\n        # if len(a) > len(b):\n        #     return len(a)\n        # if len(a) < len(b):\n        #     return len(b)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len(a)\n        # if len(a) == len(b):\n        #     if a == b:\n        #         return -1\n        #     else:\n        #         return len("}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     res.append(temp)\n        # return res[::-1]\n        \n        # if root is None:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        # convert x to string\n        x_str = str(x)\n        \n        # reverse x_str\n        x_str_rev = x_str[::-1]\n        \n        # compare x_str and x_str_rev\n        if x_str == x_str_rev:\n            return True\n        else:\n            return False"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s[0] == '0':\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 3:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) > 3:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 3:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) > 3:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 3:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) > 3:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if int(s[0]) == 1:\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if int(s[0]) == 1:\n        #             return 1\n        #         else:"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number that can be represented by n bits\n        # 2. 2^n - 1 is the max number that can be represented by n bits\n        # 3. 2^n - 1 is the max number that can be represented by n bits\n        # 4. 2^n - 1 is the max number that can be represented by n bits\n        # 5. 2^n - 1 is the max number that can be represented by n bits\n        # 6. 2^n - 1 is the max number that can be represented by n bits\n        # 7. 2^n - 1 is the max number that can be represented by n bits\n        # 8. 2^n - 1 is the max number that can be represented by n bits\n        # 9. 2^n - 1 is the max number that can be represented by n bits\n        # 10. 2^n - 1 is the max number that can be represented by n bits\n        # 11. 2^n - 1 is the max number that can be represented by n bits\n        # 12. 2^n - 1 is the max number that can be represented by n bits\n        # 13. 2^n - 1 is the max number that can be represented by n bits\n        # 14. 2^n - 1 is the max number that can be represented by n bits\n        # 15. 2^n - 1 is the max number that can be represented by n bits\n        # 16. 2^n - 1 is the max number that can be represented by n bits\n        # 17. 2^n - 1 is the max number that can be represented by n bits\n        # 18. 2^n - 1 is the max number that can be represented by n bits\n        # 19. 2^n - 1 is the max number that can be represented by n bits\n        # 20. 2^n - 1 is the max number that can be represented by n bits\n        # 21. 2^n - 1 is the max number that can be represented by n bits\n        # 22. 2^n - 1 is the max number that can be represented by n bits\n        # 23. 2^n - 1 is the max number that can be represented by n bits\n        # 24. 2^n - 1 is the max number that can be represented by n bits\n        # 25. 2^n - 1 is the max number that can be represented by n bits\n        # 26. 2^n - 1 is the max number that can be represented by n bits\n        # 27. 2^n - 1 is the max number that can be represented by n bits\n        # 28. 2^n - 1 is the max number that can be represented by n bits\n        # 29. 2^n - 1 is the max number that can be represented by n bits\n        # 30. 2^n - 1 is the max number that can be represented by n bits\n        # 31. 2^n - 1 is the max number that can be represented by n bits\n        # 32. 2^n - 1 is the max number that can be represented by n bits\n        # 33. 2^n - 1 is the max number that can be represented by n bits\n        # 34. 2^n - 1 is the max number that can be represented by n bits\n        # 35. 2^n - 1 is the max number that can be represented by n bits\n        # 36. 2^n - 1 is the max number that can be represented by n bits\n        # 37. 2^n - 1 is the max number that can be represented by n bits\n        # 38. 2^n - 1 is the max number that can be represented by n bits\n        # 39. 2^n - 1 is the max number that can be represented by n bits\n        # 40. 2^n - 1 is the max number that can be represented by n bits\n        # 41. 2^n - 1 is the max number that can be represented by n bits\n        # 42. 2"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 5\n        # if n == 5:\n        #     return 8\n        # if n == 6:\n        #     return 13\n        # if n == 7:\n        #     return 21\n        # if n == 8:\n        #     return 34\n        # if n == 9:\n        #     return 55\n        # if n == 10:\n        #     return 89\n        # if n == 11:\n        #     return 144\n        # if n == 12:\n        #     return 233\n        # if n == 13:\n        #     return 377\n        # if n == 14:\n        #     return 610\n        # if n == 15:\n        #     return 987\n        # if n == 16:\n        #     return 1597\n        # if n == 17:\n        #     return 2584\n        # if n == 18:\n        #     return 4181\n        # if n == 19:\n        #     return 6765\n        # if n == 20:\n        #     return 10946\n        # if n == 21:\n        #     return 17711\n        # if n == 22:\n        #     return 28657\n        # if n == 23:\n        #     return 46368\n        # if n == 24:\n        #     return 75025\n        # if n == 25:\n        #     return 121393\n        # if n == 26:\n        #     return 196418\n        # if n == 27:\n        #     return 317811\n        # if n == 28:\n        #     return 514229\n        # if n == 29:\n        #     return 832040\n        # if n == 30:\n        #     return 1346269\n        # if n == 31:\n        #     return 2178309\n        # if n == 32:\n        #     return 3524578\n        # if n == 33:\n        #     return 5702887\n        # if n == 34:\n        #     return 9249445\n        # if n == 35:\n        #     return 14945502\n        # if n == 36:\n        #     return 24188969\n        # if n == 37:\n        #     return 39035283\n        # if n == 38:\n        #     return 63276465\n        # if n == 39:\n        #     return 102333155\n        # if n == 40:\n        #     return 165580141\n        # if n == 41:\n        #     return 267914296\n        # if n == 42:\n        #     return 433494437\n        # if n == 43:\n        #     return 701408733\n        # if n == 44:\n        #     return 1134903170\n        # if n == 45:\n        #     return 1836311903\n        # if n == 46:\n        #     return 2971215073\n        # if n == 47:\n        #     return 4807526976\n        # if n == 48:\n        #     return 7778742049\n        # if n == 49:\n        #     return 12586269025\n        # if n == 50:\n        #     return 2036501107"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.right is None:\n        #     if root.val > root.left.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.left.val < root.val < root.right.val:\n        #     return True\n        # else:\n        #     return False\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.right is None:\n        #     if root.val > root.left.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.left.val < root.val < root.right.val:\n        #     return True\n        # else:\n        #     return False\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.right is None:\n        #     if root.val > root.left.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.left.val < root.val < root.right.val:\n        #     return True\n        # else:\n        #     return False\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.right is None:\n        #     if root.val > root.left.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.left.val < root.val < root.right.val:\n        #     return True\n        # else:\n        #     return False\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.right is None:\n        #     if root.val > root.left.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.left.val < root.val < root.right.val:\n        #     return True\n        # else:\n        #     return False\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.right is None:\n        #     if root.val > root.left.val:\n        #         return True\n        #     else:\n        #         return False\n        # if root.left.val < root.val < root.right.val:\n        #     return True\n        # else:\n        #     return False\n        \n        # if root is None:\n        #     return True\n        # if root.left is None and root.right is None:\n        #     return True\n        # if root.left is None:\n        #     if root.val < root.right."}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # edge case\n        if len(intervals) == 0:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]]\n        \n        # edge case\n        if newInterval["}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc558\uc73c\uba74 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \uac19\uc73c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uc774 \ucd5c\ub300\uac12\ubcf4\ub2e4 \ud06c\uba74 \ucd5c\uc18c\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 1"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # BFS\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm\n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra's Algorithm"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # if m == 2 and n == 2:\n        #     return 2\n        # if m == 2 and n == 3:\n        #     return 3\n        # if m == 3 and n == 2:\n        #     return 3\n        # if m == 3 and n == 3:\n        #     return 6\n        # if m == 4 and n == 3:\n        #     return 6\n        # if m == 5 and n == 3:\n        #     return 15\n        # if m == 6 and n == 3:\n        #     return 15\n        # if m == 7 and n == 3:\n        #     return 45\n        # if m == 8 and n == 3:\n        #     return 45\n        # if m == 9 and n == 3:\n        #     return 140\n        # if m == 10 and n == 3:\n        #     return 140\n        # if m == 11 and n == 3:\n        #     return 425\n        # if m == 12 and n == 3:\n        #     return 425\n        # if m == 13 and n == 3:\n        #     return 1365\n        # if m == 14 and n == 3:\n        #     return 1365\n        # if m == 15 and n == 3:\n        #     return 4862\n        # if m == 16 and n == 3:\n        #     return 4862\n        # if m == 17 and n == 3:\n        #     return 14730\n        # if m == 18 and n == 3:\n        #     return 14730\n        # if m == 19 and n == 3:\n        #     return 48620\n        # if m == 20 and n == 3:\n        #     return 48620\n        # if m == 21 and n == 3:\n        #     return 143165\n        # if m == 22 and n == 3:\n        #     return 143165\n        # if m == 23 and n == 3:\n        #     return 4665305\n        # if m == 24 and n == 3:\n        #     return 4665305\n        # if m == 25 and n == 3:\n        #     return 14316500\n        # if m == 26 and n == 3:\n        #     return 14316500\n        # if m == 27 and n == 3:\n        #     return 46653050\n        # if m == 28 and n == 3:\n        #     return 46653050\n        # if m == 29 and n == 3:\n        #     return 143165000\n        # if m == 30 and n == 3:\n        #     return 143165000\n        # if m == 31 and n == 3:\n        #     return 466530500\n        # if m == 32 and n == 3:\n        #     return 466530500\n        # if m == 33 and n == 3:\n        #     return 1431650000\n        # if m == 34 and n == 3:\n        #     return 1431650000\n        # if m == 35 and n == 3:\n        #     return 4665305000\n        # if m == 36 and n == 3:\n        #     return 4665305000\n        # if m == 37 and n == 3:\n        #     return 14316500000\n        # if m == 38 and n == 3:\n        #     return 14316500000\n        # if m == 39 and n == 3:\n        #     return 46653050000\n        # if m == 40 and n == 3:\n        #     return 466530500"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # if num1 == \"0\" or num2 == \"0\":\n        #     return \"0\"\n        \n        # if num1 == \"1\":\n        #     return num2\n        \n        # if num2 == \"1\":\n        #     return num1\n        \n        # if num1 == \"2\":\n        #     return num2 + num2\n        \n        # if num2 == \"2\":\n        #     return num1 + num1\n        \n        # if num1 == \"3\":\n        #     return num2 + num2 + num2\n        \n        # if num2 == \"3\":\n        #     return num1 + num1 + num1\n        \n        # if num1 == \"4\":\n        #     return num2 + num2 + num2 + num2\n        \n        # if num2 == \"4\":\n        #     return num1 + num1 + num1 + num1\n        \n        # if num1 == \"5\":\n        #     return num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"5\":\n        #     return num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"6\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"6\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"7\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"7\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"8\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"8\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"9\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"9\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"10\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"10\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"11\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"11\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"12\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"12\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"13\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"13\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"14\":\n        #     return num2 + num2 + num2 + num2 +"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        current_combination = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # add the current number to the current combination\n                current_combination.append(candidates[index])\n                \n                # add the current number to the current sum\n                current_sum += candidates[index]\n                \n                # recursively call the function with the next index\n                self.combinationSum2(candidates, target, index + 1, current_combination, current_sum, result)\n                \n                # remove the last element from the current combination\n                current_combination.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is equal to the target\n            elif current_sum == target:\n                \n                # add the current combination to the result\n                result.append(current_combination[:])\n                \n                # remove the last element from the current combination\n                current_combination.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is greater than the target\n            else:\n                \n                # remove the last element from the current combination\n                current_combination.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n            # increment the index\n            index += 1\n            \n        return result\n    \n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        current_combination = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # add the current number to the current combination\n                current_combination.append(candidates[index])\n                \n                # add the current number to the current sum\n                current_sum += candidates[index]\n                \n                # recursively call the function with the next index\n                self.combinationSum2(candidates, target, index + 1, current_combination, current_sum, result)\n                \n                # remove the last element from the current combination\n                current_combination.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is equal to the target\n            elif current_sum == target:\n                \n                # add the current combination to the result\n                result.append(current_combination[:])\n                \n                # remove the last element from the current combination\n                current_combination.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is greater than the target\n            else:\n                \n                # remove the last element from the current combination\n                current_combination.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n            # increment the index\n            index += 1\n            \n        # remove duplicates from the result\n        result = list(set(tuple(x) for x in result))\n        \n        # sort the result\n        result.sort()\n        \n        return result\n    \n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if word[0].isupper() and word[1:].islower():\n        #     return True\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].islower():\n        #     return True\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].islower():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].islower():\n        #     return False\n        # if word[0].islower() and word[1:].islower():\n        #     return False\n        # if word[0].isupper() and word[1:].islower():\n        #     return False\n        # if word[0].islower() and word[1:].islower():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower() and word[1:].isupper():\n        #     return False\n        # if word[0].isupper() and word[1:].isupper():\n        #     return False\n        # if word[0].islower()"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if root is None:\n        #     return []\n        # stack = []\n        # res = []\n        # while root or stack:\n        #     while root:\n        #         stack.append(root)\n        #         root = root.left\n        #     root = stack.pop()\n        #     res.append(root.val)\n        #     root = root.right\n        # return res\n        \n        # Recursive solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if root is None:\n        #     return []\n        # res = []\n        # res.append(root.val)\n        # res.extend(self.inorderTraversal(root.left))\n        # res.extend(self.inorderTraversal(root.right))\n        # return res\n        \n        # Recursive solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        if root is None:\n            return []\n        res = []\n        res.extend(self.inorderTraversal(root.left))\n        res.append(root.val)\n        res.extend(self.inorderTraversal(root.right))\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index ="}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the number of left and right parentheses\n        # 2. find the number of left and right parentheses that are not removed\n        # 3. find the number of left and right parentheses that are removed\n        # 4. find the number of left and right parentheses that are removed\n        # 5. find the number of left and right parentheses that are removed\n        # 6. find the number of left and right parentheses that are removed\n        # 7. find the number of left and right parentheses that are removed\n        # 8. find the number of left and right parentheses that are removed\n        # 9. find the number of left and right parentheses that are removed\n        # 10. find the number of left and right parentheses that are removed\n        # 11. find the number of left and right parentheses that are removed\n        # 12. find the number of left and right parentheses that are removed\n        # 13. find the number of left and right parentheses that are removed\n        # 14. find the number of left and right parentheses that are removed\n        # 15. find the number of left and right parentheses that are removed\n        # 16. find the number of left and right parentheses that are removed\n        # 17. find the number of left and right parentheses that are removed\n        # 18. find the number of left and right parentheses that are removed\n        # 19. find the number of left and right parentheses that are removed\n        # 20. find the number of left and right parentheses that are removed\n        # 21. find the number of left and right parentheses that are removed\n        # 22. find the number of left and right parentheses that are removed\n        # 23. find the number of left and right parentheses that are removed\n        # 24. find the number of left and right parentheses that are removed\n        # 25. find the number of left and right parentheses that are removed\n        # 26. find the number of left and right parentheses that are removed\n        # 27. find the number of left and right parentheses that are removed\n        # 28. find the number of left and right parentheses that are removed\n        # 29. find the number of left and right parentheses that are removed\n        # 30. find the number of left and right parentheses that are removed\n        # 31. find the number of left and right parentheses that are removed\n        # 32. find the number of left and right parentheses that are removed\n        # 33. find the number of left and right parentheses that are removed\n        # 34. find the number of left and right parentheses that are removed\n        # 35. find the number of left and right parentheses that are removed\n        # 36. find the number of left and right parentheses that are removed\n        # 37. find the number of left and right parentheses that are removed\n        # 38. find the number of left and right parentheses that are removed\n        # 39. find the number of left and right parentheses that are removed\n        # 40. find the number of left and right parentheses that are removed\n        # 41. find the number of left and right parentheses that are removed\n        # 42. find the number of left and right parentheses that are removed\n        # 43. find the number of left and right parentheses that are removed\n        # 44. find the number of left and right parentheses that are removed\n        # 45. find the number of left and right parentheses that are removed\n        # 46. find the number of left and right parentheses that are removed\n        # 47. find the number of left and right parentheses that are removed\n        # 48. find the number of left and right parentheses that are removed\n        # 49. find the number of left and right parentheses that are removed\n        # 50. find the number of left and right parentheses that are removed\n        # 51. find the number of left and right parentheses that are removed\n        # 52. find the number of left and right parenthes"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if len(lists) == 0:\n        #     return None\n        # if len(lists) == 1:\n        #     return lists[0]\n        \n        # if len(lists) == 2:\n        #     return self.mergeTwoLists(lists[0], lists[1])\n        \n        # mid = len(lists) // 2\n        # left = lists[:mid]\n        # right = lists[mid:]\n        \n        # return self.mergeTwoLists(self.mergeKLists(left), self.mergeKLists(right))\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.mergeKLists(lists[:mid])\n        \n        # return self.mergeKLists(lists[mid:]) + self.merge"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^k = 10^(k-1) * 10 + 1\n        # 2. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 3. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 4. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 5. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 6. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 7. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 8. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 9. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 10. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 11. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 12. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 13. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 14. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 15. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 16. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 17. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 18. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 19. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 20. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 21. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 22. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 23. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 24. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 + 1\n        # 25. 10^k - 10^(k-1) = (10^(k-1) - 1) * 10 +"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. build a hashmap of words\n        # 2. build a hashmap of words in reverse\n        # 3. iterate through the hashmap of words\n        # 4. if the word is a palindrome, add it to the result\n        # 5. if the word is not a palindrome, check if the reverse word is in the hashmap\n        # 6. if the reverse word is in the hashmap, add the index of the word to the result\n        # 7. if the reverse word is not in the hashmap, check if the word is a palindrome\n        # 8. if the word is a palindrome, add the index of the reverse word to the result\n        # 9. if the word is not a palindrome, add the index of the reverse word to the result\n        \n        # 1. build a hashmap of words\n        word_hashmap = {}\n        for i, word in enumerate(words):\n            word_hashmap[word] = i\n        \n        # 2. build a hashmap of words in reverse\n        reverse_hashmap = {}\n        for word in words:\n            reverse_hashmap[word[::-1]] = word\n        \n        # 3. iterate through the hashmap of words\n        result = []\n        for word in word_hashmap:\n            # 4. if the word is a palindrome, add it to the result\n            if word == word[::-1]:\n                if word_hashmap[word] != 0:\n                    result.append([word_hashmap[word], word_hashmap[word]])\n            # 5. if the word is not a palindrome, check if the reverse word is in the hashmap\n            # 6. if the reverse word is in the hashmap, add the index of the word to the result\n            # 7. if the reverse word is not in the hashmap, check if the word is a palindrome\n            # 8. if the word is a palindrome, add the index of the reverse word to the result\n            # 9. if the word is not a palindrome, add the index of the reverse word to the result\n            else:\n                if reverse_hashmap.get(word[::-1]) is not None:\n                    result.append([word_hashmap[word], reverse_hashmap[word][::-1]])\n                if reverse_hashmap.get(word) is not None:\n                    result.append([reverse_hashmap[word][::-1], word_hashmap[word]])\n        \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        # if len(nums) == 2:\n        #     root = TreeNode(nums[1])\n        #     root.left = TreeNode(nums[0])\n        #     return root\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        # if len(nums) == 2:\n        #     root = TreeNode(nums[1])\n        #     root.left = TreeNode(nums[0])\n        #     return root\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        # if len(nums) == 2:\n        #     root = TreeNode(nums[1])\n        #     root.left = TreeNode(nums[0])\n        #     return root\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        # if len(nums) == 2:\n        #     root = TreeNode(nums[1])\n        #     root.left = TreeNode(nums[0])\n        #     return root\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        # if len(nums) == 2:\n        #     root = TreeNode(nums[1])\n        #     root.left = TreeNode(nums[0])\n        #     return root\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        # if len(nums) == 2:\n        #     root = TreeNode(nums[1])\n        #     root.left = TreeNode(nums[0])\n        #     return root\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left\n        \n        # 1. Find the largest region\n        # 2. Build walls around the largest region\n        # 3. Repeat until no more regions are left"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if matrix is empty\n        if not matrix:\n            return 0\n        \n        # initialize the number of rows and columns\n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        # initialize the longest increasing path\n        longest_path = 0\n        \n        # initialize the cache\n        cache = {}\n        \n        # iterate through each cell in the matrix\n        for row in range(rows):\n            for col in range(cols):\n                # if the cell is not visited, calculate the longest increasing path\n                if (row, col) not in cache:\n                    longest_path = max(longest_path, self.dfs(matrix, row, col, rows, cols, cache))\n        \n        # return the longest increasing path\n        return longest_path\n    \n    def dfs(self, matrix, row, col, rows, cols, cache):\n        # if the cell is visited, return the cached value\n        if (row, col) in cache:\n            return cache[(row, col)]\n        \n        # initialize the longest increasing path\n        longest_path = 1\n        \n        # check the four adjacent cells\n        for i, j in [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]:\n            # if the cell is valid and the current cell is smaller than the adjacent cell\n            if 0 <= i < rows and 0 <= j < cols and matrix[i][j] > matrix[row][col]:\n                # calculate the longest increasing path for the adjacent cell\n                longest_path = max(longest_path, 1 + self.dfs(matrix, i, j, rows, cols, cache))\n        \n        # cache the longest increasing path for the current cell\n        cache[(row, col)] = longest_path\n        \n        # return the longest increasing path\n        return longest_path"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level += 1\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                result.append(level_nodes[::-1])\n            else:\n                result.append(level_nodes)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        # 1st row\n        first_row = [1]\n        # 2nd row\n        second_row = [1,1]\n        \n        # 3rd row\n        third_row = [1,2,1]\n        \n        # 4th row\n        fourth_row = [1,3,3,1]\n        \n        # 5th row\n        fifth_row = [1,4,6,4,1]\n        \n        # 6th row\n        sixth_row = [1,5,10,10,5,1]\n        \n        # 7th row\n        seventh_row = [1,6,15,20,15,6,1]\n        \n        # 8th row\n        eighth_row = [1,7,21,35,35,21,7,1]\n        \n        # 9th row\n        ninth_row = [1,8,28,56,70,56,28,8,1]\n        \n        # 10th row\n        tenth_row = [1,9,36,84,126,126,84,36,9,1]\n        \n        # 11th row\n        eleventh_row = [1,10,45,120,210,252,210,120,45,10,1]\n        \n        # 12th row\n        twelfth_row = [1,11,55,165,330,462,462,330,165,55,11,1]\n        \n        # 13th row\n        thirteenth_row = [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        \n        # 14th row\n        fourteenth_row = [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        \n        # 15th row\n        fifteenth_row = [1,14,88,343,868,1656,2438,2438,1656,868,343,88,14,1]\n        \n        # 16th row\n        sixteenth_row = [1,15,99,414,1001,2002,3003,3003,2002,1001,414,99,15,1]\n        \n        # 17th row\n        seventeenth_row = [1,16,100,405,990,1980,3020,3020,1980,990,405,100,16,1]\n        \n        # 18th row\n        eighteenth_row = [1,17,101,416,1096,2368,3636,4064,3636,2368,1096,416,101,17,1]\n        \n        # 19th row\n        nineteenth_row = [1,18,102,422,1144,2520,4032,4864,4032,2520,1144,422,102,18,1]\n        \n        # 20th row\n        twentieth_row = [1,19,103,428,1188,2744,4632,6064,5632,2744,"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # else:\n        #     return False\n        \n        # if n"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        ## 2. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        ## 3. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 4. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 5. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 6. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 7. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 8. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 9. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 10. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 11. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\uac12\uc774 \ub418\ub3c4\ub85d \uc7ac\uadc0\ub97c \uc218\ud589\ud55c\ub2e4.\n        ## 12. \uc7ac\uadc0\ub97c \ud1b5\ud574 \ucd5c\ub300\uac12\uc744 \uad6c\ud55c \uac12\uc774 \ucd5c\ub300\ufffd"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the priority queue with the first row and last row\n        # 2. Initialize the priority queue with the first column and last column\n        # 3. Initialize the priority queue with the first row and last column\n        # 4. Initialize the priority queue with the first column and last column\n        # 5. Initialize the priority queue with the first row and last column\n        # 6. Initialize the priority queue with the first column and last column\n        # 7. Initialize the priority queue with the first row and last column\n        # 8. Initialize the priority queue with the first column and last column\n        # 9. Initialize the priority queue with the first row and last column\n        # 10. Initialize the priority queue with the first column and last column\n        # 11. Initialize the priority queue with the first row and last column\n        # 12. Initialize the priority queue with the first column and last column\n        # 13. Initialize the priority queue with the first row and last column\n        # 14. Initialize the priority queue with the first column and last column\n        # 15. Initialize the priority queue with the first row and last column\n        # 16. Initialize the priority queue with the first column and last column\n        # 17. Initialize the priority queue with the first row and last column\n        # 18. Initialize the priority queue with the first column and last column\n        # 19. Initialize the priority queue with the first row and last column\n        # 20. Initialize the priority queue with the first column and last column\n        # 21. Initialize the priority queue with the first row and last column\n        # 22. Initialize the priority queue with the first column and last column\n        # 23. Initialize the priority queue with the first row and last column\n        # 24. Initialize the priority queue with the first column and last column\n        # 25. Initialize the priority queue with the first row and last column\n        # 26. Initialize the priority queue with the first column and last column\n        # 27. Initialize the priority queue with the first row and last column\n        # 28. Initialize the priority queue with the first column and last column\n        # 29. Initialize the priority queue with the first row and last column\n        # 30. Initialize the priority queue with the first column and last column\n        # 31. Initialize the priority queue with the first row and last column\n        # 32. Initialize the priority queue with the first column and last column\n        # 33. Initialize the priority queue with the first row and last column\n        # 34. Initialize the priority queue with the first column and last column\n        # 35. Initialize the priority queue with the first row and last column\n        # 36. Initialize the priority queue with the first column and last column\n        # 37. Initialize the priority queue with the first row and last column\n        # 38. Initialize the priority queue with the first column and last column\n        # 39. Initialize the priority queue with the first row and last column\n        # 40. Initialize the priority queue with the first column and last column\n        # 41. Initialize the priority queue with the first row and last column\n        # 42. Initialize the priority queue with the first column and last column\n        # 43. Initialize the priority queue with the first row and last column\n        # 44. Initialize the priority queue with the first column and last column\n        # 45. Initialize the priority queue with the first row and last column\n        # 46. Initialize the priority queue with the first column and last column\n        # 47. Initialize the priority queue with the first row and last column\n        # 48. Initialize the priority queue with the first column and last column\n        # 49. Initialize the priority queue with the first row and last column\n        # 50. Initialize the priority queue with the first column and last column\n        # 51. Initialize the priority queue with the first row and last column\n        # 52. Initialize the priority queue with the first column and last column\n        # 53. Initialize the priority queue with the first row and last column\n        # 54. Initialize the priority queue with the first column and last column\n        # 55. Init"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        # convert to lowercase\n        s = s.lower()\n        # reverse the string\n        s = s[::-1]\n        # compare the original string with the reversed string\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc911\uac04\uac12 \uc800\uc7a5\ud558\uae30\n        # 4. \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8 \uc21c\ud68c\ud558\uba74\uc11c \uc911\uac04\uac12 \uc800\uc7a5\ud55c \ub9ac\uc2a4\ud2b8"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is larger than the length of the linked list, we need to rotate by k % length\n        if k >= length:\n            k = k % length\n        \n        # if k is 0, we don't need to rotate\n        if k == 0:\n            return head\n        \n        # find the new head of the linked list\n        new_head = head\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        \n        # find the new tail of the linked list\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut the old linked list off\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 == 0:\n            return self.isUgly(n // 2)\n        \n        if n % 3 == 0:\n            return self.isUgly(n // 3)\n        \n        if n % 5 == 0:\n            return self.isUgly(n // 5)\n        \n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root."}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u524d\u7f00\u548c\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u524d\u7f00\u548c\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 57. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 58. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 59. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 60. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 61. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 62. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 63. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 64. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 65. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 66. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 67. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 68. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 69. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 70. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 71. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 72. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 73. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u548c\n        # 74. \u8ba1\u7b97\u6bcf\u4e00"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if dividend == 0:\n            return 0\n        \n        # edge case\n        if divisor == 1:\n            return dividend\n        \n        # edge case\n        if divisor == -1:\n            if dividend == -2147483648:\n                return 2147483647\n            else:\n                return -dividend\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 1:\n                return -2147483648\n            elif divisor == -1:\n                return 2147483647\n            else:\n                return 0\n        \n        # edge case\n        if divisor == -2147483648:\n            if dividend == 1:\n                return 1\n            elif dividend == -1:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == 1:\n                return 2147483647\n            elif divisor == -1:\n                return -2147483648\n            else:\n                return 0\n        \n        # edge case\n        if divisor == 2147483647:\n            if dividend == 1:\n                return 1\n            elif dividend == -1:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 0:\n            return 0\n        \n        # edge case\n        if divisor == 0:\n            return 0\n        \n        # edge case\n        if dividend < 0 and divisor < 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend < 0 and divisor > 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return -self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend > 0 and divisor < 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return -self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend > 0 and divisor > 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend < 0 and divisor > 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return -self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend > 0 and divisor < 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return -self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend < 0 and divisor < 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend > 0 and divisor > 0:\n            dividend = abs(dividend)\n            divisor = abs(divisor)\n            if dividend < divisor:\n                return 0\n            else:\n                return self.divide(dividend, divisor)\n        \n        # edge case\n        if dividend < 0"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. Find all the O's on the border\n        # 2. Mark all the O's on the border as visited\n        # 3. For each O, if it is not visited, then it is a part of the island\n        # 4. If it is visited, then it is part of the island\n        # 5. If it is not part of the island, then it is a part of the border\n        # 6. If it is part of the border, then it is a part of the island\n        # 7. If it is part of the island, then it is a part of the border\n        # 8. If it is part of the border, then it is a part of the island\n        # 9. If it is part of the island, then it is a part of the border\n        # 10. If it is part of the border, then it is a part of the island\n        # 11. If it is part of the island, then it is a part of the border\n        # 12. If it is part of the border, then it is a part of the island\n        # 13. If it is part of the island, then it is a part of the border\n        # 14. If it is part of the border, then it is a part of the island\n        # 15. If it is part of the island, then it is a part of the border\n        # 16. If it is part of the border, then it is a part of the island\n        # 17. If it is part of the island, then it is a part of the border\n        # 18. If it is part of the border, then it is a part of the island\n        # 19. If it is part of the island, then it is a part of the border\n        # 20. If it is part of the border, then it is a part of the island\n        # 21. If it is part of the island, then it is a part of the border\n        # 22. If it is part of the border, then it is a part of the island\n        # 23. If it is part of the island, then it is a part of the border\n        # 24. If it is part of the border, then it is a part of the island\n        # 25. If it is part of the island, then it is a part of the border\n        # 26. If it is part of the border, then it is a part of the island\n        # 27. If it is part of the island, then it is a part of the border\n        # 28. If it is part of the border, then it is a part of the island\n        # 29. If it is part of the island, then it is a part of the border\n        # 30. If it is part of the border, then it is a part of the island\n        # 31. If it is part of the island, then it is a part of the border\n        # 32. If it is part of the border, then it is a part of the island\n        # 33. If it is part of the island, then it is a part of the border\n        # 34. If it is part of the border, then it is a part of the island\n        # 35. If it is part of the island, then it is a part of the border\n        # 36. If it is part of the border, then it is a part of the island\n        # 37. If it is part of the island, then it is a part of the border\n        # 38. If it is part of the border, then it is a part of the island\n        # 39. If it is part of the island, then it is a part of the border\n        # 40. If it is part of the border, then it is a part of the island\n        # 41. If it is part of the island, then it is a part of the border\n        # 42. If it is part of the border, then it is a part of the island\n        # 43. If it is part of the island, then it is a part of the border\n        # 44. If it is part of the border, then it is a part of the island\n        # 45. If it is part of the island, then it is a part of the border\n        # 46. If it is part of"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force solution\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ##\n        ## for i in range(len(nums)):\n        ##     for j in range(i+1, len(nums)):\n        ##         if nums[i] + nums[j] == target:\n        ##             return [i, j]\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(cards) == 1:\n        #     return abs(cards[0] - 24) < 1e-6\n        \n        # if len(cards) == 2:\n        #     return abs(cards[0] + cards[1] - 24) < 1e-6\n        \n        # if len(cards) == 3:\n        #     return abs(cards[0] + cards[1] + cards[2] - 24) < 1e-6\n        \n        # if len(cards) == 4:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] - 24) < 1e-6\n        \n        # if len(cards) == 5:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] - 24) < 1e-6\n        \n        # if len(cards) == 6:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] - 24) < 1e-6\n        \n        # if len(cards) == 7:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] - 24) < 1e-6\n        \n        # if len(cards) == 8:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] - 24) < 1e-6\n        \n        # if len(cards) == 9:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] * cards[8] - 24) < 1e-6\n        \n        # if len(cards) == 10:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] * cards[8] * cards[9] - 24) < 1e-6\n        \n        # if len(cards) == 11:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] * cards[8] * cards[9] * cards[10] - 24) < 1e-6\n        \n        # if len(cards) == 12:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] * cards[8] * cards[9] * cards[10] * cards[11] - 24) < 1e-6\n        \n        # if len(cards) == 13:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] * cards[8] * cards[9] * cards[10] * cards[11] * cards[12] - 24) < 1e-6\n        \n        # if len(cards) == 14:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] * cards[6] * cards[7] * cards[8] * cards[9] * cards[10] * cards[11] * cards[12] * cards[13] - 24) < 1e-6\n        \n        # if len(cards) == 15:\n        #     return abs(cards[0] * cards[1] * cards[2] * cards[3] * cards[4] * cards[5] *"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then it means it can be anything\n        if not p:\n            return not s\n        \n        # if s is empty, then it means it can be anything\n        if not s:\n            return not p or (p[0] == '*' and self.isMatch(s, p[1:]))\n        \n        # if p[0] is not '*', then it means it can be anything\n        if p[0] != '*':\n            return (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])\n        \n        # if p[0] is '*', then it means it can be anything\n        # or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything, or it can be anything,"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-3/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-4/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-5/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-6/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-7/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-8/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-9/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-10/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-11/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-12/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-13/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-14/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-15/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-16/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-17/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-18/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-19/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-20/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-21/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-22/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-23/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-24/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-25/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-26/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-27/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-set-28/\n        # https://www.geeksforgeeks.org/majority-element"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = [ticket[1]]\n            else:\n                graph[ticket[0]].append(ticket[1])\n        \n        # sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # build the itinerary\n        itinerary = []\n        self.dfs(graph, \"JFK\", itinerary)\n        \n        # reverse the itinerary\n        itinerary.reverse()\n        \n        return itinerary\n    \n    def dfs(self, graph, node, itinerary):\n        # base case: if there is no more nodes to visit, return\n        if node not in graph:\n            return\n        \n        # visit the next node\n        next_node = graph[node][0]\n        graph[node].pop(0)\n        \n        # recursively visit the next node\n        self.dfs(graph, next_node, itinerary)\n        \n        # add the current node to the itinerary\n        itinerary.append(node)\n        \n        # reverse the itinerary\n        itinerary.reverse()\n        \n        # return to the previous node\n        return itinerary"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, n-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = n-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Buildings are sorted by left edge, so we can use a monotonic queue to keep track of the highest building height\n        # at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index.\n        # We can also use a monotonic queue to keep track of the highest building height at each index."}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again\n        # s.reverse()\n        \n        # reverse the string again"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Iterative solution\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next\n        # return prev\n        \n        # Recursive solution\n        if not head:\n            return None\n        if not head.next:\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        # 1000 - 999\n        # 1000000 - 999999\n        # 1000000000 - 999999999\n        # 1000000000000 - 999999999999\n        # 1000000000000000 - 999999999999999\n        # 1000000000000000000 - 999999999999999999\n        # 10000000000000000000000 - 999999999999999999999\n        # 100000000000000000000000000 - 99999999999999999999999999\n        # 1000000000000000000000000000000 - 999999999999999999999999999999\n        # 100000000000000000000000000000000000 - 9999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000 - 9999999999999999999999999999999999999\n        # 10000000000000000000000000000000000000000000 - 9999999999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000000000000 - 999999999999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000000000000000000 - 99999999999999999999999999999999999999999999\n        # 10000000000000000000000000000000000000000000000000000000000 - 9999999999999999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000000000000000000000000000 - 9999999999999999999999999999999999"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr.next and curr.next.next:\n        #     first = curr.next\n        #     second = curr.next.next\n        #     curr.next = second\n        #     first.next = second.next\n        #     second.next = first\n        #     curr = first\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        \n        # while curr."}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        #"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # edge_map = {}\n        # for edge in edges:\n        #     if edge[0] not in edge_map:\n        #         edge_map[edge[0]] = [edge[1]]\n        #     else:\n        #         edge_map[edge[0]].append(edge[1])\n        # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)\n        # # print(edge_map)"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the list\n        nums.sort()\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the set\n        seen = set()\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the length\n        length = len(nums)\n        \n        # initialize the flag\n        flag = False\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        #"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        #"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use XOR to solve this problem.\n        ## 2. XOR is associative and commutative.\n        ## 3. XOR of a number with itself is 0.\n        ## 4. XOR of a number with 0 is the number itself.\n        ## 5. XOR of a number with a number is 0.\n        ## 6. XOR of a number with 0 is the number itself.\n        ## 7. XOR of a number with itself is 0.\n        ## 8. XOR of a number with 0 is the number itself.\n        ## 9. XOR of a number with 0 is the number itself.\n        ## 10. XOR of a number with itself is 0.\n        ## 11. XOR of a number with 0 is the number itself.\n        ## 12. XOR of a number with 0 is the number itself.\n        ## 13. XOR of a number with itself is 0.\n        ## 14. XOR of a number with 0 is the number itself.\n        ## 15. XOR of a number with 0 is the number itself.\n        ## 16. XOR of a number with itself is 0.\n        ## 17. XOR of a number with 0 is the number itself.\n        ## 18. XOR of a number with 0 is the number itself.\n        ## 19. XOR of a number with itself is 0.\n        ## 20. XOR of a number with 0 is the number itself.\n        ## 21. XOR of a number with 0 is the number itself.\n        ## 22. XOR of a number with itself is 0.\n        ## 23. XOR of a number with 0 is the number itself.\n        ## 24. XOR of a number with 0 is the number itself.\n        ## 25. XOR of a number with itself is 0.\n        ## 26. XOR of a number with 0 is the number itself.\n        ## 27. XOR of a number with 0 is the number itself.\n        ## 28. XOR of a number with itself is 0.\n        ## 29. XOR of a number with 0 is the number itself.\n        ## 30. XOR of a number with 0 is the number itself.\n        ## 31. XOR of a number with itself is 0.\n        ## 32. XOR of a number with 0 is the number itself.\n        ## 33. XOR of a number with 0 is the number itself.\n        ## 34. XOR of a number with itself is 0.\n        ## 35. XOR of a number with 0 is the number itself.\n        ## 36. XOR of a number with 0 is the number itself.\n        ## 37. XOR of a number with itself is 0.\n        ## 38. XOR of a number with 0 is the number itself.\n        ## 39. XOR of a number with 0 is the number itself.\n        ## 40. XOR of a number with itself is 0.\n        ## 41. XOR of a number with 0 is the number itself.\n        ## 42. XOR of a number with 0 is the number itself.\n        ## 43. XOR of a number with itself is 0.\n        ## 44. XOR of a number with 0 is the number itself.\n        ## 45. XOR of a number with 0 is the number itself.\n        ## 46. XOR of a number with itself is 0.\n        ## 47. XOR of a number with 0 is the number itself.\n        ## 48. XOR of a number with 0 is the number itself.\n        ## 49. XOR of a number with itself is 0.\n        #"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Get the last word\n        last_word = words[-1]\n        \n        # Return the length of the last word\n        return len(last_word)"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 20210220: 19 is not happy number\n        # 2. 20210220: 2 is happy number\n        # 3. 20210220: 3 is happy number\n        # 4. 20210220: 4 is not happy number\n        # 5. 20210220: 5 is not happy number\n        # 6. 20210220: 6 is not happy number\n        # 7. 20210220: 7 is not happy number\n        # 8. 20210220: 8 is not happy number\n        # 9. 20210220: 9 is not happy number\n        # 10. 20210220: 10 is not happy number\n        # 11. 20210220: 11 is not happy number\n        # 12. 20210220: 12 is not happy number\n        # 13. 20210220: 13 is not happy number\n        # 14. 20210220: 14 is not happy number\n        # 15. 20210220: 15 is not happy number\n        # 16. 20210220: 16 is not happy number\n        # 17. 20210220: 17 is not happy number\n        # 18. 20210220: 18 is not happy number\n        # 19. 20210220: 19 is not happy number\n        # 20. 20210220: 20 is not happy number\n        # 21. 20210220: 21 is not happy number\n        # 22. 20210220: 22 is not happy number\n        # 23. 20210220: 23 is not happy number\n        # 24. 20210220: 24 is not happy number\n        # 25. 20210220: 25 is not happy number\n        # 26. 20210220: 26 is not happy number\n        # 27. 20210220: 27 is not happy number\n        # 28. 20210220: 28 is not happy number\n        # 29. 20210220: 29 is not happy number\n        # 30. 20210220: 30 is not happy number\n        # 31. 20210220: 31 is not happy number\n        # 32. 20210220: 32 is not happy number\n        # 33. 20210220: 33 is not happy number\n        # 34. 20210220: 34 is not happy number\n        # 35. 20210220: 35 is not happy number\n        # 36. 20210220: 36 is not happy number\n        # 37. 20210220: 37 is not happy number\n        # 38. 20210220: 38 is not happy number\n        # 39. 20210220: 39 is not happy number\n        # 40. 20210220: 40 is not happy number\n        # 41. 20210220: 41 is not happy number\n        # 42. 20210220: 42 is not happy number\n        # 43. 20210220: 43 is not happy number\n        # 44. 2021"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return the index where it would be if it were inserted in order\n        \n        # binary search\n        # if target is in num"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124."}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max number in the array\n        # find the min number in the array\n        # binary search the max number\n        # binary search the min number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number\n        # binary search the mid number"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        # 2 -> abc\n        # 3 -> def\n        # 4 -> ghi\n        # 5 -> jkl\n        # 6 -> mno\n        # 7 -> pqrs\n        # 8 -> tuv\n        # 9 -> wxyz\n        \n        # 2 -> abc\n        # 3 -> def\n        # 4 -> ghi\n        # 5 -> jkl\n        # 6 -> mno\n        # 7 -> pqrs\n        # 8 -> tuv\n        # 9 -> wxyz\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        # 4 -> [g,h,i]\n        # 5 -> [j,k,l]\n        # 6 -> [m,n,o]\n        # 7 -> [p,q,r,s]\n        # 8 -> [t,u,v]\n        # 9 -> [w,x,y,z]\n        \n        # 2 -> [a,b,c]\n        # 3 -> [d,e,f]\n        #"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result array\n        result = []\n        \n        # initialize the current combination\n        current = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # add the current element to the current combination\n                current.append(candidates[index])\n                \n                # update the current sum\n                current_sum += candidates[index]\n                \n                # recursively call the function with the next element\n                result += self.combinationSum(candidates, target, index, current, current_sum)\n                \n                # remove the last element from the current combination\n                current.pop()\n                \n                # update the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is equal to the target\n            elif current_sum == target:\n                \n                # add the current combination to the result array\n                result.append(current.copy())\n                \n                # remove the last element from the current combination\n                current.pop()\n                \n                # update the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is greater than the target\n            else:\n                \n                # break the loop\n                break\n            \n            # increment the index\n            index += 1\n            \n        # return the result array\n        return result\n    \n    def combinationSum(self, candidates, target, index, current, current_sum):\n        \n        # initialize the result array\n        result = []\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum + candidates[index] <= target:\n                \n                # add the current element to the current combination\n                current.append(candidates[index])\n                \n                # recursively call the function with the next element\n                result += self.combinationSum(candidates, target, index, current, current_sum + candidates[index])\n                \n                # remove the last element from the current combination\n                current.pop()\n                \n            # if the current sum is equal to the target\n            elif current_sum + candidates[index] == target:\n                \n                # add the current combination to the result array\n                result.append(current.copy())\n                \n                # remove the last element from the current combination\n                current.pop()\n                \n            # if the current sum is greater than the target\n            else:\n                \n                # break the loop\n                break\n            \n            # increment the index\n            index += 1\n            \n        # return the result array\n        return result"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is 0, return 10\n        # 3. If the nearest palindrome is 9, return 9\n        # 4. If the nearest palindrome is 10, return 11\n        # 5. If the nearest palindrome is 99, return 110\n        # 6. If the nearest palindrome is 100, return 111\n        # 7. If the nearest palindrome is 999, return 1111\n        # 8. If the nearest palindrome is 1000, return 1111\n        # 9. If the nearest palindrome is 9999, return 11111\n        # 10. If the nearest palindrome is 10000, return 11111\n        # 11. If the nearest palindrome is 99999, return 111111\n        # 12. If the nearest palindrome is 100000, return 111111\n        # 13. If the nearest palindrome is 999999, return 1111111\n        # 14. If the nearest palindrome is 1000000, return 1111111\n        # 15. If the nearest palindrome is 9999999, return 11111111\n        # 16. If the nearest palindrome is 10000000, return 11111111\n        # 17. If the nearest palindrome is 99999999, return 111111111\n        # 18. If the nearest palindrome is 100000000, return 111111111\n        # 19. If the nearest palindrome is 999999999, return 1111111111\n        # 20. If the nearest palindrome is 1000000000, return 1111111111\n        # 21. If the nearest palindrome is 9999999999, return 11111111111\n        # 22. If the nearest palindrome is 10000000000, return 11111111111\n        # 23. If the nearest palindrome is 99999999999, return 111111111111\n        # 24. If the nearest palindrome is 100000000000, return 111111111111\n        # 25. If the nearest palindrome is 999999999999, return 1111111111111\n        # 26. If the nearest palindrome is 1000000000000, return 1111111111111\n        # 27. If the nearest palindrome is 9999999999999, return 11111111111111\n        # 28. If the nearest palindrome is 10000000000000, return 11111111111111\n        # 29. If the nearest palindrome is 99999999999999, return 111111111111111\n        # 30. If the nearest palindrome is 100000000000000, return 111111111111111\n        # 31. If the nearest palindrome is 999999999999999, return 11"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Initialize the matrix with zeros\n        matrix = [[0] * n for _ in range(n)]\n        \n        # 2. Initialize the direction and the current position\n        direction = 0\n        row, col = 0, 0\n        \n        # 3. Initialize the value of the matrix\n        value = 1\n        \n        # 4. Loop until the matrix is filled\n        while value <= n * n:\n            # 4.1 Move in the direction\n            if direction == 0:\n                # Move right\n                matrix[row][col] = value\n                col += 1\n                value += 1\n            elif direction == 1:\n                # Move down\n                matrix[row][col] = value\n                row += 1\n                value += 1\n            elif direction == 2:\n                # Move left\n                matrix[row][col] = value\n                col -= 1\n                value += 1\n            else:\n                # Move up\n                matrix[row][col] = value\n                row -= 1\n                value += 1\n            \n            # 4.2 Check if the direction needs to be changed\n            if col == n - 1 - direction or row == n - 1 - direction:\n                direction = (direction + 1) % 4\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #    \n        #"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        ## 2. Reverse each row\n        for i in range(n):\n            matrix[i].reverse()\n        \n        ## 3. Swap the rows\n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the max and min product of subarray\n        ## 2. Find the max product of the whole array\n        ## 3. Return the max of 1 and 2\n        \n        ## 1. Find the max and min product of subarray\n        max_product = nums[0]\n        min_product = nums[0]\n        max_product_so_far = nums[0]\n        min_product_so_far = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            \n            max_product = max(nums[i], nums[i] * max_product)\n            min_product = min(nums[i], nums[i] * min_product)\n            \n            max_product_so_far = max(max_product, max_product_so_far)\n            \n            if nums[i] == 0:\n                max_product = 1\n                min_product = 1\n                \n        ## 2. Find the max product of the whole array\n        return max(max_product_so_far, max_product)"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Sort the scores in descending order\n        # 2. Assign the rank to each score\n        # 3. Assign the rank to the scores\n        # 4. Return the rank\n        \n        # 1. Sort the scores in descending order\n        sorted_scores = sorted(score, reverse=True)\n        \n        # 2. Assign the rank to each score\n        rank_to_score = {}\n        for i, score in en\n        rank_to_score[score] = i + 1\n        \n        # 3. Assign the rank to the scores\n        for i, score in enumerate(sorted_scores):\n            if i == 0:\n                rank_to_score[score] = \"Gold Medal\"\n            elif i == 1:\n                rank_to_score[score] = \"Silver Medal\"\n            elif i == 2:\n                rank_to_score[score] = \"Bronze Medal\"\n            else:\n                rank_to_score[score] = str(i + 1)\n        \n        # 4. Return the rank\n        return [rank_to_score[score] for score in score]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\n        answer = 0\n        \n        # 2. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\n        # 2-1. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-2. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-3. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-4. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-5. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-6. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-7. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-8. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-9. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-10. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-11. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-12. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-13. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-14. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-15. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-16. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-17. \uc815\ub2f5\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c 0\uc73c\ub85c \ucd08\uae30\ud654\n        # 2-18. \ufffd"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Create a dictionary of words and their frequency\n        ## 2. Create a dictionary of words and their frequency\n        ## 3. Create a dictionary of words and their frequency\n        ## 4. Create a dictionary of words and their frequency\n        ## 5. Create a dictionary of words and their frequency\n        ## 6. Create a dictionary of words and their frequency\n        ## 7. Create a dictionary of words and their frequency\n        ## 8. Create a dictionary of words and their frequency\n        ## 9. Create a dictionary of words and their frequency\n        ## 10. Create a dictionary of words and their frequency\n        ## 11. Create a dictionary of words and their frequency\n        ## 12. Create a dictionary of words and their frequency\n        ## 13. Create a dictionary of words and their frequency\n        ## 14. Create a dictionary of words and their frequency\n        ## 15. Create a dictionary of words and their frequency\n        ## 16. Create a dictionary of words and their frequency\n        ## 17. Create a dictionary of words and their frequency\n        ## 18. Create a dictionary of words and their frequency\n        ## 19. Create a dictionary of words and their frequency\n        ## 20. Create a dictionary of words and their frequency\n        ## 21. Create a dictionary of words and their frequency\n        ## 22. Create a dictionary of words and their frequency\n        ## 23. Create a dictionary of words and their frequency\n        ## 24. Create a dictionary of words and their frequency\n        ## 25. Create a dictionary of words and their frequency\n        ## 26. Create a dictionary of words and their frequency\n        ## 27. Create a dictionary of words and their frequency\n        ## 28. Create a dictionary of words and their frequency\n        ## 29. Create a dictionary of words and their frequency\n        ## 30. Create a dictionary of words and their frequency\n        ## 31. Create a dictionary of words and their frequency\n        ## 32. Create a dictionary of words and their frequency\n        ## 33. Create a dictionary of words and their frequency\n        ## 34. Create a dictionary of words and their frequency\n        ## 35. Create a dictionary of words and their frequency\n        ## 36. Create a dictionary of words and their frequency\n        ## 37. Create a dictionary of words and their frequency\n        ## 38. Create a dictionary of words and their frequency\n        ## 39. Create a dictionary of words and their frequency\n        ## 40. Create a dictionary of words and their frequency\n        ## 41. Create a dictionary of words and their frequency\n        ## 42. Create a dictionary of words and their frequency\n        ## 43. Create a dictionary of words and their frequency\n        ## 44. Create a dictionary of words and their frequency\n        ## 45. Create a dictionary of words and their frequency\n        ## 46. Create a dictionary of words and their frequency\n        ## 47. Create a dictionary of words and their frequency\n        ## 48. Create a dictionary of words and their frequency\n        ## 49. Create a dictionary of words and their frequency\n        ## 50. Create a dictionary of words and their frequency\n        ## 51. Create a dictionary of words and their frequency\n        ## 52. Create a dictionary of words and their frequency\n        ## 53. Create a dictionary of words and their frequency\n        ## 54. Create a dictionary of words and their frequency\n        ## 55. Create a dictionary of words and their frequency\n        ## 56. Create a dictionary of words and their frequency\n        ## 57. Create a dictionary of words and their frequency\n        ## 58. Create a dictionary of words and their frequency\n        ## 59. Create a dictionary of words and their frequency\n        ## 60. Create a dictionary of words and their frequency\n        ## 61. Create a dictionary of words and their frequency\n        ## 62. Create a dictionary of words and their frequency\n        ## 63. Create a dictionary of words and their frequency\n        ## 64. Create a dictionary of words and their frequency\n        ## 65. Create a"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the max element in the array\n        max_element = max(arr)\n        \n        # 2. Find the index of the max element\n        max_index = arr.index(max_element)\n        \n        # 3. Find the index of the first element that is smaller than the max element\n        first_smaller_index = max_index\n        for i in range(max_index):\n            if arr[i] < max_element:\n                first_smaller_index = i\n                break\n        \n        # 4. Find the index of the last element that is smaller than the max element\n        last_smaller_index = max_index\n        for i in range(max_index, len(arr)):\n            if arr[i] < max_element:\n                last_smaller_index = i\n                break\n        \n        # 5. Find the number of chunks that can be made\n        chunks = last_smaller_index - first_smaller_index + 1\n        \n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val < curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val < curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val < curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val < curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val < curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val < curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val < curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val < curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val < curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val < curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val < curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        \n        # while curr:\n        #     if curr.next and curr.val == curr.next.val:\n        #         while curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #         curr = curr.next\n        #     else:\n        #         prev = curr\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        \n        # while curr:\n        #     if curr.next and curr.val == curr.next.val:\n        #         while curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #         curr = curr.next\n        #     else:\n        #         prev = curr\n        #         curr = curr.next\n        # return dummy.next\n        \n        if head is None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        # print(nums)\n        # print(nums[0])\n        # print(nums[1])\n        # print(nums[2])\n        # print(nums[3])\n        # print(nums[4])\n        # print(nums[5])\n        # print(nums[6])\n        # print(nums[7])\n        # print(nums[8])\n        # print(nums[9])\n        # print(nums[10])\n        # print(nums[11])\n        # print(nums[12])\n        # print(nums[13])\n        # print(nums[14])\n        # print(nums[15])\n        # print(nums[16])\n        # print(nums[17])\n        # print(nums[18])\n        # print(nums[19])\n        # print(nums[20])\n        # print(nums[21])\n        # print(nums[22])\n        # print(nums[23])\n        # print(nums[24])\n        # print(nums[25])\n        # print(nums[26])\n        # print(nums[27])\n        # print(nums[28])\n        # print(nums[29])\n        # print(nums[30])\n        # print(nums[31])\n        # print(nums[32])\n        # print(nums[33])\n        # print(nums[34])\n        # print(nums[35])\n        # print(nums[36])\n        # print(nums[37])\n        # print(nums[38])\n        # print(nums[39])\n        # print(nums[40])\n        # print(nums[41])\n        # print(nums[42])\n        # print(nums[43])\n        # print(nums[44])\n        # print(nums[45])\n        # print(nums[46])\n        # print(nums[47])\n        # print(nums[48])\n        # print(nums[49])\n        # print(nums[50])\n        # print(nums[51])\n        # print(nums[52])\n        # print(nums[53])\n        # print(nums[54])\n        # print(nums[55])\n        # print(nums[56])\n        # print(nums[57])\n        # print(nums[58])\n        # print(nums[59])\n        # print(nums[60])\n        # print(nums[61])\n        # print(nums[62])\n        # print(nums[63])\n        # print(nums[64])\n        # print(nums[65])\n        # print(nums[66])\n        # print(nums[67])\n        # print(nums[68])\n        # print(nums[69])\n        # print(nums[70])\n        # print(nums[71])\n        # print(nums[72])\n        # print(nums[73])\n        # print(nums[74])\n        # print(nums[75])\n        # print(nums[76])\n        # print(nums[77])\n        # print(nums[78])\n        # print(nums[79])\n        # print(nums[80])\n        # print(nums[81])\n        # print(nums[82])\n        # print(nums[83])\n        # print(nums[84])\n        # print(nums[85])\n        # print(nums[86])\n        # print(nums[87])\n        # print(nums[88])\n        # print(nums[89])\n        # print(nums[90])\n        # print(nums[91])"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # if word1 == word2:\n        #     return 0\n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # else:\n        #     return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        \n        # if len(word1) == 0 or len(word2) == 0:\n        #     return len(word1) + len(word2)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1["}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor of x and y\n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count += 1\n        #     xor = xor >> 1\n        # return count\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor > 0:\n        #     if xor & 1:\n        #         count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        if root is None:\n            return []\n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        if root.left is None:\n            return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        if root.right is None:\n            return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return (ty - sy) % sx == 0\n        # if sy == ty and sx < tx:\n        #     return (tx - sx) % sy == 0\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty % sx)\n        # if sx < tx and sy < ty:\n        #     return self.reaching"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        v1 = v1 + [0] * (len(v2) - len(v1))\n        v2 = v2 + [0] * (len(v1) - len(v2))\n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # print(courses)\n        # print(courses[0][1])\n        # print(courses[1][1])\n        # print(courses[2][1])\n        # print(courses[3][1])\n        # print(courses[4][1])\n        # print(courses[5][1])\n        # print(courses[6][1])\n        # print(courses[7][1])\n        # print(courses[8][1])\n        # print(courses[9][1])\n        # print(courses[10][1])\n        # print(courses[11][1])\n        # print(courses[12][1])\n        # print(courses[13][1])\n        # print(courses[14][1])\n        # print(courses[15][1])\n        # print(courses[16][1])\n        # print(courses[17][1])\n        # print(courses[18][1])\n        # print(courses[19][1])\n        # print(courses[20][1])\n        # print(courses[21][1])\n        # print(courses[22][1])\n        # print(courses[23][1])\n        # print(courses[24][1])\n        # print(courses[25][1])\n        # print(courses[26][1])\n        # print(courses[27][1])\n        # print(courses[28][1])\n        # print(courses[29][1])\n        # print(courses[30][1])\n        # print(courses[31][1])\n        # print(courses[32][1])\n        # print(courses[33][1])\n        # print(courses[34][1])\n        # print(courses[35][1])\n        # print(courses[36][1])\n        # print(courses[37][1])\n        # print(courses[38][1])\n        # print(courses[39][1])\n        # print(courses[40][1])\n        # print(courses[41][1])\n        # print(courses[42][1])\n        # print(courses[43][1])\n        # print(courses[44][1])\n        # print(courses[45][1])\n        # print(courses[46][1])\n        # print(courses[47][1])\n        # print(courses[48][1])\n        # print(courses[49][1])\n        # print(courses[50][1])\n        # print(courses[51][1])\n        # print(courses[52][1])\n        # print(courses[53][1])\n        # print(courses[54][1])\n        # print(courses[55][1])\n        # print(courses[56][1])\n        # print(courses[57][1])\n        # print(courses[58][1])\n        # print(courses[59][1])\n        # print(courses[60][1])\n        # print(courses[61][1])\n        # print(courses[62][1])\n        # print(courses[63][1])\n        # print(courses[64][1])\n        # print(courses[65][1])\n        # print(courses[66][1])\n        # print(courses[67][1])\n        # print(courses[68][1])\n        # print(courses[69][1])\n        # print(courses[70][1])\n        # print(courses[7"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if k == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        # while curr:\n        #     # find the kth node\n        #     kth = curr\n        #     for i in range(k):\n        #         if kth.next:\n        #             kth = kth.next\n        #         else:\n        #             return dummy.next\n        #     # reverse the k nodes\n        #     prev = None\n        #     curr = curr.next\n        #     for i in range(k):\n        #         temp = curr.next\n        #         curr.next = prev\n        #         prev = curr\n        #         curr = temp\n        #     # connect the kth node to the next group\n        #     kth.next = curr\n        #     # connect the prev node to the next group\n        #     kth = prev\n        # return dummy.next\n        \n        # if k == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        # while curr:\n        #     # find the kth node\n        #     kth = curr\n        #     for i in range(k):\n        #         if kth.next:\n        #             kth = kth.next\n        #         else:\n        #             return dummy.next\n        #     # reverse the k nodes\n        #     prev = None\n        #     curr = curr.next\n        #     for i in range(k):\n        #         temp = curr.next\n        #         curr.next = prev\n        #         prev = curr\n        #         curr = temp\n        #     # connect the kth node to the next group\n        #     kth.next = curr\n        #     # connect the prev node to the next group\n        #     kth = prev\n        # return dummy.next\n        \n        # if k == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        # while curr:\n        #     # find the kth node\n        #     kth = curr\n        #     for i in range(k):\n        #         if kth.next:\n        #             kth = kth.next\n        #         else:\n        #             return dummy.next\n        #     # reverse the k nodes\n        #     prev = None\n        #     curr = curr.next\n        #     for i in range(k):\n        #         temp = curr.next\n        #         curr.next = prev\n        #         prev = curr\n        #         curr = temp\n        #     # connect the kth node to the next group\n        #     kth.next = curr\n        #     # connect the prev node to the next group\n        #     kth = prev\n        # return dummy.next\n        \n        # if k == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = dummy\n        # while curr:\n        #     # find the kth node\n        #     kth = curr\n        #     for i in range(k):\n        #         if kth.next:\n        #             kth = kth.next\n        #         else:\n        #             return dummy.next\n        #     # reverse the k nodes\n        #     prev = None\n        #     curr = curr.next\n        #     for i in range(k):\n        #         temp = curr.next\n        #         curr.next = prev\n        #         prev = curr\n        #         curr = temp\n        #     # connect the kth node to the next group\n        #     kth.next = curr\n        #     # connect the prev node to the next group\n        #     kth = prev\n        # return dummy.next\n        \n        # if k == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        # if len(s) == 2:\n        #     return False\n        # if len(s) == 1:\n        #     return False\n        # if len(s) == 3:\n        #     return False\n        # if len(s) == 4:\n        #     return False\n        # if len(s) == 5:\n        #     return False\n        # if len(s) == 6:\n        #     return False\n        # if len(s) == 7:\n        #     return False\n        # if len(s) == 8:\n        #     return False\n        # if len(s) == 9:\n        #     return False\n        # if len(s) == 10:\n        #     return False\n        # if len(s) == 11:\n        #     return False\n        # if len(s) == 12:\n        #     return False\n        # if len(s) == 13:\n        #     return False\n        # if len(s) == 14:\n        #     return False\n        # if len(s) == 15:\n        #     return False\n        # if len(s) == 16:\n        #     return False\n        # if len(s) == 17:\n        #     return False\n        # if len(s) == 18:\n        #     return False\n        # if len(s) == 19:\n        #     return False\n        # if len(s) == 20:\n        #     return False\n        # if len(s) == 21:\n        #     return False\n        # if len(s) == 22:\n        #     return False\n        # if len(s) == 23:\n        #     return False\n        # if len(s) == 24:\n        #     return False\n        # if len(s) == 25:\n        #     return False\n        # if len(s) == 26:\n        #     return False\n        # if len(s) == 27:\n        #     return False\n        # if len(s) == 28:\n        #     return False\n        # if len(s) == 29:\n        #     return False\n        # if len(s) == 30:\n        #     return False\n        # if len(s) == 31:\n        #     return False\n        # if len(s) == 32:\n        #     return False\n        # if len(s) == 33:\n        #     return False\n        # if len(s) == 34:\n        #     return False\n        # if len(s) == 35:\n        #     return False\n        # if len(s) == 36:\n        #     return False\n        # if len(s) == 37:\n        #     return False\n        # if len(s) == 38:\n        #     return False\n        # if len(s) == 39:\n        #     return False\n        # if len(s) == 40:\n        #     return False\n        # if len(s) == 41:\n        #     return False\n        # if len(s) == 42:\n        #     return False\n        # if len(s) == 43:\n        #     return False\n        # if len(s) == 44:\n        #     return False\n        # if len(s) == 45:\n        #     return False\n        # if len(s) == 46:\n        #     return False\n        # if len(s) == 47:\n        #     return False\n        # if len(s) == 48:\n        #     return False\n        # if len(s) == 49:\n        #     return False\n        # if len(s) == 50:\n        #     return False\n        # if len(s) == 51:\n        #     return False\n        # if len(s) == 52:\n        #     return False\n        # if len(s) == 53:\n        #     return False\n        # if len(s) == 54:\n        #     return False\n        # if len(s) == 55:\n        #     return False\n        # if len(s) == 56:\n        #     return False\n        # if len"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9,10\n        # 2. 1,2,3,4,5,6,7,8,9,10\n        # 3. 1,2,3,4,5,6,7,8,9,10\n        # 4. 1,2,3,4,5,6,7,8,9,10\n        # 5. 1,2,3,4,5,6,7,8,9,10\n        # 6. 1,2,3,4,5,6,7,8,9,10\n        # 7. 1,2,3,4,5,6,7,8,9,10\n        # 8. 1,2,3,4,5,6,7,8,9,10\n        # 9. 1,2,3,4,5,6,7,8,9,10\n        # 10. 1,2,3,4,5,6,7,8,9,10\n        # 11. 1,2,3,4,5,6,7,8,9,10\n        # 12. 1,2,3,4,5,6,7,8,9,10\n        # 13. 1,2,3,4,5,6,7,8,9,10\n        # 14. 1,2,3,4,5,6,7,8,9,10\n        # 15. 1,2,3,4,5,6,7,8,9,10\n        # 16. 1,2,3,4,5,6,7,8,9,10\n        # 17. 1,2,3,4,5,6,7,8,9,10\n        # 18. 1,2,3,4,5,6,7,8,9,10\n        # 19. 1,2,3,4,5,6,7,8,9,10\n        # 20. 1,2,3,4,5,6,7,8,9,10\n        # 21. 1,2,3,4,5,6,7,8,9,10\n        # 22. 1,2,3,4,5,6,7,8,9,10\n        # 23. 1,2,3,4,5,6,7,8,9,10\n        # 24. 1,2,3,4,5,6,7,8,9,10\n        # 25. 1,2,3,4,5,6,7,8,9,10\n        # 26. 1,2,3,4,5,6,7,8,9,10\n        # 27. 1,2,3,4,5,6,7,8,9,10\n        # 28. 1,2,3,4,5,6,7,8,9,10\n        # 29. 1,2,3,4,5,6,7,8,9,10\n        # 30. 1,2,3,4,5,6,7,8,9,10\n        # 31. 1,2,3,4,5,6,7,8,9,10\n        # 32. 1,2,3,4,5,6,7,8,9,10\n        # 33. 1,2,3,4,5,6,7,8,9,10\n        # 34. 1,2,3,4,5,6,7,8,9,10\n        # 35. 1,2,3,4,5,6,7,8,9,10\n        # 36. 1,2,3,4,5,6,7,8,9,10\n        # 37. 1,2,3,4,5,6,7,8,9,"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## Approach:\n        ## 1. We can use XOR to find the single number.\n        ## 2. XOR of a number with itself is 0.\n        ## 3. XOR of a number with 0 is the number itself.\n        ## 4. So we can XOR all the numbers in the array and the single number will be the result.\n        ## 5. We can use a hashmap to store the frequency of each number.\n        ## 6. We can also use a set to store the frequency of each number.\n        ## 7. We can also use a dictionary to store the frequency of each number.\n        ## 8. We can also use a counter to store the frequency of each number.\n        ## 9. We can also use a bit manipulation to store the frequency of each number.\n        ## 10. We can also use a bit manipulation to store the frequency of each number.\n        ## 11. We can also use a bit manipulation to store the frequency of each number.\n        ## 12. We can also use a bit manipulation to store the frequency of each number.\n        ## 13. We can also use a bit manipulation to store the frequency of each number.\n        ## 14. We can also use a bit manipulation to store the frequency of each number.\n        ## 15. We can also use a bit manipulation to store the frequency of each number.\n        ## 16. We can also use a bit manipulation to store the frequency of each number.\n        ## 17. We can also use a bit manipulation to store the frequency of each number.\n        ## 18. We can also use a bit manipulation to store the frequency of each number.\n        ## 19. We can also use a bit manipulation to store the frequency of each number.\n        ## 20. We can also use a bit manipulation to store the frequency of each number.\n        ## 21. We can also use a bit manipulation to store the frequency of each number.\n        ## 22. We can also use a bit manipulation to store the frequency of each number.\n        ## 23. We can also use a bit manipulation to store the frequency of each number.\n        ## 24. We can also use a bit manipulation to store the frequency of each number.\n        ## 25. We can also use a bit manipulation to store the frequency of each number.\n        ## 26. We can also use a bit manipulation to store the frequency of each number.\n        ## 27. We can also use a bit manipulation to store the frequency of each number.\n        ## 28. We can also use a bit manipulation to store the frequency of each number.\n        ## 29. We can also use a bit manipulation to store the frequency of each number.\n        ## 30. We can also use a bit manipulation to store the frequency of each number.\n        ## 31. We can also use a bit manipulation to store the frequency of each number.\n        ## 32. We can also use a bit manipulation to store the frequency of each number.\n        ## 33. We can also use a bit manipulation to store the frequency of each number.\n        ## 34. We can also use a bit manipulation to store the frequency of each number.\n        ## 35. We can also use a bit manipulation to store the frequency of each number.\n        ## 36. We can also use a bit manipulation to store the frequency of each number.\n        ## 37. We can also use a bit manipulation to store the frequency of each number.\n        ## 38. We can also use a bit manipulation to store the frequency of each number.\n        ## 39. We can also use a bit manipulation to store the frequency of each number.\n        ## 40. We can also use a bit manipulation to store the frequency of each number.\n        ## 41. We can also use a bit manipulation to store the frequency of each number.\n        ## 42. We can also use a bit manipulation to store the frequency of"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict of stickers\n        # 2. build a dict of target\n        # 3. build a dict of target with 0\n        # 4. build a dict of target with 1\n        # 5. build a dict of target with 2\n        # 6. build a dict of target with 3\n        # 7. build a dict of target with 4\n        # 8. build a dict of target with 5\n        # 9. build a dict of target with 6\n        # 10. build a dict of target with 7\n        # 11. build a dict of target with 8\n        # 12. build a dict of target with 9\n        # 13. build a dict of target with 10\n        # 14. build a dict of target with 11\n        # 15. build a dict of target with 12\n        # 16. build a dict of target with 13\n        # 17. build a dict of target with 14\n        # 18. build a dict of target with 15\n        # 19. build a dict of target with 16\n        # 20. build a dict of target with 17\n        # 21. build a dict of target with 18\n        # 22. build a dict of target with 19\n        # 23. build a dict of target with 20\n        # 24. build a dict of target with 21\n        # 25. build a dict of target with 22\n        # 26. build a dict of target with 23\n        # 27. build a dict of target with 24\n        # 28. build a dict of target with 25\n        # 29. build a dict of target with 26\n        # 30. build a dict of target with 27\n        # 31. build a dict of target with 28\n        # 32. build a dict of target with 29\n        # 33. build a dict of target with 30\n        # 34. build a dict of target with 31\n        # 35. build a dict of target with 32\n        # 36. build a dict of target with 33\n        # 37. build a dict of target with 34\n        # 38. build a dict of target with 35\n        # 39. build a dict of target with 36\n        # 40. build a dict of target with 37\n        # 41. build a dict of target with 38\n        # 42. build a dict of target with 39\n        # 43. build a dict of target with 40\n        # 44. build a dict of target with 41\n        # 45. build a dict of target with 42\n        # 46. build a dict of target with 43\n        # 47. build a dict of target with 44\n        # 48. build a dict of target with 45\n        # 49. build a dict of target with 46\n        # 50. build a dict of target with 47\n        # 51. build a dict of target with 48\n        # 52. build a dict of target with 49\n        # 53. build a dict of target with 50\n        # 54. build a dict of target with 51\n        # 55. build a dict of target with 52\n        # 56. build a dict of target with 53\n        # 57. build a dict of target with 54\n        # 58. build a dict of target with 55\n        # 59. build a dict of target with 56\n        # 60. build a dict of target with 57\n        # 61. build a dict of target with 58\n        # 62. build a dict of target with 59\n        # 63. build a dict of target with 60\n        # 64. build a dict of target with 61\n        # 65. build a dict of target with 62\n        # 66. build a dict of"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the square root of x\n        # 2. if x is 0, return 0\n        # 3. if x is 1, return 1\n        # 4. if x is 2, return 1\n        # 5. if x is 3, return 1\n        # 6. if x is 4, return 2\n        # 7. if x is 5, return 2\n        # 8. if x is 6, return 2\n        # 9. if x is 7, return 2\n        # 10. if x is 8, return 3\n        # 11. if x is 9, return 3\n        # 12. if x is 10, return 3\n        # 13. if x is 11, return 3\n        # 14. if x is 12, return 3\n        # 15. if x is 13, return 3\n        # 16. if x is 14, return 3\n        # 17. if x is 15, return 3\n        # 18. if x is 16, return 4\n        # 19. if x is 17, return 4\n        # 20. if x is 18, return 4\n        # 21. if x is 19, return 4\n        # 22. if x is 20, return 4\n        # 23. if x is 21, return 4\n        # 24. if x is 22, return 4\n        # 25. if x is 23, return 4\n        # 26. if x is 24, return 4\n        # 27. if x is 25, return 4\n        # 28. if x is 26, return 4\n        # 29. if x is 27, return 4\n        # 30. if x is 28, return 4\n        # 31. if x is 29, return 4\n        # 32. if x is 30, return 4\n        # 33. if x is 31, return 4\n        # 34. if x is 32, return 4\n        # 35. if x is 33, return 4\n        # 36. if x is 34, return 4\n        # 37. if x is 35, return 4\n        # 38. if x is 36, return 4\n        # 39. if x is 37, return 4\n        # 40. if x is 38, return 4\n        # 41. if x is 39, return 4\n        # 42. if x is 40, return 4\n        # 43. if x is 41, return 4\n        # 44. if x is 42, return 4\n        # 45. if x is 43, return 4\n        # 46. if x is 44, return 4\n        # 47. if x is 45, return 4\n        # 48. if x is 46, return 4\n        # 49. if x is 47, return 4\n        # 50. if x is 48, return 4\n        # 51. if x is 49, return 4\n        # 52. if x is 50, return 4\n        # 53. if x is 51, return 4\n        # 54. if x is 52, return 4\n        # 55. if x is 53, return 4\n        # 56. if x is 54, return 4\n        # 57. if x is 55, return 4\n        # 58. if x is 56, return 4\n        # 59. if x is 57, return 4\n        # 60. if x is 58, return 4\n        # 61. if x is 59, return 4\n        # 62"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary of roman numerals and their values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # Initialize the result variable\n        result = 0\n        \n        # Iterate through the string from the end\n        for i in range(len(s)-1, -1, -1):\n            # If the current character is less than the next character, subtract the value of the current character from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # Otherwise, add the value of the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # Return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a set to store the numbers\n        # If the number is already in the set, return True\n        # Otherwise, add the number to the set\n        # Return False if the set is empty\n        \n        # Create a set\n        num_set = set()\n        \n        # Loop through the list\n        for num in nums:\n            # If the number is already in the set, return True\n            if num in num_set:\n                return True\n            # Otherwise, add the number to the set\n            else:\n                num_set.add(num)\n        \n        # Return False if the set is empty\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ufffd"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) == 0:\n        #     return nums2[len(nums2)//2]\n        # if len(nums2) == 0:\n        #     return nums1[len(nums1)//2]\n        \n        # if len(nums1) == 1 and len(nums2) == 1:\n        #     return (nums1[0] + nums2[0]) / 2\n        \n        # if len(nums1) == 1:\n        #     if len(nums2) == 2:\n        #         return (nums1[0] + nums2[1]) / 2\n        #     else:\n        #         return nums1[0]\n        # if len(nums2) == 1:\n        #     if len(nums1) == 2:\n        #         return (nums2[0] + nums1[1]) / 2\n        #     else:\n        #         return nums2[0]\n        \n        # if len(nums1) == 2 and len(nums2) == 2:\n        #     return (nums1[0] + nums2[1]) / 2\n        \n        # if len(nums1) == 2:\n        #     if nums1[0] < nums2[0]:\n        #         return nums1[0]\n        #     else:\n        #         return nums2[0]\n        # if len(nums2) == 2:\n        #     if nums1[0] < nums2[0]:\n        #         return nums2[0]\n        #     else:\n        #         return nums1[0]\n        \n        # if len(nums1) == 3 and len(nums2) == 3:\n        #     if nums1[0] < nums2[0]:\n        #         if nums1[1] < nums2[1]:\n        #             return nums1[1]\n        #         else:\n        #             return nums2[1]\n        #     else:\n        #         if nums1[1] < nums2[1]:\n        #             return nums1[1]\n        #         else:\n        #             return nums2[1]\n        \n        # if len(nums1) == 3:\n        #     if nums1[0] < nums2[0]:\n        #         if nums1[1] < nums2[1]:\n        #             if nums1[2] < nums2[2]:\n        #                 return nums1[2]\n        #             else:\n        #                 return nums2[2]\n        #         else:\n        #             return nums2[1]\n        #     else:\n        #         if nums1[1] < nums2[1]:\n        #             if nums1[2] < nums2[2]:\n        #                 return nums1[2]\n        #             else:\n        #                 return nums2[2]\n        #         else:\n        #             return nums2[1]\n        \n        # if len(nums2) == 3:\n        #     if nums1[0] < nums2[0]:\n        #         if nums1[1] < nums2[1]:\n        #             if nums1[2] < nums2[2]:\n        #                 return nums1[2]\n        #             else:\n        #                 return nums2[2]\n        #         else:\n        #             return nums2[1]\n        #     else:\n        #         if nums1[1] < nums2[1]:\n        #             if nums1[2] < nums2[2]:\n        #                 return nums1[2]\n        #             else:\n        #                 return nums2[2]\n        #         else:\n        #             return nums2[1]\n        \n        # if len(nums1) == 4 and len(nums2) == 4:\n        #     if nums1[0] < nums2[0]:\n        #         if nums1[1] < nums2[1]:\n        #             if nums1[2] < nums2"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # if rowIndex == 2:\n        #     return [1,2,1]\n        # if rowIndex == 3:\n        #     return [1,3,3,1]\n        # if rowIndex == 4:\n        #     return [1,4,6,4,1]\n        # if rowIndex == 5:\n        #     return [1,5,10,10,5,1]\n        # if rowIndex == 6:\n        #     return [1,6,15,20,15,6,1]\n        # if rowIndex == 7:\n        #     return [1,7,21,35,35,21,7,1]\n        # if rowIndex == 8:\n        #     return [1,8,28,56,70,56,28,8,1]\n        # if rowIndex == 9:\n        #     return [1,9,36,84,126,126,84,36,9,1]\n        # if rowIndex == 10:\n        #     return [1,10,45,120,210,252,210,120,45,10,1]\n        # if rowIndex == 11:\n        #     return [1,11,55,165,330,462,462,330,165,55,11,1]\n        # if rowIndex == 12:\n        #     return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        # if rowIndex == 13:\n        #     return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        # if rowIndex == 14:\n        #     return [1,14,88,343,868,1656,2446,2800,2446,1656,868,343,88,14,1]\n        # if rowIndex == 15:\n        #     return [1,15,99,414,1001,2002,3003,3432,3003,2002,1001,414,99,15,1]\n        # if rowIndex == 16:\n        #     return [1,16,100,455,1200,2500,4142,5660,5660,4142,2500,1200,455,100,16,1]\n        # if rowIndex == 17:\n        #     return [1,17,111,514,1550,3524,6048,8008,8008,6048,3524,1550,514,111,17,1]\n        # if rowIndex == 18:\n        #     return [1,18,122,567,1820,4032,7082,9696,10696,9696,7082,4032,1820,567,122,18,1]\n        # if rowIndex == 19:\n        #     return [1,19,133,656,2200,5005,9289,14410,18012,18012,9289,5005,2200,656,133,19,1]\n        # if rowIndex == 20:\n        #     return [1"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # left = self.pathSum(root.left, targetSum - root.val)\n        # right = self.pathSum(root.right, targetSum - root.val)\n        # if left == [] and right == []:\n        #     return []\n        # if left == []:\n        #     return right\n        # if right == []:\n        #     return left\n        # res = []\n        # for i in left:\n        #     for j in right:\n        #         res.append([root.val] + i + j)\n        # return res\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # left = self.pathSum(root.left, targetSum - root.val)\n        # right = self.pathSum(root.right, targetSum - root.val)\n        # if left == [] and right == []:\n        #     return []\n        # if left == []:\n        #     return right\n        # if right == []:\n        #     return left\n        # res = []\n        # for i in left:\n        #     for j in right:\n        #         res.append([root.val] + i + j)\n        # return res\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # left = self.pathSum(root.left, targetSum - root.val)\n        # right = self.pathSum(root.right, targetSum - root.val)\n        # if left == [] and right == []:\n        #     return []\n        # if left == []:\n        #     return right\n        # if right == []:\n        #     return left\n        # res = []\n        # for i in left:\n        #     for j in right:\n        #         res.append([root.val] + i + j)\n        # return res\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # left = self.pathSum(root.left, targetSum - root.val)\n        # right = self.pathSum(root.right, targetSum - root.val)\n        # if left == [] and right == []:\n        #     return []\n        # if left == []:\n        #     return right\n        # if right == []:\n        #     return left\n        # res = []\n        # for i in left:\n        #     for j in right:\n        #         res.append([root.val] + i +"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    neighbor = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word == endWord:\n                            return self.build_path(graph, neighbor, endWord)\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n        \n        return []\n    \n    def build_path(self, graph, neighbor, endWord):\n        path = [endWord]\n        while neighbor != \"*\":\n            for neighbor_word in graph[neighbor]:\n                if neighbor_word == endWord:\n                    path.append(neighbor_word)\n                    break\n            neighbor = neighbor[:-1]\n        path.reverse()\n        return [path]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # while n % 2 == 0:\n        #     n = n / 2\n        # if n == 1:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the result array\n        result = [[]]\n        \n        # initialize the current subset\n        curr_subset = []\n        \n        # initialize the index\n        i = 0\n        \n        # loop through the array\n        while i < len(nums):\n            \n            # if the current subset is empty\n            if not curr_subset:\n                \n                # add the current element to the subset\n                curr_subset.append(nums[i])\n                \n                # add the subset to the result array\n                result.append(curr_subset)\n                \n                # increment the index\n                i += 1\n                \n            # if the current element is not the same as the previous element\n            elif nums[i] != nums[i-1]:\n                \n                # add the current element to the subset\n                curr_subset.append(nums[i])\n                \n                # add the subset to the result array\n                result.append(curr_subset)\n                \n                # reset the subset\n                curr_subset = []\n                \n                # increment the index\n                i += 1\n                \n            # if the current element is the same as the previous element\n            else:\n                \n                # increment the index\n                i += 1\n                \n        # return the result array\n        return result"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 13. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4."}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Find the four corners of the rectangle\n        ## 2. Find the area of the rectangle\n        ## 3. Find the area of the rectangle minus the area of the corners\n        ## 4. If the area of the rectangle minus the area of the corners is not zero, return False\n        ## 5. If the area of the rectangle minus the area of the corners is zero, return True\n        \n        ## 1. Find the four corners of the rectangle\n        x1, y1, x2, y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n        \n        ## 2. Find the area of the rectangle\n        area = (x2 - x1) * (y2 - y1)\n        \n        ## 3. Find the area of the rectangle minus the area of the corners\n        corners = set()\n        corners.add((x1, y1))\n        corners.add((x1, y2))\n        corners.add((x2, y1))\n        corners.add((x2, y2))\n        \n        area_minus_corners = area - len(corners)\n        \n        ## 4. If the area of the rectangle minus the area of the corners is not zero, return False\n        if area_minus_corners != 0:\n            return False\n        \n        ## 5. If the area of the rectangle minus the area of the corners is zero, return True\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force solution\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        # max_sum = nums[0]\n        # curr_sum = nums[0]\n        # for i in range(1, len(nums)):\n        #     if curr_sum < 0:\n        #         curr_sum = nums[i]\n        #     else:\n        #         curr_sum += nums[i]\n        #     max_sum = max(max_sum, curr_sum)\n        # return max_sum\n        \n        ## Dynamic programming solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        max_sum = nums[0]\n        curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            if curr_sum < 0:\n                curr_sum = nums[i]\n            else:\n                curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the empty square\n        empty_square = None\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 0:\n                    empty_square = (i, j)\n                    break\n        \n        # 2. Find the goal state\n        goal_state = [1, 2, 3, 4, 5]\n        goal_state.remove(0)\n        goal_state.remove(board[0][0])\n        goal_state.remove(board[0][1])\n        goal_state.remove(board[1][0])\n        goal_state.remove(board[1][1])\n        \n        # 3. Find the possible moves\n        possible_moves = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 0:\n                    possible_moves.append((i, j))\n        \n        # 4. Find the possible moves for each square\n        possible_moves_dict = {}\n        for move in possible_moves:\n            i, j = move\n            if i == 0:\n                if j == 1:\n                    possible_moves_dict[(i, j)] = [(i, j+1)]\n                elif j == 3:\n                    possible_moves_dict[(i, j)] = [(i, j-1)]\n                else:\n                    possible_moves_dict[(i, j)] = [(i, j-1), (i, j+1)]\n            elif i == 1:\n                if j == 0:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                elif j == 2:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                else:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n            elif i == 2:\n                if j == 1:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                elif j == 3:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                else:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n            elif i == 3:\n                if j == 0:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                elif j == 2:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                else:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n            elif i == 4:\n                if j == 1:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                elif j == 3:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                else:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n            elif i == 5:\n                if j == 0:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                elif j == 2:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j)]\n                else:\n                    possible_moves_dict[(i, j)] = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n        \n        # 5. Find the possible moves for each square"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_map:\n        #         s_map[s[i]] = t[i]\n        #     elif s_map[s[i]] != t[i]:\n        #         return False\n        #     if t[i] not in t_map:\n        #         t_map[t[i]] = s[i]\n        #     elif t_map[t[i]] != s[i]:\n        #         return False\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_map:\n        #         s_map[s[i]] = t[i]\n        #     elif s_map[s[i]] != t[i]:\n        #         return False\n        #     if t[i] not in t_map:\n        #         t_map[t[i]] = s[i]\n        #     elif t_map[t[i]] != s[i]:\n        #         return False\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_map:\n        #         s_map[s[i]] = t[i]\n        #     elif s_map[s[i]] != t[i]:\n        #         return False\n        #     if t[i] not in t_map:\n        #         t_map[t[i]] = s[i]\n        #     elif t_map[t[i]] != s[i]:\n        #         return False\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_map:\n        #         s_map[s[i]] = t[i]\n        #     elif s_map[s[i]] != t[i]:\n        #         return False\n        #     if t[i] not in t_map:\n        #         t_map[t[i]] = s[i]\n        #     elif t_map[t[i]] != s[i]:\n        #         return False\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_map:\n        #         s_map[s[i]] = t[i]\n        #     elif s_map[s[i]] != t[i]:\n        #         return False\n        #     if t[i] not in t_map:\n        #         t_map[t[i]] = s[i]\n        #     elif t_map[t[i]] != s[i]:\n        #         return False\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_map:\n        #         s_map[s[i]] = t[i]\n        #     elif s_map[s[i]] != t[i]:\n        #         return False\n        #     if t[i] not in t_map:\n        #         t_map[t[i]] = s[i]\n        #     elif t_map[t[i]] != s[i]:\n        #         return False"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element\n        # if nums has more than one element, find the pivot index\n        # if nums[pivot] is equal to target, return True\n        # if nums[pivot] is not equal to target, check if target is in the left or right half of the array\n        # if target is in the left half, recursively call search on the left half\n        # if target is in the right half, recursively call search on the right half\n        # if target is not in the left half and target is not in the right half, return False\n        \n        # if nums is empty, return False\n        if not nums:\n            return False\n        \n        # if nums has only one element, return True if target is equal to that element\n        if len(nums) == 1:\n            return nums[0] == target\n        \n        # find the pivot index\n        pivot = self.find_pivot(nums)\n        \n        # if nums[pivot] is equal to target, return True\n        if nums[pivot] == target:\n            return True\n        \n        # if nums[pivot] is not equal to target, check if target is in the left or right half of the array\n        if nums[pivot] < target:\n            # if target is in the left half, recursively call search on the left half\n            if self.search(nums[:pivot], target):\n                return True\n            # if target is in the right half, recursively call search on the right half\n            else:\n                return self.search(nums[pivot+1:], target)\n        else:\n            # if target is not in the left half and target is not in the right half, return False\n            return False\n        \n    def find_pivot(self, nums):\n        # find the pivot index\n        # if nums[pivot] is equal to target, return True\n        # if nums[pivot] is not equal to target, check if target is in the left or right half of the array\n        # if target is in the left half, recursively call search on the left half\n        # if target is in the right half, recursively call search on the right half\n        # if target is not in the left half and target is not in the right half, return False\n        \n        # if nums is empty, return False\n        if not nums:\n            return False\n        \n        # if nums has only one element, return True if target is equal to that element\n        if len(nums) == 1:\n            return 0\n        \n        # find the pivot index\n        pivot = len(nums) // 2\n        \n        # if nums[pivot] is equal to target, return True\n        if nums[pivot] == nums[0]:\n            return 0\n        \n        # if nums[pivot] is not equal to target, check if target is in the left or right half of the array\n        if nums[pivot] < nums[0]:\n            # if target is in the left half, recursively call search on the left half\n            if self.find_pivot(nums[:pivot]) is not False:\n                return self.find_pivot(nums[:pivot])\n            # if target is not in the left half, recursively call search on the right half\n            else:\n                return self.find_pivot(nums[pivot+1:])\n        else:\n            # if target is not in the left half and target is not in the right half, return False\n            return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # else:\n        #     obstacleGrid[0][0] = 1\n        #     for i in range(1, len(obstacleGrid[0])):\n        #         if obstacleGrid[0][i] == 1:\n        #             obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        #         else:\n        #             obstacleGrid[0][i] = obstacleGrid[0][i-1] + 1\n        #     for i in range(1, len(obstacleGrid)):\n        #         if obstacleGrid[i][0] == 1:\n        #             obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        #         else:\n        #             obstacleGrid[i][0] = obstacleGrid[i-1][0] + 1\n        #     for i in range(1, len(obstacleGrid)):\n        #         for j in range(1, len(obstacleGrid[0])):\n        #             if obstacleGrid[i][j] == 1:\n        #                 obstacleGrid[i][j] = 0\n        #             else:\n        #                 obstacleGrid[i][j] = obstacleGrid[i][j-1] + obstacleGrid[i-1][j]\n        #     return obstacleGrid[-1][-1]\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # else:\n        #     obstacleGrid[0][0] = 1\n        #     for i in range(1, len(obstacleGrid[0])):\n        #         if obstacleGrid[0][i] == 1:\n        #             obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        #         else:\n        #             obstacleGrid[0][i] = obstacleGrid[0][i-1] + 1\n        #     for i in range(1, len(obstacleGrid)):\n        #         if obstacleGrid[i][0] == 1:\n        #             obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        #         else:\n        #             obstacleGrid[i][0] = obstacleGrid[i-1][0] + 1\n        #     for i in range(1, len(obstacleGrid)):\n        #         for j in range(1, len(obstacleGrid[0])):\n        #             if obstacleGrid[i][j] == 1:\n        #                 obstacleGrid[i][j] = 0\n        #             else:\n        #                 obstacleGrid[i][j] = obstacleGrid[i][j-1] + obstacleGrid[i-1][j]\n        #     return obstacleGrid[-1][-1]\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # else:\n        #     obstacleGrid[0][0] = 1\n        #     for i in range(1, len(obstacleGrid[0])):\n        #         if obstacleGrid[0][i] == 1:\n        #             obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        #         else:\n        #             obstacleGrid[0][i] = obstacleGrid[0][i-1] + 1\n        #     for i in range(1, len(obstacleGrid)):\n        #         if obstacleGrid[i][0] == 1:\n        #             obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        #         else:\n        #             obstacleGrid[i][0] = obstacleGrid[i-1][0] + 1\n        #     for i in range(1, len(obstacleGrid)):\n        #         for j in range(1, len(obstacleGrid[0])):\n        #             if obstacleGrid[i][j] == 1:\n        #                 obstacleGrid[i][j] = 0\n        #             else:\n        #                 obstacleGrid[i][j] = obstacleGrid[i][j-1] + obstacleGrid[i-1][j]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s[0] == '0':\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:\n        #         return 1\n        # if s[0] == '0':\n        #     return 0\n        # if s[1] == '0':\n        #     if s[0] == '1':\n        #         return 1\n        #     else:\n        #         return 0\n        # else:\n        #     if s[0] == '1':\n        #         return 2\n        #     else:"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the closest sum\n        closest_sum = nums[0] + nums[1] + nums[2]\n        \n        # initialize the closest difference\n        closest_diff = abs(closest_sum - target)\n        \n        # initialize the length of the array\n        n = len(nums)\n        \n        # loop through the array\n        for i in range(n):\n            \n            # initialize the left and right pointers\n            left = i + 1\n            right = n - 1\n            \n            # loop through the array\n            while left < right:\n                \n                # calculate the sum\n                sum = nums[i] + nums[left] + nums[right]\n                \n                # calculate the difference\n                diff = abs(sum - target)\n                \n                # if the difference is less than the closest difference\n                if diff < closest_diff:\n                    \n                    # update the closest sum\n                    closest_sum = sum\n                    \n                    # update the closest difference\n                    closest_diff = diff\n                    \n                # if the sum is less than the target\n                if sum < target:\n                    \n                    # increment the left pointer\n                    left += 1\n                    \n                # if the sum is greater than the target\n                else:\n                    \n                    # decrement the right pointer\n                    right -= 1\n                    \n        # return the closest sum\n        return closest_sum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root."}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 1st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 2nd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3rd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 5th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 6th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 7th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 8th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 9th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 10th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 11th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 12th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 13th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 14th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 15th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 16th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 17th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 18th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 19th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 20th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 21st solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 22nd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 23rd solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 24th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 25th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 26th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 27th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 28th solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 29th solution\n        ## Time Complexity: O("}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # inorder traversal\n        # keep track of the previous node\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference\n        # keep track of the min difference"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if haystack is empty, return -1\n        if len(haystack) == 0:\n            return -1\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle =="}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \uc22b\uc790, 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 5. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 6. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \uc22b\uc790, 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 5. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 6. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \uc22b\uc790, 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 5. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 6. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \uc22b\uc790, 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ucd94\uac00\n        # 5. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \uc0ad\uc81c\n        # 6. \ucd5c\uc18c 1\uac1c \ubb38\uc790 \ubcc0\uacbd\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \uc22b\uc790, 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790\n        # 3. \uc5f0\uc18d\ub41c 3"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240, 245, 250, 255, 260, 265, 270, 275, 280, 285, 290, 295, 300, 305, 310, 315, 320, 325, 330, 335, 340, 345, 350, 355, 360, 365, 370, 375, 380, 385, 390, 395, 400, 405, 410, 415, 420, 425, 430, 435, 440, 445, 450, 455, 460, 465, 470, 475, 480, 485, 490, 495, 500, 505, 510, 515, 520, 525, 530, 535, 540, 545, 550, 555, 560, 565, 570, 575, 580, 585, 590, 595, 600, 605, 610, 615, 620, 625, 630, 635, 640, 645, 650, 655, 660, 665, 670, 675, 680, 685, 690, 695, 700, 705, 710, 715, 720, 725, 730, 735, 740, 745, 750, 755, 760, 765, 770, 775, 780, 785, 790, 795, 800, 805, 810, 815, 820, 825, 830, 835, 840, 845, 850, 855, 860, 865, 870, 875, 880, 885, 890, 895, 900, 905, 910, 915, 920, 925, 930, 935, 940, 945, 950, 955, 960, 965, 970, 975, 980, 985, 990, 995, 1000\n        \"\"\"\n        # 2. 2, 5, 10, 15, 20, 25, 30,"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        # initialize the dictionary\n        d = {}\n        for i in range(numRows):\n            d[i] = []\n        \n        # initialize the index\n        i = 0\n        # initialize the direction\n        direction = 1\n        \n        # loop through the string\n        for c in s:\n            # add the character to the dictionary\n            d[i].append(c)\n            # increment the index\n            i += direction\n            # if the index is at the end of the dictionary, change the direction\n            if i == numRows - 1 or i == 0:\n                direction *= -1\n        \n        # initialize the output string\n        output = \"\"\n        # loop through the dictionary\n        for i in range(numRows):\n            # loop through the characters in the dictionary\n            for c in d[i]:\n                # add the character to the output string\n                output += c\n        \n        # return the output string\n        return output"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Approach 1: Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE\n        ## TLE"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Create a hashmap with the number as key and value as 1\n        ## 2. Iterate through the array and for each number, if the number is not in the hashmap, add it to the result array\n        ## 3. Iterate through the hashmap and for each number, if the number is not in the hashmap, add it to the result array\n        ## 4. Return the result array\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Create a hashmap with the number as key and value as 1\n        hashmap = {}\n        for num in nums:\n            hashmap[num] = 1\n        \n        ## Iterate through the array and for each number, if the number is not in the hashmap, add it to the result array\n        result = []\n        for i in range(1, len(nums) + 1):\n            if i not in hashmap:\n                result.append(i)\n        \n        ## Iterate through the hashmap and for each number, if the number is not in the hashmap, add it to the result array\n        for i in range(1, len(nums) + 1):\n            if i not in hashmap:\n                result.append(i)\n        \n        return result"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start and end\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        # initialize the result and the last two numbers\n        result = 0\n        last_two = [intervals[0][1], intervals[1][1]]\n        \n        # iterate through the intervals\n        for i in range(2, len(intervals)):\n            # if the current interval is smaller than the last two numbers, update the last two numbers\n            if intervals[i][0] <= last_two[1]:\n                last_two[0] = intervals[i][1]\n                last_two[1] = intervals[i][1]\n            # if the current interval is larger than the last two numbers, update the last two numbers\n            else:\n                last_two[0] = last_two[1]\n                last_two[1] = intervals[i][1]\n            # update the result\n            result += 1\n        \n        # add the last two numbers to the result\n        result += last_two[1] - last_two[0] + 1\n        \n        # return the result\n        return result"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return True\n        # return self.isMirror(root.left, root.right)\n        \n        # Iterative solution\n        if root is None:\n            return True\n        \n        stack = [(root.left, root.right)]\n        while stack:\n            left, right = stack.pop()\n            if left is None and right is None:\n                continue\n            if left is None or right is None:\n                return False\n            if left.val != right.val:\n                return False\n            stack.append((left.left, right.right))\n            stack.append((left.right, right.left))\n        return True\n        \n    def isMirror(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            res.append(node.val)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap left and right nodes\n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        # recursively invert left and right nodes\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[0] == 1:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n - 1:\n            return 2\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n - 1:\n            return 2\n        \n        # edge case\n        if nums[-1] > n - 2:\n            return 3\n        \n        # edge case\n        if nums[-1] > n - 3:\n            return 4\n        \n        # edge case\n        if nums[-1] > n - 4:\n            return 5\n        \n        # edge case\n        if nums[-1] > n - 5:\n            return 6\n        \n        # edge case\n        if nums[-1] > n - 6:\n            return 7\n        \n        # edge case\n        if nums[-1] > n - 7:\n            return 8\n        \n        # edge case\n        if nums[-1] > n - 8:\n            return 9\n        \n        # edge case\n        if nums[-1] > n - 9:\n            return 10\n        \n        # edge case\n        if nums[-1] > n - 10:\n            return 11\n        \n        # edge case\n        if nums[-1] > n - 11:\n            return 12\n        \n        # edge case\n        if nums[-1] > n - 12:\n            return 13\n        \n        # edge case\n        if nums[-1] > n - 13:\n            return 14\n        \n        # edge case\n        if nums[-1] > n - 14:\n            return 15\n        \n        # edge case\n        if nums[-1] > n - 15:\n            return 16\n        \n        # edge case\n        if nums[-1] > n - 16:\n            return 17\n        \n        # edge case\n        if nums[-1] > n - 17:\n            return 18\n        \n        # edge case\n        if nums[-1] > n - 18:\n            return 19\n        \n        # edge case\n        if nums[-1] > n - 19:\n            return 20\n        \n        # edge case\n        if nums[-1] > n - 20:\n            return 21\n        \n        # edge case\n        if nums[-1] > n - 21:\n            return 22\n        \n        # edge case\n        if nums[-1] > n - 22:\n            return 23\n        \n        # edge case\n        if nums[-1] > n - 23:\n            return 24\n        \n        # edge case\n        if nums[-1] > n - 24:\n            return 25\n        \n        # edge case\n        if nums[-1] > n - 25:\n            return 26\n        \n        # edge case\n        if nums[-1] > n - 26:\n            return 27\n        \n        # edge case\n        if nums[-1] > n - 27:\n            return 28\n        \n        # edge case\n        if nums[-1] > n - 28:\n            return 29\n        \n        # edge case\n        if nums[-1] > n - 29:\n            return 30\n        \n        # edge case\n        if nums[-1] > n - 30:\n            return 31\n        \n        # edge case\n        if nums[-1] > n - 31:\n            return 32\n        \n        # edge case\n        if nums[-1] > n - 32:\n            return 33\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\ub97c \uc81c\uac70\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\uc704 \uc6d0\uc18c\uc640 \ud604\uc7ac \uc6d0\uc18c\uc758 \ucc28\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ub41c \ufffd"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        # if denominator == 0:\n        #     return \"0\"\n        # if numerator == 0:\n        #     return \"0\"\n        # if numerator < 0 and denominator < 0:\n        #     numerator = abs(numerator)\n        #     denominator = abs(denominator)\n        # if numerator < 0:\n        #     sign = \"-\"\n        #     numerator = abs(numerator)\n        # else:\n        #     sign = \"\"\n        # if numerator < denominator:\n        #     return sign + \"0\"\n        # if numerator == denominator:\n        #     return sign + \"1\"\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator % denominator == 0:\n        #     return sign + str(numerator // denominator)\n        # if numerator %"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # # find the middle of the linked list\n        # slow = head\n        # fast = head\n        # while fast.next and fast.next.next:\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # # split the linked list into two halves\n        # mid = slow.next\n        # slow.next = None\n        \n        # # recursively sort the left and right halves\n        # left = self.sortList(head)\n        # right = self.sortList(mid)\n        \n        # # merge the sorted halves\n        # dummy = ListNode()\n        # curr = dummy\n        # while left and right:\n        #     if left.val < right.val:\n        #         curr.next = left\n        #         left = left.next\n        #     else:\n        #         curr.next = right\n        #         right = right.next\n        #     curr = curr.next\n        \n        # if left:\n        #     curr.next = left\n        # if right:\n        #     curr.next = right\n        \n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # # find the middle of the linked list\n        # slow = head\n        # fast = head\n        # while fast.next and fast.next.next:\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # # split the linked list into two halves\n        # mid = slow.next\n        # slow.next = None\n        \n        # # recursively sort the left and right halves\n        # left = self.sortList(head)\n        # right = self.sortList(mid)\n        \n        # # merge the sorted halves\n        # dummy = ListNode()\n        # curr = dummy\n        # while left and right:\n        #     if left.val < right.val:\n        #         curr.next = left\n        #         left = left.next\n        #     else:\n        #         curr.next = right\n        #         right = right.next\n        #     curr = curr.next\n        \n        # if left:\n        #     curr.next = left\n        # if right:\n        #     curr.next = right\n        \n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # # find the middle of the linked list\n        # slow = head\n        # fast = head\n        # while fast.next and fast.next.next:\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # # split the linked list into two halves\n        # mid = slow.next\n        # slow.next = None\n        \n        # # recursively sort the left and right halves\n        # left = self.sortList(head)\n        # right = self.sortList(mid)\n        \n        # # merge the sorted halves\n        # dummy = ListNode()\n        # curr = dummy\n        # while left and right:\n        #     if left.val < right.val:\n        #         curr.next = left\n        #         left = left.next\n        #     else:\n        #         curr.next = right\n        #         right = right.next\n        #     curr = curr.next\n        \n        # if left:\n        #     curr.next = left\n        # if right:\n        #     curr.next = right\n        \n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # # find the middle of the linked list\n        # slow = head\n        # fast = head\n        # while fast.next and fast.next.next:\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # # split the linked list into two halves\n        # mid = slow.next\n        # slow.next = None\n        \n        # # recursively sort the left and right halves\n        # left = self."}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Initialize the maximum number of envelopes\n        max_envelopes = 0\n        \n        # Initialize the maximum number of envelopes with the current envelope\n        max_envelopes_with_current_envelope = 0\n        \n        # Iterate over the envelopes\n        for envelope in envelopes:\n            # If the current envelope is larger than the maximum number of envelopes with the current envelope\n            if envelope[1] > max_envelopes_with_current_envelope:\n                # Update the maximum number of envelopes with the current envelope\n                max_envelopes_with_current_envelope = envelope[1]\n                # Increment the maximum number of envelopes\n                max_envelopes += 1\n            # If the current envelope is smaller than the maximum number of envelopes with the current envelope\n            else:\n                # Update the maximum number of envelopes with the current envelope\n                max_envelopes_with_current_envelope = envelope[1]\n        \n        # Return the maximum number of envelopes\n        return max_envelopes"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        ## 4. Return the head\n        \n        ## Solution 12:\n        ## Time Complexity: O(n"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Sort the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        ## 2. Initialize the result array\n        result = []\n        \n        ## 3. Initialize the pointers\n        i = 0\n        j = 0\n        \n        ## 4. Loop through the arrays\n        while i < len(nums1) and j < len(nums2):\n            \n            ## 5. If the numbers are not equal, move the pointer that is smaller\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                ## 6. If the numbers are equal, add the number to the result array and move both pointers\n                result.append(nums1[i])\n                i += 1\n                j += 1\n                \n        ## 7. Return the result array\n        return result"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into left and right\n        left = head\n        right = slow.next\n        slow.next = None\n        \n        # recursively build the tree\n        if left == right:\n            return None\n        return self.sortedListToBST(left)\n        \n        # if left == right:\n        #     return None\n        # mid = left\n        # slow = left\n        # fast = left\n        # while fast and fast.next:\n        #     slow = slow.next\n        #     fast = fast.next.next\n        #     mid = slow\n        # mid.next = None\n        # return self.sortedListToBST(left)"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 57. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        #"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Remove all spaces\n        s = s.strip()\n        \n        # 2. Check if there is a sign\n        sign = False\n        if s[0] == '-' or s[0] == '+':\n            sign = True\n            s = s[1:]\n        \n        # 3. Check if there is a decimal point\n        decimal = False\n        if s[0] == '.':\n            decimal = True\n            s = s[1:]\n        \n        # 4. Check if there is an exponent\n        exponent = False\n        if s[-1] == 'e':\n            exponent = True\n            s = s[:-1]\n        \n        # 5. Check if there is a digit\n        digit = False\n        for i in range(len(s)):\n            if s[i] == '0' or s[i] == '1' or s[i] == '2' or s[i] == '3' or s[i] == '4' or s[i] == '5' or s[i] == '6' or s[i] == '7' or s[i] == '8' or s[i] == '9':\n                digit = True\n                break\n        \n        # 6. Check if there is a valid number\n        if digit and exponent and decimal:\n            return True\n        elif digit and exponent:\n            return True\n        elif digit and not decimal:\n            return True\n        elif not digit and exponent and decimal:\n            return True\n        elif not digit and not exponent and decimal:\n            return True\n        else:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV\n        \n        # 1. 1000 -> M\n        # 2. 900 -> CM\n        # 3. 500 -> D\n        # 4. 400 -> CD\n        # 5. 100 -> C\n        # 6. 90 -> XC\n        # 7. 50 -> L\n        # 8. 40 -> XL\n        # 9. 10 -> X\n        # 10. 9 -> IX\n        # 11. 5 -> V\n        # 12. 4 -> IV"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in string s\n        ## 2. Iterate through string t and decrement the frequency of each character in hashmap\n        ## 3. Return the character with frequency of 1\n        \n        ## Create a hashmap to store the frequency of each character in string s\n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        ## Iterate through string t and decrement the frequency of each character in hashmap\n        for char in t:\n            if char not in hashmap:\n                hashmap[char] = -1\n            else:\n                hashmap[char] -= 1\n        \n        ## Return the character with frequency of 1\n        for key, value in hashmap.items():\n            if value == 1:\n                return key\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a variable to store the frequency of the character in string s\n        ## 2. Iterate through string t and decrement the frequency of each character in hashmap\n        ## 3. Return the character with frequency of 1\n        \n        ## Create a variable to store the frequency of the character in string s\n        frequency = 0\n        for char in s:\n            frequency += hashmap[char]\n        \n        ## Iterate through string t and decrement the frequency of each character in hashmap\n        for char in t:\n            frequency -= hashmap[char]\n        \n        ## Return the character with frequency of 1\n        return chr(frequency + 97)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        ## 1. Find the empty cells\n        ## 2. Fill the empty cells with numbers from 1 to 9\n        ## 3. Check if the number is valid for the row, col, and 3x3 box\n        ## 4. Recursively fill the rest of the cells with numbers from 1 to 9\n        ## 5. If the number is valid for the row, col, and 3x3 box, return True\n        ## 6. If the number is not valid for the row, col, and 3x3 box, backtrack and try the next number\n        ## 7. If all numbers are tried, return False\n        \n        ## 1. Find the empty cells\n        empty_cells = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty_cells.append((i,j))\n        \n        ## 2. Fill the empty cells with numbers from 1 to 9\n        for i,j in empty_cells:\n            for num in range(1,10):\n                if self.isValid(board, i, j, num):\n                    board[i][j] = str(num)\n                    if self.solveSudoku(board):\n                        return True\n                    else:\n                        board[i][j] = '.'\n            return False\n        \n    def isValid(self, board, i, j, num):\n        ## Check if the number is valid for the row\n        for k in range(9):\n            if board[i][k] == str(num):\n                return False\n        \n        ## Check if the number is valid for the col\n        for k in range(9):\n            if board[k][j] == str(num):\n                return False\n        \n        ## Check if the number is valid for the 3x3 box\n        box_i = i // 3\n        box_j = j // 3\n        for k in range(3):\n            for l in range(3):\n                if board[box_i*3 + k][box_j*3 + l] == str(num):\n                    return False\n        \n        return True"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder predecessor\n        ##    until you reach the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively traverse the left subtree of the inorder successor\n        ##    until you reach the first node\n        ## 6. Recursively traverse the right subtree of the inorder"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # if num == 1:\n        #     return True\n        # if num < 1:\n        #     return False\n        # if num == 2:\n        #     return False\n        # if num == 3:\n        #     return False\n        # if num == 4:\n        #     return False\n        # if num == 5:\n        #     return False\n        # if num == 6:\n        #     return False\n        # if num == 7:\n        #     return False\n        # if num == 8:\n        #     return False\n        # if num == 9:\n        #     return False\n        # if num == 10:\n        #     return False\n        # if num == 11:\n        #     return False\n        # if num == 12:\n        #     return False\n        # if num == 13:\n        #     return False\n        # if num == 14:\n        #     return False\n        # if num == 15:\n        #     return False\n        # if num == 16:\n        #     return True\n        # if num == 17:\n        #     return False\n        # if num == 18:\n        #     return False\n        # if num == 19:\n        #     return False\n        # if num == 20:\n        #     return False\n        # if num == 21:\n        #     return False\n        # if num == 22:\n        #     return False\n        # if num == 23:\n        #     return False\n        # if num == 24:\n        #     return False\n        # if num == 25:\n        #     return False\n        # if num == 26:\n        #     return False\n        # if num == 27:\n        #     return False\n        # if num == 28:\n        #     return False\n        # if num == 29:\n        #     return False\n        # if num == 30:\n        #     return False\n        # if num == 31:\n        #     return False\n        # if num == 32:\n        #     return False\n        # if num == 33:\n        #     return False\n        # if num == 34:\n        #     return False\n        # if num == 35:\n        #     return False\n        # if num == 36:\n        #     return False\n        # if num == 37:\n        #     return False\n        # if num == 38:\n        #     return False\n        # if num == 39:\n        #     return False\n        # if num == 40:\n        #     return False\n        # if num == 41:\n        #     return False\n        # if num == 42:\n        #     return False\n        # if num == 43:\n        #     return False\n        # if num == 44:\n        #     return False\n        # if num == 45:\n        #     return False\n        # if num == 46:\n        #     return False\n        # if num == 47:\n        #     return False\n        # if num == 48:\n        #     return False\n        # if num == 49:\n        #     return False\n        # if num == 50:\n        #     return False\n        # if num == 51:\n        #     return False\n        # if num == 52:\n        #     return False\n        # if num == 53:\n        #     return False\n        # if num == 54:\n        #     return False\n        # if num == 55:\n        #     return False\n        # if num == 56:\n        #     return False\n        # if num == 57:\n        #     return False\n        # if num == 58:\n        #     return False\n        # if num == 59:\n        #     return False\n        # if num == 60:\n        #     return False\n        # if num == 61:\n        #     return False\n        # if num == 62:\n        #     return False\n        # if num == 63:\n        #     return False\n        # if num == 64:\n        #     return False\n        # if num == 65:\n        #     return False\n        # if num == 66:\n        #     return False\n        # if num == 67:\n        #     return False\n        # if num == 68:\n        #     return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if n == 0:\n        #     return [0]\n        # if n == 1:\n        #     return [0,1]\n        # if n == 2:\n        #     return [0,1,1]\n        # if n == 3:\n        #     return [0,1,1,2]\n        # if n == 4:\n        #     return [0,1,1,2,2]\n        # if n == 5:\n        #     return [0,1,1,2,2,3]\n        # if n == 6:\n        #     return [0,1,1,2,2,3,3]\n        # if n == 7:\n        #     return [0,1,1,2,2,3,3,4]\n        # if n == 8:\n        #     return [0,1,1,2,2,3,3,4,4]\n        # if n == 9:\n        #     return [0,1,1,2,2,3,3,4,4,5]\n        # if n == 10:\n        #     return [0,1,1,2,2,3,3,4,4,5,5]\n        # if n == 11:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6]\n        # if n == 12:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        # if n == 13:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        # if n == 14:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        # if n == 15:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        # if n == 16:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        # if n == 17:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        # if n == 18:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10]\n        # if n == 19:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10]\n        # if n == 20:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11]\n        # if n == 21:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11]\n        # if n == 22:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12]\n        # if n == 23:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12,12]\n        # if n == 24:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        # head.next = self.remove"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s1 and s2 are not the same length, return False\n        if len(s1) != len(s2):\n            return False\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n            return True\n        \n        # if s1 and s2 are the same, return True\n        if s1 == s2[::-1"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of strings\n        path_list = path.split('/')\n        \n        # initialize a stack\n        stack = []\n        \n        # loop through the list of strings\n        for i in range(len(path_list)):\n            # if the string is not empty\n            if path_list[i] != '':\n                # if the string is '.'\n                if path_list[i] == '.':\n                    # if the stack is empty\n                    if not stack:\n                        # do nothing\n                        pass\n                    # if the stack is not empty\n                    else:\n                        # pop the last element from the stack\n                        stack.pop()\n                # if the string is '..'\n                elif path_list[i] == '..':\n                    # if the stack is empty\n                    if not stack:\n                        # do nothing\n                        pass\n                    # if the stack is not empty\n                    else:\n                        # pop the last element from the stack\n                        stack.pop()\n                # if the string is not '.' or '..'\n                else:\n                    # push the string to the stack\n                    stack.append(path_list[i])\n        \n        # initialize a string to store the simplified path\n        simplified_path = ''\n        \n        # loop through the stack\n        for i in range(len(stack)):\n            # if the stack is empty\n            if not stack:\n                # do nothing\n                pass\n            # if the stack is not empty\n            else:\n                # if the stack is not the last element\n                if i != len(stack) - 1:\n                    # concatenate the stack with a '/'\n                    simplified_path += stack[i] + '/'\n                # if the stack is the last element\n                else:\n                    # concatenate the stack with the last element\n                    simplified_path += stack[i]\n        \n        # if the simplified path is empty\n        if not simplified_path:\n            # return '/'\n            return '/'\n        # else\n        else:\n            # return the simplified path\n            return simplified_path"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['*'] = True\n        \n        # build adjacency list\n        adj_list = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                letter = board[i][j]\n                if letter not in adj_list:\n                    adj_list[letter] = []\n                adj_list[letter].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for letter in adj_list:\n            adj_matrix[letter] = {}\n            for i,j in adj_list[letter]:\n                adj_matrix[letter][(i,j)] = []\n                if i > 0:\n                    adj_matrix[letter][(i,j)].append((i-1,j))\n                if i < len(board)-1:\n                    adj_matrix[letter][(i,j)].append((i+1,j))\n                if j > 0:\n                    adj_matrix[letter][(i,j)].append((i,j-1))\n                if j < len(board[0])-1:\n                    adj_matrix[letter][(i,j)].append((i,j+1))\n        \n        # build adjacency matrix\n        adj_matrix_rev = {}\n        for letter in adj_list:\n            adj_matrix_rev[letter] = {}\n            for i,j in adj_list[letter]:\n                adj_matrix_rev[letter][(i,j)] = []\n                if i > 0:\n                    adj_matrix_rev[letter][(i,j)].append((i-1,j))\n                if i < len(board)-1:\n                    adj_matrix_rev[letter][(i,j)].append((i+1,j))\n                if j > 0:\n                    adj_matrix_rev[letter][(i,j)].append((i,j-1))\n                if j < len(board[0])-1:\n                    adj_matrix_rev[letter][(i,j)].append((i,j+1))\n        \n        # build adjacency matrix\n        adj_matrix_rev_rev = {}\n        for letter in adj_list:\n            adj_matrix_rev_rev[letter] = {}\n            for i,j in adj_list[letter]:\n                adj_matrix_rev_rev[letter][(i,j)] = []\n                if i > 0:\n                    adj_matrix_rev_rev[letter][(i,j)].append((i-1,j))\n                if i < len(board)-1:\n                    adj_matrix_rev_rev[letter][(i,j)].append((i+1,j))\n                if j > 0:\n                    adj_matrix_rev_rev[letter][(i,j)].append((i,j-1))\n                if j < len(board[0])-1:\n                    adj_matrix_rev_rev[letter][(i,j)].append((i,j+1))\n        \n        # build adjacency matrix\n        adj_matrix_rev_rev_rev = {}\n        for letter in adj_list:\n            adj_matrix_rev_rev_rev[letter] = {}\n            for i,j in adj_list[letter]:\n                adj_matrix_rev_rev_rev[letter][(i,j)] = []\n                if i > 0:\n                    adj_matrix_rev_rev_rev[letter][(i,j)].append((i-1,j))\n                if i < len(board)-1:\n                    adj_matrix_rev_rev_rev[letter][(i,j)].append((i+1,j))\n                if j > 0:\n                    adj_matrix_rev_rev_rev[letter][(i,j)].append((i,j-1))\n                if j < len(board[0])-1:\n                    adj_matrix_rev_rev_rev[letter][(i,j)].append((i,j+1))\n        \n        # build adjacency matrix\n        adj_matrix_rev_rev_rev_rev = {}"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        # for key in s_dict:\n        #     if key not in t_dict:\n        #         return False\n        #     if s_dict[key] != t_dict[key]:\n        #         return False\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        # if s_dict == t_dict:\n        #     return True\n        # return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        # if s_dict == t_dict:\n        #     return True\n        # return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        # if s_dict == t_dict:\n        #     return True\n        # return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        # if s_dict == t_dict:\n        #     return True\n        # return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        #     if t[i] not in t_dict:\n        #         t"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 2. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 3. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 4. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 5. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 6. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 7. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 8. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 9. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 10. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 11. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 12. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 13. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 14. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 15. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 16. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 17. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 18. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 19. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 20. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 21. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 22. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 23. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 24. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 25. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 26. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 27. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 28. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 29. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 30. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 31. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 32. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 33. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 34. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 35. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 36. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 37. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 38. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 39. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 40. 3 sets of 9 rows, 9 columns, and"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 144000\n        # 26^5 = 7372800\n        # 26^6 = 393216000\n        # 26^7 = 21843200000\n        # 26^8 = 1152921504000\n        # 26^9 = 57646075200000\n        # 26^10 = 317440160000000\n        # 26^11 = 17297610000000000\n        # 26^12 = 1000000000000000000\n        # 26^13 = 50000000000000000000\n        # 26^14 = 2600000000000000000000\n        # 26^15 = 132000000000000000000000\n        # 26^16 = 6600000000000000000000000\n        # 26^17 = 330000000000000000000000000\n        # 26^18 = 16500000000000000000000000000\n        # 26^19 = 873216000000000000000000000000\n        # 26^20 = 43689375000000000000000000000000\n        # 26^21 = 2184745150000000000000000000000000\n        # 26^22 = 109237300000000000000000000000000000\n        # 26^23 = 5461390000000000000000000000000000000\n        # 26^24 = 273094500000000000000000000000000000000\n        # 26^25 = 13265725000000000000000000000000000000000\n        # 26^26 = 663786000000000000000000000000000000000000\n        # 26^27 = 33189300000000000000000000000000000000000000\n        # 26^28 = 1655910000000000000000000000000000000000000000\n        # 26^29 = 87790500000000000000000000000000000000000000000\n        # 26^30 = 4389525000000000000000000000"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the pattern and words\n        pattern_dict = {}\n        word_dict = {}\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the dictionary, add it to the dictionary\n            if pattern[i] not in pattern_dict:\n                pattern_dict[pattern[i]] = words[i]\n            # if the word is not in the dictionary, add it to the dictionary\n            elif words[i] not in word_dict:\n                word_dict[words[i]] = pattern[i]\n            # if the pattern and word are not equal, return False\n            elif pattern_dict[pattern[i]] != words[i] or word_dict[words[i]] != pattern[i]:\n                return False\n        \n        # if the pattern and word are equal, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return [nums]\n        # if len(nums) == 2:\n        #     return [[nums[0], nums[1]], [nums[1], nums[0]]]\n        # if len(nums) == 3:\n        #     return [[nums[0], nums[1], nums[2]], [nums[0], nums[2], nums[1]], [nums[1], nums[0], nums[2]], [nums[1], nums[2], nums[0]], [nums[2], nums[0], nums[1]], [nums[2], nums[1], nums[0]]]\n        \n        # if len(nums) == 4:\n        #     return [[nums[0], nums[1], nums[2], nums[3]], [nums[0], nums[1], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3]], [nums[0], nums[2], nums[3], nums[1]], [nums[1], nums[0], nums[2], nums[3]], [nums[1], nums[0], nums[3], nums[2]], [nums[1], nums[2], nums[0], nums[3]], [nums[1], nums[2], nums[3], nums[0]], [nums[2], nums[0], nums[1], nums[3]], [nums[2], nums[0], nums[3], nums[1]], [nums[2], nums[1], nums[0], nums[3]], [nums[2], nums[1], nums[3], nums[0]], [nums[3], nums[0], nums[1], nums[2]], [nums[3], nums[0], nums[2], nums[1]], [nums[3], nums[1], nums[0], nums[2]], [nums[3], nums[1], nums[2], nums[0]], [nums[0], nums[1], nums[2], nums[3]], [nums[0], nums[1], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3]], [nums[0], nums[2], nums[3], nums[1]], [nums[1], nums[2], nums[3], nums[0]], [nums[1], nums[3], nums[0], nums[2]], [nums[1], nums[3], nums[2], nums[0]], [nums[2], nums[3], nums[0], nums[1]], [nums[2], nums[3], nums[1], nums[0]], [nums[3], nums[2], nums[0], nums[1]], [nums[3], nums[2], nums[1], nums[0]]]\n        \n        # if len(nums) == 5:\n        #     return [[nums[0], nums[1], nums[2], nums[3], nums[4]], [nums[0], nums[1], nums[3], nums[4], nums[2]], [nums[0], nums[1], nums[4], nums[2], nums[3]], [nums[0], nums[1], nums[4], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3], nums[4]], [nums[0], nums[2], nums[1], nums[4], nums[3]], [nums[0], nums[2], nums[3], nums[1], nums[4]], [nums[0], nums[2], nums[3], nums[4], nums"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result list\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        # Iterate over the lists\n        while l1 or l2:\n            # If both lists are empty, set the carry to 0\n            if not l1 and not l2:\n                carry = 0\n            # If only l1 is empty, set the carry to the value of l2\n            elif not l1:\n                carry = l2.val\n                l2 = l2.next\n            # If only l2 is empty, set the carry to the value of l1\n            elif not l2:\n                carry = l1.val\n                l1 = l1.next\n            # If both lists are not empty, add the values of l1 and l2\n            else:\n                carry += l1.val + l2.val\n                l1 = l1.next\n                l2 = l2.next\n            # If the carry is greater than 9, set the value of the current node to the remainder of the carry divided by 10\n            if carry > 9:\n                current.next = ListNode(carry % 10)\n                carry = carry // 10\n            # If the carry is less than 9, set the value of the current node to the carry\n            else:\n                current.next = ListNode(carry)\n            # Move to the next node\n            current = current.next\n        # If the carry is greater than 0, add a new node to the result list\n        if carry > 0:\n            current.next = ListNode(carry)\n        # Return the result list\n        return result.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Convert the decimal to binary\n        # 5. Convert the binary to decimal\n        # 6. Convert the decimal to binary\n        # 7. Convert the binary to decimal\n        # 8. Convert the decimal to binary\n        # 9. Convert the binary to decimal\n        # 10. Convert the decimal to binary\n        # 11. Convert the binary to decimal\n        # 12. Convert the decimal to binary\n        # 13. Convert the binary to decimal\n        # 14. Convert the decimal to binary\n        # 15. Convert the binary to decimal\n        # 16. Convert the decimal to binary\n        # 17. Convert the binary to decimal\n        # 18. Convert the decimal to binary\n        # 19. Convert the binary to decimal\n        # 20. Convert the decimal to binary\n        # 21. Convert the binary to decimal\n        # 22. Convert the decimal to binary\n        # 23. Convert the binary to decimal\n        # 24. Convert the decimal to binary\n        # 25. Convert the binary to decimal\n        # 26. Convert the decimal to binary\n        # 27. Convert the binary to decimal\n        # 28. Convert the decimal to binary\n        # 29. Convert the binary to decimal\n        # 30. Convert the decimal to binary\n        # 31. Convert the binary to decimal\n        # 32. Convert the decimal to binary\n        # 33. Convert the binary to decimal\n        # 34. Convert the decimal to binary\n        # 35. Convert the binary to decimal\n        # 36. Convert the decimal to binary\n        # 37. Convert the binary to decimal\n        # 38. Convert the decimal to binary\n        # 39. Convert the binary to decimal\n        # 40. Convert the decimal to binary\n        # 41. Convert the binary to decimal\n        # 42. Convert the decimal to binary\n        # 43. Convert the binary to decimal\n        # 44. Convert the decimal to binary\n        # 45. Convert the binary to decimal\n        # 46. Convert the decimal to binary\n        # 47. Convert the binary to decimal\n        # 48. Convert the decimal to binary\n        # 49. Convert the binary to decimal\n        # 50. Convert the decimal to binary\n        # 51. Convert the binary to decimal\n        # 52. Convert the decimal to binary\n        # 53. Convert the binary to decimal\n        # 54. Convert the decimal to binary\n        # 55. Convert the binary to decimal\n        # 56. Convert the decimal to binary\n        # 57. Convert the binary to decimal\n        # 58. Convert the decimal to binary\n        # 59. Convert the binary to decimal\n        # 60. Convert the decimal to binary\n        # 61. Convert the binary to decimal\n        # 62. Convert the decimal to binary\n        # 63. Convert the binary to decimal\n        # 64. Convert the decimal to binary\n        # 65. Convert the binary to decimal\n        # 66. Convert the decimal to binary\n        # 67. Convert the binary to decimal\n        # 68. Convert the decimal to binary\n        # 69. Convert the binary to decimal\n        # 70. Convert the decimal to binary\n        # 71. Convert the binary to decimal\n        # 72. Convert the decimal to binary\n        # 73. Convert the binary to decimal\n        # 74. Convert the decimal to binary\n        # 75. Convert the binary to decimal\n        # 76. Convert the decimal to binary\n        # 77. Convert the binary to decimal\n        # 78. Convert the decimal to binary\n        # 79. Convert the binary to decimal\n        # 80. Convert the decimal to binary\n        # 81. Convert the binary to decimal\n        # 82. Convert the decimal to binary\n        # 83. Convert the binary to decimal\n        # 84. Convert the decimal to binary\n        # 85. Convert the binary to decimal\n        # 86. Convert the decimal to binary"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     if node.right:\n        #         stack.append(node.right)\n        # return res[::-1]\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            res.append(node.val)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # max_area = 0\n        # for i in range(len(height)):\n        #     for j in range(i+1, len(height)):\n        #         area = min(height[i], height[j]) * (j - i)\n        #         max_area = max(max_area, area)\n        # return max_area\n        \n        # 2. Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N^2)\n        # Space Complexity: O(N)\n        \n        # Create a set of words\n        word_set = set(words)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word = \"\"\n        for word in word_set:\n            if len(word) > len(longest_word):\n                longest_word = word\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict = {}\n        for word in word_set:\n            longest_word_dict[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_2 = {}\n        for word in word_set:\n            longest_word_dict_2[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_3 = {}\n        for word in word_set:\n            longest_word_dict_3[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_4 = {}\n        for word in word_set:\n            longest_word_dict_4[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_5 = {}\n        for word in word_set:\n            longest_word_dict_5[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_6 = {}\n        for word in word_set:\n            longest_word_dict_6[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_7 = {}\n        for word in word_set:\n            longest_word_dict_7[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_8 = {}\n        for word in word_set:\n            longest_word_dict_8[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_9 = {}\n        for word in word_set:\n            longest_word_dict_9[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_10 = {}\n        for word in word_set:\n            longest_word_dict_10[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_11 = {}\n        for word in word_set:\n            longest_word_dict_11[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_12 = {}\n        for word in word_set:\n            longest_word_dict_12[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_13 = {}\n        for word in word_set:\n            longest_word_dict_13[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_14 = {}\n        for word in word_set:\n            longest_word_dict_14[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_15 = {}\n        for word in word_set:\n            longest_word_dict_15[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_16 = {}\n        for word in word_set:\n            longest_word_dict_16[word] = len(word)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word_dict_17 = {}\n        for word in word_set:\n            longest_word_dict_17[word] = len(word)\n        \n        # Create a dictionary to store the longest"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n % 4 == 0:\n        #     return False\n        # else:\n        #     return True\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n <= 3:\n        #     return True\n        # else:\n        #"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 queen\n        # 2. 2 queens\n        # 3. 3 queens\n        # 4. 4 queens\n        # 5. 5 queens\n        # 6. 6 queens\n        # 7. 7 queens\n        # 8. 8 queens\n        # 9. 9 queens\n        # 10. 10 queens\n        # 11. 11 queens\n        # 12. 12 queens\n        # 13. 13 queens\n        # 14. 14 queens\n        # 15. 15 queens\n        # 16. 16 queens\n        # 17. 17 queens\n        # 18. 18 queens\n        # 19. 19 queens\n        # 20. 20 queens\n        # 21. 21 queens\n        # 22. 22 queens\n        # 23. 23 queens\n        # 24. 24 queens\n        # 25. 25 queens\n        # 26. 26 queens\n        # 27. 27 queens\n        # 28. 28 queens\n        # 29. 29 queens\n        # 30. 30 queens\n        # 31. 31 queens\n        # 32. 32 queens\n        # 33. 33 queens\n        # 34. 34 queens\n        # 35. 35 queens\n        # 36. 36 queens\n        # 37. 37 queens\n        # 38. 38 queens\n        # 39. 39 queens\n        # 40. 40 queens\n        # 41. 41 queens\n        # 42. 42 queens\n        # 43. 43 queens\n        # 44. 44 queens\n        # 45. 45 queens\n        # 46. 46 queens\n        # 47. 47 queens\n        # 48. 48 queens\n        # 49. 49 queens\n        # 50. 50 queens\n        # 51. 51 queens\n        # 52. 52 queens\n        # 53. 53 queens\n        # 54. 54 queens\n        # 55. 55 queens\n        # 56. 56 queens\n        # 57. 57 queens\n        # 58. 58 queens\n        # 59. 59 queens\n        # 60. 60 queens\n        # 61. 61 queens\n        # 62. 62 queens\n        # 63. 63 queens\n        # 64. 64 queens\n        # 65. 65 queens\n        # 66. 66 queens\n        # 67. 67 queens\n        # 68. 68 queens\n        # 69. 69 queens\n        # 70. 70 queens\n        # 71. 71 queens\n        # 72. 72 queens\n        # 73. 73 queens\n        # 74. 74 queens\n        # 75. 75 queens\n        # 76. 76 queens\n        # 77. 77 queens\n        # 78. 78 queens\n        # 79. 79 queens\n        # 80. 80 queens\n        # 81. 81 queens\n        # 82. 82 queens\n        # 83. 83 queens\n        # 84. 84 queens\n        # 85. 85 queens\n        # 86. 86 queens\n        # 87. 87 queens"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \u521d\u59cb\u5316\u68cb\u76d8\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        # 2. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col = [set() for _ in range(n)]\n        # 3. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2 = [set() for _ in range(2*n-1)]\n        # 4. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_rev = [set() for _ in range(2*n-1)]\n        # 5. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u7ed3\u679c\n        res = []\n        # 6. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_index = [i for i in range(n)]\n        # 7. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_index = [i for i in range(2*n-1)]\n        # 8. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_rev_index = [i for i in range(2*n-1)]\n        # 9. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u7ed3\u679c\n        res_index = []\n        # 10. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_index_index = [i for i in range(n)]\n        # 11. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_index_index = [i for i in range(2*n-1)]\n        # 12. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_rev_index_index = [i for i in range(2*n-1)]\n        # 13. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u7ed3\u679c\n        res_index_index = []\n        # 14. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_index_index_index = [i for i in range(n)]\n        # 15. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_index_index_index = [i for i in range(2*n-1)]\n        # 16. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_rev_index_index_index = [i for i in range(2*n-1)]\n        # 17. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u7ed3\u679c\n        res_index_index_index = []\n        # 18. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_index_index_index_index = [i for i in range(n)]\n        # 19. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_index_index_index_index = [i for i in range(2*n-1)]\n        # 20. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_rev_index_index_index_index = [i for i in range(2*n-1)]\n        # 21. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u7ed3\u679c\n        res_index_index_index_index = []\n        # 22. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_index_index_index_index_index = [i for i in range(n)]\n        # 23. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_index_index_index_index_index = [i for i in range(2*n-1)]\n        # 24. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        d1_d2_rev_index_index_index_index_index = [i for i in range(2*n-1)]\n        # 25. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u7ed3\u679c\n        res_index_index_index_index_index = []\n        # 26. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_index_index_index_index_index_index = [i for i in range(n)]\n        # 27. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(board) == 0:\n        #     return False\n        # if len(board[0]) == 0:\n        #     return False\n        # if len(word) == 0:\n        #     return True\n        \n        # if len(board) == 1:\n        #     if word in board[0]:\n        #         return True\n        #     else:\n        #         return False\n        # if len(board[0]) == 1:\n        #     if word in board[0]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 2:\n        #     if word in board[0] + board[1]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 3:\n        #     if word in board[0] + board[1] + board[2]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 4:\n        #     if word in board[0] + board[1] + board[2] + board[3]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 5:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 6:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 7:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 8:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6] + board[7]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 9:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6] + board[7] + board[8]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 10:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6] + board[7] + board[8] + board[9]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 11:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6] + board[7] + board[8] + board[9] + board[10]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 12:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6] + board[7] + board[8] + board[9] + board[10] + board[11]:\n        #         return True\n        #     else:\n        #         return False\n        \n        # if len(board) == 13:\n        #     if word in board[0] + board[1] + board[2] + board[3] + board[4] + board[5] + board[6] + board[7] + board[8] + board[9] + board[10] + board[11] + board[12]:"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            nums1[:] = nums2[:]\n            return\n        \n        # if nums2 is empty, just return nums1\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if n == 0:\n            return\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return\n        \n        # if nums1 is empty, just return num"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. if the list has 3 elements, return the third element\n        # 4. if the list has more than 3 elements, return the third element\n        \n        # 1. sort the list\n        nums.sort()\n        \n        # 2. if the list has less than 3 elements, return the max element\n        if len(nums) < 3:\n            return nums[-1]\n        \n        # 3. if the list has 3 elements, return the third element\n        if len(nums) == 3:\n            return nums[2]\n        \n        # 4. if the list has more than 3 elements, return the third element\n        return nums[2]"}]}